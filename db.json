{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/cactus/source/css/rtl.styl","path":"css/rtl.styl","modified":0,"renderable":1},{"_id":"themes/cactus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","path":"lib/clipboard/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","path":"lib/meslo-LG/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","path":"lib/meslo-LG/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","path":"lib/meslo-LG/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","path":"lib/meslo-LG/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","path":"lib/meslo-LG/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","path":"lib/meslo-LG/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","path":"lib/meslo-LG/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","path":"lib/meslo-LG/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","path":"lib/meslo-LG/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","path":"lib/vazir-font/Vazir-Black.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","path":"lib/vazir-font/Vazir-Black.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","path":"lib/vazir-font/Vazir-Black.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","path":"lib/vazir-font/Vazir-Black.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","path":"lib/vazir-font/Vazir-Bold.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","path":"lib/vazir-font/Vazir-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","path":"lib/vazir-font/Vazir-Bold.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","path":"lib/vazir-font/Vazir-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","path":"lib/vazir-font/Vazir-Light.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","path":"lib/vazir-font/Vazir-Light.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","path":"lib/vazir-font/Vazir-Light.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","path":"lib/vazir-font/Vazir-Light.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","path":"lib/vazir-font/Vazir-Medium.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","path":"lib/vazir-font/Vazir-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","path":"lib/vazir-font/Vazir-Medium.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","path":"lib/vazir-font/Vazir-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","path":"lib/vazir-font/Vazir-Thin.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","path":"lib/vazir-font/Vazir-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","path":"lib/vazir-font/Vazir-Thin.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","path":"lib/vazir-font/Vazir-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.eot","path":"lib/vazir-font/Vazir.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.ttf","path":"lib/vazir-font/Vazir.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.woff","path":"lib/vazir-font/Vazir.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.woff2","path":"lib/vazir-font/Vazir.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","path":"lib/vazir-font/font-face.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.eot","path":"lib/font-awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.svg","path":"lib/font-awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff","path":"lib/font-awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.eot","path":"lib/font-awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.svg","path":"lib/font-awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff","path":"lib/font-awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.eot","path":"lib/font-awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.svg","path":"lib/font-awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff","path":"lib/font-awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1615304643396},{"_id":"themes/cactus/LICENSE","hash":"346ece39a983b0e7858c11f785cd846cef9eb875","modified":1615305261780},{"_id":"themes/cactus/.stylintrc","hash":"eb5f48e83657928cb0cbee031373b2cd36ca0083","modified":1615305261780},{"_id":"themes/cactus/.jshintrc","hash":"2548bd6ce44422edc7e6f9f68061ab47f26c4f57","modified":1615305261780},{"_id":"themes/cactus/.gitignore","hash":"c5345a2c5fa6c136dbe2020a405e541b4755a259","modified":1615305261780},{"_id":"themes/cactus/gulpfile.js","hash":"0e55606323a45873506c08be6528478c08373e1e","modified":1615305261780},{"_id":"themes/cactus/package.json","hash":"a6060fadd36114d8cb74e7ff4c7d073901b5edcd","modified":1615305261780},{"_id":"themes/cactus/_config.yml","hash":"8244168f2ad34dc2c750485fe9d4f85a4e56f639","modified":1615381037098},{"_id":"themes/cactus/README.md","hash":"b3d528ede1ed7a41bb8e0238d5a14100f00e3af4","modified":1615305261780},{"_id":"themes/cactus/languages/ca.yml","hash":"b79dd2c21dc6697c635e92db1f661a4b8d5d2305","modified":1615305261780},{"_id":"themes/cactus/languages/de.yml","hash":"43b2f4e078b042aaae0377a4235216a51ed82e0d","modified":1615305261780},{"_id":"themes/cactus/languages/en.yml","hash":"703548ad90034d4e5207a27eb50f726dc27e4c0c","modified":1615305261780},{"_id":"themes/cactus/languages/default.yml","hash":"703548ad90034d4e5207a27eb50f726dc27e4c0c","modified":1615305261780},{"_id":"themes/cactus/languages/es.yml","hash":"2b1fc8b0d636123e9ee39017fa20053bd1913a5a","modified":1615305261780},{"_id":"themes/cactus/languages/fa.yml","hash":"63f32e50953af1c4bd0308a4fca5862b5287c2cb","modified":1615305261780},{"_id":"themes/cactus/languages/it.yml","hash":"62800bcae1f2d2454f87f4bcf4d7593848424f61","modified":1615305261780},{"_id":"themes/cactus/languages/kr.yml","hash":"651fb83991c91b13b53ed55740e5402cf0f1c5e8","modified":1615305261780},{"_id":"themes/cactus/languages/fr.yml","hash":"5c07406998f19d219a5a7b65c0d88b6b023f85b2","modified":1615305261780},{"_id":"themes/cactus/languages/nl.yml","hash":"ac0573352ad2c737a7686bcca498b985e7bd6447","modified":1615305261780},{"_id":"themes/cactus/languages/pl.yml","hash":"8a2d6dc874d86c38d42c2c861c39590647b5d536","modified":1615305261780},{"_id":"themes/cactus/languages/pt-br.yml","hash":"4859aba788a050c2d5d0b997693b0c8c24b349f7","modified":1615305261780},{"_id":"themes/cactus/languages/ru.yml","hash":"81b57fcd1977ef534f4bf303dbc1b4710cc7f057","modified":1615305261780},{"_id":"themes/cactus/languages/tr.yml","hash":"2702914007e6bade9d6861078c0e179ac05bf48c","modified":1615305261780},{"_id":"themes/cactus/languages/vi.yml","hash":"f84893c3ec3e45875c90069e14b17ed3016ed973","modified":1615305261780},{"_id":"themes/cactus/languages/zh-CN.yml","hash":"8f81faaad9a0615b09dbc23868484a55ec958f6f","modified":1615305261780},{"_id":"themes/cactus/languages/zh-TW.yml","hash":"2f4e050c9b35a67f4a7278cec3a949533c2ac16a","modified":1615305261780},{"_id":"themes/cactus/layout/archive.ejs","hash":"53de8817e37be01b3ba8fa5ca31b9cafa2f3c011","modified":1615305261780},{"_id":"themes/cactus/layout/layout.ejs","hash":"8504004f2ed78914f806c6699d9bd722318cbe56","modified":1615305261780},{"_id":"themes/cactus/layout/page.ejs","hash":"c5465d5315a7544aa466b01fd8cfb62917a8bb1d","modified":1615305261780},{"_id":"themes/cactus/layout/post.ejs","hash":"f9149f294e6142437c58784c41f1d082a61c8b82","modified":1615305261780},{"_id":"themes/cactus/scripts/merge-configs.js","hash":"2048c3415d96b17b9d84aa44bc0c25f1210525f8","modified":1615305261780},{"_id":"themes/cactus/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1615305261780},{"_id":"themes/cactus/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1615305261780},{"_id":"themes/cactus/scripts/page_title.js","hash":"fa662dbdb82779af1b95e35ed7ccdf4866a53dee","modified":1615305261780},{"_id":"themes/cactus/layout/index.ejs","hash":"d5d42dc8e01328fe215f9043292a0696a92db35c","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/comments.ejs","hash":"4cf8d0059e5f8bc8ae1dd1a426293583fd398052","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/footer.ejs","hash":"116424c97ec87f0d8124095e73d458eb6f4f12a0","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/header.ejs","hash":"ab38dbf9b11f829e165f1a0aa6a60d556f94a0a6","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/pagination.ejs","hash":"23bf862b3b8a3cd831850504d9b5a24d21b005e7","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/search.ejs","hash":"8b4bf9cf5db0ce762a31fc3baae0f2fc004bece4","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/head.ejs","hash":"cb3ca34fb0db2578c6c64e14922c17de1cf2afcc","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/styles.ejs","hash":"be1b54388eb02176dd4722285dda19e3dce2e62e","modified":1615305261780},{"_id":"themes/cactus/source/css/_fonts.styl","hash":"354809b5a64e8a47a66c66fd1a28ac597c1460a6","modified":1615305261780},{"_id":"themes/cactus/source/css/_mixins.styl","hash":"1a9e309523df9685e8d088dcff0a809c58e2c392","modified":1615305261783},{"_id":"themes/cactus/layout/_partial/scripts.ejs","hash":"467fd1b51a0114aa4ac562d00de41f026fc718ae","modified":1615305261780},{"_id":"themes/cactus/source/css/rtl.styl","hash":"ff8700e1626feeb53d905a2df2777bda7d1eca50","modified":1615305261783},{"_id":"themes/cactus/source/css/_extend.styl","hash":"b6a4e5905a7515dda66919167531a5ab2b3d1fe2","modified":1615305261780},{"_id":"themes/cactus/source/css/_variables.styl","hash":"69d9c5e95edcaee5ccd8218262b989ce721cce79","modified":1615305261783},{"_id":"themes/cactus/source/css/style.styl","hash":"18b22cfdc7457d81db7694aef5850cc36ff87a77","modified":1615305261783},{"_id":"themes/cactus/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1615305261783},{"_id":"themes/cactus/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1615305261783},{"_id":"themes/cactus/source/js/main.js","hash":"584c5a69ac81a483a1c4377a2e2cf326c2795e7b","modified":1615305261783},{"_id":"themes/cactus/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1615305261783},{"_id":"themes/cactus/layout/_partial/post/actions_desktop.ejs","hash":"38aadd1ed890303dde582b722486138afee09b0a","modified":1615305261780},{"_id":"themes/cactus/source/js/search.js","hash":"90860ff07187cf1cf21224b05e23b5e8fcf6efef","modified":1615305261783},{"_id":"themes/cactus/layout/_partial/post/actions_mobile.ejs","hash":"79b234ff3c264e66b2e71c819228e62bf92b48e4","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/post/category.ejs","hash":"b5bfa049f17868fb09d9d2a7e1d5279fa0381d37","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/post/date.ejs","hash":"6f2d1aa9562df343b797d25705f1945323c465fb","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/post/tag.ejs","hash":"e08fae30da060f49c087f6c121868b08eb55c795","modified":1615305261780},{"_id":"themes/cactus/layout/_partial/post/share.ejs","hash":"1a294382bd14d979525b8ed934d807bc7d083e4d","modified":1615305261780},{"_id":"themes/cactus/source/css/_util.styl","hash":"2bfeb2e2605dd5235693b00c71a212646d2e0410","modified":1615305261783},{"_id":"themes/cactus/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1615305261780},{"_id":"themes/cactus/source/css/_colors/classic.styl","hash":"0f0ec41a4165814ce69688425d5ac4d701b7cc70","modified":1615305261780},{"_id":"themes/cactus/source/css/_colors/dark.styl","hash":"9c9655b42b85f754b8a573a1d4634c23c680e1bf","modified":1615305261780},{"_id":"themes/cactus/source/css/_colors/light.styl","hash":"d09f781cb02394850737b3a9efc6693307d5bf09","modified":1615305261780},{"_id":"themes/cactus/source/css/_colors/white.styl","hash":"2b25ad24573bded8b42f9d80112eab9fadbed1a5","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1615305261780},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/pojoaque.styl","hash":"4e7b6b046b8575ac749f6aec4e953a62ada27a36","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1615305261783},{"_id":"themes/cactus/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/archive.styl","hash":"ef8fc52337c4c7b010cad7c427cb78009b30f9d8","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/article.styl","hash":"c6a3c395ceb4aacba8c995bcde7b58a7ca501919","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/categories.styl","hash":"a43f00e61b3507f130b8a3f8108a4eeca147c2a0","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/comments.styl","hash":"1e90f1fb9d4c155df518cacb5a537e9de9c042c1","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/footer.styl","hash":"14dda7f155bb21e6cd33ca3d8daa5b489b4707b3","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/header.styl","hash":"7f18929e7f4ad6d20da374e8b9f85ce587220a87","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/index.styl","hash":"59c99f4ea3a73bf47ce030df166c5e33d5de31fb","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/pagination.styl","hash":"950bf517bbe7adb9a9aa4eb5ddec74ffc7598787","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/tags.styl","hash":"d571d5c7c960300d29c5f0ec3fe1140322ecd6b3","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/search.styl","hash":"159be002780c62a77f46947cf854a7342fba24f4","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/tooltip.styl","hash":"2daff581ec3efaec840cbfdee512195919c32629","modified":1615305261783},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","hash":"ee60ca5ba9401456105ef703a98092369b579c80","modified":1615305261783},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","hash":"9e8d954c46eaad8b8234fa906e9a268ee354dced","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","hash":"f1c5d7523d21c2bf820d827c9d5df4184c3866dc","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","hash":"9376516725e502f4375e06cc4fa7d940e2c93251","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","hash":"8d4810991aa94f958aff20a9cd381caf338e3061","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","hash":"cba77d3d16f7565f9ea79bd7657f4e00c7fe851f","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","hash":"e520d5f6bf7ea3c1e4f2aef2abbbc6a6f9b697cb","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","hash":"2e8e3c873e6d98acc3c10aa84997104b276e1e68","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","hash":"976b7aa7c2c2c049c548a25b5914cfbda74b0453","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","hash":"f231111b3c778b7a5898ea88c0f150c0e72be468","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","hash":"baa42f95b41411b9aeaa6c7594e5ccee10d42ac4","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.woff","hash":"c798391d624b9bb44497a87ffc4f7eb52042dceb","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.woff2","hash":"dc3c0ed67c9abb062b562e8553776f614d2946c2","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","hash":"2a95709b15ee45fc2328051038ceedddf83235bb","modified":1615305261813},{"_id":"themes/cactus/source/css/_partial/post/actions_desktop.styl","hash":"ae3d9090bf4d934d443c0a431cb09d009743155a","modified":1615305261783},{"_id":"themes/cactus/source/css/_partial/post/actions_mobile.styl","hash":"0d2966c1d870392476864af8ee3ba312ba30cb82","modified":1615305261783},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","hash":"703603273f5d5d52eb456d6385e1a68294fbd568","modified":1615305261786},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"3ad44eb5c276d1435408f253ca78da729a1aca90","modified":1615305261790},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"114f35e6d9053caca2ef6d1e34fea3f87a59245b","modified":1615305261790},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"f3f0ea4847825806062a9b7a0f629671eb6b6408","modified":1615305261790},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"830f8653e5f4a5331ac0b47c5701f65fe9f1bb32","modified":1615305261790},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","hash":"92bb6e468a1db7fbd99ccb960e15e28572254263","modified":1615305261796},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1615305261796},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1615305261796},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","hash":"603acd29416644e4b4fb8646abeada1865ba6869","modified":1615305261806},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","hash":"23ee4a19421de9a0ca9dddc5435a8efe5bf28d87","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","hash":"9ef82b07f3adad7d644c9c3a6d35a0c727bd64e8","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","hash":"658c1da4f2a0124f6340058daa6873a86e6ba4fc","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","hash":"32f51bf715663f5ca419e138617fc05f7055aef5","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","hash":"b2372b67b9519fb4fa8e05de6c0ddae56845ff79","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","hash":"17be9f699c30f0384004b46e991db8ac38a9992e","modified":1615305261810},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","hash":"31cdbcc7215d01c9dd2beb8a28f8b7a7de75b9f4","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","hash":"2c0ebb336dd012da8d575cae0ee4d048b65fe6e1","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","hash":"d53fcc2e2d6c9c77613afcd34058be1b75bb0fef","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.eot","hash":"bd3a7cb9eb70d36b4cfba8c5a05d234aefeefe3c","modified":1615305261813},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.ttf","hash":"c7a3f2f4d56c4c4ec69d395baf39b55198da0254","modified":1615305261813},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"91daac2bfba5e6a1a15ce44c53eab524d01c7fb0","modified":1615305261790},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"f356aa2e4d9b7245985d312d3bfba180f774e3b7","modified":1615305261790},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"61f40daca6978e6e7ab761e748c2dd9d236c7586","modified":1615305261796},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"b2c74520c3f506efbfefca867918e5ae28bd5222","modified":1615305261796},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"d4987ee41e0e4142d561f76b8ea8e034c4d5d9d2","modified":1615305261786},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"f34ee061900ecd1ed3d3fd9f8f47f4e84c6d56bf","modified":1615305261790},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"1622937e49766e21eacf4ac7065b711f0fe580e1","modified":1615305261790},{"_id":"themes/cactus/source/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1615305261783},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"be6b63d528286b1be2328d871c9bae95d8d57174","modified":1615305261790},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"91b40a8f284159d9fff81dc522670ef68d562682","modified":1615305261796},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1615305261803},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1615305261806},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1615305261806},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1615305261803},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1615305261806},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1615305261806},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1615305261806},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1615305261800},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1615305261803},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1615305261803},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1615305261806},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1615305261806},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"29e6c7e5a4d63d2c9563cd208456cb4f8a357868","modified":1615305261790},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"3a090431fdec61a25ed69b9e6f35a6656bde1595","modified":1615305261793},{"_id":"public/archives/index.html","hash":"2961c3efd53d5f9a09a7be35a1ce792b956017b1","modified":1615389839977},{"_id":"public/archives/2021/index.html","hash":"adf468759a893e97f3b23126d6bcdc600b9a567b","modified":1615389839977},{"_id":"public/archives/2021/03/index.html","hash":"c037a340d1860dadf3c69a6143a83c379bb0a69f","modified":1615380507044},{"_id":"public/index.html","hash":"59445e2554568eb606a4070ebd9a3e518b7974f9","modified":1615389839977},{"_id":"public/2021/03/09/hello-world/index.html","hash":"004c4116e03fefc1db0d5e9c7ddf2bed824fbc6b","modified":1615380507044},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1615380507044},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1615380507044},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Black.woff2","hash":"f1c5d7523d21c2bf820d827c9d5df4184c3866dc","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Black.woff","hash":"9e8d954c46eaad8b8234fa906e9a268ee354dced","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Bold.woff","hash":"9376516725e502f4375e06cc4fa7d940e2c93251","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Bold.woff2","hash":"8d4810991aa94f958aff20a9cd381caf338e3061","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Light.woff2","hash":"e520d5f6bf7ea3c1e4f2aef2abbbc6a6f9b697cb","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Light.woff","hash":"cba77d3d16f7565f9ea79bd7657f4e00c7fe851f","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Medium.woff2","hash":"976b7aa7c2c2c049c548a25b5914cfbda74b0453","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Medium.woff","hash":"2e8e3c873e6d98acc3c10aa84997104b276e1e68","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Thin.woff2","hash":"baa42f95b41411b9aeaa6c7594e5ccee10d42ac4","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Thin.woff","hash":"f231111b3c778b7a5898ea88c0f150c0e72be468","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir.woff2","hash":"dc3c0ed67c9abb062b562e8553776f614d2946c2","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir.woff","hash":"c798391d624b9bb44497a87ffc4f7eb52042dceb","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"3ad44eb5c276d1435408f253ca78da729a1aca90","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"f3f0ea4847825806062a9b7a0f629671eb6b6408","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"830f8653e5f4a5331ac0b47c5701f65fe9f1bb32","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"114f35e6d9053caca2ef6d1e34fea3f87a59245b","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Black.eot","hash":"603acd29416644e4b4fb8646abeada1865ba6869","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Black.ttf","hash":"23ee4a19421de9a0ca9dddc5435a8efe5bf28d87","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Bold.eot","hash":"9ef82b07f3adad7d644c9c3a6d35a0c727bd64e8","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Bold.ttf","hash":"658c1da4f2a0124f6340058daa6873a86e6ba4fc","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Light.eot","hash":"32f51bf715663f5ca419e138617fc05f7055aef5","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Light.ttf","hash":"b2372b67b9519fb4fa8e05de6c0ddae56845ff79","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Medium.eot","hash":"17be9f699c30f0384004b46e991db8ac38a9992e","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Medium.ttf","hash":"31cdbcc7215d01c9dd2beb8a28f8b7a7de75b9f4","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Thin.eot","hash":"2c0ebb336dd012da8d575cae0ee4d048b65fe6e1","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir-Thin.ttf","hash":"d53fcc2e2d6c9c77613afcd34058be1b75bb0fef","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir.eot","hash":"bd3a7cb9eb70d36b4cfba8c5a05d234aefeefe3c","modified":1615380507044},{"_id":"public/lib/vazir-font/Vazir.ttf","hash":"c7a3f2f4d56c4c4ec69d395baf39b55198da0254","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"91daac2bfba5e6a1a15ce44c53eab524d01c7fb0","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"f356aa2e4d9b7245985d312d3bfba180f774e3b7","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"61f40daca6978e6e7ab761e748c2dd9d236c7586","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"b2c74520c3f506efbfefca867918e5ae28bd5222","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"f34ee061900ecd1ed3d3fd9f8f47f4e84c6d56bf","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"d4987ee41e0e4142d561f76b8ea8e034c4d5d9d2","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"1622937e49766e21eacf4ac7065b711f0fe580e1","modified":1615380507044},{"_id":"public/css/rtl.css","hash":"9589fac02a34fd9084f805f801889028756bbb65","modified":1615380507044},{"_id":"public/js/main.js","hash":"584c5a69ac81a483a1c4377a2e2cf326c2795e7b","modified":1615380507044},{"_id":"public/js/search.js","hash":"90860ff07187cf1cf21224b05e23b5e8fcf6efef","modified":1615380507044},{"_id":"public/lib/clipboard/clipboard.min.js","hash":"ee60ca5ba9401456105ef703a98092369b579c80","modified":1615380507044},{"_id":"public/lib/vazir-font/font-face.css","hash":"2a95709b15ee45fc2328051038ceedddf83235bb","modified":1615380507044},{"_id":"public/lib/justified-gallery/css/justifiedGallery.min.css","hash":"92bb6e468a1db7fbd99ccb960e15e28572254263","modified":1615380507044},{"_id":"public/css/style.css","hash":"dbc33c43d9c34f9f83e44e2232c69e968eb58a69","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"be6b63d528286b1be2328d871c9bae95d8d57174","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"91b40a8f284159d9fff81dc522670ef68d562682","modified":1615380507044},{"_id":"public/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1615380507044},{"_id":"public/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1615380507044},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"703603273f5d5d52eb456d6385e1a68294fbd568","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1615380507044},{"_id":"public/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1615380507044},{"_id":"public/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"29e6c7e5a4d63d2c9563cd208456cb4f8a357868","modified":1615380507044},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"3a090431fdec61a25ed69b9e6f35a6656bde1595","modified":1615380507044},{"_id":"source/search/index.md","hash":"cd1f000aed02ab6dfb29ceac7e05600b1104f391","modified":1615380682538},{"_id":"source/_post/.git/HEAD","hash":"6fd171cc81940f0f672926f0a109ea5fa2f879b5","modified":1615384025292},{"_id":"source/tags/index.md","hash":"ef565cfac9b40b933d8dae3481163f36ffa30b30","modified":1615381047578},{"_id":"source/_post/.git/config","hash":"8b2f37fbd111cf4b9875e849024d3b6163a8ba30","modified":1615384025295},{"_id":"source/_post/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1615384016722},{"_id":"source/_post/.git/index","hash":"901ede754219ed0e4a76fd96c406a16cbe1c6e27","modified":1615384025322},{"_id":"source/_post/.git/packed-refs","hash":"d91191097c9fcfd757e743e82d271e0a3364969f","modified":1615384025292},{"_id":"source/_post/leetcode/3Sum.md","hash":"fc70c53e9fdd898c6806d3c044d290e86bb022f2","modified":1615384025295},{"_id":"source/_post/leetcode/Add-and-Search-Word-Data-structure-design.md","hash":"5c8350ce9d623b58afc81765332451c1e79b4563","modified":1615384025295},{"_id":"source/_post/leetcode/AddTwoNumbers.md","hash":"d09089c981bbd990466df6c455d31dc93c9c4c26","modified":1615384025295},{"_id":"source/_post/leetcode/4Sum-2.md","hash":"cbf87f8c5fc2e3ea73608a66210c1c98a807c045","modified":1615384025295},{"_id":"source/_post/leetcode/All-Elements-in-Two-Binary-Search-Trees.md","hash":"297aecf72276da6fb1a32c8db2d498d3c7cf37c3","modified":1615384025295},{"_id":"source/_post/leetcode/Advantage-Shuffle.md","hash":"7ef4cbb8b742175f435c9b8e65c2876bd6466715","modified":1615384025295},{"_id":"source/_post/leetcode/677.Map-Sum-Pairs.md","hash":"2fcfb94a1bbd5e5a9a616de16e808bb267a7d088","modified":1615384025295},{"_id":"source/_post/leetcode/All-Nodes-Distance-K-in-Binary-Tree.md","hash":"7a09bf1a956af5032746d0ad1659213be5b4ad27","modified":1615384025299},{"_id":"source/_post/leetcode/Array-Nesting.md","hash":"03fd2425f6935ac3019b952a3adc4cd2e226a661","modified":1615384025299},{"_id":"source/_post/leetcode/Asteroid-Collision.md","hash":"301764459fb3640638051ab979089226749143b1","modified":1615384025299},{"_id":"source/_post/leetcode/Balanced-Binary-Tree.md","hash":"a74d1225fb4e636c777766568a144eff97139531","modified":1615384025299},{"_id":"source/_post/leetcode/Best-Sightseeing-Pair.md","hash":"72a2bd8f43e41104df2410c2270936636fb4e2da","modified":1615384025299},{"_id":"source/_post/leetcode/Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee.md","hash":"1a35ee0259547cfe3cf46b3e6d344312566c53f0","modified":1615384025299},{"_id":"source/_post/leetcode/Best-Time-to-Buy-and-Sell-Stock.md","hash":"2d5972e004d466add22b5ee945299ba50b5eb9ae","modified":1615384025299},{"_id":"source/_post/leetcode/All-Possible-Full-Binary-Trees.md","hash":"a5e87df954a050cb83f6e491329dc0d80a3ff30b","modified":1615384025299},{"_id":"source/_post/leetcode/Binary-Search-Tree-to-Greater-Sum-Tree.md","hash":"860f3c772b55490866cd5e3ff487946074fbacdb","modified":1615384025299},{"_id":"source/_post/leetcode/Binary-Tree-Coloring-Game.md","hash":"a57fb1a06e2af2516c0b51046e02e7e48d01b2bc","modified":1615384025299},{"_id":"source/_post/leetcode/Binary-Search-Tree-Iterator.md","hash":"b8db1a0a717bb5050152a9b7e9e87aa7f8cbf441","modified":1615384025299},{"_id":"source/_post/leetcode/Binary-Tree-Level-Order-Traversal.md","hash":"4b82cf1164df6e8db5b90529c80d63ef44aa6f3a","modified":1615384025299},{"_id":"source/_post/leetcode/Binary-Tree-Paths.md","hash":"0d003b4faf26e565dfccddf63f7243aaed0a5455","modified":1615384025299},{"_id":"source/_post/leetcode/Binary-Tree-Pruning.md","hash":"bddb6f444f3b6a4d93a019e3cda7afcfd36d4f38","modified":1615384025299},{"_id":"source/_post/leetcode/Binary-Tree-Right-Side-View.md","hash":"bcaa69accb6673803946ec9afc6373c7cc625af0","modified":1615384025299},{"_id":"source/_post/leetcode/Binary-Tree-Zigzag-Level-Order-Traversal.md","hash":"71262ade247d6e50caf24bac8561d447a2751737","modified":1615384025299},{"_id":"source/_post/leetcode/Bitwise-ORs-of-Subarrays.md","hash":"34a7fdfb291b72170890e5ee56383cfb79bca7bb","modified":1615384025299},{"_id":"source/_post/leetcode/Boats-to-Save-People.md","hash":"7087c9667c42d0a40f706ce9ba7debc01b50768a","modified":1615384025299},{"_id":"source/_post/leetcode/Binary-Tree-Preorder-Inorder-Postorder-Traversal.md","hash":"26c64ea72021a16680d974e861410b84ae48fd66","modified":1615384025299},{"_id":"source/_post/leetcode/Climbing-Stairs.md","hash":"a65a03a9047907eea3e28a6f2ed709b14bdfc430","modified":1615384025299},{"_id":"source/_post/leetcode/Combination-Sum.md","hash":"780721a308635f66ba1da5aa0838f71b89782d9f","modified":1615384025299},{"_id":"source/_post/leetcode/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal.md","hash":"25b94e6883450c06515219ed85da609479d9a565","modified":1615384025302},{"_id":"source/_post/leetcode/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.md","hash":"6314ba205316e159d0d7db6b79c4f9307c66c0c9","modified":1615384025302},{"_id":"source/_post/leetcode/Construct-the-Rectangle.md","hash":"1b05998129829acde42c884f57c1e5c667bb0917","modified":1615384025302},{"_id":"source/_post/leetcode/Container_With_Most_Water.md","hash":"b91dd5e6563359cf92f8639c316b6f2133e84fa5","modified":1615384025302},{"_id":"source/_post/leetcode/Contains-Duplicate-II.md","hash":"98d0f15e589bda5029c96779d76514d192755be4","modified":1615384025302},{"_id":"source/_post/leetcode/Convert-Sorted-Array-to-Binary-Search-Tree.md","hash":"e8307b112ed55e4e7e57cb33451b235f11f69cef","modified":1615384025302},{"_id":"source/_post/leetcode/Count-Numbers-with-Unique-Digits.md","hash":"5282ab44cf8e1f7c51fd58d412f0357fded57d63","modified":1615384025302},{"_id":"source/_post/leetcode/Count-Servers-that-Communicate.md","hash":"7b1bf79175986fd4e0a0780d34b535c849f39aaa","modified":1615384025302},{"_id":"source/_post/leetcode/Counting-Bits.md","hash":"9f5fa9822355a695381c8270f28abf2f0fdc6f2c","modified":1615384025302},{"_id":"source/_post/leetcode/Deepest-Leaves-Sum.md","hash":"368363707781e1087cc57f59c39bc8227408c018","modified":1615384025302},{"_id":"source/_post/leetcode/Delete-Leaves-With-a-Given-ValueMedium.md","hash":"954b6ac25dd856041ccc4390f3efabaa520199bc","modified":1615384025302},{"_id":"source/_post/leetcode/Delete-Node-in-a-BST.md","hash":"4c17cede7f6d24f437900d2a43a37fd4529d5959","modified":1615384025302},{"_id":"source/_post/leetcode/Course-Schedule.md","hash":"e503af315f80abbb98aacf1e62d97dd412aa1c0f","modified":1615384025302},{"_id":"source/_post/leetcode/Delete-Nodes-And-Return-Forest.md","hash":"a8cb57b790665914148efff8789ed6d4c0f30c28","modified":1615384025302},{"_id":"source/_post/leetcode/Diagonal-Traverse.md","hash":"66ab45cc59b8a5713e50ca36a930780e548d1bd8","modified":1615384025302},{"_id":"source/_post/leetcode/Diameter-of-Binary-Tree.md","hash":"ae871b90a8cd2c2ff542c23f1c2bc948c61fc6e7","modified":1615384025302},{"_id":"source/_post/leetcode/Evaluate-Reverse-Polish-Notation.md","hash":"9060111b61330454ec5e9594a5fae8bcceceb1b7","modified":1615384025302},{"_id":"source/_post/leetcode/Evaluate-Division.md","hash":"b7752111b7103ece2eb9e30010d4fd1afc0bb9ae","modified":1615384025302},{"_id":"source/_post/leetcode/Find-Bottom-Left-Tree.md","hash":"f260ff3a11880bf647406c6e3fa0c0cba2f912b8","modified":1615384025302},{"_id":"source/_post/leetcode/Find-Largest-Value-in-Each-Tree-Row.md","hash":"e44f5fc7bc10e398be70b016e3698137b2cfab01","modified":1615384025302},{"_id":"source/_post/leetcode/Find-Peak-Element.md","hash":"5debaa6edcc203d93ca6ca34bdafc27f7447e2f6","modified":1615384025302},{"_id":"source/_post/leetcode/Find-the-Duplicate-Number.md","hash":"ad496edd5e999f11b5322f7c4a09e2af39174ca0","modified":1615384025302},{"_id":"source/_post/leetcode/Flatten-Binary-Tree-to-Linked-List.md","hash":"3bff030769293405b44549a75aa289a57e09a043","modified":1615384025305},{"_id":"source/_post/leetcode/Daily-Temperatures.md","hash":"efee652a8f8d68b29036cd7f7894ed78f3e454e1","modified":1615384025302},{"_id":"source/_post/leetcode/Flatten-a-Multilevel-Doubly-Linked-List.md","hash":"d78c6421174e0a97f0f580bbc9330a00dc02f148","modified":1615384025305},{"_id":"source/_post/leetcode/Flipping-an-Image.md","hash":"fef980f56bd8b52d0d8526ed83ab28842f1049e3","modified":1615384025305},{"_id":"source/_post/leetcode/Decode-String.md","hash":"bee3437769295479c22708c8312382016160b964","modified":1615384025302},{"_id":"source/_post/leetcode/Flatten-Nested-List-Iterator.md","hash":"e4ca2fe9b95496c8824cfd109905cbc27acf3778","modified":1615384025305},{"_id":"source/_post/leetcode/Flip-Equivalent-Binary-Trees.md","hash":"867b7511386d3e4a8e8018297b3be600e2b07f9d","modified":1615384025305},{"_id":"source/_post/leetcode/Friend-Circles.md","hash":"9bcb3a8f68e2e43736b830de3a0c01c1bf0154e7","modified":1615384025305},{"_id":"source/_post/leetcode/Global-and-Local-Inversions.md","hash":"4c3869f154a6033cde653e4b065b276b793e8d10","modified":1615384025305},{"_id":"source/_post/leetcode/Generate-Parentheses.md","hash":"fd97777c57d2041dd4cdb9f224badc11c39ce036","modified":1615384025305},{"_id":"source/_post/leetcode/Hamming-Distance.md","hash":"9a85db1325b89d01730c56964b03d4f491b02960","modified":1615384025305},{"_id":"source/_post/leetcode/House-Robber.md","hash":"fd9ce705e8e011e733958c81fe316597dd733b86","modified":1615384025305},{"_id":"source/_post/leetcode/Find-Eventual-Safe-States.md","hash":"fe0601aa14c8518d69eae3c8f0209ee139dfe072","modified":1615384025302},{"_id":"source/_post/leetcode/Implement-Rand10-Using-Rand7.md","hash":"6e6fedd780ca95e054a55b8764b143c4654c3394","modified":1615384025305},{"_id":"source/_post/leetcode/Insert-into-a-binary-search-tree.md","hash":"5188f998de8f54b4eb03c832cd8be696874b102a","modified":1615384025305},{"_id":"source/_post/leetcode/Implement-Trie-Prefix-Tree.md","hash":"eebaf13e7738d162147e27c3b3b0826bf89283a6","modified":1615384025305},{"_id":"source/_post/leetcode/Intersection-of-Two-Arrays-II.md","hash":"bcf532b2a578b3eed8214b5fdc74d2b11c3576e7","modified":1615384025305},{"_id":"source/_post/leetcode/Intersection-of-Two-Arrays.md","hash":"a5dc774ed8394632c3428f7249328f6b490ba44d","modified":1615384025305},{"_id":"source/_post/leetcode/Group-Anagrams.md","hash":"a5da6313e443a2c69fe244341577a767a84a2ad4","modified":1615384025305},{"_id":"source/_post/leetcode/Interval-List-Intersections.md","hash":"4f17df7e4549abdf62e26521d19ea7fbc7b1c8a1","modified":1615384025305},{"_id":"source/_post/leetcode/Intersection-of-Two-Linked-Lists.md","hash":"ee217f282bce8ac0ffdb93a969e4916383ea462d","modified":1615384025305},{"_id":"source/_post/leetcode/House-Robber-III.md","hash":"4ed12b434a0843975cb1cc72598ad5436c71f8af","modified":1615384025305},{"_id":"source/_post/leetcode/Invert-Binary-Tree.md","hash":"1d9713d5b902a20317a16f17ee7a602bb9614784","modified":1615384025305},{"_id":"source/_post/leetcode/Judge-Route-Cicle.md","hash":"55f31d554d0bd64b6e6b70b0a78a62850a341c3a","modified":1615384025305},{"_id":"source/_post/leetcode/Is-Graph-Bipartite.md","hash":"5e1bc53358f79272d42a8db0362fda067c02592b","modified":1615384025305},{"_id":"source/_post/leetcode/Jump-Game-III.md","hash":"4f8694906e502b0709c5e575187cdc6b388b7aaa","modified":1615384025305},{"_id":"source/_post/leetcode/Jump-Game.md","hash":"904dc0f2b866eeb1c730e370bab5efa3e962c32a","modified":1615384025305},{"_id":"source/_post/leetcode/K-Closest-Points-to-Origin.md","hash":"4ef0923bd1cc183d0f582b3d67b9961979ef9b92","modified":1615384025305},{"_id":"source/_post/leetcode/Keys-and-Rooms.md","hash":"7f1b0e1690ae1cbd0f9b0f3b4fc7e96564078dc3","modified":1615384025309},{"_id":"source/_post/leetcode/Kth-Smallest-Element-in-a-BST.md","hash":"e26374b495550908cf59a2cf283e81ea195f7396","modified":1615384025309},{"_id":"source/_post/leetcode/Kth-Largest-Element-in-an-array.md","hash":"406120ccdc9639a759af99c097fd9a8ba991c136","modified":1615384025309},{"_id":"source/_post/leetcode/Largest-Sum-of-Averages.md","hash":"bf5adb61d8a59ef8460992059eecb0b1cfc43ca8","modified":1615384025309},{"_id":"source/_post/leetcode/LeetCode-Stack-Tag-总结.md","hash":"e447763678530119f7e8a99e6169701aa53d7d40","modified":1615384025309},{"_id":"source/_post/leetcode/Length-of-Last-Word.md","hash":"2232e840a2b65e43bc23f326b33e730aa211eaab","modified":1615384025309},{"_id":"source/_post/leetcode/Letter-Combinations-of-a-Phone-Number.md","hash":"a1df579ef50c7d062c0f5f1aaa0c6240181567a3","modified":1615384025309},{"_id":"source/_post/leetcode/Lexicographical-Number.md","hash":"c03a9404ca4d08bf6af38e9811c910a14f361730","modified":1615384025309},{"_id":"source/_post/leetcode/Linked-List-Cycle.md","hash":"580b60e4ac43d3177a0c983248891f4b622e9bda","modified":1615384025309},{"_id":"source/_post/leetcode/Linked-List-Random-Node.md","hash":"3a6e6e057de64de8ba5db3db37cc1b791d7e8d28","modified":1615384025309},{"_id":"source/_post/leetcode/Longest-Harmonious-Subsequence.md","hash":"3e2a5d791d19883d84ec3add603cf1926426c332","modified":1615384025309},{"_id":"source/_post/leetcode/Longest-Continuous-Increasing-Subsqeuence.md","hash":"1deea95ed7c78a49c64aff96fe542bb77c7c05e9","modified":1615384025309},{"_id":"source/_post/leetcode/Longest-Common-Subsequence.md","hash":"c1154f17efeebc18af270f4f0acd526364e414e5","modified":1615384025309},{"_id":"source/_post/leetcode/Longest-Palindrome.md","hash":"4d8ba52b2788a2c70b9eaa889a92de336c9524f9","modified":1615384025309},{"_id":"source/_post/leetcode/Longest-Palindromic-Subsequence.md","hash":"6b065197fa8bdda66bcaf91bc534a07f4f378590","modified":1615384025309},{"_id":"source/_post/leetcode/Longest-Word-in-Dictionary-through-Deleting.md","hash":"ea920fe9cd36da135f54a855f3eb093a4cba2b47","modified":1615384025309},{"_id":"source/_post/leetcode/Longest-Repeating-Character-Replacement.md","hash":"28347ceaceebed06186e14a1accfceb302675d8a","modified":1615384025309},{"_id":"source/_post/leetcode/Longest-String-Chain.md","hash":"013529ce2229d79fb3c215d5ba20b6d182b4509c","modified":1615384025309},{"_id":"source/_post/leetcode/Longest-SubString-with-At-Least-K-Repeating-Characters.md","hash":"76d3b9afbd44547e1d10c2165327bdabdeaa27b9","modified":1615384025309},{"_id":"source/_post/leetcode/LongestCommonPrefix.md","hash":"17cfdd9bdf88c1e4aabe1c08e990c50aa2712349","modified":1615384025309},{"_id":"source/_post/leetcode/LongestPalindromicSubString.md","hash":"02580bb25f646267004782b1f123da1f28f19329","modified":1615384025309},{"_id":"source/_post/leetcode/LongestSubstringWithoutRepeatingCharacters.md","hash":"7ad75191ed31ec0ca1cc8b6784cbaf61228cd824","modified":1615384025309},{"_id":"source/_post/leetcode/Lowest-Common-Ancestor-of-a-Binary-Tree.md","hash":"b16ea49fd232c32bd9ade92b7f6de550ed6f294f","modified":1615384025309},{"_id":"source/_post/leetcode/Majority-Element.md","hash":"b0ecf22ff5e8c19fac1a79315d25b54cc69b0be9","modified":1615384025309},{"_id":"source/_post/leetcode/Matchsticks-to-Square.md","hash":"9844f1697551aaa9bc7aeb46b399d74d1e1ece1e","modified":1615384025312},{"_id":"source/_post/leetcode/Maximal-Square.md","hash":"fa7335d3db7105e493bc1f63576ba8e66ca08cea","modified":1615384025312},{"_id":"source/_post/leetcode/Maximum-Difference-Between-Node-and-Ancestor.md","hash":"0e68703e903ae8dd4e924d7d5e700eb8852ee4dd","modified":1615384025312},{"_id":"source/_post/leetcode/Maximum-Length-of-Repeated-Subarray.md","hash":"eeff9acd41ffea00a95098bcb0cf2639fb094624","modified":1615384025312},{"_id":"source/_post/leetcode/Maximum-Binary-Tree.md","hash":"ab8f8685b91aec49622472329bfd0f8d5774209a","modified":1615384025312},{"_id":"source/_post/leetcode/Maximum-Level-Sum-of-a-Binary-Tree.md","hash":"f27d8c5952aa3f52400404ca01120a6408473045","modified":1615384025312},{"_id":"source/_post/leetcode/Maximum-Swap.md","hash":"0729f9edb96394781883d6aef1de95718a81117a","modified":1615384025312},{"_id":"source/_post/leetcode/Maximun-Depth-of-Binary-Tree.md","hash":"398e145d24dd1a837b6f7afee4d4ea05776d8175","modified":1615384025312},{"_id":"source/_post/leetcode/MaximumProductSubarray.md","hash":"f879d662dd829438283cf0359457cc8815366464","modified":1615384025312},{"_id":"source/_post/leetcode/MedianOfTwoSortedArrays.md","hash":"277d38cafc8ba161a95f7270f16e21dfc538e275","modified":1615384025312},{"_id":"source/_post/leetcode/Merge-Intervals.md","hash":"5cf71657d25937aadf95060d874b865848daf406","modified":1615384025312},{"_id":"source/_post/leetcode/MergeTwoSortedList.md","hash":"b94850754a0fded9735c27d0a0ab96ec46af1505","modified":1615384025312},{"_id":"source/_post/leetcode/Merge-Two-Binary-Trees.md","hash":"e91431edf8ef1646bd7b88034e5ba8a8dacf60ce","modified":1615384025312},{"_id":"source/_post/leetcode/Min-Cost-Climbing-Stairs.md","hash":"929b020ac03eb5884b4768eee3e002287529799b","modified":1615384025312},{"_id":"source/_post/leetcode/Minimum-ASCII-Delete-Sum-for-Two-Strings.md","hash":"591c53f38736a15b0d0322742ffa99b343904d17","modified":1615384025312},{"_id":"source/_post/leetcode/Minimum-Falling-Path-Sum.md","hash":"6c8da2a221dd7944ef9017984d839d36d322c264","modified":1615384025312},{"_id":"source/_post/leetcode/Move-Zeroes.md","hash":"56989bff9b151062d9f8bc6f23865dc872fd8080","modified":1615384025312},{"_id":"source/_post/leetcode/Minimum-Moves-to-Equal-Array-Elements-II.md","hash":"9ae1ea1df029b3d895f865e0335f90f1962ef2fa","modified":1615384025312},{"_id":"source/_post/leetcode/Network-Delay-Time.md","hash":"ec5f8989d4828d5393e71ce0181b35adc43982a6","modified":1615384025312},{"_id":"source/_post/leetcode/N-ary-Tree-Level-Order-Traversal.md","hash":"90d2484aceff7d5b6b4b5ea122e3aeae9252aabd","modified":1615384025312},{"_id":"source/_post/leetcode/Next-Greater-Element-III.md","hash":"465336d2de3f86688e278f0393e9c8bab8d95ac3","modified":1615384025312},{"_id":"source/_post/leetcode/Nim-Game.md","hash":"2f8171cb83f59efdb5ceb2c7568af29ee00ad03c","modified":1615384025312},{"_id":"source/_post/leetcode/Odd-Even-Linked-List.md","hash":"fa3f0120af2f7220c7f5f6049168df68e3f01ec2","modified":1615384025315},{"_id":"source/_post/leetcode/Number-of-Islands.md","hash":"2b30172b4ebe96334b34542db3219122ed4d0848","modified":1615384025315},{"_id":"source/_post/leetcode/Next-Permutation.md","hash":"7cc8de236c82a8dac602a09abfad3beeaf4f6306","modified":1615384025312},{"_id":"source/_post/leetcode/Palindrome-Linked-List.md","hash":"569c6383887b94a6eb57faf5d2a79116e119a4ba","modified":1615384025315},{"_id":"source/_post/leetcode/Partition-Labels.md","hash":"4881b23efc78b4bff37bcf0903f0e0f9fabf2da2","modified":1615384025315},{"_id":"source/_post/leetcode/Path-Sum.md","hash":"0a57b830cd60179d51ea6e131ed46964c215e09f","modified":1615384025315},{"_id":"source/_post/leetcode/Partition-to-K-Equal-Sum-Subsets.md","hash":"8ab8b6fdf4dbe554d66618232e52cebbe321b790","modified":1615384025315},{"_id":"source/_post/leetcode/Perfect-Squares.md","hash":"74f9c35d560aaa0035467d3c88d9e0b2a532583d","modified":1615384025315},{"_id":"source/_post/leetcode/Permutations.md","hash":"e6b21e56b509fa8d50b7131ce495ab1b82c2c8d7","modified":1615384025315},{"_id":"source/_post/leetcode/Plus-One.md","hash":"dab91c6fd6d96ba941255af6d88a6214052cf932","modified":1615384025315},{"_id":"source/_post/leetcode/Populating-Next-Right-Pointers-in-Each-Node-II.md","hash":"f4d02c00b0195995e0cb2808b59c5bfcc127327b","modified":1615384025315},{"_id":"source/_post/leetcode/Possible-Bipartition.md","hash":"ed98aedb69dbbcd036f8603e4ff34e2a7b050eba","modified":1615384025315},{"_id":"source/_post/leetcode/Print-FooBar-Alternately.md","hash":"f0ede19b643bee2dd38fede45aab2422f1a13cd3","modified":1615384025315},{"_id":"source/_post/leetcode/Pow(x,y).md","hash":"43d684bbc306a37aea052cc960bdff8e2ba77496","modified":1615384025315},{"_id":"source/_post/leetcode/Product-of-Array-Except-Self.md","hash":"ebdbc5828b67e4b1aff7d1abf74254af32766215","modified":1615384025315},{"_id":"source/_post/leetcode/Redundant-Connection.md","hash":"0d9b415309a6187cb64d09acedb26480a12efabc","modified":1615384025315},{"_id":"source/_post/leetcode/Remove-Duplicates-from-Sorted-Array.md","hash":"2e3cd652162a6262b4639b798d73470834531bac","modified":1615384025315},{"_id":"source/_post/leetcode/Remove-Element.md","hash":"71f95559915c54c5f240ba72c25d92d8ad7c2ce9","modified":1615384025315},{"_id":"source/_post/leetcode/Rectangle-Area.md","hash":"1ab0a565935ed09b087518bb011fe4b22dfe9b87","modified":1615384025315},{"_id":"source/_post/leetcode/Reverse-Linked-List.md","hash":"32a52a73d293f6f87d60cccf3b5a35256af07619","modified":1615384025315},{"_id":"source/_post/leetcode/Remove-Nth-Node-From-End-of-List.md","hash":"bef67db003b44631b98c875ac120fb78af37a613","modified":1615384025315},{"_id":"source/_post/leetcode/Repeated-Substring-Pattern.md","hash":"8082439771e8302ebdbc793f43094148a838eafd","modified":1615384025315},{"_id":"source/_post/leetcode/Replace-Words.md","hash":"fd50bf465b296183af6ea8400e96d64b8c188630","modified":1615384025315},{"_id":"source/_post/leetcode/Reverse-String.md","hash":"d5cbe53b1d7880f25e3fd83a0e88d908cd333be3","modified":1615384025315},{"_id":"source/_post/leetcode/Reverse-Words-in-a-String-III.md","hash":"82bbc592ea6133dc2c9b47ff2da68982cd2766de","modified":1615384025315},{"_id":"source/_post/leetcode/Reverse-Substrings-Between-Each-Pair-of-Parentheses.md","hash":"6e1a03234edf3927f15eccf3237071a28a7002d3","modified":1615384025315},{"_id":"source/_post/leetcode/Same-Tree.md","hash":"a701f5dfddfeff7df26759fc7caf0108d3af9ee9","modified":1615384025315},{"_id":"source/_post/leetcode/Satisfiability-of-Equality-Equations.md","hash":"159d5013ba715a50257eb82b95c2ca97772d3e4c","modified":1615384025315},{"_id":"source/_post/leetcode/Rotate-Function.md","hash":"ec763f24fecddeba5308679a60b483684700177a","modified":1615384025315},{"_id":"source/_post/leetcode/Rotate-Image.md","hash":"0200f1ccb27454d1281fbc7aa6a07227795f8788","modified":1615384025315},{"_id":"source/_post/leetcode/Shifting-Letters.md","hash":"046ee725509e54dd56dabc78ad802bdd3635a290","modified":1615384025319},{"_id":"source/_post/leetcode/Search-a-2D-Matrix-II.md","hash":"1d96de76b34459d433a984bdcf52fa015dd91bc9","modified":1615384025315},{"_id":"source/_post/leetcode/Serialize-and-Deserialize-BST.md","hash":"46a225ff12156b22fb0d34a48c776196fdcce069","modified":1615384025315},{"_id":"source/_post/leetcode/Search-in-Rotated-Sorted-Array.md","hash":"7f701384504f7ea2706e9a6d4501ee023b42aa68","modified":1615384025315},{"_id":"source/_post/leetcode/Single-Number-III.md","hash":"95e29e839506941e745b8411f99076759b9c6c5a","modified":1615384025319},{"_id":"source/_post/leetcode/Sort-Characters-By-Frequency.md","hash":"bc872c72685cc0b5d82055401a0ede7f28960986","modified":1615384025319},{"_id":"source/_post/leetcode/Sort-Colors.md","hash":"b5ca1a147f56bc9c812527625209deb5a36de26d","modified":1615384025319},{"_id":"source/_post/leetcode/Simplify-Path.md","hash":"a0a5630bd5b6dd9e4043fc064cb4e8d2a2efeebf","modified":1615384025319},{"_id":"source/_post/leetcode/Sort-List.md","hash":"9dc43e733b3e850523d3dfc8a861cdeabb0d9f07","modified":1615384025319},{"_id":"source/_post/leetcode/Stone-Game.md","hash":"96a54d9ced3f4f0e44576f465e0cbdc20d443770","modified":1615384025319},{"_id":"source/_post/leetcode/Spiral-Matrix.md","hash":"d144beb30795fed35232ad85d4f187a05d5760b0","modified":1615384025319},{"_id":"source/_post/leetcode/Split-Linked-List-in-Parts.md","hash":"74c5ae2807f555d58fa4f83510a32cd888eed3c6","modified":1615384025319},{"_id":"source/_post/leetcode/Subsets.md","hash":"430954ba9838dfda1c841633ac377de9ed937d51","modified":1615384025319},{"_id":"source/_post/leetcode/String-to-Integer-atoi.md","hash":"348366ef2d6e4dff3994a0a6a308821e82580c24","modified":1615384025319},{"_id":"source/_post/leetcode/Swaps-Nodes-in-Pairs.md","hash":"53553dbfebafd2841c1bcf3dae201311b647608f","modified":1615384025319},{"_id":"source/_post/leetcode/Sum-Root-to-Leaf-Numbers.md","hash":"446bff3a66d669465f6bb245836cdfc7454e6189","modified":1615384025319},{"_id":"source/_post/leetcode/Top-K-Frequent-Elements.md","hash":"3345768c2c82888ba843503c93837a3c67b82a9e","modified":1615384025319},{"_id":"source/_post/leetcode/Trim-a-Binary-Search-Tree.md","hash":"1bf667e0c05ae62595b4d6c42ce2512dfd2ee80d","modified":1615384025319},{"_id":"source/_post/leetcode/Triangle.md","hash":"f10437e035fa221cebd0bebcf863db80bfae2d30","modified":1615384025319},{"_id":"source/_post/leetcode/Symmetric-Tree.md","hash":"0fa1e75dcc79da97b3b7d8114b5e12977d4bedc9","modified":1615384025319},{"_id":"source/_post/leetcode/Unique-Paths.md","hash":"6f54151ccd0e3d07905d4af549e94c980a41821e","modified":1615384025319},{"_id":"source/_post/leetcode/Valid-Parentheses.md","hash":"cfffa8fa931533eaf56d37bf36d3c2680eb07cf7","modified":1615384025319},{"_id":"source/_post/leetcode/Unique-Binary-Search-Tree.md","hash":"ec546e6cbd55bf30096b61efed01476a94566f3a","modified":1615384025319},{"_id":"source/_post/leetcode/Unique-Substrings-in-Wraparound-String.md","hash":"eb7d0fdfd7aff2ccf128885b91679ac62d8930ff","modified":1615384025319},{"_id":"source/_post/leetcode/Validate-Stack-Sequences.md","hash":"e47985cdf7b26e0c20866510671c9c41624463e0","modified":1615384025319},{"_id":"source/_post/leetcode/Valid-Triangle-Number.md","hash":"1d02ad91f03221073212ee6b35bea43059ebbb44","modified":1615384025319},{"_id":"source/_post/leetcode/Validate-Binary-Search-Tree.md","hash":"86bf30f870b5ce646e9ba24e17a69ef4e1c62f63","modified":1615384025319},{"_id":"source/_post/leetcode/Verify-Preorder-Serialization-of-a-Binary-Tree.md","hash":"25d780b37cf0fbf85b2d35fc756935db949ea58a","modified":1615384025319},{"_id":"source/_post/leetcode/Word-Break.md","hash":"3b65d61971e11887ac502fdd603edd9089b4082f","modified":1615384025319},{"_id":"source/_post/leetcode/Word-Search.md","hash":"355eb32ca60af10f7eedb7a84aee8fb67520d1e7","modified":1615384025319},{"_id":"source/_post/leetcode/ZigZag-Conversion.md","hash":"c5c84d50d6d446850f2c09ec56f5991de5569f0a","modified":1615384025319},{"_id":"source/_post/leetcode/airplane-seat-assignment-probability.md","hash":"f15db9951919a14d4a24ad40e3d533a9e8b308ba","modified":1615384025319},{"_id":"source/_post/leetcode/angle-between-hands-of-a-clock.md","hash":"e7f6514fffe111983af91d1b28a1b25a4723b659","modified":1615384025319},{"_id":"source/_post/leetcode/construct-binary-tree-from-preorder-and-postorder-traversal.md","hash":"b38228645402a89baed5c30a2ef634f55e2dd64b","modified":1615384025319},{"_id":"source/_post/leetcode/different-ways-to-add-parentheses.md","hash":"b70e81b0ed3ab822f1aca49425e869294740d276","modified":1615384025319},{"_id":"source/_post/leetcode/guess-number-higher-or-lower-ii.md","hash":"72823fcf865d701ad14fd9b866dc7e51f138a6bb","modified":1615384025319},{"_id":"source/_post/leetcode/h-index.md","hash":"bd0dc8ba1dbce5476d053b9100544d2db3761eba","modified":1615384025319},{"_id":"source/_post/leetcode/linked-list-components.md","hash":"6fff46057f2b1c42d35164d02be23036992dd7da","modified":1615384025319},{"_id":"source/_post/leetcode/longest-univalue-path.md","hash":"10a8e71d6af650dcaaa632921e1e71bc7d2b0f91","modified":1615384025322},{"_id":"source/_post/leetcode/maximum-product-of-word-lengths.md","hash":"df9257210fcb21da6406ae65b69190b761ed3956","modified":1615384025322},{"_id":"source/_post/leetcode/next-greater-node-in-linked-list.md","hash":"4024f78344763d214ba6ed8ff2a87c2962152e19","modified":1615384025322},{"_id":"source/_post/leetcode/populating-next-right-pointers-in-each-node.md","hash":"2add8b8495376cf747013ecad62266a3589d972d","modified":1615384025322},{"_id":"source/_post/leetcode/search-for-a-range.md","hash":"0f75e61bb1fc77e7964676f626350cf4333c298d","modified":1615384025322},{"_id":"source/_post/leetcode/water-and-jug-problem.md","hash":"a716469ebab16c6aff80b69f2fe51db406c06737","modified":1615384025322},{"_id":"source/_post/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1615384016722},{"_id":"source/_post/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1615384016722},{"_id":"source/_post/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1615384016722},{"_id":"source/_post/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1615384016722},{"_id":"source/_post/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1615384016722},{"_id":"source/_post/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1615384016722},{"_id":"source/_post/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1615384016722},{"_id":"source/_post/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1615384016722},{"_id":"source/_post/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1615384016722},{"_id":"source/_post/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1615384016722},{"_id":"source/_post/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1615384016722},{"_id":"source/_post/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1615384016722},{"_id":"source/_post/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1615384016722},{"_id":"source/_post/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1615384016722},{"_id":"source/_post/.git/logs/HEAD","hash":"bc8b8912d04eabc06531430c18ea8791294449a3","modified":1615384025292},{"_id":"source/_post/.git/refs/heads/algo","hash":"39300a55aef4d75bbc3c2db2ce6a244573eae609","modified":1615384025292},{"_id":"source/_post/.github/workflows/blank.yml","hash":"4df3856cabc8051d30dd7fadfa15068025e59f5f","modified":1615384025295},{"_id":"source/_post/.git/logs/refs/heads/algo","hash":"bc8b8912d04eabc06531430c18ea8791294449a3","modified":1615384025292},{"_id":"source/_post/.git/objects/pack/pack-18f88f8d445dc9da1607ffa6be4fe2058fc64922.idx","hash":"859d7df6965b89e403b7eb370298fa20e2172a61","modified":1615384024835},{"_id":"source/_post/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1615384025292},{"_id":"source/_post/.git/logs/refs/remotes/origin/HEAD","hash":"f8fcaae2a3fd1b119e68bb40d42a6ba1afdaa5a9","modified":1615384025292},{"_id":"source/_post/.git/objects/pack/pack-18f88f8d445dc9da1607ffa6be4fe2058fc64922.pack","hash":"cc66a569bbbc2b1d9e6db8f51f98df61a357be59","modified":1615384024835},{"_id":"public/search.xml","hash":"9d3dede5a32f0ab8a3ae4f9ebb5f044a7b8bcb7e","modified":1615389455806},{"_id":"public/tags/index.html","hash":"b27f71bc11d4a46ac08cbb8be31207f71bf2c5ab","modified":1615389839977},{"_id":"public/search/index.html","hash":"1d5fb2495afa8e627f548fea633c0154343584d7","modified":1615389839977},{"_id":"source/_post/Add-and-Search-Word-Data-structure-design.md","hash":"5c8350ce9d623b58afc81765332451c1e79b4563","modified":1615384025295},{"_id":"source/_post/4Sum-2.md","hash":"cbf87f8c5fc2e3ea73608a66210c1c98a807c045","modified":1615384025295},{"_id":"source/_post/677.Map-Sum-Pairs.md","hash":"2fcfb94a1bbd5e5a9a616de16e808bb267a7d088","modified":1615384025295},{"_id":"source/_post/3Sum.md","hash":"fc70c53e9fdd898c6806d3c044d290e86bb022f2","modified":1615384025295},{"_id":"source/_post/AddTwoNumbers.md","hash":"d09089c981bbd990466df6c455d31dc93c9c4c26","modified":1615384025295},{"_id":"source/_post/Advantage-Shuffle.md","hash":"7ef4cbb8b742175f435c9b8e65c2876bd6466715","modified":1615384025295},{"_id":"source/_post/All-Nodes-Distance-K-in-Binary-Tree.md","hash":"7a09bf1a956af5032746d0ad1659213be5b4ad27","modified":1615384025299},{"_id":"source/_post/All-Elements-in-Two-Binary-Search-Trees.md","hash":"297aecf72276da6fb1a32c8db2d498d3c7cf37c3","modified":1615384025295},{"_id":"source/_post/All-Possible-Full-Binary-Trees.md","hash":"a5e87df954a050cb83f6e491329dc0d80a3ff30b","modified":1615384025299},{"_id":"source/_post/Array-Nesting.md","hash":"03fd2425f6935ac3019b952a3adc4cd2e226a661","modified":1615384025299},{"_id":"source/_post/Asteroid-Collision.md","hash":"301764459fb3640638051ab979089226749143b1","modified":1615384025299},{"_id":"source/_post/Balanced-Binary-Tree.md","hash":"a74d1225fb4e636c777766568a144eff97139531","modified":1615384025299},{"_id":"source/_post/Best-Sightseeing-Pair.md","hash":"72a2bd8f43e41104df2410c2270936636fb4e2da","modified":1615384025299},{"_id":"source/_post/Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee.md","hash":"1a35ee0259547cfe3cf46b3e6d344312566c53f0","modified":1615384025299},{"_id":"source/_post/Binary-Search-Tree-to-Greater-Sum-Tree.md","hash":"860f3c772b55490866cd5e3ff487946074fbacdb","modified":1615384025299},{"_id":"source/_post/Best-Time-to-Buy-and-Sell-Stock.md","hash":"2d5972e004d466add22b5ee945299ba50b5eb9ae","modified":1615384025299},{"_id":"source/_post/Binary-Tree-Coloring-Game.md","hash":"a57fb1a06e2af2516c0b51046e02e7e48d01b2bc","modified":1615384025299},{"_id":"source/_post/Binary-Search-Tree-Iterator.md","hash":"b8db1a0a717bb5050152a9b7e9e87aa7f8cbf441","modified":1615384025299},{"_id":"source/_post/Binary-Tree-Level-Order-Traversal.md","hash":"4b82cf1164df6e8db5b90529c80d63ef44aa6f3a","modified":1615384025299},{"_id":"source/_post/Binary-Tree-Paths.md","hash":"0d003b4faf26e565dfccddf63f7243aaed0a5455","modified":1615384025299},{"_id":"source/_post/Binary-Tree-Pruning.md","hash":"bddb6f444f3b6a4d93a019e3cda7afcfd36d4f38","modified":1615384025299},{"_id":"source/_post/Binary-Tree-Right-Side-View.md","hash":"bcaa69accb6673803946ec9afc6373c7cc625af0","modified":1615384025299},{"_id":"source/_post/Bitwise-ORs-of-Subarrays.md","hash":"34a7fdfb291b72170890e5ee56383cfb79bca7bb","modified":1615384025299},{"_id":"source/_post/Binary-Tree-Zigzag-Level-Order-Traversal.md","hash":"71262ade247d6e50caf24bac8561d447a2751737","modified":1615384025299},{"_id":"source/_post/Binary-Tree-Preorder-Inorder-Postorder-Traversal.md","hash":"26c64ea72021a16680d974e861410b84ae48fd66","modified":1615384025299},{"_id":"source/_post/Climbing-Stairs.md","hash":"a65a03a9047907eea3e28a6f2ed709b14bdfc430","modified":1615384025299},{"_id":"source/_post/Combination-Sum.md","hash":"780721a308635f66ba1da5aa0838f71b89782d9f","modified":1615384025299},{"_id":"source/_post/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal.md","hash":"25b94e6883450c06515219ed85da609479d9a565","modified":1615384025302},{"_id":"source/_post/Boats-to-Save-People.md","hash":"7087c9667c42d0a40f706ce9ba7debc01b50768a","modified":1615384025299},{"_id":"source/_post/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.md","hash":"6314ba205316e159d0d7db6b79c4f9307c66c0c9","modified":1615384025302},{"_id":"source/_post/Construct-the-Rectangle.md","hash":"1b05998129829acde42c884f57c1e5c667bb0917","modified":1615384025302},{"_id":"source/_post/Container_With_Most_Water.md","hash":"b91dd5e6563359cf92f8639c316b6f2133e84fa5","modified":1615384025302},{"_id":"source/_post/Contains-Duplicate-II.md","hash":"98d0f15e589bda5029c96779d76514d192755be4","modified":1615384025302},{"_id":"source/_post/Convert-Sorted-Array-to-Binary-Search-Tree.md","hash":"e8307b112ed55e4e7e57cb33451b235f11f69cef","modified":1615384025302},{"_id":"source/_post/Count-Numbers-with-Unique-Digits.md","hash":"5282ab44cf8e1f7c51fd58d412f0357fded57d63","modified":1615384025302},{"_id":"source/_post/Count-Servers-that-Communicate.md","hash":"7b1bf79175986fd4e0a0780d34b535c849f39aaa","modified":1615384025302},{"_id":"source/_post/Counting-Bits.md","hash":"9f5fa9822355a695381c8270f28abf2f0fdc6f2c","modified":1615384025302},{"_id":"source/_post/Daily-Temperatures.md","hash":"efee652a8f8d68b29036cd7f7894ed78f3e454e1","modified":1615384025302},{"_id":"source/_post/Decode-String.md","hash":"bee3437769295479c22708c8312382016160b964","modified":1615384025302},{"_id":"source/_post/Course-Schedule.md","hash":"e503af315f80abbb98aacf1e62d97dd412aa1c0f","modified":1615384025302},{"_id":"source/_post/Deepest-Leaves-Sum.md","hash":"368363707781e1087cc57f59c39bc8227408c018","modified":1615384025302},{"_id":"source/_post/Delete-Leaves-With-a-Given-ValueMedium.md","hash":"954b6ac25dd856041ccc4390f3efabaa520199bc","modified":1615384025302},{"_id":"source/_post/Delete-Node-in-a-BST.md","hash":"4c17cede7f6d24f437900d2a43a37fd4529d5959","modified":1615384025302},{"_id":"source/_post/Delete-Nodes-And-Return-Forest.md","hash":"a8cb57b790665914148efff8789ed6d4c0f30c28","modified":1615384025302},{"_id":"source/_post/Diagonal-Traverse.md","hash":"66ab45cc59b8a5713e50ca36a930780e548d1bd8","modified":1615384025302},{"_id":"source/_post/Diameter-of-Binary-Tree.md","hash":"ae871b90a8cd2c2ff542c23f1c2bc948c61fc6e7","modified":1615384025302},{"_id":"source/_post/Find-Largest-Value-in-Each-Tree-Row.md","hash":"e44f5fc7bc10e398be70b016e3698137b2cfab01","modified":1615384025302},{"_id":"source/_post/Find-Bottom-Left-Tree.md","hash":"f260ff3a11880bf647406c6e3fa0c0cba2f912b8","modified":1615384025302},{"_id":"source/_post/Find-Eventual-Safe-States.md","hash":"fe0601aa14c8518d69eae3c8f0209ee139dfe072","modified":1615384025302},{"_id":"source/_post/Find-Peak-Element.md","hash":"5debaa6edcc203d93ca6ca34bdafc27f7447e2f6","modified":1615384025302},{"_id":"source/_post/Find-the-Duplicate-Number.md","hash":"ad496edd5e999f11b5322f7c4a09e2af39174ca0","modified":1615384025302},{"_id":"source/_post/Flatten-Binary-Tree-to-Linked-List.md","hash":"3bff030769293405b44549a75aa289a57e09a043","modified":1615384025305},{"_id":"source/_post/Flatten-a-Multilevel-Doubly-Linked-List.md","hash":"d78c6421174e0a97f0f580bbc9330a00dc02f148","modified":1615384025305},{"_id":"source/_post/Evaluate-Division.md","hash":"b7752111b7103ece2eb9e30010d4fd1afc0bb9ae","modified":1615384025302},{"_id":"source/_post/Flatten-Nested-List-Iterator.md","hash":"e4ca2fe9b95496c8824cfd109905cbc27acf3778","modified":1615384025305},{"_id":"source/_post/Flipping-an-Image.md","hash":"fef980f56bd8b52d0d8526ed83ab28842f1049e3","modified":1615384025305},{"_id":"source/_post/Flip-Equivalent-Binary-Trees.md","hash":"867b7511386d3e4a8e8018297b3be600e2b07f9d","modified":1615384025305},{"_id":"source/_post/Friend-Circles.md","hash":"9bcb3a8f68e2e43736b830de3a0c01c1bf0154e7","modified":1615384025305},{"_id":"source/_post/Generate-Parentheses.md","hash":"fd97777c57d2041dd4cdb9f224badc11c39ce036","modified":1615384025305},{"_id":"source/_post/Global-and-Local-Inversions.md","hash":"4c3869f154a6033cde653e4b065b276b793e8d10","modified":1615384025305},{"_id":"source/_post/Group-Anagrams.md","hash":"a5da6313e443a2c69fe244341577a767a84a2ad4","modified":1615384025305},{"_id":"source/_post/Hamming-Distance.md","hash":"9a85db1325b89d01730c56964b03d4f491b02960","modified":1615384025305},{"_id":"source/_post/House-Robber.md","hash":"fd9ce705e8e011e733958c81fe316597dd733b86","modified":1615384025305},{"_id":"source/_post/House-Robber-III.md","hash":"4ed12b434a0843975cb1cc72598ad5436c71f8af","modified":1615384025305},{"_id":"source/_post/Implement-Rand10-Using-Rand7.md","hash":"6e6fedd780ca95e054a55b8764b143c4654c3394","modified":1615384025305},{"_id":"source/_post/Insert-into-a-binary-search-tree.md","hash":"5188f998de8f54b4eb03c832cd8be696874b102a","modified":1615384025305},{"_id":"source/_post/Intersection-of-Two-Arrays-II.md","hash":"bcf532b2a578b3eed8214b5fdc74d2b11c3576e7","modified":1615384025305},{"_id":"source/_post/Intersection-of-Two-Arrays.md","hash":"a5dc774ed8394632c3428f7249328f6b490ba44d","modified":1615384025305},{"_id":"source/_post/Intersection-of-Two-Linked-Lists.md","hash":"ee217f282bce8ac0ffdb93a969e4916383ea462d","modified":1615384025305},{"_id":"source/_post/Implement-Trie-Prefix-Tree.md","hash":"eebaf13e7738d162147e27c3b3b0826bf89283a6","modified":1615384025305},{"_id":"source/_post/Interval-List-Intersections.md","hash":"4f17df7e4549abdf62e26521d19ea7fbc7b1c8a1","modified":1615384025305},{"_id":"source/_post/Invert-Binary-Tree.md","hash":"1d9713d5b902a20317a16f17ee7a602bb9614784","modified":1615384025305},{"_id":"source/_post/Is-Graph-Bipartite.md","hash":"5e1bc53358f79272d42a8db0362fda067c02592b","modified":1615384025305},{"_id":"source/_post/Judge-Route-Cicle.md","hash":"55f31d554d0bd64b6e6b70b0a78a62850a341c3a","modified":1615384025305},{"_id":"source/_post/Jump-Game-III.md","hash":"4f8694906e502b0709c5e575187cdc6b388b7aaa","modified":1615384025305},{"_id":"source/_post/Jump-Game.md","hash":"904dc0f2b866eeb1c730e370bab5efa3e962c32a","modified":1615384025305},{"_id":"source/_post/K-Closest-Points-to-Origin.md","hash":"4ef0923bd1cc183d0f582b3d67b9961979ef9b92","modified":1615384025305},{"_id":"source/_post/Keys-and-Rooms.md","hash":"7f1b0e1690ae1cbd0f9b0f3b4fc7e96564078dc3","modified":1615384025309},{"_id":"source/_post/Kth-Largest-Element-in-an-array.md","hash":"406120ccdc9639a759af99c097fd9a8ba991c136","modified":1615384025309},{"_id":"source/_post/Kth-Smallest-Element-in-a-BST.md","hash":"e26374b495550908cf59a2cf283e81ea195f7396","modified":1615384025309},{"_id":"source/_post/Largest-Sum-of-Averages.md","hash":"bf5adb61d8a59ef8460992059eecb0b1cfc43ca8","modified":1615384025309},{"_id":"source/_post/LeetCode-Stack-Tag-总结.md","hash":"e447763678530119f7e8a99e6169701aa53d7d40","modified":1615384025309},{"_id":"source/_post/Length-of-Last-Word.md","hash":"2232e840a2b65e43bc23f326b33e730aa211eaab","modified":1615384025309},{"_id":"source/_post/Letter-Combinations-of-a-Phone-Number.md","hash":"a1df579ef50c7d062c0f5f1aaa0c6240181567a3","modified":1615384025309},{"_id":"source/_post/Evaluate-Reverse-Polish-Notation.md","hash":"9060111b61330454ec5e9594a5fae8bcceceb1b7","modified":1615384025302},{"_id":"source/_post/Lexicographical-Number.md","hash":"c03a9404ca4d08bf6af38e9811c910a14f361730","modified":1615384025309},{"_id":"source/_post/Linked-List-Cycle.md","hash":"580b60e4ac43d3177a0c983248891f4b622e9bda","modified":1615384025309},{"_id":"source/_post/Linked-List-Random-Node.md","hash":"3a6e6e057de64de8ba5db3db37cc1b791d7e8d28","modified":1615384025309},{"_id":"source/_post/Longest-Common-Subsequence.md","hash":"c1154f17efeebc18af270f4f0acd526364e414e5","modified":1615384025309},{"_id":"source/_post/Longest-Continuous-Increasing-Subsqeuence.md","hash":"1deea95ed7c78a49c64aff96fe542bb77c7c05e9","modified":1615384025309},{"_id":"source/_post/Longest-Harmonious-Subsequence.md","hash":"3e2a5d791d19883d84ec3add603cf1926426c332","modified":1615384025309},{"_id":"source/_post/Longest-Palindrome.md","hash":"4d8ba52b2788a2c70b9eaa889a92de336c9524f9","modified":1615384025309},{"_id":"source/_post/Longest-Palindromic-Subsequence.md","hash":"6b065197fa8bdda66bcaf91bc534a07f4f378590","modified":1615384025309},{"_id":"source/_post/Longest-Repeating-Character-Replacement.md","hash":"28347ceaceebed06186e14a1accfceb302675d8a","modified":1615384025309},{"_id":"source/_post/Longest-String-Chain.md","hash":"013529ce2229d79fb3c215d5ba20b6d182b4509c","modified":1615384025309},{"_id":"source/_post/Longest-SubString-with-At-Least-K-Repeating-Characters.md","hash":"76d3b9afbd44547e1d10c2165327bdabdeaa27b9","modified":1615384025309},{"_id":"source/_post/Longest-Word-in-Dictionary-through-Deleting.md","hash":"ea920fe9cd36da135f54a855f3eb093a4cba2b47","modified":1615384025309},{"_id":"source/_post/LongestCommonPrefix.md","hash":"17cfdd9bdf88c1e4aabe1c08e990c50aa2712349","modified":1615384025309},{"_id":"source/_post/LongestPalindromicSubString.md","hash":"02580bb25f646267004782b1f123da1f28f19329","modified":1615384025309},{"_id":"source/_post/LongestSubstringWithoutRepeatingCharacters.md","hash":"7ad75191ed31ec0ca1cc8b6784cbaf61228cd824","modified":1615384025309},{"_id":"source/_post/Lowest-Common-Ancestor-of-a-Binary-Tree.md","hash":"b16ea49fd232c32bd9ade92b7f6de550ed6f294f","modified":1615384025309},{"_id":"source/_post/Majority-Element.md","hash":"b0ecf22ff5e8c19fac1a79315d25b54cc69b0be9","modified":1615384025309},{"_id":"source/_post/Matchsticks-to-Square.md","hash":"9844f1697551aaa9bc7aeb46b399d74d1e1ece1e","modified":1615384025312},{"_id":"source/_post/Maximal-Square.md","hash":"fa7335d3db7105e493bc1f63576ba8e66ca08cea","modified":1615384025312},{"_id":"source/_post/Maximum-Binary-Tree.md","hash":"ab8f8685b91aec49622472329bfd0f8d5774209a","modified":1615384025312},{"_id":"source/_post/Maximum-Difference-Between-Node-and-Ancestor.md","hash":"0e68703e903ae8dd4e924d7d5e700eb8852ee4dd","modified":1615384025312},{"_id":"source/_post/Maximum-Level-Sum-of-a-Binary-Tree.md","hash":"f27d8c5952aa3f52400404ca01120a6408473045","modified":1615384025312},{"_id":"source/_post/Maximum-Length-of-Repeated-Subarray.md","hash":"eeff9acd41ffea00a95098bcb0cf2639fb094624","modified":1615384025312},{"_id":"source/_post/Maximum-Swap.md","hash":"0729f9edb96394781883d6aef1de95718a81117a","modified":1615384025312},{"_id":"source/_post/Merge-Intervals.md","hash":"5cf71657d25937aadf95060d874b865848daf406","modified":1615384025312},{"_id":"source/_post/Merge-Two-Binary-Trees.md","hash":"e91431edf8ef1646bd7b88034e5ba8a8dacf60ce","modified":1615384025312},{"_id":"source/_post/MergeTwoSortedList.md","hash":"b94850754a0fded9735c27d0a0ab96ec46af1505","modified":1615384025312},{"_id":"source/_post/Min-Cost-Climbing-Stairs.md","hash":"929b020ac03eb5884b4768eee3e002287529799b","modified":1615384025312},{"_id":"source/_post/Minimum-ASCII-Delete-Sum-for-Two-Strings.md","hash":"591c53f38736a15b0d0322742ffa99b343904d17","modified":1615384025312},{"_id":"source/_post/Minimum-Falling-Path-Sum.md","hash":"6c8da2a221dd7944ef9017984d839d36d322c264","modified":1615384025312},{"_id":"source/_post/Minimum-Moves-to-Equal-Array-Elements-II.md","hash":"9ae1ea1df029b3d895f865e0335f90f1962ef2fa","modified":1615384025312},{"_id":"source/_post/Move-Zeroes.md","hash":"56989bff9b151062d9f8bc6f23865dc872fd8080","modified":1615384025312},{"_id":"source/_post/MaximumProductSubarray.md","hash":"f879d662dd829438283cf0359457cc8815366464","modified":1615384025312},{"_id":"source/_post/N-ary-Tree-Level-Order-Traversal.md","hash":"90d2484aceff7d5b6b4b5ea122e3aeae9252aabd","modified":1615384025312},{"_id":"source/_post/Network-Delay-Time.md","hash":"ec5f8989d4828d5393e71ce0181b35adc43982a6","modified":1615384025312},{"_id":"source/_post/Next-Greater-Element-III.md","hash":"465336d2de3f86688e278f0393e9c8bab8d95ac3","modified":1615384025312},{"_id":"source/_post/Next-Permutation.md","hash":"7cc8de236c82a8dac602a09abfad3beeaf4f6306","modified":1615384025312},{"_id":"source/_post/Nim-Game.md","hash":"2f8171cb83f59efdb5ceb2c7568af29ee00ad03c","modified":1615384025312},{"_id":"source/_post/Number-of-Islands.md","hash":"2b30172b4ebe96334b34542db3219122ed4d0848","modified":1615384025315},{"_id":"source/_post/Odd-Even-Linked-List.md","hash":"fa3f0120af2f7220c7f5f6049168df68e3f01ec2","modified":1615384025315},{"_id":"source/_post/Palindrome-Linked-List.md","hash":"569c6383887b94a6eb57faf5d2a79116e119a4ba","modified":1615384025315},{"_id":"source/_post/Partition-Labels.md","hash":"4881b23efc78b4bff37bcf0903f0e0f9fabf2da2","modified":1615384025315},{"_id":"source/_post/Partition-to-K-Equal-Sum-Subsets.md","hash":"8ab8b6fdf4dbe554d66618232e52cebbe321b790","modified":1615384025315},{"_id":"source/_post/Path-Sum.md","hash":"0a57b830cd60179d51ea6e131ed46964c215e09f","modified":1615384025315},{"_id":"source/_post/Perfect-Squares.md","hash":"74f9c35d560aaa0035467d3c88d9e0b2a532583d","modified":1615384025315},{"_id":"source/_post/Permutations.md","hash":"e6b21e56b509fa8d50b7131ce495ab1b82c2c8d7","modified":1615384025315},{"_id":"source/_post/Maximun-Depth-of-Binary-Tree.md","hash":"398e145d24dd1a837b6f7afee4d4ea05776d8175","modified":1615384025312},{"_id":"source/_post/Plus-One.md","hash":"dab91c6fd6d96ba941255af6d88a6214052cf932","modified":1615384025315},{"_id":"source/_post/MedianOfTwoSortedArrays.md","hash":"277d38cafc8ba161a95f7270f16e21dfc538e275","modified":1615384025312},{"_id":"source/_post/Populating-Next-Right-Pointers-in-Each-Node-II.md","hash":"f4d02c00b0195995e0cb2808b59c5bfcc127327b","modified":1615384025315},{"_id":"source/_post/Pow(x,y).md","hash":"43d684bbc306a37aea052cc960bdff8e2ba77496","modified":1615384025315},{"_id":"source/_post/Print-FooBar-Alternately.md","hash":"f0ede19b643bee2dd38fede45aab2422f1a13cd3","modified":1615384025315},{"_id":"source/_post/Product-of-Array-Except-Self.md","hash":"ebdbc5828b67e4b1aff7d1abf74254af32766215","modified":1615384025315},{"_id":"source/_post/Rectangle-Area.md","hash":"1ab0a565935ed09b087518bb011fe4b22dfe9b87","modified":1615384025315},{"_id":"source/_post/Possible-Bipartition.md","hash":"ed98aedb69dbbcd036f8603e4ff34e2a7b050eba","modified":1615384025315},{"_id":"source/_post/Redundant-Connection.md","hash":"0d9b415309a6187cb64d09acedb26480a12efabc","modified":1615384025315},{"_id":"source/_post/Remove-Duplicates-from-Sorted-Array.md","hash":"2e3cd652162a6262b4639b798d73470834531bac","modified":1615384025315},{"_id":"source/_post/Remove-Nth-Node-From-End-of-List.md","hash":"bef67db003b44631b98c875ac120fb78af37a613","modified":1615384025315},{"_id":"source/_post/Remove-Element.md","hash":"71f95559915c54c5f240ba72c25d92d8ad7c2ce9","modified":1615384025315},{"_id":"source/_post/Repeated-Substring-Pattern.md","hash":"8082439771e8302ebdbc793f43094148a838eafd","modified":1615384025315},{"_id":"source/_post/Replace-Words.md","hash":"fd50bf465b296183af6ea8400e96d64b8c188630","modified":1615384025315},{"_id":"source/_post/Reverse-Linked-List.md","hash":"32a52a73d293f6f87d60cccf3b5a35256af07619","modified":1615384025315},{"_id":"source/_post/Reverse-String.md","hash":"d5cbe53b1d7880f25e3fd83a0e88d908cd333be3","modified":1615384025315},{"_id":"source/_post/Reverse-Substrings-Between-Each-Pair-of-Parentheses.md","hash":"6e1a03234edf3927f15eccf3237071a28a7002d3","modified":1615384025315},{"_id":"source/_post/Reverse-Words-in-a-String-III.md","hash":"82bbc592ea6133dc2c9b47ff2da68982cd2766de","modified":1615384025315},{"_id":"source/_post/Rotate-Function.md","hash":"ec763f24fecddeba5308679a60b483684700177a","modified":1615384025315},{"_id":"source/_post/Rotate-Image.md","hash":"0200f1ccb27454d1281fbc7aa6a07227795f8788","modified":1615384025315},{"_id":"source/_post/Same-Tree.md","hash":"a701f5dfddfeff7df26759fc7caf0108d3af9ee9","modified":1615384025315},{"_id":"source/_post/Satisfiability-of-Equality-Equations.md","hash":"159d5013ba715a50257eb82b95c2ca97772d3e4c","modified":1615384025315},{"_id":"source/_post/Search-a-2D-Matrix-II.md","hash":"1d96de76b34459d433a984bdcf52fa015dd91bc9","modified":1615384025315},{"_id":"source/_post/Search-in-Rotated-Sorted-Array.md","hash":"7f701384504f7ea2706e9a6d4501ee023b42aa68","modified":1615384025315},{"_id":"source/_post/Serialize-and-Deserialize-BST.md","hash":"46a225ff12156b22fb0d34a48c776196fdcce069","modified":1615384025315},{"_id":"source/_post/Shifting-Letters.md","hash":"046ee725509e54dd56dabc78ad802bdd3635a290","modified":1615384025319},{"_id":"source/_post/Simplify-Path.md","hash":"a0a5630bd5b6dd9e4043fc064cb4e8d2a2efeebf","modified":1615384025319},{"_id":"source/_post/Single-Number-III.md","hash":"95e29e839506941e745b8411f99076759b9c6c5a","modified":1615384025319},{"_id":"source/_post/Sort-Characters-By-Frequency.md","hash":"bc872c72685cc0b5d82055401a0ede7f28960986","modified":1615384025319},{"_id":"source/_post/Sort-Colors.md","hash":"b5ca1a147f56bc9c812527625209deb5a36de26d","modified":1615384025319},{"_id":"source/_post/Sort-List.md","hash":"9dc43e733b3e850523d3dfc8a861cdeabb0d9f07","modified":1615384025319},{"_id":"source/_post/Spiral-Matrix.md","hash":"d144beb30795fed35232ad85d4f187a05d5760b0","modified":1615384025319},{"_id":"source/_post/Split-Linked-List-in-Parts.md","hash":"74c5ae2807f555d58fa4f83510a32cd888eed3c6","modified":1615384025319},{"_id":"source/_post/Stone-Game.md","hash":"96a54d9ced3f4f0e44576f465e0cbdc20d443770","modified":1615384025319},{"_id":"source/_post/Subsets.md","hash":"430954ba9838dfda1c841633ac377de9ed937d51","modified":1615384025319},{"_id":"source/_post/Sum-Root-to-Leaf-Numbers.md","hash":"446bff3a66d669465f6bb245836cdfc7454e6189","modified":1615384025319},{"_id":"source/_post/Swaps-Nodes-in-Pairs.md","hash":"53553dbfebafd2841c1bcf3dae201311b647608f","modified":1615384025319},{"_id":"source/_post/String-to-Integer-atoi.md","hash":"348366ef2d6e4dff3994a0a6a308821e82580c24","modified":1615384025319},{"_id":"source/_post/Symmetric-Tree.md","hash":"0fa1e75dcc79da97b3b7d8114b5e12977d4bedc9","modified":1615384025319},{"_id":"source/_post/Top-K-Frequent-Elements.md","hash":"3345768c2c82888ba843503c93837a3c67b82a9e","modified":1615384025319},{"_id":"source/_post/Triangle.md","hash":"f10437e035fa221cebd0bebcf863db80bfae2d30","modified":1615384025319},{"_id":"source/_post/Trim-a-Binary-Search-Tree.md","hash":"1bf667e0c05ae62595b4d6c42ce2512dfd2ee80d","modified":1615384025319},{"_id":"source/_post/Unique-Binary-Search-Tree.md","hash":"ec546e6cbd55bf30096b61efed01476a94566f3a","modified":1615384025319},{"_id":"source/_post/Unique-Paths.md","hash":"6f54151ccd0e3d07905d4af549e94c980a41821e","modified":1615384025319},{"_id":"source/_post/Unique-Substrings-in-Wraparound-String.md","hash":"eb7d0fdfd7aff2ccf128885b91679ac62d8930ff","modified":1615384025319},{"_id":"source/_post/Valid-Parentheses.md","hash":"cfffa8fa931533eaf56d37bf36d3c2680eb07cf7","modified":1615384025319},{"_id":"source/_post/Valid-Triangle-Number.md","hash":"1d02ad91f03221073212ee6b35bea43059ebbb44","modified":1615384025319},{"_id":"source/_post/Validate-Binary-Search-Tree.md","hash":"86bf30f870b5ce646e9ba24e17a69ef4e1c62f63","modified":1615384025319},{"_id":"source/_post/Validate-Stack-Sequences.md","hash":"e47985cdf7b26e0c20866510671c9c41624463e0","modified":1615384025319},{"_id":"source/_post/Verify-Preorder-Serialization-of-a-Binary-Tree.md","hash":"25d780b37cf0fbf85b2d35fc756935db949ea58a","modified":1615384025319},{"_id":"source/_post/Word-Break.md","hash":"3b65d61971e11887ac502fdd603edd9089b4082f","modified":1615384025319},{"_id":"source/_post/ZigZag-Conversion.md","hash":"c5c84d50d6d446850f2c09ec56f5991de5569f0a","modified":1615384025319},{"_id":"source/_post/airplane-seat-assignment-probability.md","hash":"f15db9951919a14d4a24ad40e3d533a9e8b308ba","modified":1615384025319},{"_id":"source/_post/Word-Search.md","hash":"355eb32ca60af10f7eedb7a84aee8fb67520d1e7","modified":1615384025319},{"_id":"source/_post/angle-between-hands-of-a-clock.md","hash":"e7f6514fffe111983af91d1b28a1b25a4723b659","modified":1615384025319},{"_id":"source/_post/construct-binary-tree-from-preorder-and-postorder-traversal.md","hash":"b38228645402a89baed5c30a2ef634f55e2dd64b","modified":1615384025319},{"_id":"source/_post/different-ways-to-add-parentheses.md","hash":"b70e81b0ed3ab822f1aca49425e869294740d276","modified":1615384025319},{"_id":"source/_post/guess-number-higher-or-lower-ii.md","hash":"72823fcf865d701ad14fd9b866dc7e51f138a6bb","modified":1615384025319},{"_id":"source/_post/h-index.md","hash":"bd0dc8ba1dbce5476d053b9100544d2db3761eba","modified":1615384025319},{"_id":"source/_post/linked-list-components.md","hash":"6fff46057f2b1c42d35164d02be23036992dd7da","modified":1615384025319},{"_id":"source/_post/longest-univalue-path.md","hash":"10a8e71d6af650dcaaa632921e1e71bc7d2b0f91","modified":1615384025322},{"_id":"source/_post/maximum-product-of-word-lengths.md","hash":"df9257210fcb21da6406ae65b69190b761ed3956","modified":1615384025322},{"_id":"source/_post/next-greater-node-in-linked-list.md","hash":"4024f78344763d214ba6ed8ff2a87c2962152e19","modified":1615384025322},{"_id":"source/_post/populating-next-right-pointers-in-each-node.md","hash":"2add8b8495376cf747013ecad62266a3589d972d","modified":1615384025322},{"_id":"source/_post/search-for-a-range.md","hash":"0f75e61bb1fc77e7964676f626350cf4333c298d","modified":1615384025322},{"_id":"source/_post/water-and-jug-problem.md","hash":"a716469ebab16c6aff80b69f2fe51db406c06737","modified":1615384025322},{"_id":"source/_posts/3Sum.md","hash":"fc70c53e9fdd898c6806d3c044d290e86bb022f2","modified":1615384025295},{"_id":"source/_posts/677.Map-Sum-Pairs.md","hash":"2fcfb94a1bbd5e5a9a616de16e808bb267a7d088","modified":1615384025295},{"_id":"source/_posts/AddTwoNumbers.md","hash":"d09089c981bbd990466df6c455d31dc93c9c4c26","modified":1615384025295},{"_id":"source/_posts/Add-and-Search-Word-Data-structure-design.md","hash":"5c8350ce9d623b58afc81765332451c1e79b4563","modified":1615384025295},{"_id":"source/_posts/Advantage-Shuffle.md","hash":"7ef4cbb8b742175f435c9b8e65c2876bd6466715","modified":1615384025295},{"_id":"source/_posts/4Sum-2.md","hash":"cbf87f8c5fc2e3ea73608a66210c1c98a807c045","modified":1615384025295},{"_id":"source/_posts/All-Elements-in-Two-Binary-Search-Trees.md","hash":"297aecf72276da6fb1a32c8db2d498d3c7cf37c3","modified":1615384025295},{"_id":"source/_posts/All-Nodes-Distance-K-in-Binary-Tree.md","hash":"7a09bf1a956af5032746d0ad1659213be5b4ad27","modified":1615384025299},{"_id":"source/_posts/Array-Nesting.md","hash":"03fd2425f6935ac3019b952a3adc4cd2e226a661","modified":1615384025299},{"_id":"source/_posts/All-Possible-Full-Binary-Trees.md","hash":"a5e87df954a050cb83f6e491329dc0d80a3ff30b","modified":1615384025299},{"_id":"source/_posts/Asteroid-Collision.md","hash":"301764459fb3640638051ab979089226749143b1","modified":1615384025299},{"_id":"source/_posts/Balanced-Binary-Tree.md","hash":"a74d1225fb4e636c777766568a144eff97139531","modified":1615384025299},{"_id":"source/_posts/Best-Sightseeing-Pair.md","hash":"72a2bd8f43e41104df2410c2270936636fb4e2da","modified":1615384025299},{"_id":"source/_posts/Best-Time-to-Buy-and-Sell-Stock.md","hash":"2d5972e004d466add22b5ee945299ba50b5eb9ae","modified":1615384025299},{"_id":"source/_posts/Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee.md","hash":"1a35ee0259547cfe3cf46b3e6d344312566c53f0","modified":1615384025299},{"_id":"source/_posts/Binary-Search-Tree-to-Greater-Sum-Tree.md","hash":"860f3c772b55490866cd5e3ff487946074fbacdb","modified":1615384025299},{"_id":"source/_posts/Binary-Tree-Coloring-Game.md","hash":"a57fb1a06e2af2516c0b51046e02e7e48d01b2bc","modified":1615384025299},{"_id":"source/_posts/Binary-Tree-Level-Order-Traversal.md","hash":"4b82cf1164df6e8db5b90529c80d63ef44aa6f3a","modified":1615384025299},{"_id":"source/_posts/Binary-Tree-Paths.md","hash":"0d003b4faf26e565dfccddf63f7243aaed0a5455","modified":1615384025299},{"_id":"source/_posts/Binary-Tree-Pruning.md","hash":"bddb6f444f3b6a4d93a019e3cda7afcfd36d4f38","modified":1615384025299},{"_id":"source/_posts/Binary-Tree-Right-Side-View.md","hash":"bcaa69accb6673803946ec9afc6373c7cc625af0","modified":1615384025299},{"_id":"source/_posts/Bitwise-ORs-of-Subarrays.md","hash":"34a7fdfb291b72170890e5ee56383cfb79bca7bb","modified":1615384025299},{"_id":"source/_posts/Binary-Search-Tree-Iterator.md","hash":"b8db1a0a717bb5050152a9b7e9e87aa7f8cbf441","modified":1615384025299},{"_id":"source/_posts/Boats-to-Save-People.md","hash":"7087c9667c42d0a40f706ce9ba7debc01b50768a","modified":1615384025299},{"_id":"source/_posts/Climbing-Stairs.md","hash":"a65a03a9047907eea3e28a6f2ed709b14bdfc430","modified":1615384025299},{"_id":"source/_posts/Combination-Sum.md","hash":"780721a308635f66ba1da5aa0838f71b89782d9f","modified":1615384025299},{"_id":"source/_posts/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal.md","hash":"25b94e6883450c06515219ed85da609479d9a565","modified":1615384025302},{"_id":"source/_posts/Binary-Tree-Zigzag-Level-Order-Traversal.md","hash":"71262ade247d6e50caf24bac8561d447a2751737","modified":1615384025299},{"_id":"source/_posts/Construct-the-Rectangle.md","hash":"1b05998129829acde42c884f57c1e5c667bb0917","modified":1615384025302},{"_id":"source/_posts/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.md","hash":"6314ba205316e159d0d7db6b79c4f9307c66c0c9","modified":1615384025302},{"_id":"source/_posts/Binary-Tree-Preorder-Inorder-Postorder-Traversal.md","hash":"26c64ea72021a16680d974e861410b84ae48fd66","modified":1615384025299},{"_id":"source/_posts/Container_With_Most_Water.md","hash":"b91dd5e6563359cf92f8639c316b6f2133e84fa5","modified":1615384025302},{"_id":"source/_posts/Contains-Duplicate-II.md","hash":"98d0f15e589bda5029c96779d76514d192755be4","modified":1615384025302},{"_id":"source/_posts/Convert-Sorted-Array-to-Binary-Search-Tree.md","hash":"e8307b112ed55e4e7e57cb33451b235f11f69cef","modified":1615384025302},{"_id":"source/_posts/Count-Numbers-with-Unique-Digits.md","hash":"5282ab44cf8e1f7c51fd58d412f0357fded57d63","modified":1615384025302},{"_id":"source/_posts/Count-Servers-that-Communicate.md","hash":"7b1bf79175986fd4e0a0780d34b535c849f39aaa","modified":1615384025302},{"_id":"source/_posts/Counting-Bits.md","hash":"9f5fa9822355a695381c8270f28abf2f0fdc6f2c","modified":1615384025302},{"_id":"source/_posts/Daily-Temperatures.md","hash":"efee652a8f8d68b29036cd7f7894ed78f3e454e1","modified":1615384025302},{"_id":"source/_posts/Deepest-Leaves-Sum.md","hash":"368363707781e1087cc57f59c39bc8227408c018","modified":1615384025302},{"_id":"source/_posts/Course-Schedule.md","hash":"e503af315f80abbb98aacf1e62d97dd412aa1c0f","modified":1615384025302},{"_id":"source/_posts/Delete-Leaves-With-a-Given-ValueMedium.md","hash":"954b6ac25dd856041ccc4390f3efabaa520199bc","modified":1615384025302},{"_id":"source/_posts/Delete-Node-in-a-BST.md","hash":"4c17cede7f6d24f437900d2a43a37fd4529d5959","modified":1615384025302},{"_id":"source/_posts/Decode-String.md","hash":"bee3437769295479c22708c8312382016160b964","modified":1615384025302},{"_id":"source/_posts/Delete-Nodes-And-Return-Forest.md","hash":"a8cb57b790665914148efff8789ed6d4c0f30c28","modified":1615384025302},{"_id":"source/_posts/Diagonal-Traverse.md","hash":"66ab45cc59b8a5713e50ca36a930780e548d1bd8","modified":1615384025302},{"_id":"source/_posts/Find-Bottom-Left-Tree.md","hash":"f260ff3a11880bf647406c6e3fa0c0cba2f912b8","modified":1615384025302},{"_id":"source/_posts/Find-Largest-Value-in-Each-Tree-Row.md","hash":"e44f5fc7bc10e398be70b016e3698137b2cfab01","modified":1615384025302},{"_id":"source/_posts/Find-Peak-Element.md","hash":"5debaa6edcc203d93ca6ca34bdafc27f7447e2f6","modified":1615384025302},{"_id":"source/_posts/Find-Eventual-Safe-States.md","hash":"fe0601aa14c8518d69eae3c8f0209ee139dfe072","modified":1615384025302},{"_id":"source/_posts/Find-the-Duplicate-Number.md","hash":"ad496edd5e999f11b5322f7c4a09e2af39174ca0","modified":1615384025302},{"_id":"source/_posts/Flatten-a-Multilevel-Doubly-Linked-List.md","hash":"d78c6421174e0a97f0f580bbc9330a00dc02f148","modified":1615384025305},{"_id":"source/_posts/Flip-Equivalent-Binary-Trees.md","hash":"867b7511386d3e4a8e8018297b3be600e2b07f9d","modified":1615384025305},{"_id":"source/_posts/Flatten-Binary-Tree-to-Linked-List.md","hash":"3bff030769293405b44549a75aa289a57e09a043","modified":1615384025305},{"_id":"source/_posts/Evaluate-Reverse-Polish-Notation.md","hash":"9060111b61330454ec5e9594a5fae8bcceceb1b7","modified":1615384025302},{"_id":"source/_posts/Flipping-an-Image.md","hash":"fef980f56bd8b52d0d8526ed83ab28842f1049e3","modified":1615384025305},{"_id":"source/_posts/Diameter-of-Binary-Tree.md","hash":"ae871b90a8cd2c2ff542c23f1c2bc948c61fc6e7","modified":1615384025302},{"_id":"source/_posts/Friend-Circles.md","hash":"9bcb3a8f68e2e43736b830de3a0c01c1bf0154e7","modified":1615384025305},{"_id":"source/_posts/Global-and-Local-Inversions.md","hash":"4c3869f154a6033cde653e4b065b276b793e8d10","modified":1615384025305},{"_id":"source/_posts/Generate-Parentheses.md","hash":"fd97777c57d2041dd4cdb9f224badc11c39ce036","modified":1615384025305},{"_id":"source/_posts/Hamming-Distance.md","hash":"9a85db1325b89d01730c56964b03d4f491b02960","modified":1615384025305},{"_id":"source/_posts/Flatten-Nested-List-Iterator.md","hash":"e4ca2fe9b95496c8824cfd109905cbc27acf3778","modified":1615384025305},{"_id":"source/_posts/Group-Anagrams.md","hash":"a5da6313e443a2c69fe244341577a767a84a2ad4","modified":1615384025305},{"_id":"source/_posts/Implement-Rand10-Using-Rand7.md","hash":"6e6fedd780ca95e054a55b8764b143c4654c3394","modified":1615384025305},{"_id":"source/_posts/House-Robber-III.md","hash":"4ed12b434a0843975cb1cc72598ad5436c71f8af","modified":1615384025305},{"_id":"source/_posts/House-Robber.md","hash":"fd9ce705e8e011e733958c81fe316597dd733b86","modified":1615384025305},{"_id":"source/_posts/Insert-into-a-binary-search-tree.md","hash":"5188f998de8f54b4eb03c832cd8be696874b102a","modified":1615384025305},{"_id":"source/_posts/Implement-Trie-Prefix-Tree.md","hash":"eebaf13e7738d162147e27c3b3b0826bf89283a6","modified":1615384025305},{"_id":"source/_posts/Intersection-of-Two-Arrays-II.md","hash":"bcf532b2a578b3eed8214b5fdc74d2b11c3576e7","modified":1615384025305},{"_id":"source/_posts/Intersection-of-Two-Arrays.md","hash":"a5dc774ed8394632c3428f7249328f6b490ba44d","modified":1615384025305},{"_id":"source/_posts/Interval-List-Intersections.md","hash":"4f17df7e4549abdf62e26521d19ea7fbc7b1c8a1","modified":1615384025305},{"_id":"source/_posts/Invert-Binary-Tree.md","hash":"1d9713d5b902a20317a16f17ee7a602bb9614784","modified":1615384025305},{"_id":"source/_posts/Intersection-of-Two-Linked-Lists.md","hash":"ee217f282bce8ac0ffdb93a969e4916383ea462d","modified":1615384025305},{"_id":"source/_posts/Evaluate-Division.md","hash":"b7752111b7103ece2eb9e30010d4fd1afc0bb9ae","modified":1615384025302},{"_id":"source/_posts/Judge-Route-Cicle.md","hash":"55f31d554d0bd64b6e6b70b0a78a62850a341c3a","modified":1615384025305},{"_id":"source/_posts/Jump-Game-III.md","hash":"4f8694906e502b0709c5e575187cdc6b388b7aaa","modified":1615384025305},{"_id":"source/_posts/Is-Graph-Bipartite.md","hash":"5e1bc53358f79272d42a8db0362fda067c02592b","modified":1615384025305},{"_id":"source/_posts/K-Closest-Points-to-Origin.md","hash":"4ef0923bd1cc183d0f582b3d67b9961979ef9b92","modified":1615384025305},{"_id":"source/_posts/Keys-and-Rooms.md","hash":"7f1b0e1690ae1cbd0f9b0f3b4fc7e96564078dc3","modified":1615384025309},{"_id":"source/_posts/Jump-Game.md","hash":"904dc0f2b866eeb1c730e370bab5efa3e962c32a","modified":1615384025305},{"_id":"source/_posts/Kth-Smallest-Element-in-a-BST.md","hash":"e26374b495550908cf59a2cf283e81ea195f7396","modified":1615384025309},{"_id":"source/_posts/Largest-Sum-of-Averages.md","hash":"bf5adb61d8a59ef8460992059eecb0b1cfc43ca8","modified":1615384025309},{"_id":"source/_posts/Kth-Largest-Element-in-an-array.md","hash":"406120ccdc9639a759af99c097fd9a8ba991c136","modified":1615384025309},{"_id":"source/_posts/Length-of-Last-Word.md","hash":"2232e840a2b65e43bc23f326b33e730aa211eaab","modified":1615384025309},{"_id":"source/_posts/Lexicographical-Number.md","hash":"c03a9404ca4d08bf6af38e9811c910a14f361730","modified":1615384025309},{"_id":"source/_posts/Letter-Combinations-of-a-Phone-Number.md","hash":"a1df579ef50c7d062c0f5f1aaa0c6240181567a3","modified":1615384025309},{"_id":"source/_posts/LeetCode-Stack-Tag-总结.md","hash":"e447763678530119f7e8a99e6169701aa53d7d40","modified":1615384025309},{"_id":"source/_posts/Linked-List-Cycle.md","hash":"580b60e4ac43d3177a0c983248891f4b622e9bda","modified":1615384025309},{"_id":"source/_posts/Longest-Continuous-Increasing-Subsqeuence.md","hash":"1deea95ed7c78a49c64aff96fe542bb77c7c05e9","modified":1615384025309},{"_id":"source/_posts/Longest-Harmonious-Subsequence.md","hash":"3e2a5d791d19883d84ec3add603cf1926426c332","modified":1615384025309},{"_id":"source/_posts/Linked-List-Random-Node.md","hash":"3a6e6e057de64de8ba5db3db37cc1b791d7e8d28","modified":1615384025309},{"_id":"source/_posts/Longest-Common-Subsequence.md","hash":"c1154f17efeebc18af270f4f0acd526364e414e5","modified":1615384025309},{"_id":"source/_posts/Longest-Palindromic-Subsequence.md","hash":"6b065197fa8bdda66bcaf91bc534a07f4f378590","modified":1615384025309},{"_id":"source/_posts/Longest-Palindrome.md","hash":"4d8ba52b2788a2c70b9eaa889a92de336c9524f9","modified":1615384025309},{"_id":"source/_posts/Longest-String-Chain.md","hash":"013529ce2229d79fb3c215d5ba20b6d182b4509c","modified":1615384025309},{"_id":"source/_posts/Longest-Repeating-Character-Replacement.md","hash":"28347ceaceebed06186e14a1accfceb302675d8a","modified":1615384025309},{"_id":"source/_posts/Longest-Word-in-Dictionary-through-Deleting.md","hash":"ea920fe9cd36da135f54a855f3eb093a4cba2b47","modified":1615384025309},{"_id":"source/_posts/Longest-SubString-with-At-Least-K-Repeating-Characters.md","hash":"76d3b9afbd44547e1d10c2165327bdabdeaa27b9","modified":1615384025309},{"_id":"source/_posts/LongestCommonPrefix.md","hash":"17cfdd9bdf88c1e4aabe1c08e990c50aa2712349","modified":1615384025309},{"_id":"source/_posts/LongestPalindromicSubString.md","hash":"02580bb25f646267004782b1f123da1f28f19329","modified":1615384025309},{"_id":"source/_posts/Lowest-Common-Ancestor-of-a-Binary-Tree.md","hash":"b16ea49fd232c32bd9ade92b7f6de550ed6f294f","modified":1615384025309},{"_id":"source/_posts/Matchsticks-to-Square.md","hash":"9844f1697551aaa9bc7aeb46b399d74d1e1ece1e","modified":1615384025312},{"_id":"source/_posts/Maximum-Binary-Tree.md","hash":"ab8f8685b91aec49622472329bfd0f8d5774209a","modified":1615384025312},{"_id":"source/_posts/LongestSubstringWithoutRepeatingCharacters.md","hash":"7ad75191ed31ec0ca1cc8b6784cbaf61228cd824","modified":1615384025309},{"_id":"source/_posts/Majority-Element.md","hash":"b0ecf22ff5e8c19fac1a79315d25b54cc69b0be9","modified":1615384025309},{"_id":"source/_posts/Maximal-Square.md","hash":"fa7335d3db7105e493bc1f63576ba8e66ca08cea","modified":1615384025312},{"_id":"source/_posts/Maximum-Level-Sum-of-a-Binary-Tree.md","hash":"f27d8c5952aa3f52400404ca01120a6408473045","modified":1615384025312},{"_id":"source/_posts/Maximum-Difference-Between-Node-and-Ancestor.md","hash":"0e68703e903ae8dd4e924d7d5e700eb8852ee4dd","modified":1615384025312},{"_id":"source/_posts/Maximum-Swap.md","hash":"0729f9edb96394781883d6aef1de95718a81117a","modified":1615384025312},{"_id":"source/_posts/Merge-Intervals.md","hash":"5cf71657d25937aadf95060d874b865848daf406","modified":1615384025312},{"_id":"source/_posts/Merge-Two-Binary-Trees.md","hash":"e91431edf8ef1646bd7b88034e5ba8a8dacf60ce","modified":1615384025312},{"_id":"source/_posts/MergeTwoSortedList.md","hash":"b94850754a0fded9735c27d0a0ab96ec46af1505","modified":1615384025312},{"_id":"source/_posts/Minimum-ASCII-Delete-Sum-for-Two-Strings.md","hash":"591c53f38736a15b0d0322742ffa99b343904d17","modified":1615384025312},{"_id":"source/_posts/Min-Cost-Climbing-Stairs.md","hash":"929b020ac03eb5884b4768eee3e002287529799b","modified":1615384025312},{"_id":"source/_posts/Maximum-Length-of-Repeated-Subarray.md","hash":"eeff9acd41ffea00a95098bcb0cf2639fb094624","modified":1615384025312},{"_id":"source/_posts/Minimum-Falling-Path-Sum.md","hash":"6c8da2a221dd7944ef9017984d839d36d322c264","modified":1615384025312},{"_id":"source/_posts/Minimum-Moves-to-Equal-Array-Elements-II.md","hash":"9ae1ea1df029b3d895f865e0335f90f1962ef2fa","modified":1615384025312},{"_id":"source/_posts/Move-Zeroes.md","hash":"56989bff9b151062d9f8bc6f23865dc872fd8080","modified":1615384025312},{"_id":"source/_posts/N-ary-Tree-Level-Order-Traversal.md","hash":"90d2484aceff7d5b6b4b5ea122e3aeae9252aabd","modified":1615384025312},{"_id":"source/_posts/Network-Delay-Time.md","hash":"ec5f8989d4828d5393e71ce0181b35adc43982a6","modified":1615384025312},{"_id":"source/_posts/Maximun-Depth-of-Binary-Tree.md","hash":"398e145d24dd1a837b6f7afee4d4ea05776d8175","modified":1615384025312},{"_id":"source/_posts/Next-Greater-Element-III.md","hash":"465336d2de3f86688e278f0393e9c8bab8d95ac3","modified":1615384025312},{"_id":"source/_posts/Next-Permutation.md","hash":"7cc8de236c82a8dac602a09abfad3beeaf4f6306","modified":1615384025312},{"_id":"source/_posts/Nim-Game.md","hash":"2f8171cb83f59efdb5ceb2c7568af29ee00ad03c","modified":1615384025312},{"_id":"source/_posts/Number-of-Islands.md","hash":"2b30172b4ebe96334b34542db3219122ed4d0848","modified":1615384025315},{"_id":"source/_posts/Odd-Even-Linked-List.md","hash":"fa3f0120af2f7220c7f5f6049168df68e3f01ec2","modified":1615384025315},{"_id":"source/_posts/Palindrome-Linked-List.md","hash":"569c6383887b94a6eb57faf5d2a79116e119a4ba","modified":1615384025315},{"_id":"source/_posts/Partition-Labels.md","hash":"4881b23efc78b4bff37bcf0903f0e0f9fabf2da2","modified":1615384025315},{"_id":"source/_posts/Partition-to-K-Equal-Sum-Subsets.md","hash":"8ab8b6fdf4dbe554d66618232e52cebbe321b790","modified":1615384025315},{"_id":"source/_posts/Path-Sum.md","hash":"0a57b830cd60179d51ea6e131ed46964c215e09f","modified":1615384025315},{"_id":"source/_posts/Perfect-Squares.md","hash":"74f9c35d560aaa0035467d3c88d9e0b2a532583d","modified":1615384025315},{"_id":"source/_posts/Plus-One.md","hash":"dab91c6fd6d96ba941255af6d88a6214052cf932","modified":1615384025315},{"_id":"source/_posts/Permutations.md","hash":"e6b21e56b509fa8d50b7131ce495ab1b82c2c8d7","modified":1615384025315},{"_id":"source/_posts/Populating-Next-Right-Pointers-in-Each-Node-II.md","hash":"f4d02c00b0195995e0cb2808b59c5bfcc127327b","modified":1615384025315},{"_id":"source/_posts/MedianOfTwoSortedArrays.md","hash":"277d38cafc8ba161a95f7270f16e21dfc538e275","modified":1615384025312},{"_id":"source/_posts/Possible-Bipartition.md","hash":"ed98aedb69dbbcd036f8603e4ff34e2a7b050eba","modified":1615384025315},{"_id":"source/_posts/MaximumProductSubarray.md","hash":"f879d662dd829438283cf0359457cc8815366464","modified":1615384025312},{"_id":"source/_posts/Pow(x,y).md","hash":"43d684bbc306a37aea052cc960bdff8e2ba77496","modified":1615384025315},{"_id":"source/_posts/Product-of-Array-Except-Self.md","hash":"ebdbc5828b67e4b1aff7d1abf74254af32766215","modified":1615384025315},{"_id":"source/_posts/Print-FooBar-Alternately.md","hash":"f0ede19b643bee2dd38fede45aab2422f1a13cd3","modified":1615384025315},{"_id":"source/_posts/Rectangle-Area.md","hash":"1ab0a565935ed09b087518bb011fe4b22dfe9b87","modified":1615384025315},{"_id":"source/_posts/Redundant-Connection.md","hash":"0d9b415309a6187cb64d09acedb26480a12efabc","modified":1615384025315},{"_id":"source/_posts/Remove-Element.md","hash":"71f95559915c54c5f240ba72c25d92d8ad7c2ce9","modified":1615384025315},{"_id":"source/_posts/Remove-Duplicates-from-Sorted-Array.md","hash":"2e3cd652162a6262b4639b798d73470834531bac","modified":1615384025315},{"_id":"source/_posts/Remove-Nth-Node-From-End-of-List.md","hash":"bef67db003b44631b98c875ac120fb78af37a613","modified":1615384025315},{"_id":"source/_posts/Repeated-Substring-Pattern.md","hash":"8082439771e8302ebdbc793f43094148a838eafd","modified":1615384025315},{"_id":"source/_posts/Replace-Words.md","hash":"fd50bf465b296183af6ea8400e96d64b8c188630","modified":1615384025315},{"_id":"source/_posts/Reverse-Linked-List.md","hash":"32a52a73d293f6f87d60cccf3b5a35256af07619","modified":1615384025315},{"_id":"source/_posts/Reverse-String.md","hash":"d5cbe53b1d7880f25e3fd83a0e88d908cd333be3","modified":1615384025315},{"_id":"source/_posts/Reverse-Substrings-Between-Each-Pair-of-Parentheses.md","hash":"6e1a03234edf3927f15eccf3237071a28a7002d3","modified":1615384025315},{"_id":"source/_posts/Reverse-Words-in-a-String-III.md","hash":"82bbc592ea6133dc2c9b47ff2da68982cd2766de","modified":1615384025315},{"_id":"source/_posts/Rotate-Function.md","hash":"ec763f24fecddeba5308679a60b483684700177a","modified":1615384025315},{"_id":"source/_posts/Rotate-Image.md","hash":"0200f1ccb27454d1281fbc7aa6a07227795f8788","modified":1615384025315},{"_id":"source/_posts/Same-Tree.md","hash":"a701f5dfddfeff7df26759fc7caf0108d3af9ee9","modified":1615384025315},{"_id":"source/_posts/Satisfiability-of-Equality-Equations.md","hash":"159d5013ba715a50257eb82b95c2ca97772d3e4c","modified":1615384025315},{"_id":"source/_posts/Search-a-2D-Matrix-II.md","hash":"1d96de76b34459d433a984bdcf52fa015dd91bc9","modified":1615384025315},{"_id":"source/_posts/Search-in-Rotated-Sorted-Array.md","hash":"7f701384504f7ea2706e9a6d4501ee023b42aa68","modified":1615384025315},{"_id":"source/_posts/Serialize-and-Deserialize-BST.md","hash":"46a225ff12156b22fb0d34a48c776196fdcce069","modified":1615384025315},{"_id":"source/_posts/Shifting-Letters.md","hash":"046ee725509e54dd56dabc78ad802bdd3635a290","modified":1615384025319},{"_id":"source/_posts/Simplify-Path.md","hash":"a0a5630bd5b6dd9e4043fc064cb4e8d2a2efeebf","modified":1615384025319},{"_id":"source/_posts/Single-Number-III.md","hash":"95e29e839506941e745b8411f99076759b9c6c5a","modified":1615384025319},{"_id":"source/_posts/Sort-Characters-By-Frequency.md","hash":"bc872c72685cc0b5d82055401a0ede7f28960986","modified":1615384025319},{"_id":"source/_posts/Sort-Colors.md","hash":"b5ca1a147f56bc9c812527625209deb5a36de26d","modified":1615384025319},{"_id":"source/_posts/Sort-List.md","hash":"9dc43e733b3e850523d3dfc8a861cdeabb0d9f07","modified":1615384025319},{"_id":"source/_posts/Spiral-Matrix.md","hash":"d144beb30795fed35232ad85d4f187a05d5760b0","modified":1615384025319},{"_id":"source/_posts/Split-Linked-List-in-Parts.md","hash":"74c5ae2807f555d58fa4f83510a32cd888eed3c6","modified":1615384025319},{"_id":"source/_posts/Stone-Game.md","hash":"96a54d9ced3f4f0e44576f465e0cbdc20d443770","modified":1615384025319},{"_id":"source/_posts/String-to-Integer-atoi.md","hash":"348366ef2d6e4dff3994a0a6a308821e82580c24","modified":1615384025319},{"_id":"source/_posts/Subsets.md","hash":"430954ba9838dfda1c841633ac377de9ed937d51","modified":1615384025319},{"_id":"source/_posts/Sum-Root-to-Leaf-Numbers.md","hash":"446bff3a66d669465f6bb245836cdfc7454e6189","modified":1615384025319},{"_id":"source/_posts/Swaps-Nodes-in-Pairs.md","hash":"53553dbfebafd2841c1bcf3dae201311b647608f","modified":1615384025319},{"_id":"source/_posts/Symmetric-Tree.md","hash":"0fa1e75dcc79da97b3b7d8114b5e12977d4bedc9","modified":1615384025319},{"_id":"source/_posts/Top-K-Frequent-Elements.md","hash":"3345768c2c82888ba843503c93837a3c67b82a9e","modified":1615384025319},{"_id":"source/_posts/Triangle.md","hash":"f10437e035fa221cebd0bebcf863db80bfae2d30","modified":1615384025319},{"_id":"source/_posts/Trim-a-Binary-Search-Tree.md","hash":"1bf667e0c05ae62595b4d6c42ce2512dfd2ee80d","modified":1615384025319},{"_id":"source/_posts/Unique-Binary-Search-Tree.md","hash":"ec546e6cbd55bf30096b61efed01476a94566f3a","modified":1615384025319},{"_id":"source/_posts/Unique-Paths.md","hash":"6f54151ccd0e3d07905d4af549e94c980a41821e","modified":1615384025319},{"_id":"source/_posts/Unique-Substrings-in-Wraparound-String.md","hash":"eb7d0fdfd7aff2ccf128885b91679ac62d8930ff","modified":1615384025319},{"_id":"source/_posts/Valid-Parentheses.md","hash":"cfffa8fa931533eaf56d37bf36d3c2680eb07cf7","modified":1615384025319},{"_id":"source/_posts/Valid-Triangle-Number.md","hash":"1d02ad91f03221073212ee6b35bea43059ebbb44","modified":1615384025319},{"_id":"source/_posts/Validate-Binary-Search-Tree.md","hash":"86bf30f870b5ce646e9ba24e17a69ef4e1c62f63","modified":1615384025319},{"_id":"source/_posts/Verify-Preorder-Serialization-of-a-Binary-Tree.md","hash":"25d780b37cf0fbf85b2d35fc756935db949ea58a","modified":1615384025319},{"_id":"source/_posts/Validate-Stack-Sequences.md","hash":"e47985cdf7b26e0c20866510671c9c41624463e0","modified":1615384025319},{"_id":"source/_posts/Word-Break.md","hash":"3b65d61971e11887ac502fdd603edd9089b4082f","modified":1615384025319},{"_id":"source/_posts/Word-Search.md","hash":"355eb32ca60af10f7eedb7a84aee8fb67520d1e7","modified":1615384025319},{"_id":"source/_posts/ZigZag-Conversion.md","hash":"c5c84d50d6d446850f2c09ec56f5991de5569f0a","modified":1615384025319},{"_id":"source/_posts/airplane-seat-assignment-probability.md","hash":"f15db9951919a14d4a24ad40e3d533a9e8b308ba","modified":1615384025319},{"_id":"source/_posts/angle-between-hands-of-a-clock.md","hash":"e7f6514fffe111983af91d1b28a1b25a4723b659","modified":1615384025319},{"_id":"source/_posts/different-ways-to-add-parentheses.md","hash":"b70e81b0ed3ab822f1aca49425e869294740d276","modified":1615384025319},{"_id":"source/_posts/construct-binary-tree-from-preorder-and-postorder-traversal.md","hash":"b38228645402a89baed5c30a2ef634f55e2dd64b","modified":1615384025319},{"_id":"source/_posts/guess-number-higher-or-lower-ii.md","hash":"72823fcf865d701ad14fd9b866dc7e51f138a6bb","modified":1615384025319},{"_id":"source/_posts/h-index.md","hash":"bd0dc8ba1dbce5476d053b9100544d2db3761eba","modified":1615384025319},{"_id":"source/_posts/linked-list-components.md","hash":"6fff46057f2b1c42d35164d02be23036992dd7da","modified":1615384025319},{"_id":"source/_posts/longest-univalue-path.md","hash":"10a8e71d6af650dcaaa632921e1e71bc7d2b0f91","modified":1615384025322},{"_id":"source/_posts/maximum-product-of-word-lengths.md","hash":"df9257210fcb21da6406ae65b69190b761ed3956","modified":1615384025322},{"_id":"source/_posts/next-greater-node-in-linked-list.md","hash":"4024f78344763d214ba6ed8ff2a87c2962152e19","modified":1615384025322},{"_id":"source/_posts/populating-next-right-pointers-in-each-node.md","hash":"2add8b8495376cf747013ecad62266a3589d972d","modified":1615384025322},{"_id":"source/_posts/search-for-a-range.md","hash":"0f75e61bb1fc77e7964676f626350cf4333c298d","modified":1615384025322},{"_id":"source/_posts/water-and-jug-problem.md","hash":"a716469ebab16c6aff80b69f2fe51db406c06737","modified":1615384025322},{"_id":"source/_posts/.git/HEAD","hash":"6fd171cc81940f0f672926f0a109ea5fa2f879b5","modified":1615384025292},{"_id":"source/_posts/.git/config","hash":"8b2f37fbd111cf4b9875e849024d3b6163a8ba30","modified":1615384025295},{"_id":"source/_posts/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1615384016722},{"_id":"source/_posts/.git/index","hash":"901ede754219ed0e4a76fd96c406a16cbe1c6e27","modified":1615384025322},{"_id":"source/_posts/.git/packed-refs","hash":"d91191097c9fcfd757e743e82d271e0a3364969f","modified":1615384025292},{"_id":"source/_posts/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1615384016722},{"_id":"source/_posts/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1615384016722},{"_id":"source/_posts/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1615384016722},{"_id":"source/_posts/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1615384016722},{"_id":"source/_posts/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1615384016722},{"_id":"source/_posts/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1615384016722},{"_id":"source/_posts/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1615384016722},{"_id":"source/_posts/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1615384016722},{"_id":"source/_posts/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1615384016722},{"_id":"source/_posts/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1615384016722},{"_id":"source/_posts/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1615384016722},{"_id":"source/_posts/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1615384016722},{"_id":"source/_posts/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1615384016722},{"_id":"source/_posts/.git/logs/HEAD","hash":"bc8b8912d04eabc06531430c18ea8791294449a3","modified":1615384025292},{"_id":"source/_posts/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1615384016722},{"_id":"source/_posts/.github/workflows/blank.yml","hash":"4df3856cabc8051d30dd7fadfa15068025e59f5f","modified":1615384025295},{"_id":"source/_posts/.git/objects/pack/pack-18f88f8d445dc9da1607ffa6be4fe2058fc64922.idx","hash":"859d7df6965b89e403b7eb370298fa20e2172a61","modified":1615384024835},{"_id":"source/_posts/.git/refs/heads/algo","hash":"39300a55aef4d75bbc3c2db2ce6a244573eae609","modified":1615384025292},{"_id":"source/_posts/.git/logs/refs/heads/algo","hash":"bc8b8912d04eabc06531430c18ea8791294449a3","modified":1615384025292},{"_id":"source/_posts/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1615384025292},{"_id":"source/_posts/.git/logs/refs/remotes/origin/HEAD","hash":"f8fcaae2a3fd1b119e68bb40d42a6ba1afdaa5a9","modified":1615384025292},{"_id":"source/_posts/.git/objects/pack/pack-18f88f8d445dc9da1607ffa6be4fe2058fc64922.pack","hash":"cc66a569bbbc2b1d9e6db8f51f98df61a357be59","modified":1615384024835},{"_id":"public/2020/10/13/h-index/index.html","hash":"200026400a408f5d14ad75c4a7bacf3322506aa0","modified":1615389839977},{"_id":"public/2020/02/02/Delete-Leaves-With-a-Given-ValueMedium/index.html","hash":"b90cb956469deefdbffc1673a8f21fe2a7865726","modified":1615389839977},{"_id":"public/2020/01/31/Deepest-Leaves-Sum/index.html","hash":"eb598205b1f3b504c0653c9cbef3f03edb2b2eb2","modified":1615389839977},{"_id":"public/2020/01/05/Flip-Equivalent-Binary-Trees/index.html","hash":"9d6005220812ba92b0f153512a64dfe8e7448e7a","modified":1615389839977},{"_id":"public/2019/12/23/Flipping-an-Image/index.html","hash":"d7072a98da71c0b47762a1f4b4afa8ffcd0b26fd","modified":1615389839977},{"_id":"public/2019/12/17/Validate-Stack-Sequences/index.html","hash":"b91033061410522f27763f2384361862663d484e","modified":1615389839977},{"_id":"public/2019/12/11/Binary-Tree-Pruning/index.html","hash":"8d0b0be4fe278e7d5e0610968c0a02ecd5e04ac0","modified":1615389839977},{"_id":"public/2019/12/01/Insert-into-a-binary-search-tree/index.html","hash":"be5d8f73e5ca8ad4381b3a4ddbcbaa18bb4772f3","modified":1615389839977},{"_id":"public/2019/11/30/Shifting-Letters/index.html","hash":"21b9a66114a8f849691c58b61c0b67154eb542dd","modified":1615389839977},{"_id":"public/2019/03/13/Stone-Game/index.html","hash":"1dcfff8cf9ccb6249df1f53bf37c854cc5ca3329","modified":1615389839977},{"_id":"public/2018/01/26/Same-Tree/index.html","hash":"b6d48358ae3aa00dcc926d860cd5c1a8ace32884","modified":1615389839977},{"_id":"public/2017/12/19/Judge-Route-Cicle/index.html","hash":"1171c2b8040c7575507feea919b4e560ac1b7a54","modified":1615389839977},{"_id":"public/2017/12/16/Reverse-String/index.html","hash":"711251711b638b8e18818245dc86de51f8ae2e1a","modified":1615389839977},{"_id":"public/2017/12/01/Swaps-Nodes-in-Pairs/index.html","hash":"681708f52018f44a78389d66836e41e7460da47c","modified":1615389839977},{"_id":"public/2017/11/28/Plus-One/index.html","hash":"caf915a5846bca965a27a6ca5efb978a7f849b8c","modified":1615389839977},{"_id":"public/2017/11/22/Hamming-Distance/index.html","hash":"d23563f7464673a4be1681ffbcc0ec2b05b42952","modified":1615389839977},{"_id":"public/2017/11/01/Number-of-Islands/index.html","hash":"a339faa2bfb50a2a5b22d1ccdb0755190a81681e","modified":1615389839977},{"_id":"public/archives/page/2/index.html","hash":"580acd3cb2265295e52ff723d72fc7068808f33e","modified":1615389839977},{"_id":"public/archives/page/3/index.html","hash":"a3e522b3d6b5216c60a04eb94bf37b98911b3410","modified":1615389839977},{"_id":"public/archives/page/4/index.html","hash":"4074ba7ede753954d341faa432f541e5a766e442","modified":1615389839977},{"_id":"public/archives/page/5/index.html","hash":"e030baaefc1923d2b2c60aaf92b66d5766e72d40","modified":1615389839977},{"_id":"public/archives/page/6/index.html","hash":"22b6b42db18380c87d90885560468ac8f79d4f81","modified":1615389839977},{"_id":"public/archives/page/7/index.html","hash":"234491308e2374b4a3b6f2db0eb82e111b46746c","modified":1615389839977},{"_id":"public/archives/page/8/index.html","hash":"576f010fde276485a819b0dfd09c3320a85e36b5","modified":1615389839977},{"_id":"public/archives/page/9/index.html","hash":"55966f58330f572720056116d8affef5ed2d1b72","modified":1615389839977},{"_id":"public/archives/page/10/index.html","hash":"25435454e44fb758faafb4ac5fbfd6106770a1c3","modified":1615389839977},{"_id":"public/archives/page/11/index.html","hash":"5abc27c402e04c0b046f450f44bed1f4b0cc63fc","modified":1615389839977},{"_id":"public/archives/page/12/index.html","hash":"f46a8efedb80ed50b912fecc22f7b4c100e4b1eb","modified":1615389839977},{"_id":"public/archives/page/13/index.html","hash":"4759a6e20fe98d9885fcb59ba7a2fa2c01220ff6","modified":1615389839977},{"_id":"public/archives/page/14/index.html","hash":"6c9d0075bd51453cc0ce49bafb2716e3c80c4ecd","modified":1615389839977},{"_id":"public/archives/page/15/index.html","hash":"e1dabc083dee1d1a930acb6f7cfc55dc727bc8c9","modified":1615389839977},{"_id":"public/archives/page/16/index.html","hash":"05a0b5811ca39d0b708131f99d9e422617a4e720","modified":1615389839977},{"_id":"public/archives/page/17/index.html","hash":"c6bf5e82610b1fd37ca6735ee015a332907e9026","modified":1615389839977},{"_id":"public/archives/page/18/index.html","hash":"982753b70217a32319add10d6b8c9889b9a69284","modified":1615389839977},{"_id":"public/archives/page/19/index.html","hash":"012429da9f14f9fcd17b42b49bc56d44cbb76b1a","modified":1615389839977},{"_id":"public/archives/page/20/index.html","hash":"2355a8abbb6d7ce7af15e1ace8693b4dbe331b50","modified":1615389839977},{"_id":"public/archives/2017/index.html","hash":"15f9a82d55eeb10c917996a6fe63a27012f5fa0e","modified":1615389839977},{"_id":"public/archives/2017/page/2/index.html","hash":"b960e6a80b43c9750271c003b2f3ce98784fe167","modified":1615389839977},{"_id":"public/archives/2017/page/3/index.html","hash":"c0b49a458b241687435f2e21ff86703744b12d8d","modified":1615389839977},{"_id":"public/archives/2017/page/4/index.html","hash":"a1779ca2188be66c85dbbe89dfe0cb1aead7480c","modified":1615389839977},{"_id":"public/archives/2017/page/5/index.html","hash":"0de72f9dab6f7e997ae28cb8108fc201733588fd","modified":1615389839977},{"_id":"public/archives/2017/page/6/index.html","hash":"e4c777953d03e871d24add0b7a79216727074c36","modified":1615389839977},{"_id":"public/archives/2017/page/7/index.html","hash":"b3171c3ce6560eca9da46a1d501891d49ae07367","modified":1615389839977},{"_id":"public/archives/2017/page/8/index.html","hash":"dd9e3f27e63296f6b238871286adc56b600e5906","modified":1615389839977},{"_id":"public/archives/2017/page/9/index.html","hash":"9c894576c0659c4ba71e30d115af7e59f6924897","modified":1615389839977},{"_id":"public/archives/2017/09/index.html","hash":"3239df4697ca74cef8634be3587d8f3ca0bfd738","modified":1615389839977},{"_id":"public/archives/2017/10/index.html","hash":"feb57a584c836d3224a75222421476a62bd25311","modified":1615389839977},{"_id":"public/archives/2017/10/page/2/index.html","hash":"4b45e26cd543cf22c4a5e9d51c5fc04b227747df","modified":1615389839977},{"_id":"public/archives/2017/10/page/3/index.html","hash":"bdf7d8c895bd03748e81b62962bf8115a2cd80ab","modified":1615389839977},{"_id":"public/archives/2017/10/page/4/index.html","hash":"0a489e4d0bff78c1a9076965c035c14308c929ec","modified":1615389839977},{"_id":"public/archives/2017/11/index.html","hash":"e4884926f20c93a758ae512e8bd555da4a9451a7","modified":1615389839977},{"_id":"public/archives/2017/11/page/2/index.html","hash":"ab9854418ab0b90dab3632d26c6297625cbb7f2e","modified":1615389839977},{"_id":"public/archives/2017/11/page/3/index.html","hash":"e167cad0859326a83854b2b45275d8d186f757bf","modified":1615389839977},{"_id":"public/archives/2017/12/index.html","hash":"cd6d394524b6d57471ff82395dccfa52fe385df9","modified":1615389839977},{"_id":"public/archives/2017/12/page/2/index.html","hash":"7b82a4b2191663267964fc42a4b2f316034a865b","modified":1615389839977},{"_id":"public/archives/2018/index.html","hash":"32154e9fd3720b0826f8341f8c0d1d96c214b4b4","modified":1615389839977},{"_id":"public/archives/2018/page/2/index.html","hash":"845d06437b13587cc859a25c8578a626b04fef5f","modified":1615389839977},{"_id":"public/archives/2018/01/index.html","hash":"02690aaaf491eae0aff4334e792bad5568272a6f","modified":1615389839977},{"_id":"public/archives/2018/01/page/2/index.html","hash":"c46d6b38643cd73c722a4c0e147555624cc9b819","modified":1615389839977},{"_id":"public/archives/2018/02/index.html","hash":"cf97884fe2020d3f1cbe9f3767afc40ad9d83f49","modified":1615389839977},{"_id":"public/archives/2019/index.html","hash":"4f1f37e1fd764015bae17d28eb61155cc17d818c","modified":1615389839977},{"_id":"public/archives/2019/page/2/index.html","hash":"c29ff02969ea3f019f5d9721c423d93b5d978d76","modified":1615389839977},{"_id":"public/archives/2019/page/3/index.html","hash":"5b3ba6c979dfa63749f2a56a77ce07bb746a5c1a","modified":1615389839977},{"_id":"public/archives/2019/page/4/index.html","hash":"16e23a92cb16621afa3f2b41d1f56cdb5bba397e","modified":1615389839977},{"_id":"public/archives/2019/page/5/index.html","hash":"ef30d32ef64d5389f4416564909450f4c03c8d7f","modified":1615389839977},{"_id":"public/archives/2019/page/6/index.html","hash":"7c6313194bba8835fdeea3b0949a1a6f19bc17b1","modified":1615389839977},{"_id":"public/archives/2019/page/7/index.html","hash":"46264a8577304b8a251e190a093bd5cd2d9d235c","modified":1615389839977},{"_id":"public/archives/2019/02/index.html","hash":"aee879e2ec8106439e5aa645797f4d9aa6dcf48b","modified":1615389839977},{"_id":"public/archives/2019/03/index.html","hash":"093d7aff2fd9d454a332944b5ec0a61d86e688af","modified":1615389839977},{"_id":"public/archives/2019/03/page/2/index.html","hash":"3870b9034681d30f1efbef34e03129c8be108367","modified":1615389839977},{"_id":"public/archives/2019/11/index.html","hash":"c52ec05c097597ee7a18cc969df2fcbe7e1c75c9","modified":1615389839977},{"_id":"public/archives/2019/11/page/2/index.html","hash":"1ea042cee3463191ea05447a45b4dcbcf280a22d","modified":1615389839977},{"_id":"public/archives/2019/11/page/3/index.html","hash":"d1bd11545ff8de3e6e783ee7977bf4e8cec2a2b5","modified":1615389839977},{"_id":"public/archives/2019/12/index.html","hash":"e890ab1f5786bcb7c3904d8122c440dda0483a4b","modified":1615389839977},{"_id":"public/archives/2019/12/page/2/index.html","hash":"188b998e49db1cf40c3dd35d8aeab13a2498a509","modified":1615389839977},{"_id":"public/archives/2019/12/page/3/index.html","hash":"9f01273230d21e68128632aa4c2fe9f9ba75926e","modified":1615389839977},{"_id":"public/archives/2020/index.html","hash":"eb74deb285ff546bc5586c873e03ac621159b45a","modified":1615389839977},{"_id":"public/archives/2020/page/2/index.html","hash":"d3e3a31dee269a7a36f3e2ab47b412c3d8346a38","modified":1615389839977},{"_id":"public/archives/2020/page/3/index.html","hash":"c346b0c3740a67692f3afdc46a6163e7dd10948a","modified":1615389839977},{"_id":"public/archives/2020/01/index.html","hash":"afb5d8414d84ced1f0ff002e16be44d3d5ebc7e0","modified":1615389839977},{"_id":"public/archives/2020/02/index.html","hash":"87d67a87a71fe731afde653c8dec0ef13fe9bef7","modified":1615389839977},{"_id":"public/archives/2020/03/index.html","hash":"7be9c69d1436cf8c787204a8bce2286dc6050946","modified":1615389839977},{"_id":"public/archives/2020/10/index.html","hash":"230b9da4070fdf7eb3e20482c94d0f6fd1d60649","modified":1615389839977},{"_id":"public/archives/2021/01/index.html","hash":"aff71d259adaa0692eff50e066761805058d6a20","modified":1615389839977},{"_id":"public/categories/LeetCode/index.html","hash":"f7daf40f8fb9099509d2415fdf735308de265ad9","modified":1615389839977},{"_id":"public/categories/LeetCode/page/2/index.html","hash":"7b02410dcf20fb64e8d91a092a4b483d3f5434ec","modified":1615389839977},{"_id":"public/categories/LeetCode/page/3/index.html","hash":"3124d157dc06faffa36169250749512207a6129d","modified":1615389839977},{"_id":"public/categories/LeetCode/page/4/index.html","hash":"134adf9e155c44b2ac07a1d3dad7d44a80c94be0","modified":1615389839977},{"_id":"public/categories/LeetCode/page/5/index.html","hash":"7ed08910b974da41d10ade9c7eaaa1d364ffec4f","modified":1615389839977},{"_id":"public/categories/LeetCode/page/6/index.html","hash":"4ea8e9f1297eda408e381c76af0f73cd0d26be26","modified":1615389839977},{"_id":"public/categories/LeetCode/page/7/index.html","hash":"b0eca5fd0c0fcafcd399221aa0ee8feb008761a0","modified":1615389839977},{"_id":"public/categories/LeetCode/page/8/index.html","hash":"1b8de6e698051c34631e4c299e555360b1b12cd8","modified":1615389839977},{"_id":"public/categories/LeetCode/page/9/index.html","hash":"d947c2c8259032744aeabb2a09651e99aff1d974","modified":1615389839977},{"_id":"public/categories/LeetCode/page/10/index.html","hash":"9a01f09ce496898aba09e74f4fc8172d54c0fc73","modified":1615389839977},{"_id":"public/categories/LeetCode/page/11/index.html","hash":"d849f4ff0956eed8788d5b2e048f92c363397f91","modified":1615389839977},{"_id":"public/categories/LeetCode/page/12/index.html","hash":"def35a1ff57857cff0eb4a669e242a5692eaf0e2","modified":1615389839977},{"_id":"public/categories/LeetCode/page/13/index.html","hash":"14c2efb32fdc60dc4d8b7126d7df757c38045943","modified":1615389839977},{"_id":"public/categories/LeetCode/page/14/index.html","hash":"b377e787d1f281ebcbc06f37af9efccb5086f5fc","modified":1615389839977},{"_id":"public/categories/LeetCode/page/15/index.html","hash":"911cfbbfc01194b28f8ea9ca88aa6e0daba40032","modified":1615389839977},{"_id":"public/categories/LeetCode/page/16/index.html","hash":"60e8d9f23e0903b5594273b0f936ef2d052896b3","modified":1615389839977},{"_id":"public/categories/LeetCode/page/17/index.html","hash":"3310ede513af0d2ed737200e1f0f6ec601fa5a6e","modified":1615389839977},{"_id":"public/categories/LeetCode/page/18/index.html","hash":"a5210971ee97e3b02ad6cd84b60894a922fab7e0","modified":1615389839977},{"_id":"public/categories/LeetCode/page/19/index.html","hash":"3ee2b86415efbb33ace173211ec8ecdf0a29e6b3","modified":1615389839977},{"_id":"public/categories/LeetCode/page/20/index.html","hash":"33e132c6521ded2452721cd2b8f0049c2c3b064f","modified":1615389839977},{"_id":"public/page/2/index.html","hash":"5f06bf9713ea27087700780bc2f60c09a8b0cabb","modified":1615389839977},{"_id":"public/page/3/index.html","hash":"0a632b88046559efc6e0f0d754ff974aff060f80","modified":1615389839977},{"_id":"public/page/4/index.html","hash":"e357cfabdc42f164d161f4ee48b1504301e6eaf1","modified":1615389839977},{"_id":"public/page/5/index.html","hash":"19e821895c7f81524c340cb249e1765450bf2963","modified":1615389839977},{"_id":"public/page/6/index.html","hash":"8c095cb3aecf10927b1675b8a0816b3eed5c420c","modified":1615389839977},{"_id":"public/page/7/index.html","hash":"eac576abc14192771b2f3cb4d0d9bbc1cabbf609","modified":1615389839977},{"_id":"public/page/8/index.html","hash":"ba7f13a9d9d5e6927c0480ac11528e8a8b5a968f","modified":1615389839977},{"_id":"public/page/9/index.html","hash":"de08faae38ccb34ce46b0149d987a456234f74b6","modified":1615389839977},{"_id":"public/page/10/index.html","hash":"597581e7c6adc0a7e48757d6f7af45007af65fc8","modified":1615389839977},{"_id":"public/page/11/index.html","hash":"60d20cd7b4e47453e7a1eab2f802311ddc56c84b","modified":1615389839977},{"_id":"public/page/12/index.html","hash":"59e5f3490ca1f694dbef085914a0e6ed17bcf94a","modified":1615389839977},{"_id":"public/page/13/index.html","hash":"7e84be57614f15d6f2eb54764d5728c463471818","modified":1615389839977},{"_id":"public/page/14/index.html","hash":"d2f3ab79600a197b11f4c404d4279b172c1fe47f","modified":1615389839977},{"_id":"public/page/15/index.html","hash":"15512e53ecdce4e626b6c3e4c37f0d7925bc1330","modified":1615389839977},{"_id":"public/page/16/index.html","hash":"b7ab0015bb0f997f82a8960324f372ccb1eb4108","modified":1615389839977},{"_id":"public/page/17/index.html","hash":"f8f750363b6d52bf598dfbf94bb1a5b31f1c75a3","modified":1615389839977},{"_id":"public/page/18/index.html","hash":"6e6db58d2063b087eb6bd3d3c1c981615e773926","modified":1615389839977},{"_id":"public/page/19/index.html","hash":"54cde28e77d5ccfc1857e2cc90b3ac1c07bc41e5","modified":1615389839977},{"_id":"public/page/20/index.html","hash":"c74fef4dda613ad55babdf897b9c5fb72885ab6e","modified":1615389839977},{"_id":"public/tags/LeetCode/index.html","hash":"0996827fc6d62da60460b16e656ca8012987a728","modified":1615389839977},{"_id":"public/tags/LeetCode/page/2/index.html","hash":"712f55e1c1973c0f52f4000beb25d766aa31ad66","modified":1615389839977},{"_id":"public/tags/LeetCode/page/3/index.html","hash":"1286e4830199cc8e50a56515a9b4c5edd9be6bb8","modified":1615389839977},{"_id":"public/tags/LeetCode/page/4/index.html","hash":"d45a0a3151e270f5581a392f71d874bd319228fc","modified":1615389839977},{"_id":"public/tags/LeetCode/page/5/index.html","hash":"1e03493a484fa2d88f052453f15cbf83220ddf89","modified":1615389839977},{"_id":"public/tags/LeetCode/page/6/index.html","hash":"1dbc5f88151df162686f6973a92be3ee828caa27","modified":1615389839977},{"_id":"public/tags/LeetCode/page/7/index.html","hash":"7ffbf6a0273cf1364e8461becb6b3d55d67880a7","modified":1615389839977},{"_id":"public/tags/LeetCode/page/8/index.html","hash":"3ae4876ee627c3caf567d414967136099ef1df14","modified":1615389839977},{"_id":"public/tags/LeetCode/page/9/index.html","hash":"4b706aaae33ef3b51f386535989148bbf0b600f9","modified":1615389839977},{"_id":"public/tags/LeetCode/page/10/index.html","hash":"93153a68589d301476d99b2307b41c8da2b8f040","modified":1615389839977},{"_id":"public/tags/LeetCode/page/11/index.html","hash":"edc25c6f1ca0dc391c513f612dded374ee9f0c24","modified":1615389839977},{"_id":"public/tags/LeetCode/page/12/index.html","hash":"37bae48c99ae5774c165b720aeb5c4e1e97dd084","modified":1615389839977},{"_id":"public/tags/LeetCode/page/13/index.html","hash":"47e9dc09b89583b134cde9bcb5f04c4adc83a4b5","modified":1615389839977},{"_id":"public/tags/LeetCode/page/14/index.html","hash":"3bcf6c640eb7b74474fdcf875a9d77ebe2df8e00","modified":1615389839977},{"_id":"public/tags/LeetCode/page/15/index.html","hash":"12a012a6bfd09a0d331916c3d13658a15aa8bac3","modified":1615389839977},{"_id":"public/tags/LeetCode/page/16/index.html","hash":"3caab0ec6de1bbd731f9bafe519181d8130a7a02","modified":1615389839977},{"_id":"public/tags/LeetCode/page/17/index.html","hash":"783f5d4e882ef66fa81d9c0b68d081d438d252ab","modified":1615389839977},{"_id":"public/tags/LeetCode/page/18/index.html","hash":"98534a06dba6c9c8ab6173c2abf804ad695ed708","modified":1615389839977},{"_id":"public/tags/LeetCode/page/19/index.html","hash":"040c3bff19d6a5dc6a3ee3b6da14cd8e6c2c0d61","modified":1615389839977},{"_id":"public/tags/LeetCode/page/20/index.html","hash":"efbb48a6fd791bce1c7115e2032b03f2c083e88d","modified":1615389839977},{"_id":"public/tags/Tires/index.html","hash":"ece3771af9bc72285da64b2b4a7717e35f91ad6c","modified":1615389839977},{"_id":"public/tags/链表/index.html","hash":"082bff9b56e43fdadb5657ede90508104ce4aee0","modified":1615389839977},{"_id":"public/tags/算法/index.html","hash":"669cfb213329b4f4a6f26be4fb54634a0d4e9244","modified":1615389839977},{"_id":"public/tags/Tree/index.html","hash":"a435aee76d1a4b0a82ded6b99b9ff34c0861d6a3","modified":1615389839977},{"_id":"public/tags/Tree/page/2/index.html","hash":"701445d020ddb5bfca03262b5ba8636913f5bf9c","modified":1615389839977},{"_id":"public/tags/Tree/page/3/index.html","hash":"30f90bec8ff52b538f934204c8790450fe056289","modified":1615389839977},{"_id":"public/tags/DP/index.html","hash":"b3e16f2b7ab6291174fde9fa05c0b7017c484058","modified":1615389839977},{"_id":"public/tags/Stack/index.html","hash":"c13829649e28037ce38f80bc024e2d6043517699","modified":1615389839977},{"_id":"public/tags/Stack/page/2/index.html","hash":"5e943b30ab08df782d80235e6a99fdff2b8a871c","modified":1615389839977},{"_id":"public/tags/Design/index.html","hash":"ed5fa4433111e04ebf2b70ed3bd5f173f3140912","modified":1615389839977},{"_id":"public/tags/Queues/index.html","hash":"b222909251dbc54ab48087d58db8bce778eb8b54","modified":1615389839977},{"_id":"public/tags/BFS/index.html","hash":"907222c7a61d4d70b74e59c1e8892eeb609524ee","modified":1615389839977},{"_id":"public/tags/动态规划/index.html","hash":"05ba5c1283f73e43c0f1fd3617c34493bc653f8f","modified":1615389839977},{"_id":"public/tags/Hash/index.html","hash":"022aca059b227de4d46100b17fbf254159ac5459","modified":1615389839977},{"_id":"public/tags/图/index.html","hash":"c7d88767e2bc92aa3293d600fdade01877d12ce9","modified":1615389839977},{"_id":"public/tags/Depth-first-Search/index.html","hash":"91b3164fd97e9d3293d5a995218c4396651350d5","modified":1615389839977},{"_id":"public/tags/Linked-List/index.html","hash":"ce31922261fd08bc04441bc38301d94769fce63b","modified":1615389839977},{"_id":"public/tags/串/index.html","hash":"bd87087226fff1ffdd90dcc2f39268d3d1028c15","modified":1615389839977},{"_id":"public/tags/分治法/index.html","hash":"b37d3fa308cd9d39041ef6277e987928dc3270f6","modified":1615389839977},{"_id":"public/tags/LinkedList/index.html","hash":"7c339c3874761105caf87e9850b21a7f4884fff5","modified":1615389839977},{"_id":"public/tags/String/index.html","hash":"add61671d9cfa98ad873c77bd2855d14d2fc95f1","modified":1615389839977},{"_id":"public/tags/Search/index.html","hash":"b84e1626b4ae65488512dfaac5912d2b1665f90e","modified":1615389839977},{"_id":"public/tags/二叉树/index.html","hash":"39e0e3d6cb504a77ec702745eb37118a018c1159","modified":1615389839977},{"_id":"public/tags/FSM/index.html","hash":"55c4962388e46faf8b5ab8cadb4ca209e1ab7620","modified":1615389839977},{"_id":"public/tags/Bit-Manipulation/index.html","hash":"5243cfbfed687d0729772b811c4a03b7a6a3935a","modified":1615389839977},{"_id":"public/tags/sort/index.html","hash":"aaa7c58cb84d09db0bb21d69536f2639da6dd6a8","modified":1615389839977},{"_id":"public/tags/List/index.html","hash":"fe53c9492a1d1d2025c9cc14e8a4cafa71aa24df","modified":1615389839977},{"_id":"public/tags/Array/index.html","hash":"d1e8737d452e74c3a5bb4f214009b12d5dd1274b","modified":1615389839977},{"_id":"public/tags/ListNode/index.html","hash":"2f7451fbe2189e8108527430637006c18b345622","modified":1615389839977},{"_id":"public/tags/Brainteaser/index.html","hash":"a21d7aef3f03a17f1741e12d0d439351b09fec6c","modified":1615389839977},{"_id":"public/tags/Math/index.html","hash":"5e93db5e95729089a319562d1432d0ae9f670833","modified":1615389839977},{"_id":"public/tags/Dynamic-Programming/index.html","hash":"b55b4972c15f26f18c4062767c83dfa591dd2432","modified":1615389839977},{"_id":"public/tags/Minimax/index.html","hash":"3d1bf3c9bf7d063df8c588dc42ca3e16be8220a1","modified":1615389839977},{"_id":"public/tags/Sort/index.html","hash":"86c3c6ca5ca868cadccedd0d06ae197b8bededac","modified":1615389839977},{"_id":"public/tags/Hash-Table/index.html","hash":"85260a8cbf47b8de3ae3bf2e26c9ebaf8f40bf7a","modified":1615389839977},{"_id":"public/tags/Recursion/index.html","hash":"f3717ac36fbeabb33b4a8b70d6cb3ca7b4f0a9de","modified":1615389839977},{"_id":"public/tags/查找/index.html","hash":"c8f02bfede6533c39ddeab6a76904f59fc661bd5","modified":1615389839977},{"_id":"public/2021/01/21/maximum-product-of-word-lengths/index.html","hash":"2d4f6d0881a65348fcac957c1de3e17710a758fc","modified":1615389839977},{"_id":"public/2021/01/20/longest-univalue-path/index.html","hash":"24bf8701a86a7e8b1325abed5d8cfcbac10cb1e7","modified":1615389839977},{"_id":"public/2020/10/14/water-and-jug-problem/index.html","hash":"d352a05a7cc0fe96473806c9582b83fad7344b21","modified":1615389839977},{"_id":"public/2020/10/12/populating-next-right-pointers-in-each-node/index.html","hash":"faa0c409a6b27b60e6322754151efb1d2fa1f3e6","modified":1615389839977},{"_id":"public/2020/10/11/airplane-seat-assignment-probability/index.html","hash":"036c4251bfbba0d0d837016c78b73c03b33c58f7","modified":1615389839977},{"_id":"public/2020/10/10/next-greater-node-in-linked-list/index.html","hash":"9c3d961fe3e902bb4c1d2dea912cec94c0ef7e9e","modified":1615389839977},{"_id":"public/2020/10/09/guess-number-higher-or-lower-ii/index.html","hash":"e01ebdfe3adecf933089cd3046b2a519df91c4cf","modified":1615389839977},{"_id":"public/2020/10/08/construct-binary-tree-from-preorder-and-postorder-traversal/index.html","hash":"8923cd6845fe3e2965b49c68808bc7a56c5609e8","modified":1615389839977},{"_id":"public/2020/10/07/linked-list-components/index.html","hash":"28cca85dbd7b0b6b7d57392826b62750532b5bd9","modified":1615389839977},{"_id":"public/2020/10/06/angle-between-hands-of-a-clock/index.html","hash":"28ce36b07444df67295eb090d17bd1f18031f788","modified":1615389839977},{"_id":"public/2020/10/05/677.Map-Sum-Pairs/index.html","hash":"40c461408caf40eef8db6c34c70fc2b304b87a49","modified":1615389839977},{"_id":"public/2020/03/31/Binary-Search-Tree-Iterator/index.html","hash":"ea45ead8e1b2b5791421129dfaaa95f25aafe680","modified":1615389839977},{"_id":"public/2020/03/31/Evaluate-Reverse-Polish-Notation/index.html","hash":"73dacc51c1fac74bb06f5876962dcf13b75b024d","modified":1615389839977},{"_id":"public/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/index.html","hash":"38636b861fe5dfd19d7fd68e3f64fe78a9bd3666","modified":1615389839977},{"_id":"public/2020/03/23/LeetCode-Stack-Tag-总结/index.html","hash":"6d7d7c9ca02e916d12f66b219c8033a76a904482","modified":1615389839977},{"_id":"public/2020/01/28/Jump-Game-III/index.html","hash":"e70a81308201573d36b529413109c1dccd2fb327","modified":1615389839977},{"_id":"public/2020/01/27/Top-K-Frequent-Elements/index.html","hash":"db6985f89ccdd51343139ad2db07dd0040e550db","modified":1615389839977},{"_id":"public/2020/01/13/Evaluate-Division/index.html","hash":"8023eacdbf247b964947ce0d4affd28cda38f42b","modified":1615389839977},{"_id":"public/2020/01/07/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/index.html","hash":"a65a3a980aef57bfebf3195c3e100e8a662d222d","modified":1615389839977},{"_id":"public/2020/01/06/Asteroid-Collision/index.html","hash":"a88eaf270cdcf01405f01b7e71135c5b30d1f5ac","modified":1615389839977},{"_id":"public/2020/01/04/Maximum-Difference-Between-Node-and-Ancestor/index.html","hash":"eadd8de0c58d54f1916f9187621f9fd2658ec041","modified":1615389839977},{"_id":"public/2020/01/03/All-Elements-in-Two-Binary-Search-Trees/index.html","hash":"0ce39877cf63c6b94a84505d15a5cdc0a406c45c","modified":1615389839977},{"_id":"public/2020/01/02/Implement-Rand10-Using-Rand7/index.html","hash":"a42535cd27495ab6ccb5688287d166727a70c5a0","modified":1615389839977},{"_id":"public/2019/12/29/Count-Servers-that-Communicate/index.html","hash":"a430e43da8ab77cd63b3a875ac7ef9d492ce253a","modified":1615389839977},{"_id":"public/2019/12/28/Satisfiability-of-Equality-Equations/index.html","hash":"692e3c9634def628103df8c1e677bd66db70a07c","modified":1615389839977},{"_id":"public/2019/12/27/Binary-Tree-Coloring-Game/index.html","hash":"22178f4d45c845d6ce55b48fc024109fede41179","modified":1615389839977},{"_id":"public/2019/12/26/Maximum-Level-Sum-of-a-Binary-Tree/index.html","hash":"30ad3708946bbc930b8060ab0f3e03f21673bdf6","modified":1615389839977},{"_id":"public/2019/12/24/Maximum-Length-of-Repeated-Subarray/index.html","hash":"7766d21aac3697dd4922c1b41994784e1b187dcc","modified":1615389839977},{"_id":"public/2019/12/22/Interval-List-Intersections/index.html","hash":"7d0519792cdaaea3ffb12e72d9a22708a82a0ec2","modified":1615389839977},{"_id":"public/2019/12/21/Binary-Search-Tree-to-Greater-Sum-Tree/index.html","hash":"1c2e0c34d6c1b1162ee54b8968f69892b93b13ec","modified":1615389839977},{"_id":"public/2019/12/20/Find-Eventual-Safe-States/index.html","hash":"53f28a6339ae4575525b9b2f54a72045c264037f","modified":1615389839977},{"_id":"public/2019/12/19/Flatten-a-Multilevel-Doubly-Linked-List/index.html","hash":"6f7f0796cd12fe0e398192608b8eefd0810bee8f","modified":1615389839977},{"_id":"public/2019/12/18/Find-Largest-Value-in-Each-Tree-Row/index.html","hash":"3f5f5647d3b4626b7e65969b8ece8172e48b320f","modified":1615389839977},{"_id":"public/2019/12/16/Network-Delay-Time/index.html","hash":"fd290518a50812f8ddd28274ff86b8cc725376a9","modified":1615389839977},{"_id":"public/2019/12/15/Largest-Sum-of-Averages/index.html","hash":"9c6ad43f11cc435a06a1b3e181e46938a623bf55","modified":1615389839977},{"_id":"public/2019/12/14/Unique-Substrings-in-Wraparound-String/index.html","hash":"3a656bf21c6e756d401bc989aa6bd1bf36deca37","modified":1615389839977},{"_id":"public/2019/12/13/Redundant-Connection/index.html","hash":"54e38e24a57f3a48574102f4e46bd4330127aa42","modified":1615389839977},{"_id":"public/2019/12/12/Print-FooBar-Alternately/index.html","hash":"5fc06a2d92dc56c5d481cf4a865a0a5e9ce58e7d","modified":1615389839977},{"_id":"public/2019/12/10/Friend-Circles/index.html","hash":"eec4c7d2ff9fa22a3e446f07ab5a1b253f8fe697","modified":1615389839977},{"_id":"public/2019/12/09/Minimum-ASCII-Delete-Sum-for-Two-Strings/index.html","hash":"a2a3a5802d27cea17a90229dc3fd1c113834dccf","modified":1615389839977},{"_id":"public/2019/12/08/Rotate-Function/index.html","hash":"2162e6f6ae50cd5ac71bb51f9238f7b6d6cbca2b","modified":1615389839977},{"_id":"public/2019/12/07/Longest-Word-in-Dictionary-through-Deleting/index.html","hash":"add7c845b74e45bd8962929e7f5a7c07b893c766","modified":1615389839977},{"_id":"public/2019/12/06/Partition-Labels/index.html","hash":"bdc496b0919347966ef4862847c738b0f8d2303f","modified":1615389839977},{"_id":"public/2019/12/05/Add-and-Search-Word-Data-structure-design/index.html","hash":"e2c961b37e7f774536967f1d2c15a42f81e18b77","modified":1615389839977},{"_id":"public/2019/12/04/Best-Sightseeing-Pair/index.html","hash":"2de9493de5a9db6aac67a141c73adb7c8addf6dd","modified":1615389839977},{"_id":"public/2019/12/03/Longest-Palindromic-Subsequence/index.html","hash":"6dd8dbb1fe03a3963c10af80af9412dacfac07f0","modified":1615389839977},{"_id":"public/2019/12/02/Global-and-Local-Inversions/index.html","hash":"d422d3eb386388245074b5a77b7bed57a78a53e7","modified":1615389839977},{"_id":"public/2019/11/28/Delete-Node-in-a-BST/index.html","hash":"3933474417288e4770b9587480f3afa4af0aa5c0","modified":1615389839977},{"_id":"public/2019/11/27/Longest-Common-Subsequence/index.html","hash":"6db626805b4ea3bc4f37cfe19282e3c9dbb96605","modified":1615389839977},{"_id":"public/2019/11/26/Possible-Bipartition/index.html","hash":"827c1153badc962522841a55e5a724cbed51d475","modified":1615389839977},{"_id":"public/2019/11/25/Is-Graph-Bipartite/index.html","hash":"502d61aee75ae33147a6c50f2a4e55e73fbe8a3a","modified":1615389839977},{"_id":"public/2019/11/24/Minimum-Moves-to-Equal-Array-Elements-II/index.html","hash":"e041ee6df444910c27ee2c6091bebed1bca5feb7","modified":1615389839977},{"_id":"public/2019/11/23/N-ary-Tree-Level-Order-Traversal/index.html","hash":"e4236dedd875fe8e4cf497e544e596583977b08a","modified":1615389839977},{"_id":"public/2019/11/22/All-Possible-Full-Binary-Trees/index.html","hash":"ba64c076995db75b6d3c085a73b9cb6f03dead3a","modified":1615389839977},{"_id":"public/2019/11/21/Kth-Smallest-Element-in-a-BST/index.html","hash":"975bc60022a9991155b89e789135d21854244f33","modified":1615389839977},{"_id":"public/2019/11/20/Triangle/index.html","hash":"5ead1980dd16c7e624461869f91f7175a8c58bf1","modified":1615389839977},{"_id":"public/2019/11/19/Advantage-Shuffle/index.html","hash":"16b363617901d7e7ea4cf3b42f9da00769300e60","modified":1615389839977},{"_id":"public/2019/11/18/Delete-Nodes-And-Return-Forest/index.html","hash":"6053e3e34d75dd02eb073f49b4415705457cdfea","modified":1615389839977},{"_id":"public/2019/11/17/Boats-to-Save-People/index.html","hash":"95ef45da30fcc178e8acd78058b5dd6877f5d2f0","modified":1615389839977},{"_id":"public/2019/11/16/Diagonal-Traverse/index.html","hash":"b1cb9b3eecb00e4893fd9cfdcb9625a371862ea1","modified":1615389839977},{"_id":"public/2019/11/15/Keys-and-Rooms/index.html","hash":"05577a51c43179ae3f0842e7ac5f16d6c7e83209","modified":1615389839977},{"_id":"public/2019/11/14/Populating-Next-Right-Pointers-in-Each-Node-II/index.html","hash":"4622e06af235bf57e8ef164d82d4a6249c241bf9","modified":1615389839977},{"_id":"public/2019/11/13/Next-Greater-Element-III/index.html","hash":"92c91c2d0b6eaa564b20c73e4ebd02c08cf8d4bc","modified":1615389839977},{"_id":"public/2019/11/12/Replace-Words/index.html","hash":"91c7ee4ce98869c8f08ba952ec886157a3873fc2","modified":1615389839977},{"_id":"public/2019/11/11/Sort-Characters-By-Frequency/index.html","hash":"72ff432c824488f4c4f441e3cd00e069c519d19a","modified":1615389839977},{"_id":"public/2019/11/10/Longest-String-Chain/index.html","hash":"e02997a3cf91d60782c6e75669c83f20b6872519","modified":1615389839977},{"_id":"public/2019/11/09/Reverse-Substrings-Between-Each-Pair-of-Parentheses/index.html","hash":"e099dededc4df980f051d85b39f8d26fdaf3c8db","modified":1615389839977},{"_id":"public/2019/11/08/Decode-String/index.html","hash":"bd6c32f8882af1fb0156766da11aafbb1414a7e2","modified":1615389839977},{"_id":"public/2019/11/07/Serialize-and-Deserialize-BST/index.html","hash":"678a83f64d41347765082c30b5afc1daa53b46f3","modified":1615389839977},{"_id":"public/2019/11/06/K-Closest-Points-to-Origin/index.html","hash":"14c4948c6b6e3cfa7dcf117e45e108c3e07ce813","modified":1615389839977},{"_id":"public/2019/03/21/Maximum-Binary-Tree/index.html","hash":"6493ed9f4b45a70683ce87bdfa778d0ed25966f5","modified":1615389839977},{"_id":"public/2019/03/20/Daily-Temperatures/index.html","hash":"c9569b01305bb5c53106779a3166b2728e81b9b0","modified":1615389839977},{"_id":"public/2019/03/12/Array-Nesting/index.html","hash":"dbaeb90f5f79d55e22251a969fcabf507c7ca24a","modified":1615389839977},{"_id":"public/2019/03/11/Bitwise-ORs-of-Subarrays/index.html","hash":"7364d9dc489515d6ff3da86b182dc894adb9b7c9","modified":1615389839977},{"_id":"public/2019/03/09/Odd-Even-Linked-List/index.html","hash":"9f28e9801b96bac6674706b728763d475fe9c78c","modified":1615389839977},{"_id":"public/2019/03/08/Matchsticks-to-Square/index.html","hash":"c4eee29fc3a1aa83060141202a2827ead4326b0d","modified":1615389839977},{"_id":"public/2019/03/07/All-Nodes-Distance-K-in-Binary-Tree/index.html","hash":"b89d2b28765cdf27347f6b28f6ccb541ea7d12a4","modified":1615389839977},{"_id":"public/2019/03/06/Sum-Root-to-Leaf-Numbers/index.html","hash":"8518f03fa937570ae5944b3bb4345ca71fbbb1bb","modified":1615389839977},{"_id":"public/2019/03/05/Longest-Repeating-Character-Replacement/index.html","hash":"e7e67e5da8996c623bf8386c2c396c0d6ada67a3","modified":1615389839977},{"_id":"public/2019/03/04/Minimum-Falling-Path-Sum/index.html","hash":"1adcdc197230106cc09d386cc63ce31117e513c0","modified":1615389839977},{"_id":"public/2019/03/03/Spiral-Matrix/index.html","hash":"65dea97c9cf4735de315b46b14ec391c802b4974","modified":1615389839977},{"_id":"public/2019/03/02/Simplify-Path/index.html","hash":"20e1e362e8bc652570a972aec8a8e60c495d8eaa","modified":1615389839977},{"_id":"public/2019/02/15/ZigZag-Conversion/index.html","hash":"37cd987c2ebf26a1d3e55ded29fa091e65ab40c5","modified":1615389839977},{"_id":"public/2019/02/14/String-to-Integer-atoi/index.html","hash":"1d19d1aab600b2cb1ca2849f3da0f30e216a72da","modified":1615389839977},{"_id":"public/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/index.html","hash":"3ae36c9a627ca9e6c2a926b27a4c2039ed05aa32","modified":1615389839977},{"_id":"public/2018/02/14/Flatten-Nested-List-Iterator/index.html","hash":"5c425bb1624c7cdc81d28c07021c225f4b8d474f","modified":1615389839977},{"_id":"public/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/index.html","hash":"27cbe984275761a11238201fa67b6f6086c70f1a","modified":1615389839977},{"_id":"public/2018/01/27/Search-a-2D-Matrix-II/index.html","hash":"66bc4530b628e37b9cdc03e057070fae9984fd6d","modified":1615389839977},{"_id":"public/2018/01/25/Nim-Game/index.html","hash":"11b1953e27374cd458b4fff095a0ee12ff1c540b","modified":1615389839977},{"_id":"public/2018/01/24/Construct-the-Rectangle/index.html","hash":"05735feb27a5820162ad5dd1ab26ea239d933bfd","modified":1615389839977},{"_id":"public/2018/01/23/Rotate-Image/index.html","hash":"470ff808bad4400c6a7ca3f22208c8b7ef8af63f","modified":1615389839977},{"_id":"public/2018/01/22/Repeated-Substring-Pattern/index.html","hash":"22b82f9f3875172252516c1a20b0673598472480","modified":1615389839977},{"_id":"public/2018/01/21/Linked-List-Random-Node/index.html","hash":"8d6937c814789dbd7fc02d2905465577df05cb3b","modified":1615389839977},{"_id":"public/2018/01/20/Binary-Tree-Paths/index.html","hash":"6955788baa1d115d6583daa6abebff23dd490c1c","modified":1615389839977},{"_id":"public/2018/01/19/Split-Linked-List-in-Parts/index.html","hash":"221748a3d87c2197a87ddaea304285a115cb2353","modified":1615389839977},{"_id":"public/2018/01/18/Min-Cost-Climbing-Stairs/index.html","hash":"d4741e2fb3cb719f2953c6f604790b4b62d8807a","modified":1615389839977},{"_id":"public/2018/01/17/Rectangle-Area/index.html","hash":"1638ef272fd264925491cf60cdd36dfc8fe2b194","modified":1615389839977},{"_id":"public/2018/01/16/Longest-Palindrome/index.html","hash":"4f4b55cf65d639680dd893e462f8a7666b27a354","modified":1615389839977},{"_id":"public/2018/01/15/Remove-Duplicates-from-Sorted-Array/index.html","hash":"4cbeef11774ea5fe179dac7bfbcd68e7547e2723","modified":1615389839977},{"_id":"public/2017/12/18/Intersection-of-Two-Arrays/index.html","hash":"f4ee5e0bd12391aa3f0debecef1ae1ea811ddb08","modified":1615389839977},{"_id":"public/2017/12/17/Remove-Element/index.html","hash":"a4119377fb85f1ef7c1e64bd0793ba9e66436acc","modified":1615389839977},{"_id":"public/2017/12/15/Reverse-Words-in-a-String-III/index.html","hash":"8d0b20839632913febcd46efa490db00948a94d6","modified":1615389839977},{"_id":"public/2017/12/14/Intersection-of-Two-Arrays-II/index.html","hash":"74d46e27a0f6dcd55bdef349cc6676c6c284f426","modified":1615389839977},{"_id":"public/2017/12/13/Longest-Harmonious-Subsequence/index.html","hash":"e7ec2661382b9b13613062525c7df5175ec631e6","modified":1615389839977},{"_id":"public/2017/12/12/Length-of-Last-Word/index.html","hash":"7b1830940b452f900c72b20df87582bc03954bff","modified":1615389839977},{"_id":"public/2017/12/11/Maximum-Swap/index.html","hash":"fdd0ce996af465387a47c745d67f06cdc11ca5c1","modified":1615389839977},{"_id":"public/2017/12/10/Contains-Duplicate-II/index.html","hash":"11a6575a2a39a5df21c90495647f428af8c039ea","modified":1615389839977},{"_id":"public/2017/12/09/Lexicographical-Number/index.html","hash":"2b4640b81c9102ac7db3dd37b25c0a947b13a37d","modified":1615389839977},{"_id":"public/2017/12/08/Find-Peak-Element/index.html","hash":"c25f52bb518ab7f78afc4ed5d5ca99e1060be739","modified":1615389839977},{"_id":"public/2017/12/07/Find-Bottom-Left-Tree/index.html","hash":"3a272dfeb55a6eff6d4ea9e24e03819f4c2f6ef8","modified":1615389839977},{"_id":"public/2017/12/06/Count-Numbers-with-Unique-Digits/index.html","hash":"f9a8fe3db0d2014499c03a37192be35e05e0473d","modified":1615389839977},{"_id":"public/2017/12/05/Trim-a-Binary-Search-Tree/index.html","hash":"6808d313cf9d82b0974e0170e0f1405489659c3b","modified":1615389839977},{"_id":"public/2017/12/04/Longest-Continuous-Increasing-Subsqeuence/index.html","hash":"5af31e409a699cf00b8502914c253fe5102632ec","modified":1615389839977},{"_id":"public/2017/12/03/Valid-Triangle-Number/index.html","hash":"99dc6bcc75830f3de9dfc925abc67176590b8263","modified":1615389839977},{"_id":"public/2017/12/02/Binary-Tree-Right-Side-View/index.html","hash":"e8528870e8e1c5f3f365d6400d4e983591c49364","modified":1615389839977},{"_id":"public/2017/11/30/Convert-Sorted-Array-to-Binary-Search-Tree/index.html","hash":"14477bf8dce280ed057c6d3c60d136c9ab8725f1","modified":1615389839977},{"_id":"public/2017/11/29/Path-Sum/index.html","hash":"aa5a23e2517a196b48d3a974c89c27e78030014c","modified":1615389839977},{"_id":"public/2017/11/27/Single-Number-III/index.html","hash":"7a708513a04a3092a62d3eefe6ed44b80f393cfa","modified":1615389839977},{"_id":"public/2017/11/26/House-Robber-III/index.html","hash":"260416c30006932c91d8a38ea2aae36f4ff0bc79","modified":1615389839977},{"_id":"public/2017/11/25/Merge-Two-Binary-Trees/index.html","hash":"49256c189b3ae6edd459eb0cfcd3096afa37cc48","modified":1615389839977},{"_id":"public/2017/11/24/Diameter-of-Binary-Tree/index.html","hash":"7e27fabf13f7f2dc6f5265d2b12d878833364cd7","modified":1615389839977},{"_id":"public/2017/11/23/Counting-Bits/index.html","hash":"c16e43655047ff93585fc7977126f24961607637","modified":1615389839977},{"_id":"public/2017/11/21/Find-the-Duplicate-Number/index.html","hash":"4cea18c098a16448b34bf3569f46beee862bb027","modified":1615389839977},{"_id":"public/2017/11/20/Perfect-Squares/index.html","hash":"b0438612104a7b4da1ca5c170307bcca6c7e4b4c","modified":1615389839977},{"_id":"public/2017/11/19/House-Robber/index.html","hash":"299ff162c395b4c3851d42197aaad2f9b935afa3","modified":1615389839977},{"_id":"public/2017/11/18/Course-Schedule/index.html","hash":"683611c82c061998980b63814c163a93b2b51772","modified":1615389839977},{"_id":"public/2017/11/17/Implement-Trie-Prefix-Tree/index.html","hash":"c3d001f698abf42849d1034ad1864c6963030975","modified":1615389839977},{"_id":"public/2017/11/16/Maximal-Square/index.html","hash":"23fa5414ebb97b0fcdc4164f82fff7207501bb68","modified":1615389839977},{"_id":"public/2017/11/15/Best-Time-to-Buy-and-Sell-Stock/index.html","hash":"958d2184d66ed9f14d1f46ffd2eba9157d3da39c","modified":1615389839977},{"_id":"public/2017/11/14/Symmetric-Tree/index.html","hash":"e275a2ae81c5abeea3b9dab087c683c064c48972","modified":1615389839977},{"_id":"public/2017/11/13/Balanced-Binary-Tree/index.html","hash":"cde0b33369155e5b50383a29822f2297b5e6d555","modified":1615389839977},{"_id":"public/2017/11/12/Climbing-Stairs/index.html","hash":"33e75aec051c78df101aa426c3339436b87fcf01","modified":1615389839977},{"_id":"public/2017/11/11/Maximun-Depth-of-Binary-Tree/index.html","hash":"fd80f1e9c117647bf2ae5ffd397eb9e4078aacaa","modified":1615389839977},{"_id":"public/2017/11/10/Majority-Element/index.html","hash":"48a89e09017cdf62c11bfe292ab5a01e3a8c8c0f","modified":1615389839977},{"_id":"public/2017/11/09/Move-Zeroes/index.html","hash":"d6083d81f31d71eca67b9f7238d43f74a790b279","modified":1615389839977},{"_id":"public/2017/11/08/Product-of-Array-Except-Self/index.html","hash":"75fc3b33abe8603f79b829526eafbfdce533bce8","modified":1615389839977},{"_id":"public/2017/11/07/Lowest-Common-Ancestor-of-a-Binary-Tree/index.html","hash":"71155a05207437673f5197b8bae110b2ffd1129f","modified":1615389839977},{"_id":"public/2017/11/06/Palindrome-Linked-List/index.html","hash":"95fb26178f1c41625650eeb34c193c68d5223399","modified":1615389839977},{"_id":"public/2017/11/05/Invert-Binary-Tree/index.html","hash":"dabe99260edfe9864250d3fc760392af00940a7f","modified":1615389839977},{"_id":"public/2017/11/04/Reverse-Linked-List/index.html","hash":"220a4cf59a580c135c30cad13091c092d449fd0a","modified":1615389839977},{"_id":"public/2017/11/03/Kth-Largest-Element-in-an-array/index.html","hash":"23561cc2b5fe97a5da3e39266251847ecf5c753d","modified":1615389839977},{"_id":"public/2017/11/02/Intersection-of-Two-Linked-Lists/index.html","hash":"d4c25b30b0135502b12247b9ace73f6f0e485cf6","modified":1615389839977},{"_id":"public/2017/10/31/Sort-List/index.html","hash":"2d7fb2049424bb0b99fb26a146fc40625de316b4","modified":1615389839977},{"_id":"public/2017/10/30/Linked-List-Cycle/index.html","hash":"f08b43a112cbafa681ab2759adf4747a468457b1","modified":1615389839977},{"_id":"public/2017/10/29/Partition-to-K-Equal-Sum-Subsets/index.html","hash":"2317bf2cace39a88281eebedc349c9d3cecabb04","modified":1615389839977},{"_id":"public/2017/10/28/Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/index.html","hash":"038a46de6a0382305cdc29e2caddad4ae7448a2b","modified":1615389839977},{"_id":"public/2017/10/27/Word-Break/index.html","hash":"1dfaa3a70c69d8387ad0f8a6b08160ada0adfdea","modified":1615389839977},{"_id":"public/2017/10/26/Flatten-Binary-Tree-to-Linked-List/index.html","hash":"4e8a7dd4bec60c97166db1bb3bde28085f96b93c","modified":1615389839977},{"_id":"public/2017/10/25/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/index.html","hash":"c0a2f21d06350cdc179e057b1d37c098bfc124c5","modified":1615389839977},{"_id":"public/2017/10/24/Binary-Tree-Level-Order-Traversal/index.html","hash":"b5eb236944494fa53dbdbd3687c7934a96eaab7a","modified":1615389839977},{"_id":"public/2017/10/23/Validate-Binary-Search-Tree/index.html","hash":"333dcad578e57c7f39de54f69c68dae426ae02d6","modified":1615389839977},{"_id":"public/2017/10/22/Unique-Binary-Search-Tree/index.html","hash":"1f09bc5ba7a77b52aca3268e38dfe1e3eebe5e01","modified":1615389839977},{"_id":"public/2017/10/21/Word-Search/index.html","hash":"1107ccdda3aefad2f5ccd93f720b747bb3cb430d","modified":1615389839977},{"_id":"public/2017/10/20/Subsets/index.html","hash":"6c72f0b2c2e367b609fd5fbd10ea799c2ab3fe5a","modified":1615389839977},{"_id":"public/2017/10/19/Sort-Colors/index.html","hash":"85dd1f35fbec50a48fafbc534539cc38cb5bb7a1","modified":1615389839977},{"_id":"public/2017/10/18/Unique-Paths/index.html","hash":"1ac79f16f71bbd19744a18fb9aa98550c00412cd","modified":1615389839977},{"_id":"public/2017/10/17/Merge-Intervals/index.html","hash":"ce33fc1959564c454c75689d81a7fc060f791bf2","modified":1615389839977},{"_id":"public/2017/10/16/Jump-Game/index.html","hash":"1f6c683bfc8b5e23fb49a1620bc11e1c839cae90","modified":1615389839977},{"_id":"public/2017/10/15/Group-Anagrams/index.html","hash":"4587670ff4c45fe32bc437cc8036f41e1a76ab00","modified":1615389839977},{"_id":"public/2017/10/14/MedianOfTwoSortedArrays/index.html","hash":"83ed965df5347a2219cf5b01b3f4367d4ec42800","modified":1615389839977},{"_id":"public/2017/10/13/Permutations/index.html","hash":"3ee5d1b88204b3ea2327eb0a37455c56a59a7c38","modified":1615389839977},{"_id":"public/2017/10/12/Combination-Sum/index.html","hash":"5618c8d708340d94417bc0e028759c8d0b7f8639","modified":1615389839977},{"_id":"public/2017/10/11/search-for-a-range/index.html","hash":"ee62e06382cce5c2bee123e5e0b4e0c47af4929c","modified":1615389839977},{"_id":"public/2017/10/10/Next-Permutation/index.html","hash":"4b8bd9f07d0f9551e715a13a71f03bd831fc7342","modified":1615389839977},{"_id":"public/2017/10/09/Search-in-Rotated-Sorted-Array/index.html","hash":"261ecf95a0555c8d81ec6bc4962002aef7a23ab5","modified":1615389839977},{"_id":"public/2017/10/08/Generate-Parentheses/index.html","hash":"618240ace6077529375c58fd1389d00e8d2bdade","modified":1615389839977},{"_id":"public/2017/10/07/Remove-Nth-Node-From-End-of-List/index.html","hash":"093c5d09df744a5daa91ac02711b45de907121bb","modified":1615389839977},{"_id":"public/2017/10/06/Letter-Combinations-of-a-Phone-Number/index.html","hash":"8af743706d4b57ff10c726613dc42d0a14846da7","modified":1615389839977},{"_id":"public/2017/10/05/Longest-SubString-with-At-Least-K-Repeating-Characters/index.html","hash":"fd83fe2b0ff4733170193164347f20c5da62d225","modified":1615389839977},{"_id":"public/2017/10/04/4Sum-2/index.html","hash":"81f0f5431b1aaae074e616b30c0f2a69f1ed27e7","modified":1615389839977},{"_id":"public/2017/10/03/LongestPalindromicSubString/index.html","hash":"49e5ad561f524699ade44e0a9329c781514a9fd6","modified":1615389839977},{"_id":"public/2017/10/02/MaximumProductSubarray/index.html","hash":"f1e57a5196e19d3f6c4ea5ec84c260468527985b","modified":1615389839977},{"_id":"public/2017/10/01/LongestSubstringWithoutRepeatingCharacters/index.html","hash":"9d7c190a5fafc50d96bac711c6c66399bbd1416a","modified":1615389839977},{"_id":"public/2017/09/30/AddTwoNumbers/index.html","hash":"65820c4cfcbcd38d27de5b7876ec3040272ed7e7","modified":1615389839977},{"_id":"public/2017/09/28/MergeTwoSortedList/index.html","hash":"d3fe91d567e11fdcdd03bec9bc431b11ae63b0d2","modified":1615389839977},{"_id":"public/2017/09/27/Container_With_Most_Water/index.html","hash":"c5bb1ae56839979a22bef4fb9ead7f93366b1da0","modified":1615389839977},{"_id":"public/2017/09/26/Pow(x,y)/index.html","hash":"f796c59453f32de226e737378c30fe6e08ec5a9e","modified":1615389839977},{"_id":"public/2017/09/25/LongestCommonPrefix/index.html","hash":"3e0ffa9772ff72cacbe5cdade64ebe40ce21ef65","modified":1615389839977},{"_id":"public/2017/09/24/Valid-Parentheses/index.html","hash":"ea3d9565148203c45b822a73f3e85b0594f16051","modified":1615389839977},{"_id":"public/2017/09/20/3Sum/index.html","hash":"3fac745dfeadbbcf5ecc2d3afd5b4f89d4dcf8a0","modified":1615389839977},{"_id":"public/2017/09/20/different-ways-to-add-parentheses/index.html","hash":"c704592188bc8ed8df88a414e80788760eaa3259","modified":1615389839977}],"Category":[{"name":"LeetCode","_id":"ckm3l69md0002qmcm4ph18bmm"}],"Data":[],"Page":[{"title":"search","type":"search","_content":"","source":"search/index.md","raw":"---\ntitle: search\ntype: search\n---\n","date":"2021-03-10T12:51:22.542Z","updated":"2021-03-10T12:51:22.538Z","path":"search/index.html","comments":1,"layout":"page","_id":"ckm3hy6yd0000ddcm5jo40xto","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2021-03-10T12:57:27.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-03-10 20:57:27\n---\n","updated":"2021-03-10T12:57:27.578Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckm3hy6yg0001ddcm2l2c21ek","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"3Sum","date":"2017-09-20T04:00:00.000Z","_content":"\n# 3Sum\n\n觉得立个`flag`：从今天开始每天在LeetCode刷一道题,今天的是[3Sum](https://leetcode.com/problems/3sum/description/)\n\n题目：\n\n> Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\n> Note: The solution set must not contain duplicate triplets.\n\n> For example, given array S = [-1, 0, 1, 2, -1, -4],\n\n> A solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n这个题的坑点有几个：\n\n- 它要求的是不同的，但是如果处理的不好的话，是很容易出现相同的。\n- 第二个是他很容易写出一个O(n^3)的算法，但是好像是跑不过去的。\n\n接近的大概思路是：\n\n- 先对数组进行排序，这样比较好解决第一个坑点\n- 把他转换成2Sum去做\n\n```c++\nvector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int> > ret;\n        sort(nums.begin(),nums.end());      //先进行排序\n\n        for(int i = 0; i < nums.size() - 2;i++) {\n            int target = -nums[i];          //转换成求2Sum\n            if (target < 0) break;\n            int beg = i + 1;\n            int end = nums.size() - 1;\n            while(beg < end) {\n                int sum = nums[beg] + nums[end];\n                if (sum < target)\n                    beg++;\n                else if (sum > target)\n                    end--;\n                else {\n                    int n1 = nums[beg];\n                    int n2 = nums[end];\n                    ret.push_back( {nums[i],nums[beg],nums[end]} );\n                    //处理重复\n                    while(beg < end && nums[beg] == n1) beg++;\n                    while(beg < end && nums[end] == n2) end--;\n                }\n            }\n            //处理重复\n            while(i + 1 < nums.size()- 2 && nums[i + 1] == nums[i])\n                i++;\n        }\n\n        return ret;\n    }\n```\n","source":"_posts/3Sum.md","raw":"---\ntitle: 3Sum\ndate: 2017-09-20T12:00:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n# 3Sum\n\n觉得立个`flag`：从今天开始每天在LeetCode刷一道题,今天的是[3Sum](https://leetcode.com/problems/3sum/description/)\n\n题目：\n\n> Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\n> Note: The solution set must not contain duplicate triplets.\n\n> For example, given array S = [-1, 0, 1, 2, -1, -4],\n\n> A solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n这个题的坑点有几个：\n\n- 它要求的是不同的，但是如果处理的不好的话，是很容易出现相同的。\n- 第二个是他很容易写出一个O(n^3)的算法，但是好像是跑不过去的。\n\n接近的大概思路是：\n\n- 先对数组进行排序，这样比较好解决第一个坑点\n- 把他转换成2Sum去做\n\n```c++\nvector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int> > ret;\n        sort(nums.begin(),nums.end());      //先进行排序\n\n        for(int i = 0; i < nums.size() - 2;i++) {\n            int target = -nums[i];          //转换成求2Sum\n            if (target < 0) break;\n            int beg = i + 1;\n            int end = nums.size() - 1;\n            while(beg < end) {\n                int sum = nums[beg] + nums[end];\n                if (sum < target)\n                    beg++;\n                else if (sum > target)\n                    end--;\n                else {\n                    int n1 = nums[beg];\n                    int n2 = nums[end];\n                    ret.push_back( {nums[i],nums[beg],nums[end]} );\n                    //处理重复\n                    while(beg < end && nums[beg] == n1) beg++;\n                    while(beg < end && nums[end] == n2) end--;\n                }\n            }\n            //处理重复\n            while(i + 1 < nums.size()- 2 && nums[i + 1] == nums[i])\n                i++;\n        }\n\n        return ret;\n    }\n```\n","slug":"3Sum","published":1,"updated":"2021-03-10T13:47:05.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69m70000qmcm3ked11e6","content":"<h1 id=\"3Sum\"><a href=\"#3Sum\" class=\"headerlink\" title=\"3Sum\"></a>3Sum</h1><p>觉得立个<code>flag</code>：从今天开始每天在LeetCode刷一道题,今天的是<a href=\"https://leetcode.com/problems/3sum/description/\">3Sum</a></p>\n<p>题目：</p>\n<blockquote>\n<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n</blockquote>\n<blockquote>\n<p>Note: The solution set must not contain duplicate triplets.</p>\n</blockquote>\n<blockquote>\n<p>For example, given array S = [-1, 0, 1, 2, -1, -4],</p>\n</blockquote>\n<blockquote>\n<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>\n</blockquote>\n<p>这个题的坑点有几个：</p>\n<ul>\n<li>它要求的是不同的，但是如果处理的不好的话，是很容易出现相同的。</li>\n<li>第二个是他很容易写出一个O(n^3)的算法，但是好像是跑不过去的。</li>\n</ul>\n<p>接近的大概思路是：</p>\n<ul>\n<li>先对数组进行排序，这样比较好解决第一个坑点</li>\n<li>把他转换成2Sum去做</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\">        sort(nums.begin(),nums.end());      <span class=\"comment\">//先进行排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size() - <span class=\"number\">2</span>;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> target = -nums[i];          <span class=\"comment\">//转换成求2Sum</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &lt; <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> beg = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> end = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(beg &lt; end) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> sum = nums[beg] + nums[end];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum &lt; target)</span><br><span class=\"line\">                    beg++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; target)</span><br><span class=\"line\">                    end--;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> n1 = nums[beg];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> n2 = nums[end];</span><br><span class=\"line\">                    ret.push_back( &#123;nums[i],nums[beg],nums[end]&#125; );</span><br><span class=\"line\">                    <span class=\"comment\">//处理重复</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(beg &lt; end &amp;&amp; nums[beg] == n1) beg++;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(beg &lt; end &amp;&amp; nums[end] == n2) end--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//处理重复</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i + <span class=\"number\">1</span> &lt; nums.size()- <span class=\"number\">2</span> &amp;&amp; nums[i + <span class=\"number\">1</span>] == nums[i])</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"3Sum\"><a href=\"#3Sum\" class=\"headerlink\" title=\"3Sum\"></a>3Sum</h1><p>觉得立个<code>flag</code>：从今天开始每天在LeetCode刷一道题,今天的是<a href=\"https://leetcode.com/problems/3sum/description/\">3Sum</a></p>\n<p>题目：</p>\n<blockquote>\n<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n</blockquote>\n<blockquote>\n<p>Note: The solution set must not contain duplicate triplets.</p>\n</blockquote>\n<blockquote>\n<p>For example, given array S = [-1, 0, 1, 2, -1, -4],</p>\n</blockquote>\n<blockquote>\n<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>\n</blockquote>\n<p>这个题的坑点有几个：</p>\n<ul>\n<li>它要求的是不同的，但是如果处理的不好的话，是很容易出现相同的。</li>\n<li>第二个是他很容易写出一个O(n^3)的算法，但是好像是跑不过去的。</li>\n</ul>\n<p>接近的大概思路是：</p>\n<ul>\n<li>先对数组进行排序，这样比较好解决第一个坑点</li>\n<li>把他转换成2Sum去做</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\">        sort(nums.begin(),nums.end());      <span class=\"comment\">//先进行排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size() - <span class=\"number\">2</span>;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> target = -nums[i];          <span class=\"comment\">//转换成求2Sum</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &lt; <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> beg = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> end = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(beg &lt; end) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> sum = nums[beg] + nums[end];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum &lt; target)</span><br><span class=\"line\">                    beg++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; target)</span><br><span class=\"line\">                    end--;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> n1 = nums[beg];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> n2 = nums[end];</span><br><span class=\"line\">                    ret.push_back( &#123;nums[i],nums[beg],nums[end]&#125; );</span><br><span class=\"line\">                    <span class=\"comment\">//处理重复</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(beg &lt; end &amp;&amp; nums[beg] == n1) beg++;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(beg &lt; end &amp;&amp; nums[end] == n2) end--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//处理重复</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i + <span class=\"number\">1</span> &lt; nums.size()- <span class=\"number\">2</span> &amp;&amp; nums[i + <span class=\"number\">1</span>] == nums[i])</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"677. Map Sum Pairs","date":"2020-10-04T16:50:44.877Z","_content":"\n重新开始刷题的第1天。\n\n今天的题目是[677. Map Sum Pairs](https://leetcode-cn.com/problems/map-sum-pairs/)。\n\n一道前缀树相关的题目。\n\n一开始没看到题目中的“如果键已经存在，那么原来的键值对将被替代成新的键值对”。想当然的在实现插入时，直接增加值了。然后在第二个测例就错了。\n\n```c++\nclass TireNode {\npublic:\n    TireNode(int _value):child(256, nullptr), value(_value) {}\n\n    vector<TireNode *> child;\n    int value;\n};\n\nclass MapSum {\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {\n        root = new TireNode(0);\n    }\n    \n    void insert(string key, int val) {\n        TireNode *p = root;\n        for(int i = 0;i < key.size(); i++) {\n            int index = key[i];\n            if (p->child[index] == nullptr) {\n                p->child[index] = new TireNode(0);\n            }\n            p = p->child[index];\n            p->value += val;\n        }\n    }\n    \n    int sum(string prefix) {\n        TireNode *p = root;\n        for(int i = 0;i < prefix.size() && p != nullptr; i++) {\n            int index = prefix[i];\n            p = p->child[index];\n        }\n        return p == nullptr ? 0 : p->value;\n    }\n    TireNode *root;\n};\n```\n\n因为这里希望能够更新值，所以最简单的修改方式就是给`TireNode`增加一个`isLeaf`的属性来标识该节点是否是某个键的末尾，然后只有当`isLeaf == true`时，节点的`value`才是有意义的。这样修改的话，插入部分不需要做太多修改，但是前缀和的求解却需要递归遍历子树。\n\n```c++\nclass TireNode {\npublic:\n    TireNode(int _value = 0):child(256, nullptr), value(_value), isLeaf(false) {}\n\n    vector<TireNode *> child;\n    int value;\n    bool isLeaf;\n};\n\nclass MapSum {\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {\n        root = new TireNode(0);\n    }\n    \n    void insert(string key, int val) {\n        TireNode *p = root;\n        for(int i = 0;i < key.size(); i++) {\n            int index = key[i];\n            if (p->child[index] == nullptr) {\n                p->child[index] = new TireNode();\n            }\n            p = p->child[index];\n        }\n        p->value  = val;\n        p->isLeaf = true;\n    }\n    \n    int sum(string prefix) {\n        TireNode *p = root;\n        for(int i = 0;i < prefix.size() && p != nullptr; i++) {\n            int index = prefix[i];\n            p = p->child[index];\n        }\n        return p == nullptr ? 0 : sum(p);\n    }\n    int sum(TireNode *p) {\n        if (p == nullptr) return 0;\n        int res = p->isLeaf ? p->value : 0;\n        for(int i = 0;i < 256;i++) {\n            res += sum(p->child[i]);\n        }\n        return res;\n    }\n    TireNode *root;\n};\n```\n\n这样过是过了，但是速度贼慢，主要在于`sum`这里每次都需要重新求解。因此为了优化速度，我们给`TrieNode`结构增加一个`sum`属性，这个属性会在`insert`中维护，使其为该节点的前缀和。在维护`sum`属性的方式是通过在`insert`时，修改完末尾节点的`value`后，计算出新的`value`与旧的`value`（默认为0）的差值，然后向上更新。同时，为了加快速度和减少空间，这里还将`TireNode`的`child`从`vector`修改成`unordered_map`。\n\n```c++\nclass TireNode {\npublic:\n    TireNode(int _value = 0):value(_value), isLeaf(false), sum(0) {}\n\n    unordered_map<char, TireNode *> child;\n    int value, sum;\n    bool isLeaf;\n};\n\nclass MapSum {\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {\n        root = new TireNode(0);\n    }\n    \n    void insert(string key, int val) {\n        TireNode *p = root;\n        stack<TireNode*> st;\n        for(int i = 0;i < key.size(); i++) {\n            st.push(p);\n            char index = key[i];\n            if (p->child[index] == nullptr) {\n                p->child[index] = new TireNode();\n            }\n            p = p->child[index];\n        }\n        int diff = val - p->value;\n        while(!st.empty()) {\n            st.top()->sum += diff;\n            st.pop();\n        }\n        p->sum += diff;\n        p->value  = val;\n        p->isLeaf = true;\n    }\n    \n    int sum(string prefix) {\n        TireNode *p = root;\n        for(int i = 0;i < prefix.size() && p != nullptr; i++) {\n            char index = prefix[i];\n            p = p->child[index];\n        }\n        return p == nullptr ? 0 : p->sum;\n    }\n    int sum(TireNode *p) {\n        if (p == nullptr) return 0;\n        int res = p->isLeaf ? p->value : 0;\n        for(auto &pair: p->child) {\n            res += sum(pair.second);\n        }\n        return res;\n    }\n    TireNode *root;\n};\n```","source":"_posts/677.Map-Sum-Pairs.md","raw":"---\ntitle: 677. Map Sum Pairs\ndate: 2020-10-05T00:50:44.877Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tires\n---\n\n重新开始刷题的第1天。\n\n今天的题目是[677. Map Sum Pairs](https://leetcode-cn.com/problems/map-sum-pairs/)。\n\n一道前缀树相关的题目。\n\n一开始没看到题目中的“如果键已经存在，那么原来的键值对将被替代成新的键值对”。想当然的在实现插入时，直接增加值了。然后在第二个测例就错了。\n\n```c++\nclass TireNode {\npublic:\n    TireNode(int _value):child(256, nullptr), value(_value) {}\n\n    vector<TireNode *> child;\n    int value;\n};\n\nclass MapSum {\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {\n        root = new TireNode(0);\n    }\n    \n    void insert(string key, int val) {\n        TireNode *p = root;\n        for(int i = 0;i < key.size(); i++) {\n            int index = key[i];\n            if (p->child[index] == nullptr) {\n                p->child[index] = new TireNode(0);\n            }\n            p = p->child[index];\n            p->value += val;\n        }\n    }\n    \n    int sum(string prefix) {\n        TireNode *p = root;\n        for(int i = 0;i < prefix.size() && p != nullptr; i++) {\n            int index = prefix[i];\n            p = p->child[index];\n        }\n        return p == nullptr ? 0 : p->value;\n    }\n    TireNode *root;\n};\n```\n\n因为这里希望能够更新值，所以最简单的修改方式就是给`TireNode`增加一个`isLeaf`的属性来标识该节点是否是某个键的末尾，然后只有当`isLeaf == true`时，节点的`value`才是有意义的。这样修改的话，插入部分不需要做太多修改，但是前缀和的求解却需要递归遍历子树。\n\n```c++\nclass TireNode {\npublic:\n    TireNode(int _value = 0):child(256, nullptr), value(_value), isLeaf(false) {}\n\n    vector<TireNode *> child;\n    int value;\n    bool isLeaf;\n};\n\nclass MapSum {\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {\n        root = new TireNode(0);\n    }\n    \n    void insert(string key, int val) {\n        TireNode *p = root;\n        for(int i = 0;i < key.size(); i++) {\n            int index = key[i];\n            if (p->child[index] == nullptr) {\n                p->child[index] = new TireNode();\n            }\n            p = p->child[index];\n        }\n        p->value  = val;\n        p->isLeaf = true;\n    }\n    \n    int sum(string prefix) {\n        TireNode *p = root;\n        for(int i = 0;i < prefix.size() && p != nullptr; i++) {\n            int index = prefix[i];\n            p = p->child[index];\n        }\n        return p == nullptr ? 0 : sum(p);\n    }\n    int sum(TireNode *p) {\n        if (p == nullptr) return 0;\n        int res = p->isLeaf ? p->value : 0;\n        for(int i = 0;i < 256;i++) {\n            res += sum(p->child[i]);\n        }\n        return res;\n    }\n    TireNode *root;\n};\n```\n\n这样过是过了，但是速度贼慢，主要在于`sum`这里每次都需要重新求解。因此为了优化速度，我们给`TrieNode`结构增加一个`sum`属性，这个属性会在`insert`中维护，使其为该节点的前缀和。在维护`sum`属性的方式是通过在`insert`时，修改完末尾节点的`value`后，计算出新的`value`与旧的`value`（默认为0）的差值，然后向上更新。同时，为了加快速度和减少空间，这里还将`TireNode`的`child`从`vector`修改成`unordered_map`。\n\n```c++\nclass TireNode {\npublic:\n    TireNode(int _value = 0):value(_value), isLeaf(false), sum(0) {}\n\n    unordered_map<char, TireNode *> child;\n    int value, sum;\n    bool isLeaf;\n};\n\nclass MapSum {\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {\n        root = new TireNode(0);\n    }\n    \n    void insert(string key, int val) {\n        TireNode *p = root;\n        stack<TireNode*> st;\n        for(int i = 0;i < key.size(); i++) {\n            st.push(p);\n            char index = key[i];\n            if (p->child[index] == nullptr) {\n                p->child[index] = new TireNode();\n            }\n            p = p->child[index];\n        }\n        int diff = val - p->value;\n        while(!st.empty()) {\n            st.top()->sum += diff;\n            st.pop();\n        }\n        p->sum += diff;\n        p->value  = val;\n        p->isLeaf = true;\n    }\n    \n    int sum(string prefix) {\n        TireNode *p = root;\n        for(int i = 0;i < prefix.size() && p != nullptr; i++) {\n            char index = prefix[i];\n            p = p->child[index];\n        }\n        return p == nullptr ? 0 : p->sum;\n    }\n    int sum(TireNode *p) {\n        if (p == nullptr) return 0;\n        int res = p->isLeaf ? p->value : 0;\n        for(auto &pair: p->child) {\n            res += sum(pair.second);\n        }\n        return res;\n    }\n    TireNode *root;\n};\n```","slug":"677.Map-Sum-Pairs","published":1,"updated":"2021-03-10T13:47:05.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mb0001qmcm9nfgdu8q","content":"<p>重新开始刷题的第1天。</p>\n<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/map-sum-pairs/\">677. Map Sum Pairs</a>。</p>\n<p>一道前缀树相关的题目。</p>\n<p>一开始没看到题目中的“如果键已经存在，那么原来的键值对将被替代成新的键值对”。想当然的在实现插入时，直接增加值了。然后在第二个测例就错了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TireNode</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TireNode(<span class=\"keyword\">int</span> _value):child(<span class=\"number\">256</span>, <span class=\"literal\">nullptr</span>), value(_value) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TireNode *&gt; child;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapSum</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MapSum() &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TireNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"built_in\">string</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; key.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = key[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;child[index] == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                p-&gt;child[index] = <span class=\"keyword\">new</span> TireNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">            p-&gt;value += val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"built_in\">string</span> prefix)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; prefix.size() &amp;&amp; p != <span class=\"literal\">nullptr</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = prefix[i];</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : p-&gt;value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    TireNode *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>因为这里希望能够更新值，所以最简单的修改方式就是给<code>TireNode</code>增加一个<code>isLeaf</code>的属性来标识该节点是否是某个键的末尾，然后只有当<code>isLeaf == true</code>时，节点的<code>value</code>才是有意义的。这样修改的话，插入部分不需要做太多修改，但是前缀和的求解却需要递归遍历子树。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TireNode</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TireNode(<span class=\"keyword\">int</span> _value = <span class=\"number\">0</span>):child(<span class=\"number\">256</span>, <span class=\"literal\">nullptr</span>), value(_value), isLeaf(<span class=\"literal\">false</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TireNode *&gt; child;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isLeaf;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapSum</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MapSum() &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TireNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"built_in\">string</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; key.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = key[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;child[index] == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                p-&gt;child[index] = <span class=\"keyword\">new</span> TireNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;value  = val;</span><br><span class=\"line\">        p-&gt;isLeaf = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"built_in\">string</span> prefix)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; prefix.size() &amp;&amp; p != <span class=\"literal\">nullptr</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = prefix[i];</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : sum(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(TireNode *p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = p-&gt;isLeaf ? p-&gt;value : <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">256</span>;i++) &#123;</span><br><span class=\"line\">            res += sum(p-&gt;child[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    TireNode *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这样过是过了，但是速度贼慢，主要在于<code>sum</code>这里每次都需要重新求解。因此为了优化速度，我们给<code>TrieNode</code>结构增加一个<code>sum</code>属性，这个属性会在<code>insert</code>中维护，使其为该节点的前缀和。在维护<code>sum</code>属性的方式是通过在<code>insert</code>时，修改完末尾节点的<code>value</code>后，计算出新的<code>value</code>与旧的<code>value</code>（默认为0）的差值，然后向上更新。同时，为了加快速度和减少空间，这里还将<code>TireNode</code>的<code>child</code>从<code>vector</code>修改成<code>unordered_map</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TireNode</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TireNode(<span class=\"keyword\">int</span> _value = <span class=\"number\">0</span>):value(_value), isLeaf(<span class=\"literal\">false</span>), sum(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, TireNode *&gt; child;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value, sum;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isLeaf;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapSum</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MapSum() &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TireNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"built_in\">string</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TireNode*&gt; st;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; key.size(); i++) &#123;</span><br><span class=\"line\">            st.push(p);</span><br><span class=\"line\">            <span class=\"keyword\">char</span> index = key[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;child[index] == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                p-&gt;child[index] = <span class=\"keyword\">new</span> TireNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> diff = val - p-&gt;value;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">            st.top()-&gt;sum += diff;</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;sum += diff;</span><br><span class=\"line\">        p-&gt;value  = val;</span><br><span class=\"line\">        p-&gt;isLeaf = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"built_in\">string</span> prefix)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; prefix.size() &amp;&amp; p != <span class=\"literal\">nullptr</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> index = prefix[i];</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : p-&gt;sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(TireNode *p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = p-&gt;isLeaf ? p-&gt;value : <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;<span class=\"built_in\">pair</span>: p-&gt;child) &#123;</span><br><span class=\"line\">            res += sum(<span class=\"built_in\">pair</span>.second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    TireNode *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>重新开始刷题的第1天。</p>\n<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/map-sum-pairs/\">677. Map Sum Pairs</a>。</p>\n<p>一道前缀树相关的题目。</p>\n<p>一开始没看到题目中的“如果键已经存在，那么原来的键值对将被替代成新的键值对”。想当然的在实现插入时，直接增加值了。然后在第二个测例就错了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TireNode</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TireNode(<span class=\"keyword\">int</span> _value):child(<span class=\"number\">256</span>, <span class=\"literal\">nullptr</span>), value(_value) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TireNode *&gt; child;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapSum</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MapSum() &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TireNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"built_in\">string</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; key.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = key[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;child[index] == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                p-&gt;child[index] = <span class=\"keyword\">new</span> TireNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">            p-&gt;value += val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"built_in\">string</span> prefix)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; prefix.size() &amp;&amp; p != <span class=\"literal\">nullptr</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = prefix[i];</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : p-&gt;value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    TireNode *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>因为这里希望能够更新值，所以最简单的修改方式就是给<code>TireNode</code>增加一个<code>isLeaf</code>的属性来标识该节点是否是某个键的末尾，然后只有当<code>isLeaf == true</code>时，节点的<code>value</code>才是有意义的。这样修改的话，插入部分不需要做太多修改，但是前缀和的求解却需要递归遍历子树。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TireNode</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TireNode(<span class=\"keyword\">int</span> _value = <span class=\"number\">0</span>):child(<span class=\"number\">256</span>, <span class=\"literal\">nullptr</span>), value(_value), isLeaf(<span class=\"literal\">false</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TireNode *&gt; child;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isLeaf;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapSum</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MapSum() &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TireNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"built_in\">string</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; key.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = key[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;child[index] == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                p-&gt;child[index] = <span class=\"keyword\">new</span> TireNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;value  = val;</span><br><span class=\"line\">        p-&gt;isLeaf = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"built_in\">string</span> prefix)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; prefix.size() &amp;&amp; p != <span class=\"literal\">nullptr</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = prefix[i];</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : sum(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(TireNode *p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = p-&gt;isLeaf ? p-&gt;value : <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">256</span>;i++) &#123;</span><br><span class=\"line\">            res += sum(p-&gt;child[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    TireNode *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这样过是过了，但是速度贼慢，主要在于<code>sum</code>这里每次都需要重新求解。因此为了优化速度，我们给<code>TrieNode</code>结构增加一个<code>sum</code>属性，这个属性会在<code>insert</code>中维护，使其为该节点的前缀和。在维护<code>sum</code>属性的方式是通过在<code>insert</code>时，修改完末尾节点的<code>value</code>后，计算出新的<code>value</code>与旧的<code>value</code>（默认为0）的差值，然后向上更新。同时，为了加快速度和减少空间，这里还将<code>TireNode</code>的<code>child</code>从<code>vector</code>修改成<code>unordered_map</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TireNode</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TireNode(<span class=\"keyword\">int</span> _value = <span class=\"number\">0</span>):value(_value), isLeaf(<span class=\"literal\">false</span>), sum(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, TireNode *&gt; child;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value, sum;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isLeaf;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapSum</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MapSum() &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TireNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"built_in\">string</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TireNode*&gt; st;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; key.size(); i++) &#123;</span><br><span class=\"line\">            st.push(p);</span><br><span class=\"line\">            <span class=\"keyword\">char</span> index = key[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;child[index] == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                p-&gt;child[index] = <span class=\"keyword\">new</span> TireNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> diff = val - p-&gt;value;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">            st.top()-&gt;sum += diff;</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;sum += diff;</span><br><span class=\"line\">        p-&gt;value  = val;</span><br><span class=\"line\">        p-&gt;isLeaf = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"built_in\">string</span> prefix)</span> </span>&#123;</span><br><span class=\"line\">        TireNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; prefix.size() &amp;&amp; p != <span class=\"literal\">nullptr</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> index = prefix[i];</span><br><span class=\"line\">            p = p-&gt;child[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : p-&gt;sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(TireNode *p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = p-&gt;isLeaf ? p-&gt;value : <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;<span class=\"built_in\">pair</span>: p-&gt;child) &#123;</span><br><span class=\"line\">            res += sum(<span class=\"built_in\">pair</span>.second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    TireNode *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"4Sum_2","date":"2017-10-04T02:59:17.000Z","_content":"\n打卡,第11天。\n\n今天刷的题是[4Sum II](https://leetcode.com/problems/4sum-ii/description/),\n\n> Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\n>\n>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.\n>\n> Example:\n>\n> Input:A = [ 1, 2]\n> B = [-2,-1]\n> C = [-1, 2]\n> D = [ 0, 2]\n> Output:\n> 2\n> \n> Explanation:\n>\n> The two tuples are:\n>\n> (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n>\n> (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n\n这道题如果贼容易写出一个时间超限的题目，比如简单的四重循环。\n\n一开始老是会出现时间超限的情况，想着要把时间复杂度将下来，就想着把他转换成2Sum去做，于是就用就先把`A`和`B`的和放在一个`vector`中，同理也把`C`和`D`的和放在一个`vector`中。天真的以为这样就可以把时间复杂度降下来了。。。然而这两个vector的大小分别是`A.size()*B.size()`和`C.size()*D.size()`,然后一直没想出来怎么搞，突然想起来昨天在《像程序员一样思考》中看到的**削减问题**的方法，就开始考虑两个数组的的情况。\n\n显然如果不对数组进行排序的话，肯定是要用两个循环对所有元素遍历的，然后就考虑如果数组是排好序的话，要怎么才能减少一些不必要的遍历，如果一个较小的数一定需要一个较大的数才能使得和为0，所以一个数组从前向后遍历，一个数组从后向前进行遍历。因为数组已经有序了，所以第一个数组越前面的元素（越小）就需要第二个数组越后面的的元素（越大），可以找到一下规律：\n\n- sum > 0 -> j--\n- sum < 0 -> i++\n- sum == 0 -> count++;j--,i++\n\n当然如果直接这样写的话可能会漏掉一些重复元素，所以还需要一些修改,但是大体的思路已经出来了，所以直接上代码把：\n\n```c++\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\n    int count = 0;\n    vector<int> v1 (A.size()*B.size() ), v2(C.size()*D.size());\n    int k = 0;\n    for(auto c:C)\n        for(auto d:D)\n            v2[k++] = c+d;\n    k = 0;\n    for(auto a:A)\n        for(auto b:B)\n            v1[k++] = a+b;\n    sort(v1.begin(),v1.end());\n    sort(v2.begin(),v2.end());\n    int i = 0,j = v2.size() - 1;\n    int sum;\n    while(i < v1.size() && j >= 0){\n        sum = v1[i] + v2[j];\n        if (sum > 0)\n            j--;\n        else if (sum < 0)\n            i++;\n        else {\n            int k1 = 1,k2 = 1;\n            //处理重复元素的情况\n            while(i + 1< v1.size() && v1[i + 1 ] == v1[i]){ k1++; i++; }\n            while(j > 0 && v2[j-1] == v2[j]) { k2++; j--; }\n            i++;\n            j--;\n            count += k1*k2;\n        }\n    }\n    return count;\n}\n```\n\n然后是看看`dicuss`中别人的解法：\n\n```c++\n int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\n    unordered_map<int, int>  abSum;\n    for(auto a : A) {\n        for(auto b : B) {\n            ++abSum[a+b];\n        }\n    }\n    int count = 0;\n    for(auto c : C) {\n        for(auto d : D) {\n            auto it = abSum.find(0 - c - d);\n            if(it != abSum.end()) {\n                count += it->second;\n            }\n        }\n    }\n    return count;\n}\n```\n\n他使用`unordered_map`来完成的耶,在c++的STL中，`map`是用的红黑树，`find`的时间复杂度是`O(nlogn)`,而`unordered_map`是`hash table`,所以`find`的时间复杂度是`O(1)`，突然发现一个好用的东西。。。\n\n---\n貌似今天是中秋，恩，中秋快乐！！\n\n可惜喉咙发炎没法吃月饼。。。\n","source":"_posts/4Sum-2.md","raw":"---\ntitle: 4Sum_2\ndate: 2017-10-04T10:59:17.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n打卡,第11天。\n\n今天刷的题是[4Sum II](https://leetcode.com/problems/4sum-ii/description/),\n\n> Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\n>\n>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.\n>\n> Example:\n>\n> Input:A = [ 1, 2]\n> B = [-2,-1]\n> C = [-1, 2]\n> D = [ 0, 2]\n> Output:\n> 2\n> \n> Explanation:\n>\n> The two tuples are:\n>\n> (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n>\n> (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n\n这道题如果贼容易写出一个时间超限的题目，比如简单的四重循环。\n\n一开始老是会出现时间超限的情况，想着要把时间复杂度将下来，就想着把他转换成2Sum去做，于是就用就先把`A`和`B`的和放在一个`vector`中，同理也把`C`和`D`的和放在一个`vector`中。天真的以为这样就可以把时间复杂度降下来了。。。然而这两个vector的大小分别是`A.size()*B.size()`和`C.size()*D.size()`,然后一直没想出来怎么搞，突然想起来昨天在《像程序员一样思考》中看到的**削减问题**的方法，就开始考虑两个数组的的情况。\n\n显然如果不对数组进行排序的话，肯定是要用两个循环对所有元素遍历的，然后就考虑如果数组是排好序的话，要怎么才能减少一些不必要的遍历，如果一个较小的数一定需要一个较大的数才能使得和为0，所以一个数组从前向后遍历，一个数组从后向前进行遍历。因为数组已经有序了，所以第一个数组越前面的元素（越小）就需要第二个数组越后面的的元素（越大），可以找到一下规律：\n\n- sum > 0 -> j--\n- sum < 0 -> i++\n- sum == 0 -> count++;j--,i++\n\n当然如果直接这样写的话可能会漏掉一些重复元素，所以还需要一些修改,但是大体的思路已经出来了，所以直接上代码把：\n\n```c++\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\n    int count = 0;\n    vector<int> v1 (A.size()*B.size() ), v2(C.size()*D.size());\n    int k = 0;\n    for(auto c:C)\n        for(auto d:D)\n            v2[k++] = c+d;\n    k = 0;\n    for(auto a:A)\n        for(auto b:B)\n            v1[k++] = a+b;\n    sort(v1.begin(),v1.end());\n    sort(v2.begin(),v2.end());\n    int i = 0,j = v2.size() - 1;\n    int sum;\n    while(i < v1.size() && j >= 0){\n        sum = v1[i] + v2[j];\n        if (sum > 0)\n            j--;\n        else if (sum < 0)\n            i++;\n        else {\n            int k1 = 1,k2 = 1;\n            //处理重复元素的情况\n            while(i + 1< v1.size() && v1[i + 1 ] == v1[i]){ k1++; i++; }\n            while(j > 0 && v2[j-1] == v2[j]) { k2++; j--; }\n            i++;\n            j--;\n            count += k1*k2;\n        }\n    }\n    return count;\n}\n```\n\n然后是看看`dicuss`中别人的解法：\n\n```c++\n int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\n    unordered_map<int, int>  abSum;\n    for(auto a : A) {\n        for(auto b : B) {\n            ++abSum[a+b];\n        }\n    }\n    int count = 0;\n    for(auto c : C) {\n        for(auto d : D) {\n            auto it = abSum.find(0 - c - d);\n            if(it != abSum.end()) {\n                count += it->second;\n            }\n        }\n    }\n    return count;\n}\n```\n\n他使用`unordered_map`来完成的耶,在c++的STL中，`map`是用的红黑树，`find`的时间复杂度是`O(nlogn)`,而`unordered_map`是`hash table`,所以`find`的时间复杂度是`O(1)`，突然发现一个好用的东西。。。\n\n---\n貌似今天是中秋，恩，中秋快乐！！\n\n可惜喉咙发炎没法吃月饼。。。\n","slug":"4Sum-2","published":1,"updated":"2021-03-10T13:47:05.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69me0004qmcmb3tx8g6s","content":"<p>打卡,第11天。</p>\n<p>今天刷的题是<a href=\"https://leetcode.com/problems/4sum-ii/description/\">4Sum II</a>,</p>\n<blockquote>\n<p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p>\n<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.</p>\n<p>Example:</p>\n<p>Input:A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2]<br>Output:<br>2</p>\n<p>Explanation:</p>\n<p>The two tuples are:</p>\n<p>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</p>\n<p>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</p>\n</blockquote>\n<p>这道题如果贼容易写出一个时间超限的题目，比如简单的四重循环。</p>\n<p>一开始老是会出现时间超限的情况，想着要把时间复杂度将下来，就想着把他转换成2Sum去做，于是就用就先把<code>A</code>和<code>B</code>的和放在一个<code>vector</code>中，同理也把<code>C</code>和<code>D</code>的和放在一个<code>vector</code>中。天真的以为这样就可以把时间复杂度降下来了。。。然而这两个vector的大小分别是<code>A.size()*B.size()</code>和<code>C.size()*D.size()</code>,然后一直没想出来怎么搞，突然想起来昨天在《像程序员一样思考》中看到的<strong>削减问题</strong>的方法，就开始考虑两个数组的的情况。</p>\n<p>显然如果不对数组进行排序的话，肯定是要用两个循环对所有元素遍历的，然后就考虑如果数组是排好序的话，要怎么才能减少一些不必要的遍历，如果一个较小的数一定需要一个较大的数才能使得和为0，所以一个数组从前向后遍历，一个数组从后向前进行遍历。因为数组已经有序了，所以第一个数组越前面的元素（越小）就需要第二个数组越后面的的元素（越大），可以找到一下规律：</p>\n<ul>\n<li>sum &gt; 0 -&gt; j–</li>\n<li>sum &lt; 0 -&gt; i++</li>\n<li>sum == 0 -&gt; count++;j–,i++</li>\n</ul>\n<p>当然如果直接这样写的话可能会漏掉一些重复元素，所以还需要一些修改,但是大体的思路已经出来了，所以直接上代码把：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; C, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vector&lt;int&gt; v1 (A.size()*B.size() ), v2(C.size()*D.size());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:C)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> d:D)</span><br><span class=\"line\">            v2[k++] = c+d;</span><br><span class=\"line\">    k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a:A)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> b:B)</span><br><span class=\"line\">            v1[k++] = a+b;</span><br><span class=\"line\">    sort(v1.begin(),v1.end());</span><br><span class=\"line\">    sort(v2.begin(),v2.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = v2.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; v1.size() &amp;&amp; j &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        sum = v1[i] + v2[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k1 = <span class=\"number\">1</span>,k2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">//处理重复元素的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i + <span class=\"number\">1</span>&lt; v1.size() &amp;&amp; v1[i + <span class=\"number\">1</span> ] == v1[i])&#123; k1++; i++; &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; v2[j<span class=\"number\">-1</span>] == v2[j]) &#123; k2++; j--; &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">            count += k1*k2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是看看<code>dicuss</code>中别人的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; C, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;  abSum;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a : A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> b : B) &#123;</span><br><span class=\"line\">            ++abSum[a+b];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c : C) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> d : D) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> it = abSum.find(<span class=\"number\">0</span> - c - d);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it != abSum.end()) &#123;</span><br><span class=\"line\">                count += it-&gt;second;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>他使用<code>unordered_map</code>来完成的耶,在c++的STL中，<code>map</code>是用的红黑树，<code>find</code>的时间复杂度是<code>O(nlogn)</code>,而<code>unordered_map</code>是<code>hash table</code>,所以<code>find</code>的时间复杂度是<code>O(1)</code>，突然发现一个好用的东西。。。</p>\n<hr>\n<p>貌似今天是中秋，恩，中秋快乐！！</p>\n<p>可惜喉咙发炎没法吃月饼。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡,第11天。</p>\n<p>今天刷的题是<a href=\"https://leetcode.com/problems/4sum-ii/description/\">4Sum II</a>,</p>\n<blockquote>\n<p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p>\n<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.</p>\n<p>Example:</p>\n<p>Input:A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2]<br>Output:<br>2</p>\n<p>Explanation:</p>\n<p>The two tuples are:</p>\n<p>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</p>\n<p>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</p>\n</blockquote>\n<p>这道题如果贼容易写出一个时间超限的题目，比如简单的四重循环。</p>\n<p>一开始老是会出现时间超限的情况，想着要把时间复杂度将下来，就想着把他转换成2Sum去做，于是就用就先把<code>A</code>和<code>B</code>的和放在一个<code>vector</code>中，同理也把<code>C</code>和<code>D</code>的和放在一个<code>vector</code>中。天真的以为这样就可以把时间复杂度降下来了。。。然而这两个vector的大小分别是<code>A.size()*B.size()</code>和<code>C.size()*D.size()</code>,然后一直没想出来怎么搞，突然想起来昨天在《像程序员一样思考》中看到的<strong>削减问题</strong>的方法，就开始考虑两个数组的的情况。</p>\n<p>显然如果不对数组进行排序的话，肯定是要用两个循环对所有元素遍历的，然后就考虑如果数组是排好序的话，要怎么才能减少一些不必要的遍历，如果一个较小的数一定需要一个较大的数才能使得和为0，所以一个数组从前向后遍历，一个数组从后向前进行遍历。因为数组已经有序了，所以第一个数组越前面的元素（越小）就需要第二个数组越后面的的元素（越大），可以找到一下规律：</p>\n<ul>\n<li>sum &gt; 0 -&gt; j–</li>\n<li>sum &lt; 0 -&gt; i++</li>\n<li>sum == 0 -&gt; count++;j–,i++</li>\n</ul>\n<p>当然如果直接这样写的话可能会漏掉一些重复元素，所以还需要一些修改,但是大体的思路已经出来了，所以直接上代码把：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; C, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vector&lt;int&gt; v1 (A.size()*B.size() ), v2(C.size()*D.size());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:C)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> d:D)</span><br><span class=\"line\">            v2[k++] = c+d;</span><br><span class=\"line\">    k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a:A)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> b:B)</span><br><span class=\"line\">            v1[k++] = a+b;</span><br><span class=\"line\">    sort(v1.begin(),v1.end());</span><br><span class=\"line\">    sort(v2.begin(),v2.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = v2.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; v1.size() &amp;&amp; j &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        sum = v1[i] + v2[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k1 = <span class=\"number\">1</span>,k2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">//处理重复元素的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i + <span class=\"number\">1</span>&lt; v1.size() &amp;&amp; v1[i + <span class=\"number\">1</span> ] == v1[i])&#123; k1++; i++; &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; v2[j<span class=\"number\">-1</span>] == v2[j]) &#123; k2++; j--; &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">            count += k1*k2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是看看<code>dicuss</code>中别人的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; C, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;  abSum;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a : A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> b : B) &#123;</span><br><span class=\"line\">            ++abSum[a+b];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c : C) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> d : D) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> it = abSum.find(<span class=\"number\">0</span> - c - d);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it != abSum.end()) &#123;</span><br><span class=\"line\">                count += it-&gt;second;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>他使用<code>unordered_map</code>来完成的耶,在c++的STL中，<code>map</code>是用的红黑树，<code>find</code>的时间复杂度是<code>O(nlogn)</code>,而<code>unordered_map</code>是<code>hash table</code>,所以<code>find</code>的时间复杂度是<code>O(1)</code>，突然发现一个好用的东西。。。</p>\n<hr>\n<p>貌似今天是中秋，恩，中秋快乐！！</p>\n<p>可惜喉咙发炎没法吃月饼。。。</p>\n"},{"title":"Add and Search Word - Data structure design","date":"2019-12-05T04:48:24.000Z","_content":"\n> 第29天。\n\n今天的题目是[Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/):\n\n一道字典树的题目，如果知道字典树是怎样的话，应该不难做。不过这道题直接套字典树是不行的，因为它需要支持 `.` 字符来标识任意字符，所以我们在Search的时候需要做一定的修改。\n简单的来说就是原本用一个指针进行搜索，现在需要一个队列来维护多个指针进行搜索，恩，仅此而已。代码如下：\n\n```c++\nclass TrieNode{\n    \npublic:\n    char c;\n    vector<TrieNode*> childs;\n    bool flag;\n    TrieNode(char _c):c(_c),childs(26, nullptr),flag(false) {\n    }\n    TrieNode *addChild(char c) {\n        if (childs[c - 'a']) return childs[c - 'a'];\n        else return childs[c - 'a'] = new TrieNode(c);\n    }\n};\n\nclass WordDictionary {\n    TrieNode *root;\npublic:\n    /** Initialize your data structure here. */\n    WordDictionary():root(new TrieNode('?')) {\n        \n    }\n    \n    /** Adds a word into the data structure. */\n    void addWord(string word) {\n        //cout << \"Add \" << word << endl;\n        TrieNode *p = root;\n        for(auto c: word) {\n            p = p->addChild(c);\n        }\n        p->flag = true;\n    }\n    \n    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */\n    bool search(string word) {\n        // cout << \"Search \" << word << endl;\n        queue<TrieNode *> q;\n        q.push(root);\n        for(auto c: word) {\n            if (q.empty()) return false;\n            // cout << c << \" \";\n            if (c == '.') {\n                for(int i = 0,size = q.size();i < size; i++) {\n                    TrieNode *p = q.front(); q.pop();\n                    for(int j = 0;j < 26;j++) {\n                        if (p->childs[j]) q.push(p->childs[j]);\n                    }\n                }\n            } else {\n                for(int i = 0,size = q.size();i < size; i++) {\n                    TrieNode *p = q.front(); q.pop();\n                    if (p->childs[c - 'a']) q.push(p->childs[c - 'a']);\n                }\n            }\n        }\n        while(!q.empty()) {\n            if (q.front()->flag) return true;\n            q.pop();\n        }\n        return false;\n    }\n};\n```\n","source":"_posts/Add-and-Search-Word-Data-structure-design.md","raw":"---\ntitle: Add and Search Word - Data structure design\ndate: 2019-12-05T12:48:24.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第29天。\n\n今天的题目是[Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/):\n\n一道字典树的题目，如果知道字典树是怎样的话，应该不难做。不过这道题直接套字典树是不行的，因为它需要支持 `.` 字符来标识任意字符，所以我们在Search的时候需要做一定的修改。\n简单的来说就是原本用一个指针进行搜索，现在需要一个队列来维护多个指针进行搜索，恩，仅此而已。代码如下：\n\n```c++\nclass TrieNode{\n    \npublic:\n    char c;\n    vector<TrieNode*> childs;\n    bool flag;\n    TrieNode(char _c):c(_c),childs(26, nullptr),flag(false) {\n    }\n    TrieNode *addChild(char c) {\n        if (childs[c - 'a']) return childs[c - 'a'];\n        else return childs[c - 'a'] = new TrieNode(c);\n    }\n};\n\nclass WordDictionary {\n    TrieNode *root;\npublic:\n    /** Initialize your data structure here. */\n    WordDictionary():root(new TrieNode('?')) {\n        \n    }\n    \n    /** Adds a word into the data structure. */\n    void addWord(string word) {\n        //cout << \"Add \" << word << endl;\n        TrieNode *p = root;\n        for(auto c: word) {\n            p = p->addChild(c);\n        }\n        p->flag = true;\n    }\n    \n    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */\n    bool search(string word) {\n        // cout << \"Search \" << word << endl;\n        queue<TrieNode *> q;\n        q.push(root);\n        for(auto c: word) {\n            if (q.empty()) return false;\n            // cout << c << \" \";\n            if (c == '.') {\n                for(int i = 0,size = q.size();i < size; i++) {\n                    TrieNode *p = q.front(); q.pop();\n                    for(int j = 0;j < 26;j++) {\n                        if (p->childs[j]) q.push(p->childs[j]);\n                    }\n                }\n            } else {\n                for(int i = 0,size = q.size();i < size; i++) {\n                    TrieNode *p = q.front(); q.pop();\n                    if (p->childs[c - 'a']) q.push(p->childs[c - 'a']);\n                }\n            }\n        }\n        while(!q.empty()) {\n            if (q.front()->flag) return true;\n            q.pop();\n        }\n        return false;\n    }\n};\n```\n","slug":"Add-and-Search-Word-Data-structure-design","published":1,"updated":"2021-03-10T13:47:05.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mf0005qmcm5uatff51","content":"<blockquote>\n<p>第29天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/add-and-search-word-data-structure-design/\">Add and Search Word - Data structure design</a>:</p>\n<p>一道字典树的题目，如果知道字典树是怎样的话，应该不难做。不过这道题直接套字典树是不行的，因为它需要支持 <code>.</code> 字符来标识任意字符，所以我们在Search的时候需要做一定的修改。<br>简单的来说就是原本用一个指针进行搜索，现在需要一个队列来维护多个指针进行搜索，恩，仅此而已。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span>&#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TrieNode*&gt; childs;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\">    TrieNode(<span class=\"keyword\">char</span> _c):c(_c),childs(<span class=\"number\">26</span>, <span class=\"literal\">nullptr</span>),flag(<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TrieNode *<span class=\"title\">addChild</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childs[c - <span class=\"string\">&#x27;a&#x27;</span>]) <span class=\"keyword\">return</span> childs[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> childs[c - <span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"keyword\">new</span> TrieNode(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordDictionary</span> &#123;</span></span><br><span class=\"line\">    TrieNode *root;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    WordDictionary():root(<span class=\"keyword\">new</span> TrieNode(<span class=\"string\">&#x27;?&#x27;</span>)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Adds a word into the data structure. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addWord</span><span class=\"params\">(<span class=\"built_in\">string</span> word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; &quot;Add &quot; &lt;&lt; word &lt;&lt; endl;</span></span><br><span class=\"line\">        TrieNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c: word) &#123;</span><br><span class=\"line\">            p = p-&gt;addChild(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">string</span> word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; &quot;Search &quot; &lt;&lt; word &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TrieNode *&gt; q;</span><br><span class=\"line\">        q.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c: word) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; c &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,size = q.size();i &lt; size; i++) &#123;</span><br><span class=\"line\">                    TrieNode *p = q.front(); q.pop();</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; <span class=\"number\">26</span>;j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (p-&gt;childs[j]) q.push(p-&gt;childs[j]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,size = q.size();i &lt; size; i++) &#123;</span><br><span class=\"line\">                    TrieNode *p = q.front(); q.pop();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p-&gt;childs[c - <span class=\"string\">&#x27;a&#x27;</span>]) q.push(p-&gt;childs[c - <span class=\"string\">&#x27;a&#x27;</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q.front()-&gt;flag) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第29天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/add-and-search-word-data-structure-design/\">Add and Search Word - Data structure design</a>:</p>\n<p>一道字典树的题目，如果知道字典树是怎样的话，应该不难做。不过这道题直接套字典树是不行的，因为它需要支持 <code>.</code> 字符来标识任意字符，所以我们在Search的时候需要做一定的修改。<br>简单的来说就是原本用一个指针进行搜索，现在需要一个队列来维护多个指针进行搜索，恩，仅此而已。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span>&#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TrieNode*&gt; childs;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\">    TrieNode(<span class=\"keyword\">char</span> _c):c(_c),childs(<span class=\"number\">26</span>, <span class=\"literal\">nullptr</span>),flag(<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TrieNode *<span class=\"title\">addChild</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childs[c - <span class=\"string\">&#x27;a&#x27;</span>]) <span class=\"keyword\">return</span> childs[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> childs[c - <span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"keyword\">new</span> TrieNode(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordDictionary</span> &#123;</span></span><br><span class=\"line\">    TrieNode *root;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    WordDictionary():root(<span class=\"keyword\">new</span> TrieNode(<span class=\"string\">&#x27;?&#x27;</span>)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Adds a word into the data structure. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addWord</span><span class=\"params\">(<span class=\"built_in\">string</span> word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; &quot;Add &quot; &lt;&lt; word &lt;&lt; endl;</span></span><br><span class=\"line\">        TrieNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c: word) &#123;</span><br><span class=\"line\">            p = p-&gt;addChild(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">string</span> word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; &quot;Search &quot; &lt;&lt; word &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TrieNode *&gt; q;</span><br><span class=\"line\">        q.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c: word) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; c &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,size = q.size();i &lt; size; i++) &#123;</span><br><span class=\"line\">                    TrieNode *p = q.front(); q.pop();</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; <span class=\"number\">26</span>;j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (p-&gt;childs[j]) q.push(p-&gt;childs[j]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,size = q.size();i &lt; size; i++) &#123;</span><br><span class=\"line\">                    TrieNode *p = q.front(); q.pop();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p-&gt;childs[c - <span class=\"string\">&#x27;a&#x27;</span>]) q.push(p-&gt;childs[c - <span class=\"string\">&#x27;a&#x27;</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q.front()-&gt;flag) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Add Two Numbers","date":"2017-09-29T16:00:00.000Z","_content":"\n打卡，第7天\n\n> You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n> \n> You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n> Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n> \n> Output: 7 -> 0 -> 8\n \n\n从示例来看，这里的`digits`应该是倒过来的，即`2->4->3`表示的是`342`\n\n如果它不是倒过来的话，我们可能还需要用栈去将元素取出来。\n\n虽然这是一道`Medium`的题目，但是难度其实很小，思路大概是：\n\n将当期指针所指向的值相加得到一个数`x`，那么`x%10`就是这个位应该为的数，`x/10`就是进位，所以算法思路很简单：\n\n```C++\n\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    \n    int ans,add = 0;\n    ListNode ret(0);                        //头结点让单链表操作变简单\n    ListNode *p = &ret;\n    while(l1 != nullptr && l2 != nullptr){\n        ans = (l1->val + l2->val) + add;    //记得加上进位\n        add = ans/10;                       //求出进位\n        p->next = new ListNode(ans%10);\n        p = p->next;\n        l1 = l1->next;\n        l2 = l2->next;\n    }\n    while(l1){\n        ans = l1->val + add;\n        add = ans/10;\n        p->next = new ListNode(ans%10);\n        p = p->next;\n        l1 = l1->next;\n    }\n    while(l2){\n        ans = l2->val + add;\n        add = ans/10;\n        p->next = new ListNode(ans%10);\n        p = p->next;\n        l2 = l2->next;            \n    }\n    if (add != 0) p->next = new ListNode(add);//记得出来进位不为0的情况\n    return ret.next;\n}\n\n```\n\n`dicuss`中还有一个更精炼的写法：\n\n\n```C++\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    ListNode ret(0);\n    ListNode *p = &ret;\n    int add = 0,sum;\n    while(l1 || l2 || add){\n        sum = (l1?l1->val:0) + (l2?l2->val:0) + add;\n        add = sum/10;\n        p->next = new ListNode(sum%10);\n        p = p->next;\n        l1 = (l1?l1->next:nullptr);\n        l2 = (l2?l2->next:nullptr);\n    }\n    return ret.next;\n}\n```\n","source":"_posts/AddTwoNumbers.md","raw":"---\ntitle: Add Two Numbers\ndate: 2017-09-30T00:00:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - 链表\n  - 算法\n---\n\n打卡，第7天\n\n> You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n> \n> You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n> Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n> \n> Output: 7 -> 0 -> 8\n \n\n从示例来看，这里的`digits`应该是倒过来的，即`2->4->3`表示的是`342`\n\n如果它不是倒过来的话，我们可能还需要用栈去将元素取出来。\n\n虽然这是一道`Medium`的题目，但是难度其实很小，思路大概是：\n\n将当期指针所指向的值相加得到一个数`x`，那么`x%10`就是这个位应该为的数，`x/10`就是进位，所以算法思路很简单：\n\n```C++\n\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    \n    int ans,add = 0;\n    ListNode ret(0);                        //头结点让单链表操作变简单\n    ListNode *p = &ret;\n    while(l1 != nullptr && l2 != nullptr){\n        ans = (l1->val + l2->val) + add;    //记得加上进位\n        add = ans/10;                       //求出进位\n        p->next = new ListNode(ans%10);\n        p = p->next;\n        l1 = l1->next;\n        l2 = l2->next;\n    }\n    while(l1){\n        ans = l1->val + add;\n        add = ans/10;\n        p->next = new ListNode(ans%10);\n        p = p->next;\n        l1 = l1->next;\n    }\n    while(l2){\n        ans = l2->val + add;\n        add = ans/10;\n        p->next = new ListNode(ans%10);\n        p = p->next;\n        l2 = l2->next;            \n    }\n    if (add != 0) p->next = new ListNode(add);//记得出来进位不为0的情况\n    return ret.next;\n}\n\n```\n\n`dicuss`中还有一个更精炼的写法：\n\n\n```C++\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    ListNode ret(0);\n    ListNode *p = &ret;\n    int add = 0,sum;\n    while(l1 || l2 || add){\n        sum = (l1?l1->val:0) + (l2?l2->val:0) + add;\n        add = sum/10;\n        p->next = new ListNode(sum%10);\n        p = p->next;\n        l1 = (l1?l1->next:nullptr);\n        l2 = (l2?l2->next:nullptr);\n    }\n    return ret.next;\n}\n```\n","slug":"AddTwoNumbers","published":1,"updated":"2021-03-10T13:47:05.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mg0006qmcm8utkdbpc","content":"<p>打卡，第7天</p>\n<blockquote>\n<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n</blockquote>\n<blockquote>\n<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p>\n<p>Output: 7 -&gt; 0 -&gt; 8</p>\n</blockquote>\n<p>从示例来看，这里的<code>digits</code>应该是倒过来的，即<code>2-&gt;4-&gt;3</code>表示的是<code>342</code></p>\n<p>如果它不是倒过来的话，我们可能还需要用栈去将元素取出来。</p>\n<p>虽然这是一道<code>Medium</code>的题目，但是难度其实很小，思路大概是：</p>\n<p>将当期指针所指向的值相加得到一个数<code>x</code>，那么<code>x%10</code>就是这个位应该为的数，<code>x/10</code>就是进位，所以算法思路很简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans,add = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;                        <span class=\"comment\">//头结点让单链表操作变简单</span></span><br><span class=\"line\">    ListNode *p = &amp;ret;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l1 != <span class=\"literal\">nullptr</span> &amp;&amp; l2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">        ans = (l1-&gt;val + l2-&gt;val) + add;    <span class=\"comment\">//记得加上进位</span></span><br><span class=\"line\">        add = ans/<span class=\"number\">10</span>;                       <span class=\"comment\">//求出进位</span></span><br><span class=\"line\">        p-&gt;next = <span class=\"keyword\">new</span> ListNode(ans%<span class=\"number\">10</span>);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        l1 = l1-&gt;next;</span><br><span class=\"line\">        l2 = l2-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l1)&#123;</span><br><span class=\"line\">        ans = l1-&gt;val + add;</span><br><span class=\"line\">        add = ans/<span class=\"number\">10</span>;</span><br><span class=\"line\">        p-&gt;next = <span class=\"keyword\">new</span> ListNode(ans%<span class=\"number\">10</span>);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        l1 = l1-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l2)&#123;</span><br><span class=\"line\">        ans = l2-&gt;val + add;</span><br><span class=\"line\">        add = ans/<span class=\"number\">10</span>;</span><br><span class=\"line\">        p-&gt;next = <span class=\"keyword\">new</span> ListNode(ans%<span class=\"number\">10</span>);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        l2 = l2-&gt;next;            </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (add != <span class=\"number\">0</span>) p-&gt;next = <span class=\"keyword\">new</span> ListNode(add);<span class=\"comment\">//记得出来进位不为0的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret.next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中还有一个更精炼的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    ListNode *p = &amp;ret;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> add = <span class=\"number\">0</span>,sum;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l1 || l2 || add)&#123;</span><br><span class=\"line\">        sum = (l1?l1-&gt;val:<span class=\"number\">0</span>) + (l2?l2-&gt;val:<span class=\"number\">0</span>) + add;</span><br><span class=\"line\">        add = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">        p-&gt;next = <span class=\"keyword\">new</span> ListNode(sum%<span class=\"number\">10</span>);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        l1 = (l1?l1-&gt;next:<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        l2 = (l2?l2-&gt;next:<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第7天</p>\n<blockquote>\n<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n</blockquote>\n<blockquote>\n<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p>\n<p>Output: 7 -&gt; 0 -&gt; 8</p>\n</blockquote>\n<p>从示例来看，这里的<code>digits</code>应该是倒过来的，即<code>2-&gt;4-&gt;3</code>表示的是<code>342</code></p>\n<p>如果它不是倒过来的话，我们可能还需要用栈去将元素取出来。</p>\n<p>虽然这是一道<code>Medium</code>的题目，但是难度其实很小，思路大概是：</p>\n<p>将当期指针所指向的值相加得到一个数<code>x</code>，那么<code>x%10</code>就是这个位应该为的数，<code>x/10</code>就是进位，所以算法思路很简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans,add = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;                        <span class=\"comment\">//头结点让单链表操作变简单</span></span><br><span class=\"line\">    ListNode *p = &amp;ret;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l1 != <span class=\"literal\">nullptr</span> &amp;&amp; l2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">        ans = (l1-&gt;val + l2-&gt;val) + add;    <span class=\"comment\">//记得加上进位</span></span><br><span class=\"line\">        add = ans/<span class=\"number\">10</span>;                       <span class=\"comment\">//求出进位</span></span><br><span class=\"line\">        p-&gt;next = <span class=\"keyword\">new</span> ListNode(ans%<span class=\"number\">10</span>);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        l1 = l1-&gt;next;</span><br><span class=\"line\">        l2 = l2-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l1)&#123;</span><br><span class=\"line\">        ans = l1-&gt;val + add;</span><br><span class=\"line\">        add = ans/<span class=\"number\">10</span>;</span><br><span class=\"line\">        p-&gt;next = <span class=\"keyword\">new</span> ListNode(ans%<span class=\"number\">10</span>);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        l1 = l1-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l2)&#123;</span><br><span class=\"line\">        ans = l2-&gt;val + add;</span><br><span class=\"line\">        add = ans/<span class=\"number\">10</span>;</span><br><span class=\"line\">        p-&gt;next = <span class=\"keyword\">new</span> ListNode(ans%<span class=\"number\">10</span>);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        l2 = l2-&gt;next;            </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (add != <span class=\"number\">0</span>) p-&gt;next = <span class=\"keyword\">new</span> ListNode(add);<span class=\"comment\">//记得出来进位不为0的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret.next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中还有一个更精炼的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    ListNode *p = &amp;ret;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> add = <span class=\"number\">0</span>,sum;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l1 || l2 || add)&#123;</span><br><span class=\"line\">        sum = (l1?l1-&gt;val:<span class=\"number\">0</span>) + (l2?l2-&gt;val:<span class=\"number\">0</span>) + add;</span><br><span class=\"line\">        add = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">        p-&gt;next = <span class=\"keyword\">new</span> ListNode(sum%<span class=\"number\">10</span>);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        l1 = (l1?l1-&gt;next:<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        l2 = (l2?l2-&gt;next:<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Advantage Shuffle","date":"2019-11-19T04:22:52.000Z","_content":"\n> 第15天。emmm，这就半个月了？？\n\n今天的题目是[ Advantage Shuffle ]( https://leetcode.com/problems/advantage-shuffle/ ):\n\n---\n\nGiven two arrays `A` and `B` of equal size, the *advantage of `A` with respect to `B`* is the number of indices `i` for which `A[i] > B[i]`.\n\nReturn **any** permutation of `A` that maximizes its advantage with respect to `B`.\n\n \n\n**Example 1:**\n\n```\nInput: A = [2,7,11,15], B = [1,10,4,11]\nOutput: [2,11,7,15]\n```\n\n**Example 2:**\n\n```\nInput: A = [12,24,8,32], B = [13,25,32,11]\nOutput: [24,32,8,12]\n```\n\n \n\n**Note:**\n\n1. `1 <= A.length = B.length <= 10000`\n2. `0 <= A[i] <= 10^9`\n3. `0 <= B[i] <= 10^9`\n\n---\n\n这道题就是个贪心的思路，确保每个位置上，`A[i]`的值要么是`A`中第一个比`B[i]`大，要么是最小能用的值，这就涉及到了怎么找到第一个比`B[i]`大的值的问题了，我们可以二叉查找树来实现，这里用STL中的`multiset`即可：\n\n```c++\nvector<int> advantageCount1(vector<int>& A, vector<int>& B) {\n    multiset<int> S(A.begin(), A.end());\n    for(int i = 0;i < B.size(); i++) {\n        auto it = S.upper_bound(B[i]);\n        if (it == S.end()) {\n            it = S.begin();\n        }\n        A[i] = *it;\n        S.erase(it);\n    }\n    return A;\n}\n```\n\n这个方法虽然可以AC，但是时间效率不高，所以我们可以用排序的方法来代替二叉查找树，我们按B从大到小的顺序来填A的值，这样如果A中当前能用的最大值比`B[i]`要大，那么`A[i]`为A中当前能用的最大值，否则为A中当前能用的最小值。\n\n```c++\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\n    vector<int> res(A.size());\n    vector<pair<int, int>> val2index(A.size());\n\n    for(int i = 0;i < val2index.size(); i++) val2index[i] = make_pair(B[i], i);\n    sort(A.begin(), A.end());\n    sort(val2index.begin(), val2index.end());\n\n    int first = 0, last = A.size() - 1;\n    for(int i = A.size() - 1;i >= 0;i--) {\n        if (val2index[i].first >= A[last]) {\n            res[val2index[i].second] = A[first++];\n        } else {\n            res[val2index[i].second] = A[last--];\n        }\n    }\n\n    return res;\n}\n```\n\n","source":"_posts/Advantage-Shuffle.md","raw":"---\ntitle: Advantage Shuffle\ndate: 2019-11-19T12:22:52.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第15天。emmm，这就半个月了？？\n\n今天的题目是[ Advantage Shuffle ]( https://leetcode.com/problems/advantage-shuffle/ ):\n\n---\n\nGiven two arrays `A` and `B` of equal size, the *advantage of `A` with respect to `B`* is the number of indices `i` for which `A[i] > B[i]`.\n\nReturn **any** permutation of `A` that maximizes its advantage with respect to `B`.\n\n \n\n**Example 1:**\n\n```\nInput: A = [2,7,11,15], B = [1,10,4,11]\nOutput: [2,11,7,15]\n```\n\n**Example 2:**\n\n```\nInput: A = [12,24,8,32], B = [13,25,32,11]\nOutput: [24,32,8,12]\n```\n\n \n\n**Note:**\n\n1. `1 <= A.length = B.length <= 10000`\n2. `0 <= A[i] <= 10^9`\n3. `0 <= B[i] <= 10^9`\n\n---\n\n这道题就是个贪心的思路，确保每个位置上，`A[i]`的值要么是`A`中第一个比`B[i]`大，要么是最小能用的值，这就涉及到了怎么找到第一个比`B[i]`大的值的问题了，我们可以二叉查找树来实现，这里用STL中的`multiset`即可：\n\n```c++\nvector<int> advantageCount1(vector<int>& A, vector<int>& B) {\n    multiset<int> S(A.begin(), A.end());\n    for(int i = 0;i < B.size(); i++) {\n        auto it = S.upper_bound(B[i]);\n        if (it == S.end()) {\n            it = S.begin();\n        }\n        A[i] = *it;\n        S.erase(it);\n    }\n    return A;\n}\n```\n\n这个方法虽然可以AC，但是时间效率不高，所以我们可以用排序的方法来代替二叉查找树，我们按B从大到小的顺序来填A的值，这样如果A中当前能用的最大值比`B[i]`要大，那么`A[i]`为A中当前能用的最大值，否则为A中当前能用的最小值。\n\n```c++\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\n    vector<int> res(A.size());\n    vector<pair<int, int>> val2index(A.size());\n\n    for(int i = 0;i < val2index.size(); i++) val2index[i] = make_pair(B[i], i);\n    sort(A.begin(), A.end());\n    sort(val2index.begin(), val2index.end());\n\n    int first = 0, last = A.size() - 1;\n    for(int i = A.size() - 1;i >= 0;i--) {\n        if (val2index[i].first >= A[last]) {\n            res[val2index[i].second] = A[first++];\n        } else {\n            res[val2index[i].second] = A[last--];\n        }\n    }\n\n    return res;\n}\n```\n\n","slug":"Advantage-Shuffle","published":1,"updated":"2021-03-10T13:47:05.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mi000aqmcm78ksd6jd","content":"<blockquote>\n<p>第15天。emmm，这就半个月了？？</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/advantage-shuffle/\"> Advantage Shuffle </a>:</p>\n<hr>\n<p>Given two arrays <code>A</code> and <code>B</code> of equal size, the <em>advantage of <code>A</code> with respect to <code>B</code></em> is the number of indices <code>i</code> for which <code>A[i] &gt; B[i]</code>.</p>\n<p>Return <strong>any</strong> permutation of <code>A</code> that maximizes its advantage with respect to <code>B</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [2,7,11,15], B &#x3D; [1,10,4,11]</span><br><span class=\"line\">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [12,24,8,32], B &#x3D; [13,25,32,11]</span><br><span class=\"line\">Output: [24,32,8,12]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= A.length = B.length &lt;= 10000</code></li>\n<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>\n<li><code>0 &lt;= B[i] &lt;= 10^9</code></li>\n</ol>\n<hr>\n<p>这道题就是个贪心的思路，确保每个位置上，<code>A[i]</code>的值要么是<code>A</code>中第一个比<code>B[i]</code>大，要么是最小能用的值，这就涉及到了怎么找到第一个比<code>B[i]</code>大的值的问题了，我们可以二叉查找树来实现，这里用STL中的<code>multiset</code>即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">advantageCount1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">multiset</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">S</span><span class=\"params\">(A.begin(), A.end())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; B.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = S.upper_bound(B[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it == S.end()) &#123;</span><br><span class=\"line\">            it = S.begin();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        A[i] = *it;</span><br><span class=\"line\">        S.erase(it);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法虽然可以AC，但是时间效率不高，所以我们可以用排序的方法来代替二叉查找树，我们按B从大到小的顺序来填A的值，这样如果A中当前能用的最大值比<code>B[i]</code>要大，那么<code>A[i]</code>为A中当前能用的最大值，否则为A中当前能用的最小值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">advantageCount</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(A.size())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; val2index(A.size());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; val2index.size(); i++) val2index[i] = <span class=\"built_in\">make_pair</span>(B[i], i);</span><br><span class=\"line\">    sort(A.begin(), A.end());</span><br><span class=\"line\">    sort(val2index.begin(), val2index.end());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = <span class=\"number\">0</span>, last = A.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = A.size() - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val2index[i].first &gt;= A[last]) &#123;</span><br><span class=\"line\">            res[val2index[i].second] = A[first++];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res[val2index[i].second] = A[last--];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第15天。emmm，这就半个月了？？</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/advantage-shuffle/\"> Advantage Shuffle </a>:</p>\n<hr>\n<p>Given two arrays <code>A</code> and <code>B</code> of equal size, the <em>advantage of <code>A</code> with respect to <code>B</code></em> is the number of indices <code>i</code> for which <code>A[i] &gt; B[i]</code>.</p>\n<p>Return <strong>any</strong> permutation of <code>A</code> that maximizes its advantage with respect to <code>B</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [2,7,11,15], B &#x3D; [1,10,4,11]</span><br><span class=\"line\">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [12,24,8,32], B &#x3D; [13,25,32,11]</span><br><span class=\"line\">Output: [24,32,8,12]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= A.length = B.length &lt;= 10000</code></li>\n<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>\n<li><code>0 &lt;= B[i] &lt;= 10^9</code></li>\n</ol>\n<hr>\n<p>这道题就是个贪心的思路，确保每个位置上，<code>A[i]</code>的值要么是<code>A</code>中第一个比<code>B[i]</code>大，要么是最小能用的值，这就涉及到了怎么找到第一个比<code>B[i]</code>大的值的问题了，我们可以二叉查找树来实现，这里用STL中的<code>multiset</code>即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">advantageCount1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">multiset</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">S</span><span class=\"params\">(A.begin(), A.end())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; B.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = S.upper_bound(B[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it == S.end()) &#123;</span><br><span class=\"line\">            it = S.begin();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        A[i] = *it;</span><br><span class=\"line\">        S.erase(it);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法虽然可以AC，但是时间效率不高，所以我们可以用排序的方法来代替二叉查找树，我们按B从大到小的顺序来填A的值，这样如果A中当前能用的最大值比<code>B[i]</code>要大，那么<code>A[i]</code>为A中当前能用的最大值，否则为A中当前能用的最小值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">advantageCount</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(A.size())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; val2index(A.size());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; val2index.size(); i++) val2index[i] = <span class=\"built_in\">make_pair</span>(B[i], i);</span><br><span class=\"line\">    sort(A.begin(), A.end());</span><br><span class=\"line\">    sort(val2index.begin(), val2index.end());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = <span class=\"number\">0</span>, last = A.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = A.size() - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val2index[i].first &gt;= A[last]) &#123;</span><br><span class=\"line\">            res[val2index[i].second] = A[first++];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res[val2index[i].second] = A[last--];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"All Elements in Two Binary Search Trees","date":"2020-01-03T03:17:32.000Z","_content":"\n> 第54天。\n\n今天的题目是[All Elements in Two Binary Search Trees](https://leetcode.com/problems/all-elements-in-two-binary-search-trees/):\n\n先用先序遍历拿到每棵树上的值，因为是二叉搜索树，所以先序得到的就是有序的值，所以做一次归并即可：\n\n```c++\nvector<int> getAllElements(TreeNode* root1, TreeNode* root2) {\n    vector<int> left;\n    vector<int> right;\n    getAllElements(root1, left);\n    getAllElements(root2, right);\n    \n    int len = left.size() + right.size();\n    if (len == 0) return vector<int>();\n    vector<int> vec(len);\n    \n    int i = 0, j = 0, k = 0;\n    while(i < left.size() && j < right.size()) {\n        if (left[i] < right[j]) vec[k++] = left[i++];\n        else vec[k++] = right[j++];\n    }\n    while(i < left.size()) vec[k++] = left[i++];\n    while(j < right.size()) vec[k++] = right[j++];\n    return vec;\n    \n}\n\n\nvoid getAllElements(TreeNode *root, vector<int> &vec) {\n    if (root == nullptr) return ;\n    stack<TreeNode *> st;\n    while(root || !st.empty()) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n        if (!st.empty()) {\n            root = st.top(); st.pop();\n            vec.push_back(root->val);\n            root = root->right;\n        }\n    }\n}\n```\n","source":"_posts/All-Elements-in-Two-Binary-Search-Trees.md","raw":"---\ntitle: All Elements in Two Binary Search Trees\ndate: 2020-01-03T11:17:32.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第54天。\n\n今天的题目是[All Elements in Two Binary Search Trees](https://leetcode.com/problems/all-elements-in-two-binary-search-trees/):\n\n先用先序遍历拿到每棵树上的值，因为是二叉搜索树，所以先序得到的就是有序的值，所以做一次归并即可：\n\n```c++\nvector<int> getAllElements(TreeNode* root1, TreeNode* root2) {\n    vector<int> left;\n    vector<int> right;\n    getAllElements(root1, left);\n    getAllElements(root2, right);\n    \n    int len = left.size() + right.size();\n    if (len == 0) return vector<int>();\n    vector<int> vec(len);\n    \n    int i = 0, j = 0, k = 0;\n    while(i < left.size() && j < right.size()) {\n        if (left[i] < right[j]) vec[k++] = left[i++];\n        else vec[k++] = right[j++];\n    }\n    while(i < left.size()) vec[k++] = left[i++];\n    while(j < right.size()) vec[k++] = right[j++];\n    return vec;\n    \n}\n\n\nvoid getAllElements(TreeNode *root, vector<int> &vec) {\n    if (root == nullptr) return ;\n    stack<TreeNode *> st;\n    while(root || !st.empty()) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n        if (!st.empty()) {\n            root = st.top(); st.pop();\n            vec.push_back(root->val);\n            root = root->right;\n        }\n    }\n}\n```\n","slug":"All-Elements-in-Two-Binary-Search-Trees","published":1,"updated":"2021-03-10T13:47:05.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mj000cqmcmeqdwa6sd","content":"<blockquote>\n<p>第54天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/all-elements-in-two-binary-search-trees/\">All Elements in Two Binary Search Trees</a>:</p>\n<p>先用先序遍历拿到每棵树上的值，因为是二叉搜索树，所以先序得到的就是有序的值，所以做一次归并即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">getAllElements</span><span class=\"params\">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; left;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; right;</span><br><span class=\"line\">    getAllElements(root1, left);</span><br><span class=\"line\">    getAllElements(root2, right);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = left.size() + right.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(len)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; left.size() &amp;&amp; j &lt; right.size()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[i] &lt; right[j]) vec[k++] = left[i++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> vec[k++] = right[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; left.size()) vec[k++] = left[i++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &lt; right.size()) vec[k++] = right[j++];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vec;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getAllElements</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root || !st.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st.empty()) &#123;</span><br><span class=\"line\">            root = st.top(); st.pop();</span><br><span class=\"line\">            vec.push_back(root-&gt;val);</span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第54天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/all-elements-in-two-binary-search-trees/\">All Elements in Two Binary Search Trees</a>:</p>\n<p>先用先序遍历拿到每棵树上的值，因为是二叉搜索树，所以先序得到的就是有序的值，所以做一次归并即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">getAllElements</span><span class=\"params\">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; left;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; right;</span><br><span class=\"line\">    getAllElements(root1, left);</span><br><span class=\"line\">    getAllElements(root2, right);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = left.size() + right.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(len)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; left.size() &amp;&amp; j &lt; right.size()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[i] &lt; right[j]) vec[k++] = left[i++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> vec[k++] = right[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; left.size()) vec[k++] = left[i++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &lt; right.size()) vec[k++] = right[j++];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vec;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getAllElements</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root || !st.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st.empty()) &#123;</span><br><span class=\"line\">            root = st.top(); st.pop();</span><br><span class=\"line\">            vec.push_back(root-&gt;val);</span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"All Nodes Distance K in Binary Tree","date":"2019-03-07T02:07:50.000Z","_content":"\n> 第8天，感觉快要把每天刷题的习惯找回来了。。。\n\n今天的题目是[All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)\n\n这道题可以分为几个部分来解决：\n\n- 寻找`target`节点\n- 向下寻找距离当前节点K步的节点\n- 从`target`节点向前寻找\n\n虽说是三部分，但是在实现“寻找target节点”的时候，我们需要考虑到如何向前寻找，我们先把“向下寻找距离当前节点K步的节点”实现了。\n\n很容易发现，这是一个递归的过程，做遍历的时候维护好K值即可，然后加一些判断条件就能实现了。\n\n如果忽略掉“从target节点向前寻找”这个要求，我们要怎么实现寻找target节点呢？\n\n也是一个很简单的问题，就直接用递归形式的先序遍历即可，遍历时判断当前节点是否为target节点。\n\n现在就剩下最后一部分了，也是这道题的难点所在。\n\n要实现向前移动，我们可以利用“寻找target节点”的一些信息，通过一个返回值来确定，是否在某个子分支中找到 target 节点：\n\n如果找到了，我们就可以从当前节点开始向另一个分支寻找了，因为需要计算到target节点的距离，所以我们干脆把返回值设置为还需要走多少步才能到达”距离target节点K步“的位置，故：\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> distanceK(TreeNode* root, TreeNode* target, int K) {\n        vector<int> res;\n        if (root == nullptr || target == nullptr) return res;\n        downSearch(res, target, K);\n        findTarget(res, root, target, K);\n        return res;\n    }\n    \n    int findTarget(vector<int> &res, TreeNode *root, TreeNode *target, int K) {\n        if (root == nullptr) return -1;\n        if (root == target) return K - 1;\n        \n        // left\n        int left_k = findTarget(res, root->left, target, K);\n        if (left_k == 0) {\n            res.push_back(root->val); return left_k - 1;\n        } else if (left_k > 0) {\n            downSearch(res, root->right, left_k-1);\n            return left_k - 1;\n        }\n        \n        int right_k = findTarget(res, root->right, target, K);\n        if (right_k == 0) {\n            res.push_back(root->val); return right_k - 1;\n        } else if (right_k > 0) {\n            downSearch(res, root->left, right_k-1);\n            return right_k - 1;\n        }\n        return -1;\n    }\n    \n    void downSearch(vector<int> &res, TreeNode* p, int K) {\n        if (p == nullptr || K < 0) return ;\n        if (K == 0) {\n            res.push_back(p->val); return;\n        }\n        downSearch(res, p->left, K-1);\n        downSearch(res, p->right, K-1);\n    }\n};\n```\n","source":"_posts/All-Nodes-Distance-K-in-Binary-Tree.md","raw":"---\ntitle: All Nodes Distance K in Binary Tree\ndate: 2019-03-07T10:07:50.000Z\ntags:\n  - LeetCode\n  - Tree\ncategories:\n  - LeetCode\n---\n\n> 第8天，感觉快要把每天刷题的习惯找回来了。。。\n\n今天的题目是[All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)\n\n这道题可以分为几个部分来解决：\n\n- 寻找`target`节点\n- 向下寻找距离当前节点K步的节点\n- 从`target`节点向前寻找\n\n虽说是三部分，但是在实现“寻找target节点”的时候，我们需要考虑到如何向前寻找，我们先把“向下寻找距离当前节点K步的节点”实现了。\n\n很容易发现，这是一个递归的过程，做遍历的时候维护好K值即可，然后加一些判断条件就能实现了。\n\n如果忽略掉“从target节点向前寻找”这个要求，我们要怎么实现寻找target节点呢？\n\n也是一个很简单的问题，就直接用递归形式的先序遍历即可，遍历时判断当前节点是否为target节点。\n\n现在就剩下最后一部分了，也是这道题的难点所在。\n\n要实现向前移动，我们可以利用“寻找target节点”的一些信息，通过一个返回值来确定，是否在某个子分支中找到 target 节点：\n\n如果找到了，我们就可以从当前节点开始向另一个分支寻找了，因为需要计算到target节点的距离，所以我们干脆把返回值设置为还需要走多少步才能到达”距离target节点K步“的位置，故：\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> distanceK(TreeNode* root, TreeNode* target, int K) {\n        vector<int> res;\n        if (root == nullptr || target == nullptr) return res;\n        downSearch(res, target, K);\n        findTarget(res, root, target, K);\n        return res;\n    }\n    \n    int findTarget(vector<int> &res, TreeNode *root, TreeNode *target, int K) {\n        if (root == nullptr) return -1;\n        if (root == target) return K - 1;\n        \n        // left\n        int left_k = findTarget(res, root->left, target, K);\n        if (left_k == 0) {\n            res.push_back(root->val); return left_k - 1;\n        } else if (left_k > 0) {\n            downSearch(res, root->right, left_k-1);\n            return left_k - 1;\n        }\n        \n        int right_k = findTarget(res, root->right, target, K);\n        if (right_k == 0) {\n            res.push_back(root->val); return right_k - 1;\n        } else if (right_k > 0) {\n            downSearch(res, root->left, right_k-1);\n            return right_k - 1;\n        }\n        return -1;\n    }\n    \n    void downSearch(vector<int> &res, TreeNode* p, int K) {\n        if (p == nullptr || K < 0) return ;\n        if (K == 0) {\n            res.push_back(p->val); return;\n        }\n        downSearch(res, p->left, K-1);\n        downSearch(res, p->right, K-1);\n    }\n};\n```\n","slug":"All-Nodes-Distance-K-in-Binary-Tree","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ml000hqmcm4n6reye5","content":"<blockquote>\n<p>第8天，感觉快要把每天刷题的习惯找回来了。。。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/\">All Nodes Distance K in Binary Tree</a></p>\n<p>这道题可以分为几个部分来解决：</p>\n<ul>\n<li>寻找<code>target</code>节点</li>\n<li>向下寻找距离当前节点K步的节点</li>\n<li>从<code>target</code>节点向前寻找</li>\n</ul>\n<p>虽说是三部分，但是在实现“寻找target节点”的时候，我们需要考虑到如何向前寻找，我们先把“向下寻找距离当前节点K步的节点”实现了。</p>\n<p>很容易发现，这是一个递归的过程，做遍历的时候维护好K值即可，然后加一些判断条件就能实现了。</p>\n<p>如果忽略掉“从target节点向前寻找”这个要求，我们要怎么实现寻找target节点呢？</p>\n<p>也是一个很简单的问题，就直接用递归形式的先序遍历即可，遍历时判断当前节点是否为target节点。</p>\n<p>现在就剩下最后一部分了，也是这道题的难点所在。</p>\n<p>要实现向前移动，我们可以利用“寻找target节点”的一些信息，通过一个返回值来确定，是否在某个子分支中找到 target 节点：</p>\n<p>如果找到了，我们就可以从当前节点开始向另一个分支寻找了，因为需要计算到target节点的距离，所以我们干脆把返回值设置为还需要走多少步才能到达”距离target节点K步“的位置，故：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">distanceK</span><span class=\"params\">(TreeNode* root, TreeNode* target, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span> || target == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        downSearch(res, target, K);</span><br><span class=\"line\">        findTarget(res, root, target, K);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findTarget</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;res, TreeNode *root, TreeNode *target, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == target) <span class=\"keyword\">return</span> K - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// left</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left_k = findTarget(res, root-&gt;left, target, K);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left_k == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.push_back(root-&gt;val); <span class=\"keyword\">return</span> left_k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left_k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            downSearch(res, root-&gt;right, left_k<span class=\"number\">-1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> left_k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> right_k = findTarget(res, root-&gt;right, target, K);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right_k == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.push_back(root-&gt;val); <span class=\"keyword\">return</span> right_k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right_k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            downSearch(res, root-&gt;left, right_k<span class=\"number\">-1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> right_k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">downSearch</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;res, TreeNode* p, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span> || K &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (K == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.push_back(p-&gt;val); <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        downSearch(res, p-&gt;left, K<span class=\"number\">-1</span>);</span><br><span class=\"line\">        downSearch(res, p-&gt;right, K<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第8天，感觉快要把每天刷题的习惯找回来了。。。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/\">All Nodes Distance K in Binary Tree</a></p>\n<p>这道题可以分为几个部分来解决：</p>\n<ul>\n<li>寻找<code>target</code>节点</li>\n<li>向下寻找距离当前节点K步的节点</li>\n<li>从<code>target</code>节点向前寻找</li>\n</ul>\n<p>虽说是三部分，但是在实现“寻找target节点”的时候，我们需要考虑到如何向前寻找，我们先把“向下寻找距离当前节点K步的节点”实现了。</p>\n<p>很容易发现，这是一个递归的过程，做遍历的时候维护好K值即可，然后加一些判断条件就能实现了。</p>\n<p>如果忽略掉“从target节点向前寻找”这个要求，我们要怎么实现寻找target节点呢？</p>\n<p>也是一个很简单的问题，就直接用递归形式的先序遍历即可，遍历时判断当前节点是否为target节点。</p>\n<p>现在就剩下最后一部分了，也是这道题的难点所在。</p>\n<p>要实现向前移动，我们可以利用“寻找target节点”的一些信息，通过一个返回值来确定，是否在某个子分支中找到 target 节点：</p>\n<p>如果找到了，我们就可以从当前节点开始向另一个分支寻找了，因为需要计算到target节点的距离，所以我们干脆把返回值设置为还需要走多少步才能到达”距离target节点K步“的位置，故：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">distanceK</span><span class=\"params\">(TreeNode* root, TreeNode* target, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span> || target == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        downSearch(res, target, K);</span><br><span class=\"line\">        findTarget(res, root, target, K);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findTarget</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;res, TreeNode *root, TreeNode *target, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == target) <span class=\"keyword\">return</span> K - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// left</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left_k = findTarget(res, root-&gt;left, target, K);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left_k == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.push_back(root-&gt;val); <span class=\"keyword\">return</span> left_k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left_k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            downSearch(res, root-&gt;right, left_k<span class=\"number\">-1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> left_k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> right_k = findTarget(res, root-&gt;right, target, K);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right_k == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.push_back(root-&gt;val); <span class=\"keyword\">return</span> right_k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right_k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            downSearch(res, root-&gt;left, right_k<span class=\"number\">-1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> right_k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">downSearch</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;res, TreeNode* p, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span> || K &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (K == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.push_back(p-&gt;val); <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        downSearch(res, p-&gt;left, K<span class=\"number\">-1</span>);</span><br><span class=\"line\">        downSearch(res, p-&gt;right, K<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"All Possible Full Binary Trees","date":"2019-11-22T05:54:54.000Z","_content":"\n> 第18天。\n\n今天的题目是[ All Possible Full Binary Trees ]( https://leetcode.com/problems/all-possible-full-binary-trees/ ):\n\n---\n\nA *full binary tree* is a binary tree where each node has exactly 0 or 2 children.\n\nReturn a list of all possible full binary trees with `N` nodes. Each element of the answer is the root node of one possible tree.\n\nEach `node` of each tree in the answer **must** have `node.val = 0`.\n\nYou may return the final list of trees in any order.\n\n \n\n**Example 1:**\n\n```\nInput: 7\nOutput: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\nExplanation:\n```\n\n ![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png)\n\n**Note:**\n\n- `1 <= N <= 20`\n\n---\n\n这道题就是一个穷举的问题，我们知道完全二叉树的节点个数一定是奇数，所以可以先把`N`为偶数的输入先处理掉，然后就是怎么穷举的问题了。显然，一个完全二叉树的子树一定也是完全二叉树，所以我们可以以`1,3,5...,N-2`的方式穷举出出左子树中节点的个数`i`，已知左子树节点个数，那么右子树节点的个数就为`N-i-1`,我们先把左子树和右子树的可能都算出来，然后就再计算它们两两组合的所有可能即可得到所有节点个数为`N`的完全二叉树的情况。总的来说，就是一个大问题化简成小问题的思路。所以我们可以写出如下代码：\n\n```c++\nTreeNode *copyTree(TreeNode *root) {\n    if (root == nullptr) return nullptr;\n    TreeNode *res = new TreeNode(0);\n    res->left = copyTree(root->left);\n    res->right = copyTree(root->right);\n    return res;\n}\n\nvector<TreeNode*> allPossibleFBT(int N) {\n    vector<TreeNode*> res;   \n    if (N % 2 == 0) return res;\n\n    vector<vector<TreeNode*>> dp(N+1);\n    dp[1].push_back(new TreeNode(0));\n\n    for(int i = 1;i < dp.size();i+=2) {\n        // dp[i];\n        for(int j = 1;j < i;j+=2) {\n            vector<TreeNode*> &left = dp[j];\n            vector<TreeNode*> &right = dp[(i-j-1)];\n            for(auto &l: left) {\n                for(auto &r: right) {\n                    TreeNode *node = new TreeNode(0);\n                    node->left = copyTree(l);\n                    node->right = copyTree(r);\n                    dp[i].push_back(node);        \n                }\n            }\n        }\n    }\n    return dp[N];\n}\n```\n\n然后你会发现好像可以用一个数组来存在已经求解出来的结果，如果再一次求，我们可以直接返回了：\n\n```c++\nvector<TreeNode*> &allPossibleFBT(int N, vector<vector<TreeNode*>> &cache) {\n    if (cache[N].size() != 0) return cache[N];\n\n    for(int i = 1;i < N;i++) {\n        vector<TreeNode*> &left = allPossibleFBT(i, cache);\n        vector<TreeNode*> &right = allPossibleFBT(N - i - 1, cache);\n        for(auto l: left) {\n            for(auto r: right) {\n                TreeNode *node = new TreeNode(0);\n                node->left = l;\n                node->right = r;\n                cache[N].push_back(node);\n            }\n        }\n    }\n    return cache[N];\n}\n\nvector<TreeNode*> allPossibleFBT(int N) {\n    vector<TreeNode*> res;   \n    if (N % 2 == 0) return {};\n    vector<vector<TreeNode*>> cache(21);\n\n    cache[1].push_back(new TreeNode(0));\n    return allPossibleFBT(N, cache);\n}\n```\n\n如果熟悉动态规划的话，就会发现可以自顶向下的求解方式转成自底向上的求解方式，这里我们就不需要用递归去求解：\n\n```c++\nvector<TreeNode*> allPossibleFBT(int N) {\n    vector<TreeNode*> res;   \n    if (N % 2 == 0) return res;\n\n    vector<vector<TreeNode*>> dp(N+1);\n    dp[1].push_back(new TreeNode(0));\n\n    for(int i = 1;i < dp.size();i+=2) {\n        // dp[i];\n        for(int j = 1;j < i;j+=2) {\n            for(auto l: dp[j]) {\n                for(auto r: dp[i-j-1]) {\n                    TreeNode *node = new TreeNode(0);\n                    node->left = copyTree(l);\n                    node->right = copyTree(r);\n                    dp[i].push_back(node);        \n                }\n            }\n        }\n    }\n    return dp[N];\n}\n```\n\n最后，这份代码在`LeetCode`大概只能超过50%，如果要进一步，只有把`copyTree`去掉，直接赋值。这种方式是可行的，但是感觉只是在刷题时的一种技巧而已：\n\n```c++\nvector<TreeNode*> allPossibleFBT(int N) {\n    vector<TreeNode*> res;   \n    if (N % 2 == 0) return res;\n\n    vector<vector<TreeNode*>> dp(N+1);\n    dp[1].push_back(new TreeNode(0));\n\n    for(int i = 1;i < dp.size();i+=2) {\n        // dp[i];\n        for(int j = 1;j < i;j+=2) {\n            for(auto l: dp[j]) {\n                for(auto r: dp[i-j-1]) {\n                    TreeNode *node = new TreeNode(0);\n                    node->left = l;//copyTree(l);\n                    node->right = r;//copyTree(r);\n                    dp[i].push_back(node);        \n                }\n            }\n        }\n    }\n    return dp[N];\n}\n```\n\n","source":"_posts/All-Possible-Full-Binary-Trees.md","raw":"---\ntitle: All Possible Full Binary Trees\ndate: 2019-11-22T13:54:54.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第18天。\n\n今天的题目是[ All Possible Full Binary Trees ]( https://leetcode.com/problems/all-possible-full-binary-trees/ ):\n\n---\n\nA *full binary tree* is a binary tree where each node has exactly 0 or 2 children.\n\nReturn a list of all possible full binary trees with `N` nodes. Each element of the answer is the root node of one possible tree.\n\nEach `node` of each tree in the answer **must** have `node.val = 0`.\n\nYou may return the final list of trees in any order.\n\n \n\n**Example 1:**\n\n```\nInput: 7\nOutput: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\nExplanation:\n```\n\n ![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png)\n\n**Note:**\n\n- `1 <= N <= 20`\n\n---\n\n这道题就是一个穷举的问题，我们知道完全二叉树的节点个数一定是奇数，所以可以先把`N`为偶数的输入先处理掉，然后就是怎么穷举的问题了。显然，一个完全二叉树的子树一定也是完全二叉树，所以我们可以以`1,3,5...,N-2`的方式穷举出出左子树中节点的个数`i`，已知左子树节点个数，那么右子树节点的个数就为`N-i-1`,我们先把左子树和右子树的可能都算出来，然后就再计算它们两两组合的所有可能即可得到所有节点个数为`N`的完全二叉树的情况。总的来说，就是一个大问题化简成小问题的思路。所以我们可以写出如下代码：\n\n```c++\nTreeNode *copyTree(TreeNode *root) {\n    if (root == nullptr) return nullptr;\n    TreeNode *res = new TreeNode(0);\n    res->left = copyTree(root->left);\n    res->right = copyTree(root->right);\n    return res;\n}\n\nvector<TreeNode*> allPossibleFBT(int N) {\n    vector<TreeNode*> res;   \n    if (N % 2 == 0) return res;\n\n    vector<vector<TreeNode*>> dp(N+1);\n    dp[1].push_back(new TreeNode(0));\n\n    for(int i = 1;i < dp.size();i+=2) {\n        // dp[i];\n        for(int j = 1;j < i;j+=2) {\n            vector<TreeNode*> &left = dp[j];\n            vector<TreeNode*> &right = dp[(i-j-1)];\n            for(auto &l: left) {\n                for(auto &r: right) {\n                    TreeNode *node = new TreeNode(0);\n                    node->left = copyTree(l);\n                    node->right = copyTree(r);\n                    dp[i].push_back(node);        \n                }\n            }\n        }\n    }\n    return dp[N];\n}\n```\n\n然后你会发现好像可以用一个数组来存在已经求解出来的结果，如果再一次求，我们可以直接返回了：\n\n```c++\nvector<TreeNode*> &allPossibleFBT(int N, vector<vector<TreeNode*>> &cache) {\n    if (cache[N].size() != 0) return cache[N];\n\n    for(int i = 1;i < N;i++) {\n        vector<TreeNode*> &left = allPossibleFBT(i, cache);\n        vector<TreeNode*> &right = allPossibleFBT(N - i - 1, cache);\n        for(auto l: left) {\n            for(auto r: right) {\n                TreeNode *node = new TreeNode(0);\n                node->left = l;\n                node->right = r;\n                cache[N].push_back(node);\n            }\n        }\n    }\n    return cache[N];\n}\n\nvector<TreeNode*> allPossibleFBT(int N) {\n    vector<TreeNode*> res;   \n    if (N % 2 == 0) return {};\n    vector<vector<TreeNode*>> cache(21);\n\n    cache[1].push_back(new TreeNode(0));\n    return allPossibleFBT(N, cache);\n}\n```\n\n如果熟悉动态规划的话，就会发现可以自顶向下的求解方式转成自底向上的求解方式，这里我们就不需要用递归去求解：\n\n```c++\nvector<TreeNode*> allPossibleFBT(int N) {\n    vector<TreeNode*> res;   \n    if (N % 2 == 0) return res;\n\n    vector<vector<TreeNode*>> dp(N+1);\n    dp[1].push_back(new TreeNode(0));\n\n    for(int i = 1;i < dp.size();i+=2) {\n        // dp[i];\n        for(int j = 1;j < i;j+=2) {\n            for(auto l: dp[j]) {\n                for(auto r: dp[i-j-1]) {\n                    TreeNode *node = new TreeNode(0);\n                    node->left = copyTree(l);\n                    node->right = copyTree(r);\n                    dp[i].push_back(node);        \n                }\n            }\n        }\n    }\n    return dp[N];\n}\n```\n\n最后，这份代码在`LeetCode`大概只能超过50%，如果要进一步，只有把`copyTree`去掉，直接赋值。这种方式是可行的，但是感觉只是在刷题时的一种技巧而已：\n\n```c++\nvector<TreeNode*> allPossibleFBT(int N) {\n    vector<TreeNode*> res;   \n    if (N % 2 == 0) return res;\n\n    vector<vector<TreeNode*>> dp(N+1);\n    dp[1].push_back(new TreeNode(0));\n\n    for(int i = 1;i < dp.size();i+=2) {\n        // dp[i];\n        for(int j = 1;j < i;j+=2) {\n            for(auto l: dp[j]) {\n                for(auto r: dp[i-j-1]) {\n                    TreeNode *node = new TreeNode(0);\n                    node->left = l;//copyTree(l);\n                    node->right = r;//copyTree(r);\n                    dp[i].push_back(node);        \n                }\n            }\n        }\n    }\n    return dp[N];\n}\n```\n\n","slug":"All-Possible-Full-Binary-Trees","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mm000kqmcm70qc4gxy","content":"<blockquote>\n<p>第18天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/all-possible-full-binary-trees/\"> All Possible Full Binary Trees </a>:</p>\n<hr>\n<p>A <em>full binary tree</em> is a binary tree where each node has exactly 0 or 2 children.</p>\n<p>Return a list of all possible full binary trees with <code>N</code> nodes. Each element of the answer is the root node of one possible tree.</p>\n<p>Each <code>node</code> of each tree in the answer <strong>must</strong> have <code>node.val = 0</code>.</p>\n<p>You may return the final list of trees in any order.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: 7</span><br><span class=\"line\">Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</span><br><span class=\"line\">Explanation:</span><br></pre></td></tr></table></figure>\n\n<p> <img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png\"></p>\n<p><strong>Note:</strong></p>\n<ul>\n<li><code>1 &lt;= N &lt;= 20</code></li>\n</ul>\n<hr>\n<p>这道题就是一个穷举的问题，我们知道完全二叉树的节点个数一定是奇数，所以可以先把<code>N</code>为偶数的输入先处理掉，然后就是怎么穷举的问题了。显然，一个完全二叉树的子树一定也是完全二叉树，所以我们可以以<code>1,3,5...,N-2</code>的方式穷举出出左子树中节点的个数<code>i</code>，已知左子树节点个数，那么右子树节点的个数就为<code>N-i-1</code>,我们先把左子树和右子树的可能都算出来，然后就再计算它们两两组合的所有可能即可得到所有节点个数为<code>N</code>的完全二叉树的情况。总的来说，就是一个大问题化简成小问题的思路。所以我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">copyTree</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    TreeNode *res = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    res-&gt;left = copyTree(root-&gt;left);</span><br><span class=\"line\">    res-&gt;right = copyTree(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; dp(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>].push_back(<span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size();i+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i];</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; i;j+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;left = dp[j];</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;right = dp[(i-j<span class=\"number\">-1</span>)];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;l: left) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;r: right) &#123;</span><br><span class=\"line\">                    TreeNode *node = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">                    node-&gt;left = copyTree(l);</span><br><span class=\"line\">                    node-&gt;right = copyTree(r);</span><br><span class=\"line\">                    dp[i].push_back(node);        </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后你会发现好像可以用一个数组来存在已经求解出来的结果，如果再一次求，我们可以直接返回了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;<span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; &amp;cache)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache[N].size() != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> cache[N];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; N;i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;left = allPossibleFBT(i, cache);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;right = allPossibleFBT(N - i - <span class=\"number\">1</span>, cache);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> l: left) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> r: right) &#123;</span><br><span class=\"line\">                TreeNode *node = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">                node-&gt;left = l;</span><br><span class=\"line\">                node-&gt;right = r;</span><br><span class=\"line\">                cache[N].push_back(node);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache[N];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; cache(<span class=\"number\">21</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    cache[<span class=\"number\">1</span>].push_back(<span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> allPossibleFBT(N, cache);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果熟悉动态规划的话，就会发现可以自顶向下的求解方式转成自底向上的求解方式，这里我们就不需要用递归去求解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; dp(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>].push_back(<span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size();i+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i];</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; i;j+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> l: dp[j]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> r: dp[i-j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                    TreeNode *node = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">                    node-&gt;left = copyTree(l);</span><br><span class=\"line\">                    node-&gt;right = copyTree(r);</span><br><span class=\"line\">                    dp[i].push_back(node);        </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，这份代码在<code>LeetCode</code>大概只能超过50%，如果要进一步，只有把<code>copyTree</code>去掉，直接赋值。这种方式是可行的，但是感觉只是在刷题时的一种技巧而已：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; dp(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>].push_back(<span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size();i+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i];</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; i;j+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> l: dp[j]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> r: dp[i-j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                    TreeNode *node = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">                    node-&gt;left = l;<span class=\"comment\">//copyTree(l);</span></span><br><span class=\"line\">                    node-&gt;right = r;<span class=\"comment\">//copyTree(r);</span></span><br><span class=\"line\">                    dp[i].push_back(node);        </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第18天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/all-possible-full-binary-trees/\"> All Possible Full Binary Trees </a>:</p>\n<hr>\n<p>A <em>full binary tree</em> is a binary tree where each node has exactly 0 or 2 children.</p>\n<p>Return a list of all possible full binary trees with <code>N</code> nodes. Each element of the answer is the root node of one possible tree.</p>\n<p>Each <code>node</code> of each tree in the answer <strong>must</strong> have <code>node.val = 0</code>.</p>\n<p>You may return the final list of trees in any order.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: 7</span><br><span class=\"line\">Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</span><br><span class=\"line\">Explanation:</span><br></pre></td></tr></table></figure>\n\n<p> <img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png\"></p>\n<p><strong>Note:</strong></p>\n<ul>\n<li><code>1 &lt;= N &lt;= 20</code></li>\n</ul>\n<hr>\n<p>这道题就是一个穷举的问题，我们知道完全二叉树的节点个数一定是奇数，所以可以先把<code>N</code>为偶数的输入先处理掉，然后就是怎么穷举的问题了。显然，一个完全二叉树的子树一定也是完全二叉树，所以我们可以以<code>1,3,5...,N-2</code>的方式穷举出出左子树中节点的个数<code>i</code>，已知左子树节点个数，那么右子树节点的个数就为<code>N-i-1</code>,我们先把左子树和右子树的可能都算出来，然后就再计算它们两两组合的所有可能即可得到所有节点个数为<code>N</code>的完全二叉树的情况。总的来说，就是一个大问题化简成小问题的思路。所以我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">copyTree</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    TreeNode *res = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    res-&gt;left = copyTree(root-&gt;left);</span><br><span class=\"line\">    res-&gt;right = copyTree(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; dp(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>].push_back(<span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size();i+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i];</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; i;j+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;left = dp[j];</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;right = dp[(i-j<span class=\"number\">-1</span>)];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;l: left) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;r: right) &#123;</span><br><span class=\"line\">                    TreeNode *node = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">                    node-&gt;left = copyTree(l);</span><br><span class=\"line\">                    node-&gt;right = copyTree(r);</span><br><span class=\"line\">                    dp[i].push_back(node);        </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后你会发现好像可以用一个数组来存在已经求解出来的结果，如果再一次求，我们可以直接返回了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;<span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; &amp;cache)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache[N].size() != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> cache[N];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; N;i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;left = allPossibleFBT(i, cache);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; &amp;right = allPossibleFBT(N - i - <span class=\"number\">1</span>, cache);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> l: left) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> r: right) &#123;</span><br><span class=\"line\">                TreeNode *node = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">                node-&gt;left = l;</span><br><span class=\"line\">                node-&gt;right = r;</span><br><span class=\"line\">                cache[N].push_back(node);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache[N];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; cache(<span class=\"number\">21</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    cache[<span class=\"number\">1</span>].push_back(<span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> allPossibleFBT(N, cache);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果熟悉动态规划的话，就会发现可以自顶向下的求解方式转成自底向上的求解方式，这里我们就不需要用递归去求解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; dp(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>].push_back(<span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size();i+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i];</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; i;j+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> l: dp[j]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> r: dp[i-j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                    TreeNode *node = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">                    node-&gt;left = copyTree(l);</span><br><span class=\"line\">                    node-&gt;right = copyTree(r);</span><br><span class=\"line\">                    dp[i].push_back(node);        </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，这份代码在<code>LeetCode</code>大概只能超过50%，如果要进一步，只有把<code>copyTree</code>去掉，直接赋值。这种方式是可行的，但是感觉只是在刷题时的一种技巧而已：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">allPossibleFBT</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;TreeNode*&gt;&gt; dp(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>].push_back(<span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size();i+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i];</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; i;j+=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> l: dp[j]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> r: dp[i-j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                    TreeNode *node = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">                    node-&gt;left = l;<span class=\"comment\">//copyTree(l);</span></span><br><span class=\"line\">                    node-&gt;right = r;<span class=\"comment\">//copyTree(r);</span></span><br><span class=\"line\">                    dp[i].push_back(node);        </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Array Nesting","date":"2019-03-12T01:55:49.000Z","_content":"\n> 第12天。\n\n今天的题目是[565. Array Nesting](https://leetcode.com/problems/array-nesting/)\n\n总感觉这道题是刷过的。这道题的输入是一个由0到 N-1 组成的数组，按照`S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } `的规则，找到`S[i]`最长的长度。\n\n显然按这种走法，这个数组会是由多个环组成的，也就是我们要找出最长那个环的长度，我们只需要简单的去寻找即可，而且一旦我们经过了某个元素，一定不会出现在其他人的环中了，所以我们可以将其赋值为-1表示已经使用过来。\n\n这样，我们的算法就是`O(n)`的复杂度了：\n\n```c++\nclass Solution {\npublic:\n    int arrayNesting(vector<int>& nums) {\n        \n        int res = 0;\n        for(int i = 0;i < nums.size(); i++) {\n            if (nums[i] < 0) continue;\n            res = max(res, helper(nums, i));\n        }\n        return res;\n    }\n    \n    int helper(vector<int> &nums, int index) {\n        int c = 0, j = nums[index];\n        nums[index] = -1;\n        while(j >= 0) {\n            int t = nums[j];\n            nums[j] = -1;\n            j = t;\n            c++;\n        }\n        return c;\n    }\n};\n```\n","source":"_posts/Array-Nesting.md","raw":"---\ntitle: Array Nesting\ndate: 2019-03-12T09:55:49.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第12天。\n\n今天的题目是[565. Array Nesting](https://leetcode.com/problems/array-nesting/)\n\n总感觉这道题是刷过的。这道题的输入是一个由0到 N-1 组成的数组，按照`S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } `的规则，找到`S[i]`最长的长度。\n\n显然按这种走法，这个数组会是由多个环组成的，也就是我们要找出最长那个环的长度，我们只需要简单的去寻找即可，而且一旦我们经过了某个元素，一定不会出现在其他人的环中了，所以我们可以将其赋值为-1表示已经使用过来。\n\n这样，我们的算法就是`O(n)`的复杂度了：\n\n```c++\nclass Solution {\npublic:\n    int arrayNesting(vector<int>& nums) {\n        \n        int res = 0;\n        for(int i = 0;i < nums.size(); i++) {\n            if (nums[i] < 0) continue;\n            res = max(res, helper(nums, i));\n        }\n        return res;\n    }\n    \n    int helper(vector<int> &nums, int index) {\n        int c = 0, j = nums[index];\n        nums[index] = -1;\n        while(j >= 0) {\n            int t = nums[j];\n            nums[j] = -1;\n            j = t;\n            c++;\n        }\n        return c;\n    }\n};\n```\n","slug":"Array-Nesting","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mn000nqmcm7ocm26vs","content":"<blockquote>\n<p>第12天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/array-nesting/\">565. Array Nesting</a></p>\n<p>总感觉这道题是刷过的。这道题的输入是一个由0到 N-1 组成的数组，按照<code>S[i] = &#123;A[i], A[A[i]], A[A[A[i]]], ... &#125; </code>的规则，找到<code>S[i]</code>最长的长度。</p>\n<p>显然按这种走法，这个数组会是由多个环组成的，也就是我们要找出最长那个环的长度，我们只需要简单的去寻找即可，而且一旦我们经过了某个元素，一定不会出现在其他人的环中了，所以我们可以将其赋值为-1表示已经使用过来。</p>\n<p>这样，我们的算法就是<code>O(n)</code>的复杂度了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayNesting</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            res = max(res, helper(nums, i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>, j = nums[index];</span><br><span class=\"line\">        nums[index] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = nums[j];</span><br><span class=\"line\">            nums[j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            j = t;</span><br><span class=\"line\">            c++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第12天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/array-nesting/\">565. Array Nesting</a></p>\n<p>总感觉这道题是刷过的。这道题的输入是一个由0到 N-1 组成的数组，按照<code>S[i] = &#123;A[i], A[A[i]], A[A[A[i]]], ... &#125; </code>的规则，找到<code>S[i]</code>最长的长度。</p>\n<p>显然按这种走法，这个数组会是由多个环组成的，也就是我们要找出最长那个环的长度，我们只需要简单的去寻找即可，而且一旦我们经过了某个元素，一定不会出现在其他人的环中了，所以我们可以将其赋值为-1表示已经使用过来。</p>\n<p>这样，我们的算法就是<code>O(n)</code>的复杂度了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayNesting</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            res = max(res, helper(nums, i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>, j = nums[index];</span><br><span class=\"line\">        nums[index] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = nums[j];</span><br><span class=\"line\">            nums[j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            j = t;</span><br><span class=\"line\">            c++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Asteroid Collision","date":"2020-01-06T02:46:09.000Z","_content":"\n> 第57天。\n\n今天的题目是[Asteroid Collision](https://leetcode.com/problems/asteroid-collision/submissions/):\n\n用栈去模拟整个过程，因为`STL`中的栈没法直接顺序迭代出来，所以我们用`vector`模拟一个栈出来使用。\n\n不难发现，最终的结果一定是小于 0 的值在前面，而大于 0 的值在后面，所以我们只用栈维护大于 0 的值。而小于 0 的值如果前面没有 大于 0 的值的话（即已经确定没有碰撞后），直接将其放入答案中。又因为我们是用`vector`进行的模拟，所以可以在维护栈顶指针的时候也维护一个栈底指针来实现：\n\n```c++\nvector<int> asteroidCollision(vector<int>& asteroids) {\n    int size = asteroids.size();\n    if (size == 0) return vector<int>();\n    vector<int> st(size);\n    int top, beg;\n    for(beg = 0;beg < size && asteroids[beg] < 0; beg++) st[beg] = asteroids[beg];\n    top = beg;\n    for(int i = beg; i < size;i++) {\n        int a = asteroids[i];\n        if (top == beg) { \n            st[top++] = a;\n            if (a < 0) beg++;\n        }\n        else if (a > 0) st[top++] = a;\n        else if (st[top-1] == -a) top--;\n        else if (st[top-1] > -a) /* do nothing */;\n        else {\n            while(top != beg && st[top-1] < -a)\n                top--;\n            if (top != beg && st[top-1] == -a) top--;\n            else if (top == beg) {\n                st[top] = a;\n                top = beg = beg + 1;\n            }\n        }\n    }\n    return vector<int>(st.begin(), st.begin() + top);\n}\n```\n\n","source":"_posts/Asteroid-Collision.md","raw":"---\ntitle: Asteroid Collision\ndate: 2020-01-06T10:46:09.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第57天。\n\n今天的题目是[Asteroid Collision](https://leetcode.com/problems/asteroid-collision/submissions/):\n\n用栈去模拟整个过程，因为`STL`中的栈没法直接顺序迭代出来，所以我们用`vector`模拟一个栈出来使用。\n\n不难发现，最终的结果一定是小于 0 的值在前面，而大于 0 的值在后面，所以我们只用栈维护大于 0 的值。而小于 0 的值如果前面没有 大于 0 的值的话（即已经确定没有碰撞后），直接将其放入答案中。又因为我们是用`vector`进行的模拟，所以可以在维护栈顶指针的时候也维护一个栈底指针来实现：\n\n```c++\nvector<int> asteroidCollision(vector<int>& asteroids) {\n    int size = asteroids.size();\n    if (size == 0) return vector<int>();\n    vector<int> st(size);\n    int top, beg;\n    for(beg = 0;beg < size && asteroids[beg] < 0; beg++) st[beg] = asteroids[beg];\n    top = beg;\n    for(int i = beg; i < size;i++) {\n        int a = asteroids[i];\n        if (top == beg) { \n            st[top++] = a;\n            if (a < 0) beg++;\n        }\n        else if (a > 0) st[top++] = a;\n        else if (st[top-1] == -a) top--;\n        else if (st[top-1] > -a) /* do nothing */;\n        else {\n            while(top != beg && st[top-1] < -a)\n                top--;\n            if (top != beg && st[top-1] == -a) top--;\n            else if (top == beg) {\n                st[top] = a;\n                top = beg = beg + 1;\n            }\n        }\n    }\n    return vector<int>(st.begin(), st.begin() + top);\n}\n```\n\n","slug":"Asteroid-Collision","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mo000qqmcmh9ul1n3i","content":"<blockquote>\n<p>第57天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/asteroid-collision/submissions/\">Asteroid Collision</a>:</p>\n<p>用栈去模拟整个过程，因为<code>STL</code>中的栈没法直接顺序迭代出来，所以我们用<code>vector</code>模拟一个栈出来使用。</p>\n<p>不难发现，最终的结果一定是小于 0 的值在前面，而大于 0 的值在后面，所以我们只用栈维护大于 0 的值。而小于 0 的值如果前面没有 大于 0 的值的话（即已经确定没有碰撞后），直接将其放入答案中。又因为我们是用<code>vector</code>进行的模拟，所以可以在维护栈顶指针的时候也维护一个栈底指针来实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">asteroidCollision</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; asteroids)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = asteroids.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">st</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top, beg;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(beg = <span class=\"number\">0</span>;beg &lt; size &amp;&amp; asteroids[beg] &lt; <span class=\"number\">0</span>; beg++) st[beg] = asteroids[beg];</span><br><span class=\"line\">    top = beg;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg; i &lt; size;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = asteroids[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (top == beg) &#123; </span><br><span class=\"line\">            st[top++] = a;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span>) beg++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span>) st[top++] = a;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (st[top<span class=\"number\">-1</span>] == -a) top--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (st[top<span class=\"number\">-1</span>] &gt; -a) <span class=\"comment\">/* do nothing */</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(top != beg &amp;&amp; st[top<span class=\"number\">-1</span>] &lt; -a)</span><br><span class=\"line\">                top--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top != beg &amp;&amp; st[top<span class=\"number\">-1</span>] == -a) top--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (top == beg) &#123;</span><br><span class=\"line\">                st[top] = a;</span><br><span class=\"line\">                top = beg = beg + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(st.begin(), st.begin() + top);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第57天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/asteroid-collision/submissions/\">Asteroid Collision</a>:</p>\n<p>用栈去模拟整个过程，因为<code>STL</code>中的栈没法直接顺序迭代出来，所以我们用<code>vector</code>模拟一个栈出来使用。</p>\n<p>不难发现，最终的结果一定是小于 0 的值在前面，而大于 0 的值在后面，所以我们只用栈维护大于 0 的值。而小于 0 的值如果前面没有 大于 0 的值的话（即已经确定没有碰撞后），直接将其放入答案中。又因为我们是用<code>vector</code>进行的模拟，所以可以在维护栈顶指针的时候也维护一个栈底指针来实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">asteroidCollision</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; asteroids)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = asteroids.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">st</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top, beg;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(beg = <span class=\"number\">0</span>;beg &lt; size &amp;&amp; asteroids[beg] &lt; <span class=\"number\">0</span>; beg++) st[beg] = asteroids[beg];</span><br><span class=\"line\">    top = beg;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg; i &lt; size;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = asteroids[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (top == beg) &#123; </span><br><span class=\"line\">            st[top++] = a;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span>) beg++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span>) st[top++] = a;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (st[top<span class=\"number\">-1</span>] == -a) top--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (st[top<span class=\"number\">-1</span>] &gt; -a) <span class=\"comment\">/* do nothing */</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(top != beg &amp;&amp; st[top<span class=\"number\">-1</span>] &lt; -a)</span><br><span class=\"line\">                top--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top != beg &amp;&amp; st[top<span class=\"number\">-1</span>] == -a) top--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (top == beg) &#123;</span><br><span class=\"line\">                st[top] = a;</span><br><span class=\"line\">                top = beg = beg + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(st.begin(), st.begin() + top);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Balanced Binary Tree","date":"2017-11-13T13:08:54.000Z","_content":"\n第47天。\n\n今天的题目是[Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/description/):\n\n> Given a binary tree, determine if it is height-balanced.\n>\n> For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n题目意思是对这个树的每个结点来说它左子树和右子树的高度差都不大于1,我们可以把它转换成一个求高度的问题：\n\n```c++\nbool isBalanced(TreeNode* root) {\n    int h = 0;\n    return isBalanced(root,h);\n}\nbool isBalanced(TreeNode *root,int &height) {\n    if (root == nullptr) { height = 0; return true; }\n    int left,right;\n    if (!isBalanced(root->left,left) || !isBalanced(root->right,right))\n        return false;\n\n    if (abs(left - right) > 1) return false;\n\n    height = max(left,right) + 1;\n    return true;\n}\n```\n\n准备把主力语言往`python`和`c`上靠，所以以后都会写多一个`python`的解法。\n\n```python\nclass Solution:\n    def isBalanced(self,root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        res,height = self.isBalancedRec(root)\n        return res\n\n    def isBalancedRec(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool,int\n        \"\"\"\n        if root is None:\n            return True,0\n\n        leftRes,leftH = self.isBalancedRec(root.left)\n        rightRes,rightH = self.isBalancedRec(root.right)\n\n        if leftRes == False or rightRes == False:\n            return False,max(leftH,rightH)\n        else:\n            return abs(leftH-rightH) <= 1,max(leftH,rightH)+1\n```\n","source":"_posts/Balanced-Binary-Tree.md","raw":"---\ntitle: Balanced Binary Tree\ndate: 2017-11-13T21:08:54.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第47天。\n\n今天的题目是[Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/description/):\n\n> Given a binary tree, determine if it is height-balanced.\n>\n> For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n题目意思是对这个树的每个结点来说它左子树和右子树的高度差都不大于1,我们可以把它转换成一个求高度的问题：\n\n```c++\nbool isBalanced(TreeNode* root) {\n    int h = 0;\n    return isBalanced(root,h);\n}\nbool isBalanced(TreeNode *root,int &height) {\n    if (root == nullptr) { height = 0; return true; }\n    int left,right;\n    if (!isBalanced(root->left,left) || !isBalanced(root->right,right))\n        return false;\n\n    if (abs(left - right) > 1) return false;\n\n    height = max(left,right) + 1;\n    return true;\n}\n```\n\n准备把主力语言往`python`和`c`上靠，所以以后都会写多一个`python`的解法。\n\n```python\nclass Solution:\n    def isBalanced(self,root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        res,height = self.isBalancedRec(root)\n        return res\n\n    def isBalancedRec(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool,int\n        \"\"\"\n        if root is None:\n            return True,0\n\n        leftRes,leftH = self.isBalancedRec(root.left)\n        rightRes,rightH = self.isBalancedRec(root.right)\n\n        if leftRes == False or rightRes == False:\n            return False,max(leftH,rightH)\n        else:\n            return abs(leftH-rightH) <= 1,max(leftH,rightH)+1\n```\n","slug":"Balanced-Binary-Tree","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mp000uqmcmfiakeob1","content":"<p>第47天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/balanced-binary-tree/description/\">Balanced Binary Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, determine if it is height-balanced.</p>\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>\n</blockquote>\n<p>题目意思是对这个树的每个结点来说它左子树和右子树的高度差都不大于1,我们可以把它转换成一个求高度的问题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isBalanced(root,h);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> &amp;height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123; height = <span class=\"number\">0</span>; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left,right;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isBalanced(root-&gt;left,left) || !isBalanced(root-&gt;right,right))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(left - right) &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    height = max(left,right) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备把主力语言往<code>python</code>和<code>c</code>上靠，所以以后都会写多一个<code>python</code>的解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span>(<span class=\"params\">self,root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        res,height = self.isBalancedRec(root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalancedRec</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool,int</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        leftRes,leftH = self.isBalancedRec(root.left)</span><br><span class=\"line\">        rightRes,rightH = self.isBalancedRec(root.right)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> leftRes == <span class=\"literal\">False</span> <span class=\"keyword\">or</span> rightRes == <span class=\"literal\">False</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span>,<span class=\"built_in\">max</span>(leftH,rightH)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(leftH-rightH) &lt;= <span class=\"number\">1</span>,<span class=\"built_in\">max</span>(leftH,rightH)+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第47天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/balanced-binary-tree/description/\">Balanced Binary Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, determine if it is height-balanced.</p>\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>\n</blockquote>\n<p>题目意思是对这个树的每个结点来说它左子树和右子树的高度差都不大于1,我们可以把它转换成一个求高度的问题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isBalanced(root,h);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> &amp;height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123; height = <span class=\"number\">0</span>; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left,right;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isBalanced(root-&gt;left,left) || !isBalanced(root-&gt;right,right))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(left - right) &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    height = max(left,right) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备把主力语言往<code>python</code>和<code>c</code>上靠，所以以后都会写多一个<code>python</code>的解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span>(<span class=\"params\">self,root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        res,height = self.isBalancedRec(root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalancedRec</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool,int</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        leftRes,leftH = self.isBalancedRec(root.left)</span><br><span class=\"line\">        rightRes,rightH = self.isBalancedRec(root.right)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> leftRes == <span class=\"literal\">False</span> <span class=\"keyword\">or</span> rightRes == <span class=\"literal\">False</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span>,<span class=\"built_in\">max</span>(leftH,rightH)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(leftH-rightH) &lt;= <span class=\"number\">1</span>,<span class=\"built_in\">max</span>(leftH,rightH)+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Best Sightseeing Pair","date":"2019-12-04T10:58:44.000Z","_content":"\n> 第28天。\n\n今天的题目是[Best Sightseeing Pair](https://leetcode.com/problems/best-sightseeing-pair/):\n\n这道题的关键就是什么时候移动 i 这个下标，我们观察一下这个公式：`A[i] + A[j] + i - j`，转化一下就成了`(A[i] + i) + (A[j] - j)`，因此如果存在两个`i`，即`i1`和`i2`的话，当`A[i1] + i1 > A[i2] + i2`成立时，我们就可以用 `i2`去替代原来的`i1`。至于`j`的话，我们只需要从头到尾遍历一遍即可，同时在穷举`j`的时候，可以顺便穷举出`i`：\n\n```c++\nint maxScoreSightseeingPair(vector<int>& A) {\n    int size =  A.size();\n    int res = 0;\n    if (size == 0) return res;\n    \n    for(int i = 0, j = 1;j < size; j++) {\n        res = max(res, A[i] + A[j] + i - j);\n        if (A[j] + j > A[i] + i) i = j;\n    }\n    \n    return res;\n}\n```\n\n我们把式子重写成`A[j] + (A[i] + i - j)`，随着`j++`，`i - j`会减一，如果不改变 `i`的话，`(A[i] + i - j)`相比于之前就只是减一而已，如果要改变的话，`A[i] + i - j = A[j] - 1`,则我们可以将循环简化成：\n\n```c+=\nint maxScoreSightseeingPair(vector<int>& A) {\n    int size =  A.size();\n    int res = 0;\n    if (size == 0) return res;\n    int cur = 0;\n    for(int j = 0;j < size; j++) {\n        res = max(res, cur + A[j]);\n        cur = max(cur, A[j]) - 1;\n    }\n    \n    return res;\n}\n```\n","source":"_posts/Best-Sightseeing-Pair.md","raw":"---\ntitle: Best Sightseeing Pair\ndate: 2019-12-04T18:58:44.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第28天。\n\n今天的题目是[Best Sightseeing Pair](https://leetcode.com/problems/best-sightseeing-pair/):\n\n这道题的关键就是什么时候移动 i 这个下标，我们观察一下这个公式：`A[i] + A[j] + i - j`，转化一下就成了`(A[i] + i) + (A[j] - j)`，因此如果存在两个`i`，即`i1`和`i2`的话，当`A[i1] + i1 > A[i2] + i2`成立时，我们就可以用 `i2`去替代原来的`i1`。至于`j`的话，我们只需要从头到尾遍历一遍即可，同时在穷举`j`的时候，可以顺便穷举出`i`：\n\n```c++\nint maxScoreSightseeingPair(vector<int>& A) {\n    int size =  A.size();\n    int res = 0;\n    if (size == 0) return res;\n    \n    for(int i = 0, j = 1;j < size; j++) {\n        res = max(res, A[i] + A[j] + i - j);\n        if (A[j] + j > A[i] + i) i = j;\n    }\n    \n    return res;\n}\n```\n\n我们把式子重写成`A[j] + (A[i] + i - j)`，随着`j++`，`i - j`会减一，如果不改变 `i`的话，`(A[i] + i - j)`相比于之前就只是减一而已，如果要改变的话，`A[i] + i - j = A[j] - 1`,则我们可以将循环简化成：\n\n```c+=\nint maxScoreSightseeingPair(vector<int>& A) {\n    int size =  A.size();\n    int res = 0;\n    if (size == 0) return res;\n    int cur = 0;\n    for(int j = 0;j < size; j++) {\n        res = max(res, cur + A[j]);\n        cur = max(cur, A[j]) - 1;\n    }\n    \n    return res;\n}\n```\n","slug":"Best-Sightseeing-Pair","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mp000xqmcmfahh9eyi","content":"<blockquote>\n<p>第28天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/best-sightseeing-pair/\">Best Sightseeing Pair</a>:</p>\n<p>这道题的关键就是什么时候移动 i 这个下标，我们观察一下这个公式：<code>A[i] + A[j] + i - j</code>，转化一下就成了<code>(A[i] + i) + (A[j] - j)</code>，因此如果存在两个<code>i</code>，即<code>i1</code>和<code>i2</code>的话，当<code>A[i1] + i1 &gt; A[i2] + i2</code>成立时，我们就可以用 <code>i2</code>去替代原来的<code>i1</code>。至于<code>j</code>的话，我们只需要从头到尾遍历一遍即可，同时在穷举<code>j</code>的时候，可以顺便穷举出<code>i</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxScoreSightseeingPair</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size =  A.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">1</span>;j &lt; size; j++) &#123;</span><br><span class=\"line\">        res = max(res, A[i] + A[j] + i - j);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[j] + j &gt; A[i] + i) i = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们把式子重写成<code>A[j] + (A[i] + i - j)</code>，随着<code>j++</code>，<code>i - j</code>会减一，如果不改变 <code>i</code>的话，<code>(A[i] + i - j)</code>相比于之前就只是减一而已，如果要改变的话，<code>A[i] + i - j = A[j] - 1</code>,则我们可以将循环简化成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123;</span><br><span class=\"line\">    int size &#x3D;  A.size();</span><br><span class=\"line\">    int res &#x3D; 0;</span><br><span class=\"line\">    if (size &#x3D;&#x3D; 0) return res;</span><br><span class=\"line\">    int cur &#x3D; 0;</span><br><span class=\"line\">    for(int j &#x3D; 0;j &lt; size; j++) &#123;</span><br><span class=\"line\">        res &#x3D; max(res, cur + A[j]);</span><br><span class=\"line\">        cur &#x3D; max(cur, A[j]) - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第28天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/best-sightseeing-pair/\">Best Sightseeing Pair</a>:</p>\n<p>这道题的关键就是什么时候移动 i 这个下标，我们观察一下这个公式：<code>A[i] + A[j] + i - j</code>，转化一下就成了<code>(A[i] + i) + (A[j] - j)</code>，因此如果存在两个<code>i</code>，即<code>i1</code>和<code>i2</code>的话，当<code>A[i1] + i1 &gt; A[i2] + i2</code>成立时，我们就可以用 <code>i2</code>去替代原来的<code>i1</code>。至于<code>j</code>的话，我们只需要从头到尾遍历一遍即可，同时在穷举<code>j</code>的时候，可以顺便穷举出<code>i</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxScoreSightseeingPair</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size =  A.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">1</span>;j &lt; size; j++) &#123;</span><br><span class=\"line\">        res = max(res, A[i] + A[j] + i - j);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[j] + j &gt; A[i] + i) i = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们把式子重写成<code>A[j] + (A[i] + i - j)</code>，随着<code>j++</code>，<code>i - j</code>会减一，如果不改变 <code>i</code>的话，<code>(A[i] + i - j)</code>相比于之前就只是减一而已，如果要改变的话，<code>A[i] + i - j = A[j] - 1</code>,则我们可以将循环简化成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123;</span><br><span class=\"line\">    int size &#x3D;  A.size();</span><br><span class=\"line\">    int res &#x3D; 0;</span><br><span class=\"line\">    if (size &#x3D;&#x3D; 0) return res;</span><br><span class=\"line\">    int cur &#x3D; 0;</span><br><span class=\"line\">    for(int j &#x3D; 0;j &lt; size; j++) &#123;</span><br><span class=\"line\">        res &#x3D; max(res, cur + A[j]);</span><br><span class=\"line\">        cur &#x3D; max(cur, A[j]) - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Best Time to Buy and Sell Stock with Transaction Fee","date":"2017-10-28T05:34:16.000Z","_content":"\n第34天。\n\n今天又没做出来，sad，同样是一道DP的题目：\n\n> Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.\n>\n> You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)\n>\n> Return the maximum profit you can make.\n> Example 1:\n> Input: prices = [1, 3, 2, 8, 4, 9], fee = 2\n> Output: 8\n> Explanation: The maximum profit can be achieved by:\n> Buying at prices[0] = 1\n> Selling at prices[3] = 8\n> Buying at prices[4] = 4\n> Selling at prices[5] = 9\n> The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n> Note:\n> 0 < prices.length <= 50000.\n> 0 < prices[i] < 50000.\n> 0 <= fee < 50000.\n\n先理解一下题意先，大概是输入是一个表示股票价格的数组`prices`以及一个表示交易费用的`fee`,这个`fee`在每次交易的时候都需要支付。\n\n然后很自然的我们会用一个`profit`的数组来记录，每天能达到的最大`profit`，然后我们也比较容易写出一个递推式：\n`profit[i] = max(profit[j],profit[j] + prices[i] - prices[j] -fee) for j in range(0,i)`\n\n然后就写出了一个`O(n^2)`的算法：\n\n```c++\nint maxProfit(vector<int>& prices, int fee) {\n    if (prices.size() == 0) return 0;\n    vector<int> profit(prices.size(),0);\n    profit[0] = 0;\n    for(int i = 1;i < profit.size();i++) {\n        for(int j = i-1;j>=0;j--) {\n            profit[i] = max(profit[i],profit[j]);\n            int t = profit[j] + prices[i] - prices[j] - fee;\n            profit[i] = max(profit[i],t);\n        }\n    }\n    return *profit.rbegin();\n}\n```\n\n然后就时间超限了。\n\n想了一个早上也没能解决，很好又一次被`KMP`的`next`误导了，又是打算用加快内层循环的方式去做，但是还是会出现时间超限的问题。\n\n哎，还是来看看`dicuss`中的解法吧：\n\n```c++\nint maxProfit(vector<int>& prices, int fee) {\n    int s0 = 0,s1 = INT_MIN;\n    for(auto p:prices) {\n        int t = s0;\n        s0 = max(s0,s1+p);      //sell\n        s1 = max(s1,t-p-fee);   //buy\n    }\n    return s0;\n}\n```\n\n前面的解法之所以会出现超时，就是因为他的时间复杂度为`O(n^2)`,而`dicuss`中的解法却是`O(n)`的，这里的`s0`和第一个方法的`profit`是一样的，重要的s1.\n\n我们知道一次交易可以分为`buy`和`sell`,他们消耗一次`fee`，那么我们可以将这个`fee`归入到`buy`的时候，如果当前操作是`buy`,那么必须保证我们当前没有股票，也就是说上一次操作是`sell`,这里的`s0`就是表示没有股票的状态，`s1`表示是有股票的状态。\n\n对于`s0`,我们想要更新它，就只有将上一个`s1`卖出，然后取最大值\n对于`s1`，我们要更新它，就只有将当前股票买入，然后取最大值。\n\n所以就得到了上面的两条式子。\n\n\n\n","source":"_posts/Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee.md","raw":"---\ntitle: Best Time to Buy and Sell Stock with Transaction Fee\ndate: 2017-10-28T13:34:16.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - DP\n---\n\n第34天。\n\n今天又没做出来，sad，同样是一道DP的题目：\n\n> Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.\n>\n> You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)\n>\n> Return the maximum profit you can make.\n> Example 1:\n> Input: prices = [1, 3, 2, 8, 4, 9], fee = 2\n> Output: 8\n> Explanation: The maximum profit can be achieved by:\n> Buying at prices[0] = 1\n> Selling at prices[3] = 8\n> Buying at prices[4] = 4\n> Selling at prices[5] = 9\n> The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n> Note:\n> 0 < prices.length <= 50000.\n> 0 < prices[i] < 50000.\n> 0 <= fee < 50000.\n\n先理解一下题意先，大概是输入是一个表示股票价格的数组`prices`以及一个表示交易费用的`fee`,这个`fee`在每次交易的时候都需要支付。\n\n然后很自然的我们会用一个`profit`的数组来记录，每天能达到的最大`profit`，然后我们也比较容易写出一个递推式：\n`profit[i] = max(profit[j],profit[j] + prices[i] - prices[j] -fee) for j in range(0,i)`\n\n然后就写出了一个`O(n^2)`的算法：\n\n```c++\nint maxProfit(vector<int>& prices, int fee) {\n    if (prices.size() == 0) return 0;\n    vector<int> profit(prices.size(),0);\n    profit[0] = 0;\n    for(int i = 1;i < profit.size();i++) {\n        for(int j = i-1;j>=0;j--) {\n            profit[i] = max(profit[i],profit[j]);\n            int t = profit[j] + prices[i] - prices[j] - fee;\n            profit[i] = max(profit[i],t);\n        }\n    }\n    return *profit.rbegin();\n}\n```\n\n然后就时间超限了。\n\n想了一个早上也没能解决，很好又一次被`KMP`的`next`误导了，又是打算用加快内层循环的方式去做，但是还是会出现时间超限的问题。\n\n哎，还是来看看`dicuss`中的解法吧：\n\n```c++\nint maxProfit(vector<int>& prices, int fee) {\n    int s0 = 0,s1 = INT_MIN;\n    for(auto p:prices) {\n        int t = s0;\n        s0 = max(s0,s1+p);      //sell\n        s1 = max(s1,t-p-fee);   //buy\n    }\n    return s0;\n}\n```\n\n前面的解法之所以会出现超时，就是因为他的时间复杂度为`O(n^2)`,而`dicuss`中的解法却是`O(n)`的，这里的`s0`和第一个方法的`profit`是一样的，重要的s1.\n\n我们知道一次交易可以分为`buy`和`sell`,他们消耗一次`fee`，那么我们可以将这个`fee`归入到`buy`的时候，如果当前操作是`buy`,那么必须保证我们当前没有股票，也就是说上一次操作是`sell`,这里的`s0`就是表示没有股票的状态，`s1`表示是有股票的状态。\n\n对于`s0`,我们想要更新它，就只有将上一个`s1`卖出，然后取最大值\n对于`s1`，我们要更新它，就只有将当前股票买入，然后取最大值。\n\n所以就得到了上面的两条式子。\n\n\n\n","slug":"Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mq0011qmcmgtzqhs1b","content":"<p>第34天。</p>\n<p>今天又没做出来，sad，同样是一道DP的题目：</p>\n<blockquote>\n<p>Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.</p>\n<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>\n<p>Return the maximum profit you can make.<br>Example 1:<br>Input: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>Output: 8<br>Explanation: The maximum profit can be achieved by:<br>Buying at prices[0] = 1<br>Selling at prices[3] = 8<br>Buying at prices[4] = 4<br>Selling at prices[5] = 9<br>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br>Note:<br>0 &lt; prices.length &lt;= 50000.<br>0 &lt; prices[i] &lt; 50000.<br>0 &lt;= fee &lt; 50000.</p>\n</blockquote>\n<p>先理解一下题意先，大概是输入是一个表示股票价格的数组<code>prices</code>以及一个表示交易费用的<code>fee</code>,这个<code>fee</code>在每次交易的时候都需要支付。</p>\n<p>然后很自然的我们会用一个<code>profit</code>的数组来记录，每天能达到的最大<code>profit</code>，然后我们也比较容易写出一个递推式：<br><code>profit[i] = max(profit[j],profit[j] + prices[i] - prices[j] -fee) for j in range(0,i)</code></p>\n<p>然后就写出了一个<code>O(n^2)</code>的算法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices, <span class=\"keyword\">int</span> fee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">profit</span><span class=\"params\">(prices.size(),<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    profit[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; profit.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">0</span>;j--) &#123;</span><br><span class=\"line\">            profit[i] = max(profit[i],profit[j]);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = profit[j] + prices[i] - prices[j] - fee;</span><br><span class=\"line\">            profit[i] = max(profit[i],t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *profit.rbegin();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就时间超限了。</p>\n<p>想了一个早上也没能解决，很好又一次被<code>KMP</code>的<code>next</code>误导了，又是打算用加快内层循环的方式去做，但是还是会出现时间超限的问题。</p>\n<p>哎，还是来看看<code>dicuss</code>中的解法吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices, <span class=\"keyword\">int</span> fee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s0 = <span class=\"number\">0</span>,s1 = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p:prices) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = s0;</span><br><span class=\"line\">        s0 = max(s0,s1+p);      <span class=\"comment\">//sell</span></span><br><span class=\"line\">        s1 = max(s1,t-p-fee);   <span class=\"comment\">//buy</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面的解法之所以会出现超时，就是因为他的时间复杂度为<code>O(n^2)</code>,而<code>dicuss</code>中的解法却是<code>O(n)</code>的，这里的<code>s0</code>和第一个方法的<code>profit</code>是一样的，重要的s1.</p>\n<p>我们知道一次交易可以分为<code>buy</code>和<code>sell</code>,他们消耗一次<code>fee</code>，那么我们可以将这个<code>fee</code>归入到<code>buy</code>的时候，如果当前操作是<code>buy</code>,那么必须保证我们当前没有股票，也就是说上一次操作是<code>sell</code>,这里的<code>s0</code>就是表示没有股票的状态，<code>s1</code>表示是有股票的状态。</p>\n<p>对于<code>s0</code>,我们想要更新它，就只有将上一个<code>s1</code>卖出，然后取最大值<br>对于<code>s1</code>，我们要更新它，就只有将当前股票买入，然后取最大值。</p>\n<p>所以就得到了上面的两条式子。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第34天。</p>\n<p>今天又没做出来，sad，同样是一道DP的题目：</p>\n<blockquote>\n<p>Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.</p>\n<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>\n<p>Return the maximum profit you can make.<br>Example 1:<br>Input: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>Output: 8<br>Explanation: The maximum profit can be achieved by:<br>Buying at prices[0] = 1<br>Selling at prices[3] = 8<br>Buying at prices[4] = 4<br>Selling at prices[5] = 9<br>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br>Note:<br>0 &lt; prices.length &lt;= 50000.<br>0 &lt; prices[i] &lt; 50000.<br>0 &lt;= fee &lt; 50000.</p>\n</blockquote>\n<p>先理解一下题意先，大概是输入是一个表示股票价格的数组<code>prices</code>以及一个表示交易费用的<code>fee</code>,这个<code>fee</code>在每次交易的时候都需要支付。</p>\n<p>然后很自然的我们会用一个<code>profit</code>的数组来记录，每天能达到的最大<code>profit</code>，然后我们也比较容易写出一个递推式：<br><code>profit[i] = max(profit[j],profit[j] + prices[i] - prices[j] -fee) for j in range(0,i)</code></p>\n<p>然后就写出了一个<code>O(n^2)</code>的算法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices, <span class=\"keyword\">int</span> fee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">profit</span><span class=\"params\">(prices.size(),<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    profit[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; profit.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">0</span>;j--) &#123;</span><br><span class=\"line\">            profit[i] = max(profit[i],profit[j]);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = profit[j] + prices[i] - prices[j] - fee;</span><br><span class=\"line\">            profit[i] = max(profit[i],t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *profit.rbegin();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就时间超限了。</p>\n<p>想了一个早上也没能解决，很好又一次被<code>KMP</code>的<code>next</code>误导了，又是打算用加快内层循环的方式去做，但是还是会出现时间超限的问题。</p>\n<p>哎，还是来看看<code>dicuss</code>中的解法吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices, <span class=\"keyword\">int</span> fee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s0 = <span class=\"number\">0</span>,s1 = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p:prices) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = s0;</span><br><span class=\"line\">        s0 = max(s0,s1+p);      <span class=\"comment\">//sell</span></span><br><span class=\"line\">        s1 = max(s1,t-p-fee);   <span class=\"comment\">//buy</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面的解法之所以会出现超时，就是因为他的时间复杂度为<code>O(n^2)</code>,而<code>dicuss</code>中的解法却是<code>O(n)</code>的，这里的<code>s0</code>和第一个方法的<code>profit</code>是一样的，重要的s1.</p>\n<p>我们知道一次交易可以分为<code>buy</code>和<code>sell</code>,他们消耗一次<code>fee</code>，那么我们可以将这个<code>fee</code>归入到<code>buy</code>的时候，如果当前操作是<code>buy</code>,那么必须保证我们当前没有股票，也就是说上一次操作是<code>sell</code>,这里的<code>s0</code>就是表示没有股票的状态，<code>s1</code>表示是有股票的状态。</p>\n<p>对于<code>s0</code>,我们想要更新它，就只有将上一个<code>s1</code>卖出，然后取最大值<br>对于<code>s1</code>，我们要更新它，就只有将当前股票买入，然后取最大值。</p>\n<p>所以就得到了上面的两条式子。</p>\n"},{"title":"Best Time to Buy and Sell Stock","date":"2017-11-15T00:05:42.000Z","_content":"\n第49天。\n\n今天的题目是[Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/):\n\n> Say you have an array for which the ith element is the price of a given stock on day i.\n>\n> If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\n>\n> Example 1:\n> Input: [7, 1, 5, 3, 6, 4]\n> Output: 5\n>\n> max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)\n> Example 2:\n> Input: [7, 6, 4, 3, 1]\n> Output: 0\n>\n> In this case, no transaction is done, i.e. max profit = 0.\n\n之前好像做过一道类似的题目，但是那道题比这道题难多了，那道题是可以多次买入卖出的，而成每次交易是需要支付一定费用的，这道就简单多了，我们只需要记录当前最小元素，然后每次更新最小元素，然后记录当前元素与最小元素的差值即可。\n\n```python\ndef maxProfit(self, prices):\n    \"\"\"\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    profit,minElem = 0,sys.maxsize\n    for p in prices:\n        if p < minElem:\n            minElem = p\n        t = p - minElem\n        if t > profit:\n            profit = t\n    return profit\n```\n\n然后是`c++`的解：\n\n```c++\nint maxProfit(vector<int> &prices) {\n    int maxPro = 0;\n    int minPrice = INT_MAX;\n    for(int i = 0; i < prices.size(); i++){\n        minPrice = min(minPrice, prices[i]);\n        maxPro = max(maxPro, prices[i] - minPrice);\n    }\n    return maxPro;\n}\n```\n\n以及在`dicuss`中看到的：\n\n```java\npublic int maxProfit(int[] prices) {\n    int maxCur = 0, maxSoFar = 0;\n    for(int i = 1; i < prices.length; i++) {\n        maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\n        maxSoFar = Math.max(maxCur, maxSoFar);\n    }\n    return maxSoFar;\n}\n```\n","source":"_posts/Best-Time-to-Buy-and-Sell-Stock.md","raw":"---\ntitle: Best Time to Buy and Sell Stock\ndate: 2017-11-15T08:05:42.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第49天。\n\n今天的题目是[Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/):\n\n> Say you have an array for which the ith element is the price of a given stock on day i.\n>\n> If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\n>\n> Example 1:\n> Input: [7, 1, 5, 3, 6, 4]\n> Output: 5\n>\n> max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)\n> Example 2:\n> Input: [7, 6, 4, 3, 1]\n> Output: 0\n>\n> In this case, no transaction is done, i.e. max profit = 0.\n\n之前好像做过一道类似的题目，但是那道题比这道题难多了，那道题是可以多次买入卖出的，而成每次交易是需要支付一定费用的，这道就简单多了，我们只需要记录当前最小元素，然后每次更新最小元素，然后记录当前元素与最小元素的差值即可。\n\n```python\ndef maxProfit(self, prices):\n    \"\"\"\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    profit,minElem = 0,sys.maxsize\n    for p in prices:\n        if p < minElem:\n            minElem = p\n        t = p - minElem\n        if t > profit:\n            profit = t\n    return profit\n```\n\n然后是`c++`的解：\n\n```c++\nint maxProfit(vector<int> &prices) {\n    int maxPro = 0;\n    int minPrice = INT_MAX;\n    for(int i = 0; i < prices.size(); i++){\n        minPrice = min(minPrice, prices[i]);\n        maxPro = max(maxPro, prices[i] - minPrice);\n    }\n    return maxPro;\n}\n```\n\n以及在`dicuss`中看到的：\n\n```java\npublic int maxProfit(int[] prices) {\n    int maxCur = 0, maxSoFar = 0;\n    for(int i = 1; i < prices.length; i++) {\n        maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\n        maxSoFar = Math.max(maxCur, maxSoFar);\n    }\n    return maxSoFar;\n}\n```\n","slug":"Best-Time-to-Buy-and-Sell-Stock","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mr0014qmcmgb7a912y","content":"<p>第49天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/\">Best Time to Buy and Sell Stock</a>:</p>\n<blockquote>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>\n<p>Example 1:<br>Input: [7, 1, 5, 3, 6, 4]<br>Output: 5</p>\n<p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)<br>Example 2:<br>Input: [7, 6, 4, 3, 1]<br>Output: 0</p>\n<p>In this case, no transaction is done, i.e. max profit = 0.</p>\n</blockquote>\n<p>之前好像做过一道类似的题目，但是那道题比这道题难多了，那道题是可以多次买入卖出的，而成每次交易是需要支付一定费用的，这道就简单多了，我们只需要记录当前最小元素，然后每次更新最小元素，然后记录当前元素与最小元素的差值即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span>(<span class=\"params\">self, prices</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type prices: List[int]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    profit,minElem = <span class=\"number\">0</span>,sys.maxsize</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> prices:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p &lt; minElem:</span><br><span class=\"line\">            minElem = p</span><br><span class=\"line\">        t = p - minElem</span><br><span class=\"line\">        <span class=\"keyword\">if</span> t &gt; profit:</span><br><span class=\"line\">            profit = t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> profit</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>c++</code>的解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxPro = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minPrice = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size(); i++)&#123;</span><br><span class=\"line\">        minPrice = min(minPrice, prices[i]);</span><br><span class=\"line\">        maxPro = max(maxPro, prices[i] - minPrice);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxPro;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及在<code>dicuss</code>中看到的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxCur = <span class=\"number\">0</span>, maxSoFar = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">        maxCur = Math.max(<span class=\"number\">0</span>, maxCur += prices[i] - prices[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        maxSoFar = Math.max(maxCur, maxSoFar);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxSoFar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第49天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/\">Best Time to Buy and Sell Stock</a>:</p>\n<blockquote>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>\n<p>Example 1:<br>Input: [7, 1, 5, 3, 6, 4]<br>Output: 5</p>\n<p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)<br>Example 2:<br>Input: [7, 6, 4, 3, 1]<br>Output: 0</p>\n<p>In this case, no transaction is done, i.e. max profit = 0.</p>\n</blockquote>\n<p>之前好像做过一道类似的题目，但是那道题比这道题难多了，那道题是可以多次买入卖出的，而成每次交易是需要支付一定费用的，这道就简单多了，我们只需要记录当前最小元素，然后每次更新最小元素，然后记录当前元素与最小元素的差值即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span>(<span class=\"params\">self, prices</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type prices: List[int]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    profit,minElem = <span class=\"number\">0</span>,sys.maxsize</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> prices:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p &lt; minElem:</span><br><span class=\"line\">            minElem = p</span><br><span class=\"line\">        t = p - minElem</span><br><span class=\"line\">        <span class=\"keyword\">if</span> t &gt; profit:</span><br><span class=\"line\">            profit = t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> profit</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>c++</code>的解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxPro = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minPrice = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size(); i++)&#123;</span><br><span class=\"line\">        minPrice = min(minPrice, prices[i]);</span><br><span class=\"line\">        maxPro = max(maxPro, prices[i] - minPrice);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxPro;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及在<code>dicuss</code>中看到的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxCur = <span class=\"number\">0</span>, maxSoFar = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">        maxCur = Math.max(<span class=\"number\">0</span>, maxCur += prices[i] - prices[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        maxSoFar = Math.max(maxCur, maxSoFar);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxSoFar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary Search Tree Iterator","date":"2020-03-31T02:55:25.000Z","_content":"\n> 貌似又是一道之前做了，但是没写题解的题目。\n\n今天的题目是[Binary Search Tree Iterator](https://leetcode-cn.com/problems/binary-search-tree-iterator/)。\n\n这道题要求我们按从小到大的顺序返回二叉搜索树的值，而我们知道二叉搜索树的中序遍历就是从小到大的，所以问题就变成了，对一个二叉树的中序遍历问题。\n\n因为之前总结过[二叉树遍历](https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/)，所以这里我们可以套用当时提到的三种方法来解这道题：\n\n## 递归\n\n由于题目只要求了`next()`和`hasNext()`的时间复杂度，所以我们可以在构造器中对二叉树进行遍历，然后存储下来：\n\n```cpp\nclass BSTIterator {\npublic:\n    vector<int> vec;\n    int index;\n    BSTIterator(TreeNode* root) {\n        index = 0;\n        inorderTraversal(root);\n    }\n\n    void inorderTraversal(TreeNode *root) {\n        if (root) {\n            inorderTraversal(root->left);\n            vec.push_back(root->val);\n            inorderTraversal(root->right);\n        }\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        return vec[index++];\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return index != vec.size();\n    }\n};\n```\n\n这样`next()`和`hasNext()`的时间复杂度肯定是`O(1)`的，但是空间复杂度却是`O(n)`，而题目要求的是`O(h)`。\n\n## 基于栈进行迭代。\n\n基于栈对二叉树进行迭代的中序遍历大体可以分为两部：\n\n1. 不断地把先左节点移动，并把节点压入栈中（以下简称 step 1)。\n2. 弹出栈顶节点，并输出，然后先右节点方向移动（以下简称 step 2)。\n\n一旦做完以上两步，我们就输出了一个值。\n\n因为当时是在一个循环中实现的，所以和现在的情况是不一样的，`root`是在构造器中输入的，所以我们得在构造器中就把`root`压入栈中，为了不把过程弄的复杂，所以我们在构造器中就直接把 step 1 给做完，然后在`next()`中把两步的顺序倒过来，即先执行 step 2 然后执行 step 1，当然 step 2 中的输出操作显然要放到最后来做。因为在两个地方都进行了 step 1，所以我们可以把它抽象成一个单独的函数`pushleft`：\n\n```c++\nclass BSTIterator {\npublic:\n    stack<TreeNode *> st;\n    BSTIterator(TreeNode* root) {\n        pushleft(root);\n    }\n    \n    void pushleft(TreeNode *root) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n    }\n\n    /** @return the next smallest number */\n    int next() {\n        auto root = st.top(); st.pop();\n        pushleft(root->right);\n        return root->val;\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return !st.empty();\n    }\n};\n```\n\n因为基于栈的遍历算法的空间复杂度是`O(h)`，所以上面这个算法的空间复杂度也是`O(h)`（其实也很好理解，因为栈要临时存放节点个数最大就是 h），然后`hasNext()`的时间复杂度显然也是`O(1)`。下面的问题就是，`next()`的时间复杂度是否是`O(1)`。\n\n如果我们仔细观察一下题目的话，我们会发现它要求的是平均时间复杂度，因为一颗有`n`个节点的树进行遍历，我们需要做`n`次`st.push`，同时`next()`我们也要调用`n`次才能遍历整棵树，所以`n / n = 1`，即平均时间复杂度为`O(1)`。\n\n## 莫里斯遍历\n\n我们先看下莫里斯遍历的代码：\n\n```c++\nTreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n    while(root->right && root->right != end) root = root->right;\n    return root;\n}\n\nvoid inorderTraversal(TreeNode* root) {\n    while(root) {\n        if (root->left) {\n            TreeNode *p = GetRightLeaf(root->left, root);\n            if (p->right == root) {\n                p->right = nullptr;\n                cout << root->val << endl;\n                root = root->right;\n            } else {\n                p->right = root;\n                root = root->left;\n            }\n        } else {\n            cout << root->val << endl;\n            root = root->right;\n        }\n    }\n}\n```\n\n几乎可以什么都不用改的情况下，把代码移植过去：\n\n```cpp\nclass BSTIterator {\npublic:\n    TreeNode *root;\n    TreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n        while(root->right && root->right != end) root = root->right;\n        return root;\n    }\n\n    BSTIterator(TreeNode* _root):root(_root) {\n\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        int res = -1;\n        while(root) {\n            if (root->left) {\n                TreeNode *p = GetRightLeaf(root->left, root);\n                if (p->right == root) {\n                    p->right = nullptr;\n                    // cout << root->val << endl;\n                    res = root->val;\n                    root = root->right;\n                    break;\n                } else {\n                    p->right = root;\n                    root = root->left;\n                }\n            } else {\n                // cout << root->val << endl;\n                res = root->val;\n                root = root->right;\n                break;\n            }\n        }\n        return res;\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return root != nullptr;\n    }\n};\n```\n\n这个的空间复杂度显然是`O(1)`，而时间复杂度，我们可以这样理解，每个节点都会被访问两遍，即`O(2n)`，而`next()`要调用 n 次，所以时间复杂度是`O(2n / 2) = O(2) = O(1)`。\n","source":"_posts/Binary-Search-Tree-Iterator.md","raw":"---\ntitle: Binary Search Tree Iterator\ndate: 2020-03-31T10:55:25.000Z\ntags:\n  - LeetCode\n  - Stack\n  - Tree\n  - Design\ncategories:\n  - LeetCode\n---\n\n> 貌似又是一道之前做了，但是没写题解的题目。\n\n今天的题目是[Binary Search Tree Iterator](https://leetcode-cn.com/problems/binary-search-tree-iterator/)。\n\n这道题要求我们按从小到大的顺序返回二叉搜索树的值，而我们知道二叉搜索树的中序遍历就是从小到大的，所以问题就变成了，对一个二叉树的中序遍历问题。\n\n因为之前总结过[二叉树遍历](https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/)，所以这里我们可以套用当时提到的三种方法来解这道题：\n\n## 递归\n\n由于题目只要求了`next()`和`hasNext()`的时间复杂度，所以我们可以在构造器中对二叉树进行遍历，然后存储下来：\n\n```cpp\nclass BSTIterator {\npublic:\n    vector<int> vec;\n    int index;\n    BSTIterator(TreeNode* root) {\n        index = 0;\n        inorderTraversal(root);\n    }\n\n    void inorderTraversal(TreeNode *root) {\n        if (root) {\n            inorderTraversal(root->left);\n            vec.push_back(root->val);\n            inorderTraversal(root->right);\n        }\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        return vec[index++];\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return index != vec.size();\n    }\n};\n```\n\n这样`next()`和`hasNext()`的时间复杂度肯定是`O(1)`的，但是空间复杂度却是`O(n)`，而题目要求的是`O(h)`。\n\n## 基于栈进行迭代。\n\n基于栈对二叉树进行迭代的中序遍历大体可以分为两部：\n\n1. 不断地把先左节点移动，并把节点压入栈中（以下简称 step 1)。\n2. 弹出栈顶节点，并输出，然后先右节点方向移动（以下简称 step 2)。\n\n一旦做完以上两步，我们就输出了一个值。\n\n因为当时是在一个循环中实现的，所以和现在的情况是不一样的，`root`是在构造器中输入的，所以我们得在构造器中就把`root`压入栈中，为了不把过程弄的复杂，所以我们在构造器中就直接把 step 1 给做完，然后在`next()`中把两步的顺序倒过来，即先执行 step 2 然后执行 step 1，当然 step 2 中的输出操作显然要放到最后来做。因为在两个地方都进行了 step 1，所以我们可以把它抽象成一个单独的函数`pushleft`：\n\n```c++\nclass BSTIterator {\npublic:\n    stack<TreeNode *> st;\n    BSTIterator(TreeNode* root) {\n        pushleft(root);\n    }\n    \n    void pushleft(TreeNode *root) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n    }\n\n    /** @return the next smallest number */\n    int next() {\n        auto root = st.top(); st.pop();\n        pushleft(root->right);\n        return root->val;\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return !st.empty();\n    }\n};\n```\n\n因为基于栈的遍历算法的空间复杂度是`O(h)`，所以上面这个算法的空间复杂度也是`O(h)`（其实也很好理解，因为栈要临时存放节点个数最大就是 h），然后`hasNext()`的时间复杂度显然也是`O(1)`。下面的问题就是，`next()`的时间复杂度是否是`O(1)`。\n\n如果我们仔细观察一下题目的话，我们会发现它要求的是平均时间复杂度，因为一颗有`n`个节点的树进行遍历，我们需要做`n`次`st.push`，同时`next()`我们也要调用`n`次才能遍历整棵树，所以`n / n = 1`，即平均时间复杂度为`O(1)`。\n\n## 莫里斯遍历\n\n我们先看下莫里斯遍历的代码：\n\n```c++\nTreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n    while(root->right && root->right != end) root = root->right;\n    return root;\n}\n\nvoid inorderTraversal(TreeNode* root) {\n    while(root) {\n        if (root->left) {\n            TreeNode *p = GetRightLeaf(root->left, root);\n            if (p->right == root) {\n                p->right = nullptr;\n                cout << root->val << endl;\n                root = root->right;\n            } else {\n                p->right = root;\n                root = root->left;\n            }\n        } else {\n            cout << root->val << endl;\n            root = root->right;\n        }\n    }\n}\n```\n\n几乎可以什么都不用改的情况下，把代码移植过去：\n\n```cpp\nclass BSTIterator {\npublic:\n    TreeNode *root;\n    TreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n        while(root->right && root->right != end) root = root->right;\n        return root;\n    }\n\n    BSTIterator(TreeNode* _root):root(_root) {\n\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        int res = -1;\n        while(root) {\n            if (root->left) {\n                TreeNode *p = GetRightLeaf(root->left, root);\n                if (p->right == root) {\n                    p->right = nullptr;\n                    // cout << root->val << endl;\n                    res = root->val;\n                    root = root->right;\n                    break;\n                } else {\n                    p->right = root;\n                    root = root->left;\n                }\n            } else {\n                // cout << root->val << endl;\n                res = root->val;\n                root = root->right;\n                break;\n            }\n        }\n        return res;\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return root != nullptr;\n    }\n};\n```\n\n这个的空间复杂度显然是`O(1)`，而时间复杂度，我们可以这样理解，每个节点都会被访问两遍，即`O(2n)`，而`next()`要调用 n 次，所以时间复杂度是`O(2n / 2) = O(2) = O(1)`。\n","slug":"Binary-Search-Tree-Iterator","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ms0018qmcmea566m5b","content":"<blockquote>\n<p>貌似又是一道之前做了，但是没写题解的题目。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/\">Binary Search Tree Iterator</a>。</p>\n<p>这道题要求我们按从小到大的顺序返回二叉搜索树的值，而我们知道二叉搜索树的中序遍历就是从小到大的，所以问题就变成了，对一个二叉树的中序遍历问题。</p>\n<p>因为之前总结过<a href=\"https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/\">二叉树遍历</a>，所以这里我们可以套用当时提到的三种方法来解这道题：</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>由于题目只要求了<code>next()</code>和<code>hasNext()</code>的时间复杂度，所以我们可以在构造器中对二叉树进行遍历，然后存储下来：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSTIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    BSTIterator(TreeNode* root) &#123;</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        inorderTraversal(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">            inorderTraversal(root-&gt;left);</span><br><span class=\"line\">            vec.push_back(root-&gt;val);</span><br><span class=\"line\">            inorderTraversal(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return the next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vec[index++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return whether we have a next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index != vec.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这样<code>next()</code>和<code>hasNext()</code>的时间复杂度肯定是<code>O(1)</code>的，但是空间复杂度却是<code>O(n)</code>，而题目要求的是<code>O(h)</code>。</p>\n<h2 id=\"基于栈进行迭代。\"><a href=\"#基于栈进行迭代。\" class=\"headerlink\" title=\"基于栈进行迭代。\"></a>基于栈进行迭代。</h2><p>基于栈对二叉树进行迭代的中序遍历大体可以分为两部：</p>\n<ol>\n<li>不断地把先左节点移动，并把节点压入栈中（以下简称 step 1)。</li>\n<li>弹出栈顶节点，并输出，然后先右节点方向移动（以下简称 step 2)。</li>\n</ol>\n<p>一旦做完以上两步，我们就输出了一个值。</p>\n<p>因为当时是在一个循环中实现的，所以和现在的情况是不一样的，<code>root</code>是在构造器中输入的，所以我们得在构造器中就把<code>root</code>压入栈中，为了不把过程弄的复杂，所以我们在构造器中就直接把 step 1 给做完，然后在<code>next()</code>中把两步的顺序倒过来，即先执行 step 2 然后执行 step 1，当然 step 2 中的输出操作显然要放到最后来做。因为在两个地方都进行了 step 1，所以我们可以把它抽象成一个单独的函数<code>pushleft</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSTIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    BSTIterator(TreeNode* root) &#123;</span><br><span class=\"line\">        pushleft(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushleft</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** @return the next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> root = st.top(); st.pop();</span><br><span class=\"line\">        pushleft(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return whether we have a next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !st.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>因为基于栈的遍历算法的空间复杂度是<code>O(h)</code>，所以上面这个算法的空间复杂度也是<code>O(h)</code>（其实也很好理解，因为栈要临时存放节点个数最大就是 h），然后<code>hasNext()</code>的时间复杂度显然也是<code>O(1)</code>。下面的问题就是，<code>next()</code>的时间复杂度是否是<code>O(1)</code>。</p>\n<p>如果我们仔细观察一下题目的话，我们会发现它要求的是平均时间复杂度，因为一颗有<code>n</code>个节点的树进行遍历，我们需要做<code>n</code>次<code>st.push</code>，同时<code>next()</code>我们也要调用<code>n</code>次才能遍历整棵树，所以<code>n / n = 1</code>，即平均时间复杂度为<code>O(1)</code>。</p>\n<h2 id=\"莫里斯遍历\"><a href=\"#莫里斯遍历\" class=\"headerlink\" title=\"莫里斯遍历\"></a>莫里斯遍历</h2><p>我们先看下莫里斯遍历的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p-&gt;right = root;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>几乎可以什么都不用改的情况下，把代码移植过去：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSTIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TreeNode *root;</span><br><span class=\"line\">    <span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    BSTIterator(TreeNode* _root):root(_root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return the next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">                TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                    p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class=\"line\">                    res = root-&gt;val;</span><br><span class=\"line\">                    root = root-&gt;right;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    p-&gt;right = root;</span><br><span class=\"line\">                    root = root-&gt;left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class=\"line\">                res = root-&gt;val;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return whether we have a next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root != <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个的空间复杂度显然是<code>O(1)</code>，而时间复杂度，我们可以这样理解，每个节点都会被访问两遍，即<code>O(2n)</code>，而<code>next()</code>要调用 n 次，所以时间复杂度是<code>O(2n / 2) = O(2) = O(1)</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>貌似又是一道之前做了，但是没写题解的题目。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/\">Binary Search Tree Iterator</a>。</p>\n<p>这道题要求我们按从小到大的顺序返回二叉搜索树的值，而我们知道二叉搜索树的中序遍历就是从小到大的，所以问题就变成了，对一个二叉树的中序遍历问题。</p>\n<p>因为之前总结过<a href=\"https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/\">二叉树遍历</a>，所以这里我们可以套用当时提到的三种方法来解这道题：</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>由于题目只要求了<code>next()</code>和<code>hasNext()</code>的时间复杂度，所以我们可以在构造器中对二叉树进行遍历，然后存储下来：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSTIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    BSTIterator(TreeNode* root) &#123;</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        inorderTraversal(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">            inorderTraversal(root-&gt;left);</span><br><span class=\"line\">            vec.push_back(root-&gt;val);</span><br><span class=\"line\">            inorderTraversal(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return the next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vec[index++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return whether we have a next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index != vec.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这样<code>next()</code>和<code>hasNext()</code>的时间复杂度肯定是<code>O(1)</code>的，但是空间复杂度却是<code>O(n)</code>，而题目要求的是<code>O(h)</code>。</p>\n<h2 id=\"基于栈进行迭代。\"><a href=\"#基于栈进行迭代。\" class=\"headerlink\" title=\"基于栈进行迭代。\"></a>基于栈进行迭代。</h2><p>基于栈对二叉树进行迭代的中序遍历大体可以分为两部：</p>\n<ol>\n<li>不断地把先左节点移动，并把节点压入栈中（以下简称 step 1)。</li>\n<li>弹出栈顶节点，并输出，然后先右节点方向移动（以下简称 step 2)。</li>\n</ol>\n<p>一旦做完以上两步，我们就输出了一个值。</p>\n<p>因为当时是在一个循环中实现的，所以和现在的情况是不一样的，<code>root</code>是在构造器中输入的，所以我们得在构造器中就把<code>root</code>压入栈中，为了不把过程弄的复杂，所以我们在构造器中就直接把 step 1 给做完，然后在<code>next()</code>中把两步的顺序倒过来，即先执行 step 2 然后执行 step 1，当然 step 2 中的输出操作显然要放到最后来做。因为在两个地方都进行了 step 1，所以我们可以把它抽象成一个单独的函数<code>pushleft</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSTIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    BSTIterator(TreeNode* root) &#123;</span><br><span class=\"line\">        pushleft(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushleft</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** @return the next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> root = st.top(); st.pop();</span><br><span class=\"line\">        pushleft(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return whether we have a next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !st.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>因为基于栈的遍历算法的空间复杂度是<code>O(h)</code>，所以上面这个算法的空间复杂度也是<code>O(h)</code>（其实也很好理解，因为栈要临时存放节点个数最大就是 h），然后<code>hasNext()</code>的时间复杂度显然也是<code>O(1)</code>。下面的问题就是，<code>next()</code>的时间复杂度是否是<code>O(1)</code>。</p>\n<p>如果我们仔细观察一下题目的话，我们会发现它要求的是平均时间复杂度，因为一颗有<code>n</code>个节点的树进行遍历，我们需要做<code>n</code>次<code>st.push</code>，同时<code>next()</code>我们也要调用<code>n</code>次才能遍历整棵树，所以<code>n / n = 1</code>，即平均时间复杂度为<code>O(1)</code>。</p>\n<h2 id=\"莫里斯遍历\"><a href=\"#莫里斯遍历\" class=\"headerlink\" title=\"莫里斯遍历\"></a>莫里斯遍历</h2><p>我们先看下莫里斯遍历的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p-&gt;right = root;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>几乎可以什么都不用改的情况下，把代码移植过去：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSTIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TreeNode *root;</span><br><span class=\"line\">    <span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    BSTIterator(TreeNode* _root):root(_root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return the next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">                TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                    p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class=\"line\">                    res = root-&gt;val;</span><br><span class=\"line\">                    root = root-&gt;right;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    p-&gt;right = root;</span><br><span class=\"line\">                    root = root-&gt;left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class=\"line\">                res = root-&gt;val;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** @return whether we have a next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root != <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个的空间复杂度显然是<code>O(1)</code>，而时间复杂度，我们可以这样理解，每个节点都会被访问两遍，即<code>O(2n)</code>，而<code>next()</code>要调用 n 次，所以时间复杂度是<code>O(2n / 2) = O(2) = O(1)</code>。</p>\n"},{"title":"Binary Search Tree to Greater Sum Tree","date":"2019-12-21T02:26:41.000Z","_content":"\n> 第45天。\n\n今天的题目是[Binary Search Tree to Greater Sum Tree](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/):\n\n感觉这道题的题意很奇怪，不清不楚的，不过看Example还是看的出他问的是什么的，挺简单的题目：\n\n```c++\nTreeNode* bstToGst(TreeNode* root) {\n    if (root == nullptr) return root;\n    int sum = 0;\n    return bstToGst(root, sum);\n}\n\nTreeNode* bstToGst(TreeNode* root, int &sum) { \n    if (root == nullptr) return root;\n    // TreeNode *node = new TreeNode(root->val);\n    root->right = bstToGst(root->right, sum);\n    root->val = sum = root->val + sum;\n    root->left = bstToGst(root->left, sum);\n    return root;\n}\n```\n","source":"_posts/Binary-Search-Tree-to-Greater-Sum-Tree.md","raw":"---\ntitle: Binary Search Tree to Greater Sum Tree\ndate: 2019-12-21T10:26:41.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第45天。\n\n今天的题目是[Binary Search Tree to Greater Sum Tree](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/):\n\n感觉这道题的题意很奇怪，不清不楚的，不过看Example还是看的出他问的是什么的，挺简单的题目：\n\n```c++\nTreeNode* bstToGst(TreeNode* root) {\n    if (root == nullptr) return root;\n    int sum = 0;\n    return bstToGst(root, sum);\n}\n\nTreeNode* bstToGst(TreeNode* root, int &sum) { \n    if (root == nullptr) return root;\n    // TreeNode *node = new TreeNode(root->val);\n    root->right = bstToGst(root->right, sum);\n    root->val = sum = root->val + sum;\n    root->left = bstToGst(root->left, sum);\n    return root;\n}\n```\n","slug":"Binary-Search-Tree-to-Greater-Sum-Tree","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mt001bqmcmd6069ijf","content":"<blockquote>\n<p>第45天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\">Binary Search Tree to Greater Sum Tree</a>:</p>\n<p>感觉这道题的题意很奇怪，不清不楚的，不过看Example还是看的出他问的是什么的，挺简单的题目：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">bstToGst</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bstToGst(root, sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">bstToGst</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;sum)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"comment\">// TreeNode *node = new TreeNode(root-&gt;val);</span></span><br><span class=\"line\">    root-&gt;right = bstToGst(root-&gt;right, sum);</span><br><span class=\"line\">    root-&gt;val = sum = root-&gt;val + sum;</span><br><span class=\"line\">    root-&gt;left = bstToGst(root-&gt;left, sum);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第45天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\">Binary Search Tree to Greater Sum Tree</a>:</p>\n<p>感觉这道题的题意很奇怪，不清不楚的，不过看Example还是看的出他问的是什么的，挺简单的题目：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">bstToGst</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bstToGst(root, sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">bstToGst</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;sum)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"comment\">// TreeNode *node = new TreeNode(root-&gt;val);</span></span><br><span class=\"line\">    root-&gt;right = bstToGst(root-&gt;right, sum);</span><br><span class=\"line\">    root-&gt;val = sum = root-&gt;val + sum;</span><br><span class=\"line\">    root-&gt;left = bstToGst(root-&gt;left, sum);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary Tree Coloring Game","date":"2019-12-27T09:02:35.000Z","_content":"\n> 第50天。\n\n今天的题目是[Binary Tree Coloring Game](https://leetcode.com/problems/binary-tree-coloring-game/)\n\n挺唬人的题目，搞清楚题意的话，还是挺简单的。\n\n大概的意思是，现在有一个树，然后已经有个人将其中一个节点上色成红色，问你，现在按顺序涂颜色，最后你能不能赢。这个的规则有两个：\n\n- 除了第一个颜色可以随便找节点上色外，其他的都只能对自己临近的节点上色。\n- 有颜色的节点不能再次上色\n- 所以节点上完色后，节点多的人获胜\n\n![](https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png)\n\n因为是在树上，所以给第二个以及之后的节点上色的话，只有三种选择，向父节点、向左节点、向右节点。\n\n所以我们只要判断对手上色的第一个节点，三个方向中，是否存在一个方向的节点比剩余节点都要多。\n\n```c++\nbool btreeGameWinningMove(TreeNode* root, int n, int x) {\n    if (!root) return false;\n    TreeNode *node = search(root, x);\n    \n    int leftNum = getNodeNum(node->left);\n    int rightNum = getNodeNum(node->right);\n    int upNum = n - 1 - leftNum - rightNum;\n    int maxNum = max(max(leftNum, rightNum), upNum);\n    // cout << leftNum << endl;\n    // cout << rightNum << endl;\n    // cout << upNum << endl;\n    // cout << maxNum << endl;\n    return maxNum > (n - maxNum);\n\n}\n\nint getNodeNum(TreeNode *root) {\n    if (!root) return 0;\n    return 1 + getNodeNum(root->left) + getNodeNum(root->right);\n}\n\nTreeNode *search(TreeNode *root, int x) {\n    if (!root || root->val == x) return root;\n    TreeNode *node = search(root->left, x);\n    if (node) return node;\n    return search(root->right, x);\n}\n```\n\n","source":"_posts/Binary-Tree-Coloring-Game.md","raw":"---\ntitle: Binary Tree Coloring Game\ndate: 2019-12-27T17:02:35.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第50天。\n\n今天的题目是[Binary Tree Coloring Game](https://leetcode.com/problems/binary-tree-coloring-game/)\n\n挺唬人的题目，搞清楚题意的话，还是挺简单的。\n\n大概的意思是，现在有一个树，然后已经有个人将其中一个节点上色成红色，问你，现在按顺序涂颜色，最后你能不能赢。这个的规则有两个：\n\n- 除了第一个颜色可以随便找节点上色外，其他的都只能对自己临近的节点上色。\n- 有颜色的节点不能再次上色\n- 所以节点上完色后，节点多的人获胜\n\n![](https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png)\n\n因为是在树上，所以给第二个以及之后的节点上色的话，只有三种选择，向父节点、向左节点、向右节点。\n\n所以我们只要判断对手上色的第一个节点，三个方向中，是否存在一个方向的节点比剩余节点都要多。\n\n```c++\nbool btreeGameWinningMove(TreeNode* root, int n, int x) {\n    if (!root) return false;\n    TreeNode *node = search(root, x);\n    \n    int leftNum = getNodeNum(node->left);\n    int rightNum = getNodeNum(node->right);\n    int upNum = n - 1 - leftNum - rightNum;\n    int maxNum = max(max(leftNum, rightNum), upNum);\n    // cout << leftNum << endl;\n    // cout << rightNum << endl;\n    // cout << upNum << endl;\n    // cout << maxNum << endl;\n    return maxNum > (n - maxNum);\n\n}\n\nint getNodeNum(TreeNode *root) {\n    if (!root) return 0;\n    return 1 + getNodeNum(root->left) + getNodeNum(root->right);\n}\n\nTreeNode *search(TreeNode *root, int x) {\n    if (!root || root->val == x) return root;\n    TreeNode *node = search(root->left, x);\n    if (node) return node;\n    return search(root->right, x);\n}\n```\n\n","slug":"Binary-Tree-Coloring-Game","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mu001eqmcmeb0lhzkk","content":"<blockquote>\n<p>第50天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-coloring-game/\">Binary Tree Coloring Game</a></p>\n<p>挺唬人的题目，搞清楚题意的话，还是挺简单的。</p>\n<p>大概的意思是，现在有一个树，然后已经有个人将其中一个节点上色成红色，问你，现在按顺序涂颜色，最后你能不能赢。这个的规则有两个：</p>\n<ul>\n<li>除了第一个颜色可以随便找节点上色外，其他的都只能对自己临近的节点上色。</li>\n<li>有颜色的节点不能再次上色</li>\n<li>所以节点上完色后，节点多的人获胜</li>\n</ul>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png\"></p>\n<p>因为是在树上，所以给第二个以及之后的节点上色的话，只有三种选择，向父节点、向左节点、向右节点。</p>\n<p>所以我们只要判断对手上色的第一个节点，三个方向中，是否存在一个方向的节点比剩余节点都要多。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">btreeGameWinningMove</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    TreeNode *node = search(root, x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftNum = getNodeNum(node-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rightNum = getNodeNum(node-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> upNum = n - <span class=\"number\">1</span> - leftNum - rightNum;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxNum = max(max(leftNum, rightNum), upNum);</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; leftNum &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; rightNum &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; upNum &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; maxNum &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxNum &gt; (n - maxNum);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNodeNum</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">search</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root || root-&gt;val == x) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    TreeNode *node = search(root-&gt;left, x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node) <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> search(root-&gt;right, x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第50天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-coloring-game/\">Binary Tree Coloring Game</a></p>\n<p>挺唬人的题目，搞清楚题意的话，还是挺简单的。</p>\n<p>大概的意思是，现在有一个树，然后已经有个人将其中一个节点上色成红色，问你，现在按顺序涂颜色，最后你能不能赢。这个的规则有两个：</p>\n<ul>\n<li>除了第一个颜色可以随便找节点上色外，其他的都只能对自己临近的节点上色。</li>\n<li>有颜色的节点不能再次上色</li>\n<li>所以节点上完色后，节点多的人获胜</li>\n</ul>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png\"></p>\n<p>因为是在树上，所以给第二个以及之后的节点上色的话，只有三种选择，向父节点、向左节点、向右节点。</p>\n<p>所以我们只要判断对手上色的第一个节点，三个方向中，是否存在一个方向的节点比剩余节点都要多。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">btreeGameWinningMove</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    TreeNode *node = search(root, x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftNum = getNodeNum(node-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rightNum = getNodeNum(node-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> upNum = n - <span class=\"number\">1</span> - leftNum - rightNum;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxNum = max(max(leftNum, rightNum), upNum);</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; leftNum &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; rightNum &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; upNum &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; maxNum &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxNum &gt; (n - maxNum);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNodeNum</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">search</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root || root-&gt;val == x) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    TreeNode *node = search(root-&gt;left, x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node) <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> search(root-&gt;right, x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Binary Tree Level Order Traversal","date":"2017-10-24T02:29:00.000Z","_content":"\n第31天。\n\n今天的题目是之前好像就做过的了,[Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/):\n\n> Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n>\n> For example:\n> Given binary tree [3,9,20,null,null,15,7],\n\n```python\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n> return its level order traversal as:\n\n```python\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\nemmm，简单来讲就是层次遍历.\n\n一般来说，层次遍历都是用队列来实现:\n\n* 先让root入队，这时我们队列里面就有第一层的所有元素了\n* 我们记录当前层次所拥有的元素的个数size，然后出队size个元素，对于每一个出队的元素，我们遍历它一次，然后将它的左右孩子入队。\n\n```c++\nvector<vector<int>> levelOrder(TreeNode* root) {\n    vector<vector<int> > ret;\n    if (root == NULL) return ret;\n    queue<TreeNode *> q;\n    q.push(root);\n    int size = 0;\n    int last = 0;\n    while((size = q.size())) {\n        ret.push_back(vector<int>());\n        while(size--) {\n            root = q.front();\n            q.pop();\n            ret[last].push_back(root->val);\n            if (root->left) q.push(root->left);\n            if (root->right) q.push(root->right);\n        }\n        last++;\n    }\n    return ret;\n}\n```\n\n然后因为这里是返回`vector< vector<int> >`，而不是直接输出，所以我们可以取个巧，写出一个递归算法出来:\n\n```c++\nvector<vector<int> > ret;\nvector<vector<int>> levelOrder(TreeNode* root) {\n    leverlOrder(root,0);\n    return ret;\n}\nvoid levelOrder(TreeNode* root,int level) {\n    if (root==NULL)\n        return;\n    if (level >= ret.size() ) {\n        ret.push_back(vector<int>());\n    }\n    ret[level].push_back(root->val);\n    levelOrder(root->left,level+1);\n    levelOrder(root->right,level+1);\n}\n```\n\n这里其实是先序遍历，但是因为我们一直记录着层数，所以我们还是可以保证`vector<vector<int> >`的顺序是正确的。\n","source":"_posts/Binary-Tree-Level-Order-Traversal.md","raw":"---\ntitle: Binary Tree Level Order Traversal\ndate: 2017-10-24T10:29:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第31天。\n\n今天的题目是之前好像就做过的了,[Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/):\n\n> Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n>\n> For example:\n> Given binary tree [3,9,20,null,null,15,7],\n\n```python\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n> return its level order traversal as:\n\n```python\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\nemmm，简单来讲就是层次遍历.\n\n一般来说，层次遍历都是用队列来实现:\n\n* 先让root入队，这时我们队列里面就有第一层的所有元素了\n* 我们记录当前层次所拥有的元素的个数size，然后出队size个元素，对于每一个出队的元素，我们遍历它一次，然后将它的左右孩子入队。\n\n```c++\nvector<vector<int>> levelOrder(TreeNode* root) {\n    vector<vector<int> > ret;\n    if (root == NULL) return ret;\n    queue<TreeNode *> q;\n    q.push(root);\n    int size = 0;\n    int last = 0;\n    while((size = q.size())) {\n        ret.push_back(vector<int>());\n        while(size--) {\n            root = q.front();\n            q.pop();\n            ret[last].push_back(root->val);\n            if (root->left) q.push(root->left);\n            if (root->right) q.push(root->right);\n        }\n        last++;\n    }\n    return ret;\n}\n```\n\n然后因为这里是返回`vector< vector<int> >`，而不是直接输出，所以我们可以取个巧，写出一个递归算法出来:\n\n```c++\nvector<vector<int> > ret;\nvector<vector<int>> levelOrder(TreeNode* root) {\n    leverlOrder(root,0);\n    return ret;\n}\nvoid levelOrder(TreeNode* root,int level) {\n    if (root==NULL)\n        return;\n    if (level >= ret.size() ) {\n        ret.push_back(vector<int>());\n    }\n    ret[level].push_back(root->val);\n    levelOrder(root->left,level+1);\n    levelOrder(root->right,level+1);\n}\n```\n\n这里其实是先序遍历，但是因为我们一直记录着层数，所以我们还是可以保证`vector<vector<int> >`的顺序是正确的。\n","slug":"Binary-Tree-Level-Order-Traversal","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mv001iqmcmalp6gnc5","content":"<p>第31天。</p>\n<p>今天的题目是之前好像就做过的了,<a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/description/\">Binary Tree Level Order Traversal</a>:</p>\n<blockquote>\n<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>\n<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">3</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">9</span>  <span class=\"number\">20</span></span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> <span class=\"number\">15</span>   <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>return its level order traversal as:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>emmm，简单来讲就是层次遍历.</p>\n<p>一般来说，层次遍历都是用队列来实现:</p>\n<ul>\n<li>先让root入队，这时我们队列里面就有第一层的所有元素了</li>\n<li>我们记录当前层次所拥有的元素的个数size，然后出队size个元素，对于每一个出队的元素，我们遍历它一次，然后将它的左右孩子入队。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((size = q.size())) &#123;</span><br><span class=\"line\">        ret.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(size--) &#123;</span><br><span class=\"line\">            root = q.front();</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">            ret[last].push_back(root-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        last++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后因为这里是返回<code>vector&lt; vector&lt;int&gt; &gt;</code>，而不是直接输出，所以我们可以取个巧，写出一个递归算法出来:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">    leverlOrder(root,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">levelOrder</span><span class=\"params\">(TreeNode* root,<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level &gt;= ret.size() ) &#123;</span><br><span class=\"line\">        ret.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret[level].push_back(root-&gt;val);</span><br><span class=\"line\">    levelOrder(root-&gt;left,level+<span class=\"number\">1</span>);</span><br><span class=\"line\">    levelOrder(root-&gt;right,level+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里其实是先序遍历，但是因为我们一直记录着层数，所以我们还是可以保证<code>vector&lt;vector&lt;int&gt; &gt;</code>的顺序是正确的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第31天。</p>\n<p>今天的题目是之前好像就做过的了,<a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/description/\">Binary Tree Level Order Traversal</a>:</p>\n<blockquote>\n<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>\n<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">3</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">9</span>  <span class=\"number\">20</span></span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> <span class=\"number\">15</span>   <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>return its level order traversal as:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>emmm，简单来讲就是层次遍历.</p>\n<p>一般来说，层次遍历都是用队列来实现:</p>\n<ul>\n<li>先让root入队，这时我们队列里面就有第一层的所有元素了</li>\n<li>我们记录当前层次所拥有的元素的个数size，然后出队size个元素，对于每一个出队的元素，我们遍历它一次，然后将它的左右孩子入队。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((size = q.size())) &#123;</span><br><span class=\"line\">        ret.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(size--) &#123;</span><br><span class=\"line\">            root = q.front();</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">            ret[last].push_back(root-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        last++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后因为这里是返回<code>vector&lt; vector&lt;int&gt; &gt;</code>，而不是直接输出，所以我们可以取个巧，写出一个递归算法出来:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">    leverlOrder(root,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">levelOrder</span><span class=\"params\">(TreeNode* root,<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level &gt;= ret.size() ) &#123;</span><br><span class=\"line\">        ret.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret[level].push_back(root-&gt;val);</span><br><span class=\"line\">    levelOrder(root-&gt;left,level+<span class=\"number\">1</span>);</span><br><span class=\"line\">    levelOrder(root-&gt;right,level+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里其实是先序遍历，但是因为我们一直记录着层数，所以我们还是可以保证<code>vector&lt;vector&lt;int&gt; &gt;</code>的顺序是正确的。</p>\n"},{"title":"Binary-Tree-Paths","date":"2018-01-20T02:24:03.000Z","_content":"\n第89天。\n\n今天的题目是[Binary-Tree-Paths](https://leetcode.com/problems/binary-tree-paths/description/):\n\n> Given a binary tree, return all root-to-leaf paths.\n>\n> For example, given the following binary tree:\n>\n   1\n /   \\\n2     3\n \\\n  5\n> All root-to-leaf paths are:\n>\n> [\"1->2->5\", \"1->3\"]\n\n比较的简单的题目，直接用递归做就好了，因为`python`写起来比较简单，所以这里用`python`实现：\n\n```python\ndef binaryTreePaths(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: List[str]\n    \"\"\"\n    self.ret = []\n    if root is None:\n        return self.ret\n    s = []\n    self.binaryTreePathsRec(root,s)\n    return self.ret\n\n\ndef binaryTreePathsRec(self,root,s):\n    if root is None:\n        return\n    s.append(str(root.val))\n    if root.left is None and root.right is None:\n        self.ret.append('->'.join(s))\n    else:\n        self.binaryTreePathsRec(root.left,s)\n        self.binaryTreePathsRec(root.right,s)\n    s.pop()\n```\n","source":"_posts/Binary-Tree-Paths.md","raw":"---\ntitle: Binary-Tree-Paths\ndate: 2018-01-20T10:24:03.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第89天。\n\n今天的题目是[Binary-Tree-Paths](https://leetcode.com/problems/binary-tree-paths/description/):\n\n> Given a binary tree, return all root-to-leaf paths.\n>\n> For example, given the following binary tree:\n>\n   1\n /   \\\n2     3\n \\\n  5\n> All root-to-leaf paths are:\n>\n> [\"1->2->5\", \"1->3\"]\n\n比较的简单的题目，直接用递归做就好了，因为`python`写起来比较简单，所以这里用`python`实现：\n\n```python\ndef binaryTreePaths(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: List[str]\n    \"\"\"\n    self.ret = []\n    if root is None:\n        return self.ret\n    s = []\n    self.binaryTreePathsRec(root,s)\n    return self.ret\n\n\ndef binaryTreePathsRec(self,root,s):\n    if root is None:\n        return\n    s.append(str(root.val))\n    if root.left is None and root.right is None:\n        self.ret.append('->'.join(s))\n    else:\n        self.binaryTreePathsRec(root.left,s)\n        self.binaryTreePathsRec(root.right,s)\n    s.pop()\n```\n","slug":"Binary-Tree-Paths","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mv001lqmcmevat38ii","content":"<p>第89天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-paths/description/\">Binary-Tree-Paths</a>:</p>\n<blockquote>\n<p>Given a binary tree, return all root-to-leaf paths.</p>\n<p>For example, given the following binary tree:</p>\n</blockquote>\n<p>   1<br> /   <br>2     3<br> <br>  5</p>\n<blockquote>\n<p>All root-to-leaf paths are:</p>\n<p>[“1-&gt;2-&gt;5”, “1-&gt;3”]</p>\n</blockquote>\n<p>比较的简单的题目，直接用递归做就好了，因为<code>python</code>写起来比较简单，所以这里用<code>python</code>实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePaths</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    self.ret = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.ret</span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    self.binaryTreePathsRec(root,s)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ret</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePathsRec</span>(<span class=\"params\">self,root,s</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    s.append(<span class=\"built_in\">str</span>(root.val))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root.left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> root.right <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        self.ret.append(<span class=\"string\">&#x27;-&gt;&#x27;</span>.join(s))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.binaryTreePathsRec(root.left,s)</span><br><span class=\"line\">        self.binaryTreePathsRec(root.right,s)</span><br><span class=\"line\">    s.pop()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第89天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-paths/description/\">Binary-Tree-Paths</a>:</p>\n<blockquote>\n<p>Given a binary tree, return all root-to-leaf paths.</p>\n<p>For example, given the following binary tree:</p>\n</blockquote>\n<p>   1<br> /   <br>2     3<br> <br>  5</p>\n<blockquote>\n<p>All root-to-leaf paths are:</p>\n<p>[“1-&gt;2-&gt;5”, “1-&gt;3”]</p>\n</blockquote>\n<p>比较的简单的题目，直接用递归做就好了，因为<code>python</code>写起来比较简单，所以这里用<code>python</code>实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePaths</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: List[str]</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    self.ret = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.ret</span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    self.binaryTreePathsRec(root,s)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ret</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePathsRec</span>(<span class=\"params\">self,root,s</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    s.append(<span class=\"built_in\">str</span>(root.val))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root.left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> root.right <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        self.ret.append(<span class=\"string\">&#x27;-&gt;&#x27;</span>.join(s))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.binaryTreePathsRec(root.left,s)</span><br><span class=\"line\">        self.binaryTreePathsRec(root.right,s)</span><br><span class=\"line\">    s.pop()</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary Tree (Preorder|Inorder|Postorder) Traversal","date":"2020-03-24T04:10:21.000Z","_content":"\n今天将二叉树的先、中、后遍历的做了一些总结。三种遍历都有三种写法：\n\n- 递归\n  - 时间复杂度：`O(n)`\n  - 空间复杂度：`O(h)`，`h`为树高\n- 基于栈进行迭代：\n  - 时间复杂度:`O(n)`\n  - 空间复杂度：`O(n)`\n- 莫里斯算法：\n  - 时间复杂度：`O(n)`\n  - 空间复杂度：`O(1)`\n\n接下来内容有一下几个部分组成：\n1. 首先介绍二叉树先、中、后序遍历的含义\n2. 递归算法\n3. 基于栈的迭代算法\n4. 莫里斯算法\n\n## 二叉树 & 先、中、后序遍历\n\n![](https://g.gravizo.com/svg?digraph%20G%20{%20node[shape=circle]%20edge[arrowhead=vee]%201-%3E2;%201-%3E5;%202-%3E3;%202-%3E4;%20})\n\n- 先序遍历：\n\n  > 1. 访问当前节点\n  > 2. 遍历左子树\n  > 3. 遍历右子树\n\n- 中序遍历：\n\n  > 1. 遍历左子树\n  > 2. 访问当前节点\n  > 3. 遍历右子树\n\n- 后序遍历：\n\n  > 1. 遍历左子树\n  > 2. 遍历右子树\n  > 3. 访问当前节点\n\n如上图中显示的二叉树中，先、中、后序遍历分别为：\n\n- 先序：`1 2 3 4 5`\n- 中序：`3 2 4 1 5`\n- 后序：`3 4 2 5 1`\n\n## 递归算法\n\n已知三种遍历的含义之后，我们可以很容易的写出三种遍历的递归算法:\n\n```c++\nvoid prevorderTraversal(TreeNode *root) {\n    if (root) {\n        cout << root->val << endl;\n        prevorderTraversal(root->left);\n        prevorderTraversal(root->right);\n    }\n}\n\nvoid inorderTraversal(TreeNode *root) {\n    if (root) {\n        inorderTraversal(root->left);\n        cout << root->val << endl;\n        inorderTraversal(root->right);\n    }\n}\n\nvoid postorderTraversal(TreeNode *root) {\n    if (root) {\n        postorderTraversal(root->left);\n        postorderTraversal(root->right);\n        cout << root->val << endl;\n    }\n}\n```\n\n> 由于递归算法比较简单，所以这里不做过多的说明。\n>\n> 为了方便，访问节点时，只是输出节点的值。\n\n## 基于栈的迭代算法\n\n### 基于栈的迭代算法——先序遍历\n\n基于栈的遍历算法中，先序遍历是最简单的。因为先序遍历本身可以进行尾递归优化，所以很容易用`stack`对递归调用进行模拟：\n\n```c++\nvoid preorderTraversal(TreeNode *root) {\n    stack<TreeNode *> st;\n    if (root) st.push(root);\n    while(!st.empty()) {\n        root = st.top(); st.pop();\n        cout << root->val << endl;\n        if (root->right) st.push(root->right);\n        if (root->left) st.push(root->left);\n    }\n}\n```\n\n需要注意的是，因为栈用后进先出的特性，所以要先将右子树压入栈中，然后再将左子树压入栈中。\n\n### 基于栈的迭代算法——中序遍历\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28)\n\n我们以上图为例子，其中圆圈表示树中的节点，而三角形表示子树。其中的序号为访问顺序，我们可以发现，进行中序遍历的二叉树都符合这样的移动规律：\n\n1. 先一直往左孩子的方向移动，直到没有左孩子。\n2. 然后访问该节点，并遍历其右子树（这时相当于对其右子树进行 1、2、3步）。\n3. 最后返回到其父节点并从第 2 步开始。\n\n为了方便实现和代码的简洁，我们可以把观察到规律转换一下：\n\n1. 先一直往左孩子的方向移动，直到当前节点为空，同时把所有经过的节点压入栈中。\n2. 如果栈不空，则将栈顶弹出并访问，向右孩子移动并返回第一步。\n\n因此我们可以写出如下代码：\n\n```c++\nvoid inorderTraversal(TreeNode *root) {\n    stack<TreeNode *> st;\n    while(root || !st.empty()) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n        // 栈一定不为空\n        root = st.top(); st.pop();\n        cout << root->val << endl;\n        root = root->right;\n    }\n}\n```\n\n### 基于栈的迭代算法——后序遍历\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28)\n\n后序遍历与中序遍历有些类似，同样需要先一直往左孩子方向移动直到没有左孩子，但是后序遍历要先访问完右子树才能访问当前节点，因此对于栈顶节点是否要访问并弹出，我们需要判断其右子树是否被访问了。同时，因为后序遍历中，一颗树的根节点是最后访问的，所以我们可以根据右孩子是否被访问了来判断右子树是否被访问了。而我们知道，当访问完右孩子，就可以马上访问该节点了，所以我们可以维护一个指针，该指针指向上一次被访问的节点。通过判断上一次被访问的节点是否为右子树或者`nullpter`，我们就可以知道是否要访问该节点并弹栈了。\n\n```c++\nvoid postorderTraversal(TreeNode* root) {\n    TreeNode *prev = nullptr;\n    stack<TreeNode *> st;\n    while(root || !st.empty()) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n        root = st.top();\n        if (root->right == nullptr || root->right == prev) {\n            cout << root << right << endl;\n            prev = root;\n            root = nullptr;\n            st.pop();\n        } else root = root->right;\n    }\n    return res; \n}\n```\n\n## 莫里斯算法\n\n莫里斯算法是一种用时间来换空间的二叉树遍历算法。他只需要`O(1)`的空间复杂度。\n\n个人觉得它非常像中序线索树，所以我们先介绍中序线索树，然后再来理解莫里斯遍历。\n\n### 中序线索树\n\n假设一颗二叉树有`N`个节点，因为每个节点有 2 个指向孩子的指针，所以我们就有了 `2*N` 个指向节点的指针。同时，因为根节点不需要指针指向它，所以我们就使用了`2*N - (N-1) = N + 1`个空指针。线索树的想法就是将这些空指针利用上，来加快遍历速度的。\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28)\n\n对于上面的二叉树来说，其中序遍历的结果为`[6 4 7 2 5 8 9 1 3]`。\n\n如果节点 A 被访问后，马上访问 B，我们就认为 A 是 B 的前驱，B 是 A 的后继。从中序遍历的结果可以看出 6 是 4 的前驱，4 是 6 的后继。\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28)\n\n上图中，红色虚线表示后继，绿色虚线表示前驱，一般我们将前驱放在左孩子，后继放在右孩子中。为了区分一个节点的两个孩子指针到底是真的孩子，还是线索，一般需要在每个节点中增加两个flag 位来区分。\n\n### 莫里斯算法——中序遍历\n\n因为中序线索树需要给每个节点都增加两个`flag`，但是因为很多时候我们不能修改二叉树节点的数据结构，所以它在很多情况是不适合的。通过观察我们可以发现，**在建立完中序线索树后，一个节点的左子树中最右边的节点的后继线索是总指向该节点的**。我们可以根据这个规律来判断当前节点是否需要访问，是向左孩子移动还是向右孩子移动。同时，因为遍历时不需要用到前驱，所以我们不用建立前驱的节点，只需要建立后继即可。\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28)\n\n当我们访问节点`root`的时候：\n\n- 如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为`root`（建立线索），并向左孩子移动。\n- 如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为`root`，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，访问`root`节点，并向右子树移动。\n- 如果它没有左孩子，则直接访问`root`，并向右子树移动。\n\n```c++\nTreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n    while(root->right && root->right != end) root = root->right;\n    return root;\n}\n\nvoid inorderTraversal(TreeNode* root) {\n    while(root) {\n        if (root->left) {\n            TreeNode *p = GetRightLeaf(root->left, root);\n            if (p->right == root) {\n                p->right = nullptr;\n                cout << root->val << endl;\n                root = root->right;\n            } else {\n                p->right = root;\n                root = root->left;\n            }\n        } else {\n            cout << root->val << endl;\n            root = root->right;\n        }\n    }\n}\n```\n\n### 莫里斯算法——先序遍历\n\n在莫里斯算法中，先序遍历与中序遍历非常想，只是访问`root`的节点的位置变了。在中序遍历中，我们总是在向右子树移动的时候访问`root`节点。而在先序遍历的中，我们总是在向左子树移动的时候访问`root`。当然，在没有左孩子的情况时，一样也是先访问`root`节点，再想右孩子移动。\n\n当我们访问节点`root`的时候：\n\n- 如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为`root`（建立线索），访问`root`节点，并向左孩子移动。\n- 如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为`root`，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，并向右子树移动。\n- 如果它没有左孩子，则直接访问`root`，并向右子树移动。\n\n因此代码如下：\n\n```c++\nTreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n    while(root->right && root->right != end) root = root->right;\n    return root;\n}\nvoid preorderTraversal(TreeNode* root) {\n    while(root) {    \n        if (root->left) {\n            // if (root->right == nullptr) cout << \"NULL\" << endl;\n            TreeNode *p = GetRightLeaf(root->left, root);\n            if (p->right == root) {\n                p->right = nullptr;\n                root = root->right;\n            } else {\n                p->right = root;\n                cout << root->val << endl;\n                root = root->left;\n            }\n        } else {\n            cout << root->val << endl; \n            root = root->right;\n        }\n    }\n}\n```\n\n### 莫里斯遍历——后序遍历\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28)\n\n通过观察，我们可以发现先、中、后序遍历有上面这种规律，因此我们可以发现，当所有左子树被访问完了（这时只剩下一条由右孩子组成的边，这里为了简便，将其称为，右边），按逆序访问由右边即可。\n\n当我们访问节点`root`的时候：\n\n- 如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为`root`（建立线索），并向左孩子移动。\n- 如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为`root`，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，**逆序访问左子树的右边。**\n- 如果它没有左孩子，并向右子树移动。\n\n按上面的算法进行的话，会导致有一条右边没办法访问到，所以增加一个虚节点，该虚节点的左孩子为`root`,右孩子为空，即：\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28)\n\n```c++\nTreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n    while(root->right && root->right != end) root = root->right;\n    return root;\n}\nTreeNode *reverse(TreeNode *p, const function<void(int)> &func) {\n    TreeNode *prev, *next;\n    prev = nullptr;\n    while(p) {\n        func(p->val);\n        next = p->right;\n        p->right = prev;\n        prev = p;\n        p = next;\n    }\n    return prev;\n}\nvector<int> postorderTraversal2(TreeNode* root) {\n    TreeNode node(0);\n    node.left = root;\n    root = &node;\n\n    auto func1 = [&](int val) {\n        res.push_back(val);\n    };\n    auto func2 = [](int val) {};\n\n    while(root) {\n        if (root->left) {\n            TreeNode *p = GetRightLeaf(root->left, root);\n            if (p->right == root) {\n                p->right = nullptr;\n                p = reverse(root->left, func2);\n                reverse(p, func1);\n                root = root->right;\n            } else {\n                p->right = root;\n                root = root->left;\n            }\n        } else root = root->right;\n    }\n    return res;\n}\n```\n\n为了使得空间复杂度为`O(1)`，在逆序访问时，我们通过“翻转链表”的方式进行逆序访问，而不是用栈来实现。\n","source":"_posts/Binary-Tree-Preorder-Inorder-Postorder-Traversal.md","raw":"---\ntitle: Binary Tree (Preorder|Inorder|Postorder) Traversal\ndate: 2020-03-24T12:10:21.000Z\ntags:\n  - LeetCode\n  - Tree\n  - Stack\ncategories:\n  - LeetCode\n---\n\n今天将二叉树的先、中、后遍历的做了一些总结。三种遍历都有三种写法：\n\n- 递归\n  - 时间复杂度：`O(n)`\n  - 空间复杂度：`O(h)`，`h`为树高\n- 基于栈进行迭代：\n  - 时间复杂度:`O(n)`\n  - 空间复杂度：`O(n)`\n- 莫里斯算法：\n  - 时间复杂度：`O(n)`\n  - 空间复杂度：`O(1)`\n\n接下来内容有一下几个部分组成：\n1. 首先介绍二叉树先、中、后序遍历的含义\n2. 递归算法\n3. 基于栈的迭代算法\n4. 莫里斯算法\n\n## 二叉树 & 先、中、后序遍历\n\n![](https://g.gravizo.com/svg?digraph%20G%20{%20node[shape=circle]%20edge[arrowhead=vee]%201-%3E2;%201-%3E5;%202-%3E3;%202-%3E4;%20})\n\n- 先序遍历：\n\n  > 1. 访问当前节点\n  > 2. 遍历左子树\n  > 3. 遍历右子树\n\n- 中序遍历：\n\n  > 1. 遍历左子树\n  > 2. 访问当前节点\n  > 3. 遍历右子树\n\n- 后序遍历：\n\n  > 1. 遍历左子树\n  > 2. 遍历右子树\n  > 3. 访问当前节点\n\n如上图中显示的二叉树中，先、中、后序遍历分别为：\n\n- 先序：`1 2 3 4 5`\n- 中序：`3 2 4 1 5`\n- 后序：`3 4 2 5 1`\n\n## 递归算法\n\n已知三种遍历的含义之后，我们可以很容易的写出三种遍历的递归算法:\n\n```c++\nvoid prevorderTraversal(TreeNode *root) {\n    if (root) {\n        cout << root->val << endl;\n        prevorderTraversal(root->left);\n        prevorderTraversal(root->right);\n    }\n}\n\nvoid inorderTraversal(TreeNode *root) {\n    if (root) {\n        inorderTraversal(root->left);\n        cout << root->val << endl;\n        inorderTraversal(root->right);\n    }\n}\n\nvoid postorderTraversal(TreeNode *root) {\n    if (root) {\n        postorderTraversal(root->left);\n        postorderTraversal(root->right);\n        cout << root->val << endl;\n    }\n}\n```\n\n> 由于递归算法比较简单，所以这里不做过多的说明。\n>\n> 为了方便，访问节点时，只是输出节点的值。\n\n## 基于栈的迭代算法\n\n### 基于栈的迭代算法——先序遍历\n\n基于栈的遍历算法中，先序遍历是最简单的。因为先序遍历本身可以进行尾递归优化，所以很容易用`stack`对递归调用进行模拟：\n\n```c++\nvoid preorderTraversal(TreeNode *root) {\n    stack<TreeNode *> st;\n    if (root) st.push(root);\n    while(!st.empty()) {\n        root = st.top(); st.pop();\n        cout << root->val << endl;\n        if (root->right) st.push(root->right);\n        if (root->left) st.push(root->left);\n    }\n}\n```\n\n需要注意的是，因为栈用后进先出的特性，所以要先将右子树压入栈中，然后再将左子树压入栈中。\n\n### 基于栈的迭代算法——中序遍历\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28)\n\n我们以上图为例子，其中圆圈表示树中的节点，而三角形表示子树。其中的序号为访问顺序，我们可以发现，进行中序遍历的二叉树都符合这样的移动规律：\n\n1. 先一直往左孩子的方向移动，直到没有左孩子。\n2. 然后访问该节点，并遍历其右子树（这时相当于对其右子树进行 1、2、3步）。\n3. 最后返回到其父节点并从第 2 步开始。\n\n为了方便实现和代码的简洁，我们可以把观察到规律转换一下：\n\n1. 先一直往左孩子的方向移动，直到当前节点为空，同时把所有经过的节点压入栈中。\n2. 如果栈不空，则将栈顶弹出并访问，向右孩子移动并返回第一步。\n\n因此我们可以写出如下代码：\n\n```c++\nvoid inorderTraversal(TreeNode *root) {\n    stack<TreeNode *> st;\n    while(root || !st.empty()) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n        // 栈一定不为空\n        root = st.top(); st.pop();\n        cout << root->val << endl;\n        root = root->right;\n    }\n}\n```\n\n### 基于栈的迭代算法——后序遍历\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28)\n\n后序遍历与中序遍历有些类似，同样需要先一直往左孩子方向移动直到没有左孩子，但是后序遍历要先访问完右子树才能访问当前节点，因此对于栈顶节点是否要访问并弹出，我们需要判断其右子树是否被访问了。同时，因为后序遍历中，一颗树的根节点是最后访问的，所以我们可以根据右孩子是否被访问了来判断右子树是否被访问了。而我们知道，当访问完右孩子，就可以马上访问该节点了，所以我们可以维护一个指针，该指针指向上一次被访问的节点。通过判断上一次被访问的节点是否为右子树或者`nullpter`，我们就可以知道是否要访问该节点并弹栈了。\n\n```c++\nvoid postorderTraversal(TreeNode* root) {\n    TreeNode *prev = nullptr;\n    stack<TreeNode *> st;\n    while(root || !st.empty()) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n        root = st.top();\n        if (root->right == nullptr || root->right == prev) {\n            cout << root << right << endl;\n            prev = root;\n            root = nullptr;\n            st.pop();\n        } else root = root->right;\n    }\n    return res; \n}\n```\n\n## 莫里斯算法\n\n莫里斯算法是一种用时间来换空间的二叉树遍历算法。他只需要`O(1)`的空间复杂度。\n\n个人觉得它非常像中序线索树，所以我们先介绍中序线索树，然后再来理解莫里斯遍历。\n\n### 中序线索树\n\n假设一颗二叉树有`N`个节点，因为每个节点有 2 个指向孩子的指针，所以我们就有了 `2*N` 个指向节点的指针。同时，因为根节点不需要指针指向它，所以我们就使用了`2*N - (N-1) = N + 1`个空指针。线索树的想法就是将这些空指针利用上，来加快遍历速度的。\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28)\n\n对于上面的二叉树来说，其中序遍历的结果为`[6 4 7 2 5 8 9 1 3]`。\n\n如果节点 A 被访问后，马上访问 B，我们就认为 A 是 B 的前驱，B 是 A 的后继。从中序遍历的结果可以看出 6 是 4 的前驱，4 是 6 的后继。\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28)\n\n上图中，红色虚线表示后继，绿色虚线表示前驱，一般我们将前驱放在左孩子，后继放在右孩子中。为了区分一个节点的两个孩子指针到底是真的孩子，还是线索，一般需要在每个节点中增加两个flag 位来区分。\n\n### 莫里斯算法——中序遍历\n\n因为中序线索树需要给每个节点都增加两个`flag`，但是因为很多时候我们不能修改二叉树节点的数据结构，所以它在很多情况是不适合的。通过观察我们可以发现，**在建立完中序线索树后，一个节点的左子树中最右边的节点的后继线索是总指向该节点的**。我们可以根据这个规律来判断当前节点是否需要访问，是向左孩子移动还是向右孩子移动。同时，因为遍历时不需要用到前驱，所以我们不用建立前驱的节点，只需要建立后继即可。\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28)\n\n当我们访问节点`root`的时候：\n\n- 如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为`root`（建立线索），并向左孩子移动。\n- 如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为`root`，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，访问`root`节点，并向右子树移动。\n- 如果它没有左孩子，则直接访问`root`，并向右子树移动。\n\n```c++\nTreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n    while(root->right && root->right != end) root = root->right;\n    return root;\n}\n\nvoid inorderTraversal(TreeNode* root) {\n    while(root) {\n        if (root->left) {\n            TreeNode *p = GetRightLeaf(root->left, root);\n            if (p->right == root) {\n                p->right = nullptr;\n                cout << root->val << endl;\n                root = root->right;\n            } else {\n                p->right = root;\n                root = root->left;\n            }\n        } else {\n            cout << root->val << endl;\n            root = root->right;\n        }\n    }\n}\n```\n\n### 莫里斯算法——先序遍历\n\n在莫里斯算法中，先序遍历与中序遍历非常想，只是访问`root`的节点的位置变了。在中序遍历中，我们总是在向右子树移动的时候访问`root`节点。而在先序遍历的中，我们总是在向左子树移动的时候访问`root`。当然，在没有左孩子的情况时，一样也是先访问`root`节点，再想右孩子移动。\n\n当我们访问节点`root`的时候：\n\n- 如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为`root`（建立线索），访问`root`节点，并向左孩子移动。\n- 如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为`root`，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，并向右子树移动。\n- 如果它没有左孩子，则直接访问`root`，并向右子树移动。\n\n因此代码如下：\n\n```c++\nTreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n    while(root->right && root->right != end) root = root->right;\n    return root;\n}\nvoid preorderTraversal(TreeNode* root) {\n    while(root) {    \n        if (root->left) {\n            // if (root->right == nullptr) cout << \"NULL\" << endl;\n            TreeNode *p = GetRightLeaf(root->left, root);\n            if (p->right == root) {\n                p->right = nullptr;\n                root = root->right;\n            } else {\n                p->right = root;\n                cout << root->val << endl;\n                root = root->left;\n            }\n        } else {\n            cout << root->val << endl; \n            root = root->right;\n        }\n    }\n}\n```\n\n### 莫里斯遍历——后序遍历\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28)\n\n通过观察，我们可以发现先、中、后序遍历有上面这种规律，因此我们可以发现，当所有左子树被访问完了（这时只剩下一条由右孩子组成的边，这里为了简便，将其称为，右边），按逆序访问由右边即可。\n\n当我们访问节点`root`的时候：\n\n- 如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为`root`（建立线索），并向左孩子移动。\n- 如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为`root`，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，**逆序访问左子树的右边。**\n- 如果它没有左孩子，并向右子树移动。\n\n按上面的算法进行的话，会导致有一条右边没办法访问到，所以增加一个虚节点，该虚节点的左孩子为`root`,右孩子为空，即：\n\n![Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28](https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28)\n\n```c++\nTreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) {\n    while(root->right && root->right != end) root = root->right;\n    return root;\n}\nTreeNode *reverse(TreeNode *p, const function<void(int)> &func) {\n    TreeNode *prev, *next;\n    prev = nullptr;\n    while(p) {\n        func(p->val);\n        next = p->right;\n        p->right = prev;\n        prev = p;\n        p = next;\n    }\n    return prev;\n}\nvector<int> postorderTraversal2(TreeNode* root) {\n    TreeNode node(0);\n    node.left = root;\n    root = &node;\n\n    auto func1 = [&](int val) {\n        res.push_back(val);\n    };\n    auto func2 = [](int val) {};\n\n    while(root) {\n        if (root->left) {\n            TreeNode *p = GetRightLeaf(root->left, root);\n            if (p->right == root) {\n                p->right = nullptr;\n                p = reverse(root->left, func2);\n                reverse(p, func1);\n                root = root->right;\n            } else {\n                p->right = root;\n                root = root->left;\n            }\n        } else root = root->right;\n    }\n    return res;\n}\n```\n\n为了使得空间复杂度为`O(1)`，在逆序访问时，我们通过“翻转链表”的方式进行逆序访问，而不是用栈来实现。\n","slug":"Binary-Tree-Preorder-Inorder-Postorder-Traversal","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mw001pqmcm13ilgolp","content":"<p>今天将二叉树的先、中、后遍历的做了一些总结。三种遍历都有三种写法：</p>\n<ul>\n<li>递归<ul>\n<li>时间复杂度：<code>O(n)</code></li>\n<li>空间复杂度：<code>O(h)</code>，<code>h</code>为树高</li>\n</ul>\n</li>\n<li>基于栈进行迭代：<ul>\n<li>时间复杂度:<code>O(n)</code></li>\n<li>空间复杂度：<code>O(n)</code></li>\n</ul>\n</li>\n<li>莫里斯算法：<ul>\n<li>时间复杂度：<code>O(n)</code></li>\n<li>空间复杂度：<code>O(1)</code></li>\n</ul>\n</li>\n</ul>\n<p>接下来内容有一下几个部分组成：</p>\n<ol>\n<li>首先介绍二叉树先、中、后序遍历的含义</li>\n<li>递归算法</li>\n<li>基于栈的迭代算法</li>\n<li>莫里斯算法</li>\n</ol>\n<h2 id=\"二叉树-amp-先、中、后序遍历\"><a href=\"#二叉树-amp-先、中、后序遍历\" class=\"headerlink\" title=\"二叉树 &amp; 先、中、后序遍历\"></a>二叉树 &amp; 先、中、后序遍历</h2><p><img src=\"https://g.gravizo.com/svg?digraph%20G%20%7B%20node%5Bshape=circle%5D%20edge%5Barrowhead=vee%5D%201-%3E2;%201-%3E5;%202-%3E3;%202-%3E4;%20%7D\"></p>\n<ul>\n<li><p>先序遍历：</p>\n<blockquote>\n<ol>\n<li>访问当前节点</li>\n<li>遍历左子树</li>\n<li>遍历右子树</li>\n</ol>\n</blockquote>\n</li>\n<li><p>中序遍历：</p>\n<blockquote>\n<ol>\n<li>遍历左子树</li>\n<li>访问当前节点</li>\n<li>遍历右子树</li>\n</ol>\n</blockquote>\n</li>\n<li><p>后序遍历：</p>\n<blockquote>\n<ol>\n<li>遍历左子树</li>\n<li>遍历右子树</li>\n<li>访问当前节点</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<p>如上图中显示的二叉树中，先、中、后序遍历分别为：</p>\n<ul>\n<li>先序：<code>1 2 3 4 5</code></li>\n<li>中序：<code>3 2 4 1 5</code></li>\n<li>后序：<code>3 4 2 5 1</code></li>\n</ul>\n<h2 id=\"递归算法\"><a href=\"#递归算法\" class=\"headerlink\" title=\"递归算法\"></a>递归算法</h2><p>已知三种遍历的含义之后，我们可以很容易的写出三种遍历的递归算法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">prevorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        prevorderTraversal(root-&gt;left);</span><br><span class=\"line\">        prevorderTraversal(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">        inorderTraversal(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        inorderTraversal(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">        postorderTraversal(root-&gt;left);</span><br><span class=\"line\">        postorderTraversal(root-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于递归算法比较简单，所以这里不做过多的说明。</p>\n<p>为了方便，访问节点时，只是输出节点的值。</p>\n</blockquote>\n<h2 id=\"基于栈的迭代算法\"><a href=\"#基于栈的迭代算法\" class=\"headerlink\" title=\"基于栈的迭代算法\"></a>基于栈的迭代算法</h2><h3 id=\"基于栈的迭代算法——先序遍历\"><a href=\"#基于栈的迭代算法——先序遍历\" class=\"headerlink\" title=\"基于栈的迭代算法——先序遍历\"></a>基于栈的迭代算法——先序遍历</h3><p>基于栈的遍历算法中，先序遍历是最简单的。因为先序遍历本身可以进行尾递归优化，所以很容易用<code>stack</code>对递归调用进行模拟：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) st.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">        root = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) st.push(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) st.push(root-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，因为栈用后进先出的特性，所以要先将右子树压入栈中，然后再将左子树压入栈中。</p>\n<h3 id=\"基于栈的迭代算法——中序遍历\"><a href=\"#基于栈的迭代算法——中序遍历\" class=\"headerlink\" title=\"基于栈的迭代算法——中序遍历\"></a>基于栈的迭代算法——中序遍历</h3><p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28\"></p>\n<p>我们以上图为例子，其中圆圈表示树中的节点，而三角形表示子树。其中的序号为访问顺序，我们可以发现，进行中序遍历的二叉树都符合这样的移动规律：</p>\n<ol>\n<li>先一直往左孩子的方向移动，直到没有左孩子。</li>\n<li>然后访问该节点，并遍历其右子树（这时相当于对其右子树进行 1、2、3步）。</li>\n<li>最后返回到其父节点并从第 2 步开始。</li>\n</ol>\n<p>为了方便实现和代码的简洁，我们可以把观察到规律转换一下：</p>\n<ol>\n<li>先一直往左孩子的方向移动，直到当前节点为空，同时把所有经过的节点压入栈中。</li>\n<li>如果栈不空，则将栈顶弹出并访问，向右孩子移动并返回第一步。</li>\n</ol>\n<p>因此我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root || !st.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 栈一定不为空</span></span><br><span class=\"line\">        root = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基于栈的迭代算法——后序遍历\"><a href=\"#基于栈的迭代算法——后序遍历\" class=\"headerlink\" title=\"基于栈的迭代算法——后序遍历\"></a>基于栈的迭代算法——后序遍历</h3><p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28\"></p>\n<p>后序遍历与中序遍历有些类似，同样需要先一直往左孩子方向移动直到没有左孩子，但是后序遍历要先访问完右子树才能访问当前节点，因此对于栈顶节点是否要访问并弹出，我们需要判断其右子树是否被访问了。同时，因为后序遍历中，一颗树的根节点是最后访问的，所以我们可以根据右孩子是否被访问了来判断右子树是否被访问了。而我们知道，当访问完右孩子，就可以马上访问该节点了，所以我们可以维护一个指针，该指针指向上一次被访问的节点。通过判断上一次被访问的节点是否为右子树或者<code>nullpter</code>，我们就可以知道是否要访问该节点并弹栈了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode *prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root || !st.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root = st.top();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; root &lt;&lt; right &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            prev = root;</span><br><span class=\"line\">            root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"莫里斯算法\"><a href=\"#莫里斯算法\" class=\"headerlink\" title=\"莫里斯算法\"></a>莫里斯算法</h2><p>莫里斯算法是一种用时间来换空间的二叉树遍历算法。他只需要<code>O(1)</code>的空间复杂度。</p>\n<p>个人觉得它非常像中序线索树，所以我们先介绍中序线索树，然后再来理解莫里斯遍历。</p>\n<h3 id=\"中序线索树\"><a href=\"#中序线索树\" class=\"headerlink\" title=\"中序线索树\"></a>中序线索树</h3><p>假设一颗二叉树有<code>N</code>个节点，因为每个节点有 2 个指向孩子的指针，所以我们就有了 <code>2*N</code> 个指向节点的指针。同时，因为根节点不需要指针指向它，所以我们就使用了<code>2*N - (N-1) = N + 1</code>个空指针。线索树的想法就是将这些空指针利用上，来加快遍历速度的。</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28\"></p>\n<p>对于上面的二叉树来说，其中序遍历的结果为<code>[6 4 7 2 5 8 9 1 3]</code>。</p>\n<p>如果节点 A 被访问后，马上访问 B，我们就认为 A 是 B 的前驱，B 是 A 的后继。从中序遍历的结果可以看出 6 是 4 的前驱，4 是 6 的后继。</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28\"></p>\n<p>上图中，红色虚线表示后继，绿色虚线表示前驱，一般我们将前驱放在左孩子，后继放在右孩子中。为了区分一个节点的两个孩子指针到底是真的孩子，还是线索，一般需要在每个节点中增加两个flag 位来区分。</p>\n<h3 id=\"莫里斯算法——中序遍历\"><a href=\"#莫里斯算法——中序遍历\" class=\"headerlink\" title=\"莫里斯算法——中序遍历\"></a>莫里斯算法——中序遍历</h3><p>因为中序线索树需要给每个节点都增加两个<code>flag</code>，但是因为很多时候我们不能修改二叉树节点的数据结构，所以它在很多情况是不适合的。通过观察我们可以发现，<strong>在建立完中序线索树后，一个节点的左子树中最右边的节点的后继线索是总指向该节点的</strong>。我们可以根据这个规律来判断当前节点是否需要访问，是向左孩子移动还是向右孩子移动。同时，因为遍历时不需要用到前驱，所以我们不用建立前驱的节点，只需要建立后继即可。</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28\"></p>\n<p>当我们访问节点<code>root</code>的时候：</p>\n<ul>\n<li>如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为<code>root</code>（建立线索），并向左孩子移动。</li>\n<li>如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为<code>root</code>，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，访问<code>root</code>节点，并向右子树移动。</li>\n<li>如果它没有左孩子，则直接访问<code>root</code>，并向右子树移动。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p-&gt;right = root;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"莫里斯算法——先序遍历\"><a href=\"#莫里斯算法——先序遍历\" class=\"headerlink\" title=\"莫里斯算法——先序遍历\"></a>莫里斯算法——先序遍历</h3><p>在莫里斯算法中，先序遍历与中序遍历非常想，只是访问<code>root</code>的节点的位置变了。在中序遍历中，我们总是在向右子树移动的时候访问<code>root</code>节点。而在先序遍历的中，我们总是在向左子树移动的时候访问<code>root</code>。当然，在没有左孩子的情况时，一样也是先访问<code>root</code>节点，再想右孩子移动。</p>\n<p>当我们访问节点<code>root</code>的时候：</p>\n<ul>\n<li>如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为<code>root</code>（建立线索），访问<code>root</code>节点，并向左孩子移动。</li>\n<li>如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为<code>root</code>，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，并向右子树移动。</li>\n<li>如果它没有左孩子，则直接访问<code>root</code>，并向右子树移动。</li>\n</ul>\n<p>因此代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// if (root-&gt;right == nullptr) cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl;</span></span><br><span class=\"line\">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p-&gt;right = root;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>; </span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"莫里斯遍历——后序遍历\"><a href=\"#莫里斯遍历——后序遍历\" class=\"headerlink\" title=\"莫里斯遍历——后序遍历\"></a>莫里斯遍历——后序遍历</h3><p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28\"></p>\n<p>通过观察，我们可以发现先、中、后序遍历有上面这种规律，因此我们可以发现，当所有左子树被访问完了（这时只剩下一条由右孩子组成的边，这里为了简便，将其称为，右边），按逆序访问由右边即可。</p>\n<p>当我们访问节点<code>root</code>的时候：</p>\n<ul>\n<li>如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为<code>root</code>（建立线索），并向左孩子移动。</li>\n<li>如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为<code>root</code>，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，<strong>逆序访问左子树的右边。</strong></li>\n<li>如果它没有左孩子，并向右子树移动。</li>\n</ul>\n<p>按上面的算法进行的话，会导致有一条右边没办法访问到，所以增加一个虚节点，该虚节点的左孩子为<code>root</code>,右孩子为空，即：</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">reverse</span><span class=\"params\">(TreeNode *p, <span class=\"keyword\">const</span> function&lt;<span class=\"keyword\">void</span>(<span class=\"keyword\">int</span>)&gt; &amp;func)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode *prev, *next;</span><br><span class=\"line\">    prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p) &#123;</span><br><span class=\"line\">        func(p-&gt;val);</span><br><span class=\"line\">        next = p-&gt;right;</span><br><span class=\"line\">        p-&gt;right = prev;</span><br><span class=\"line\">        prev = p;</span><br><span class=\"line\">        p = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">postorderTraversal2</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">TreeNode <span class=\"title\">node</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    node.left = root;</span><br><span class=\"line\">    root = &amp;node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> func1 = [&amp;](<span class=\"keyword\">int</span> val) &#123;</span><br><span class=\"line\">        res.push_back(val);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> func2 = [](<span class=\"keyword\">int</span> val) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                p = reverse(root-&gt;left, func2);</span><br><span class=\"line\">                reverse(p, func1);</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p-&gt;right = root;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了使得空间复杂度为<code>O(1)</code>，在逆序访问时，我们通过“翻转链表”的方式进行逆序访问，而不是用栈来实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天将二叉树的先、中、后遍历的做了一些总结。三种遍历都有三种写法：</p>\n<ul>\n<li>递归<ul>\n<li>时间复杂度：<code>O(n)</code></li>\n<li>空间复杂度：<code>O(h)</code>，<code>h</code>为树高</li>\n</ul>\n</li>\n<li>基于栈进行迭代：<ul>\n<li>时间复杂度:<code>O(n)</code></li>\n<li>空间复杂度：<code>O(n)</code></li>\n</ul>\n</li>\n<li>莫里斯算法：<ul>\n<li>时间复杂度：<code>O(n)</code></li>\n<li>空间复杂度：<code>O(1)</code></li>\n</ul>\n</li>\n</ul>\n<p>接下来内容有一下几个部分组成：</p>\n<ol>\n<li>首先介绍二叉树先、中、后序遍历的含义</li>\n<li>递归算法</li>\n<li>基于栈的迭代算法</li>\n<li>莫里斯算法</li>\n</ol>\n<h2 id=\"二叉树-amp-先、中、后序遍历\"><a href=\"#二叉树-amp-先、中、后序遍历\" class=\"headerlink\" title=\"二叉树 &amp; 先、中、后序遍历\"></a>二叉树 &amp; 先、中、后序遍历</h2><p><img src=\"https://g.gravizo.com/svg?digraph%20G%20%7B%20node%5Bshape=circle%5D%20edge%5Barrowhead=vee%5D%201-%3E2;%201-%3E5;%202-%3E3;%202-%3E4;%20%7D\"></p>\n<ul>\n<li><p>先序遍历：</p>\n<blockquote>\n<ol>\n<li>访问当前节点</li>\n<li>遍历左子树</li>\n<li>遍历右子树</li>\n</ol>\n</blockquote>\n</li>\n<li><p>中序遍历：</p>\n<blockquote>\n<ol>\n<li>遍历左子树</li>\n<li>访问当前节点</li>\n<li>遍历右子树</li>\n</ol>\n</blockquote>\n</li>\n<li><p>后序遍历：</p>\n<blockquote>\n<ol>\n<li>遍历左子树</li>\n<li>遍历右子树</li>\n<li>访问当前节点</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<p>如上图中显示的二叉树中，先、中、后序遍历分别为：</p>\n<ul>\n<li>先序：<code>1 2 3 4 5</code></li>\n<li>中序：<code>3 2 4 1 5</code></li>\n<li>后序：<code>3 4 2 5 1</code></li>\n</ul>\n<h2 id=\"递归算法\"><a href=\"#递归算法\" class=\"headerlink\" title=\"递归算法\"></a>递归算法</h2><p>已知三种遍历的含义之后，我们可以很容易的写出三种遍历的递归算法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">prevorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        prevorderTraversal(root-&gt;left);</span><br><span class=\"line\">        prevorderTraversal(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">        inorderTraversal(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        inorderTraversal(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">        postorderTraversal(root-&gt;left);</span><br><span class=\"line\">        postorderTraversal(root-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于递归算法比较简单，所以这里不做过多的说明。</p>\n<p>为了方便，访问节点时，只是输出节点的值。</p>\n</blockquote>\n<h2 id=\"基于栈的迭代算法\"><a href=\"#基于栈的迭代算法\" class=\"headerlink\" title=\"基于栈的迭代算法\"></a>基于栈的迭代算法</h2><h3 id=\"基于栈的迭代算法——先序遍历\"><a href=\"#基于栈的迭代算法——先序遍历\" class=\"headerlink\" title=\"基于栈的迭代算法——先序遍历\"></a>基于栈的迭代算法——先序遍历</h3><p>基于栈的遍历算法中，先序遍历是最简单的。因为先序遍历本身可以进行尾递归优化，所以很容易用<code>stack</code>对递归调用进行模拟：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) st.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">        root = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) st.push(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) st.push(root-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，因为栈用后进先出的特性，所以要先将右子树压入栈中，然后再将左子树压入栈中。</p>\n<h3 id=\"基于栈的迭代算法——中序遍历\"><a href=\"#基于栈的迭代算法——中序遍历\" class=\"headerlink\" title=\"基于栈的迭代算法——中序遍历\"></a>基于栈的迭代算法——中序遍历</h3><p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28\"></p>\n<p>我们以上图为例子，其中圆圈表示树中的节点，而三角形表示子树。其中的序号为访问顺序，我们可以发现，进行中序遍历的二叉树都符合这样的移动规律：</p>\n<ol>\n<li>先一直往左孩子的方向移动，直到没有左孩子。</li>\n<li>然后访问该节点，并遍历其右子树（这时相当于对其右子树进行 1、2、3步）。</li>\n<li>最后返回到其父节点并从第 2 步开始。</li>\n</ol>\n<p>为了方便实现和代码的简洁，我们可以把观察到规律转换一下：</p>\n<ol>\n<li>先一直往左孩子的方向移动，直到当前节点为空，同时把所有经过的节点压入栈中。</li>\n<li>如果栈不空，则将栈顶弹出并访问，向右孩子移动并返回第一步。</li>\n</ol>\n<p>因此我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root || !st.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 栈一定不为空</span></span><br><span class=\"line\">        root = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基于栈的迭代算法——后序遍历\"><a href=\"#基于栈的迭代算法——后序遍历\" class=\"headerlink\" title=\"基于栈的迭代算法——后序遍历\"></a>基于栈的迭代算法——后序遍历</h3><p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28\"></p>\n<p>后序遍历与中序遍历有些类似，同样需要先一直往左孩子方向移动直到没有左孩子，但是后序遍历要先访问完右子树才能访问当前节点，因此对于栈顶节点是否要访问并弹出，我们需要判断其右子树是否被访问了。同时，因为后序遍历中，一颗树的根节点是最后访问的，所以我们可以根据右孩子是否被访问了来判断右子树是否被访问了。而我们知道，当访问完右孩子，就可以马上访问该节点了，所以我们可以维护一个指针，该指针指向上一次被访问的节点。通过判断上一次被访问的节点是否为右子树或者<code>nullpter</code>，我们就可以知道是否要访问该节点并弹栈了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode *prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root || !st.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root = st.top();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; root &lt;&lt; right &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            prev = root;</span><br><span class=\"line\">            root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"莫里斯算法\"><a href=\"#莫里斯算法\" class=\"headerlink\" title=\"莫里斯算法\"></a>莫里斯算法</h2><p>莫里斯算法是一种用时间来换空间的二叉树遍历算法。他只需要<code>O(1)</code>的空间复杂度。</p>\n<p>个人觉得它非常像中序线索树，所以我们先介绍中序线索树，然后再来理解莫里斯遍历。</p>\n<h3 id=\"中序线索树\"><a href=\"#中序线索树\" class=\"headerlink\" title=\"中序线索树\"></a>中序线索树</h3><p>假设一颗二叉树有<code>N</code>个节点，因为每个节点有 2 个指向孩子的指针，所以我们就有了 <code>2*N</code> 个指向节点的指针。同时，因为根节点不需要指针指向它，所以我们就使用了<code>2*N - (N-1) = N + 1</code>个空指针。线索树的想法就是将这些空指针利用上，来加快遍历速度的。</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28\"></p>\n<p>对于上面的二叉树来说，其中序遍历的结果为<code>[6 4 7 2 5 8 9 1 3]</code>。</p>\n<p>如果节点 A 被访问后，马上访问 B，我们就认为 A 是 B 的前驱，B 是 A 的后继。从中序遍历的结果可以看出 6 是 4 的前驱，4 是 6 的后继。</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28\"></p>\n<p>上图中，红色虚线表示后继，绿色虚线表示前驱，一般我们将前驱放在左孩子，后继放在右孩子中。为了区分一个节点的两个孩子指针到底是真的孩子，还是线索，一般需要在每个节点中增加两个flag 位来区分。</p>\n<h3 id=\"莫里斯算法——中序遍历\"><a href=\"#莫里斯算法——中序遍历\" class=\"headerlink\" title=\"莫里斯算法——中序遍历\"></a>莫里斯算法——中序遍历</h3><p>因为中序线索树需要给每个节点都增加两个<code>flag</code>，但是因为很多时候我们不能修改二叉树节点的数据结构，所以它在很多情况是不适合的。通过观察我们可以发现，<strong>在建立完中序线索树后，一个节点的左子树中最右边的节点的后继线索是总指向该节点的</strong>。我们可以根据这个规律来判断当前节点是否需要访问，是向左孩子移动还是向右孩子移动。同时，因为遍历时不需要用到前驱，所以我们不用建立前驱的节点，只需要建立后继即可。</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28\"></p>\n<p>当我们访问节点<code>root</code>的时候：</p>\n<ul>\n<li>如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为<code>root</code>（建立线索），并向左孩子移动。</li>\n<li>如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为<code>root</code>，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，访问<code>root</code>节点，并向右子树移动。</li>\n<li>如果它没有左孩子，则直接访问<code>root</code>，并向右子树移动。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p-&gt;right = root;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"莫里斯算法——先序遍历\"><a href=\"#莫里斯算法——先序遍历\" class=\"headerlink\" title=\"莫里斯算法——先序遍历\"></a>莫里斯算法——先序遍历</h3><p>在莫里斯算法中，先序遍历与中序遍历非常想，只是访问<code>root</code>的节点的位置变了。在中序遍历中，我们总是在向右子树移动的时候访问<code>root</code>节点。而在先序遍历的中，我们总是在向左子树移动的时候访问<code>root</code>。当然，在没有左孩子的情况时，一样也是先访问<code>root</code>节点，再想右孩子移动。</p>\n<p>当我们访问节点<code>root</code>的时候：</p>\n<ul>\n<li>如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为<code>root</code>（建立线索），访问<code>root</code>节点，并向左孩子移动。</li>\n<li>如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为<code>root</code>，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，并向右子树移动。</li>\n<li>如果它没有左孩子，则直接访问<code>root</code>，并向右子树移动。</li>\n</ul>\n<p>因此代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// if (root-&gt;right == nullptr) cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl;</span></span><br><span class=\"line\">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p-&gt;right = root;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>; </span><br><span class=\"line\">            root = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"莫里斯遍历——后序遍历\"><a href=\"#莫里斯遍历——后序遍历\" class=\"headerlink\" title=\"莫里斯遍历——后序遍历\"></a>莫里斯遍历——后序遍历</h3><p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28\"></p>\n<p>通过观察，我们可以发现先、中、后序遍历有上面这种规律，因此我们可以发现，当所有左子树被访问完了（这时只剩下一条由右孩子组成的边，这里为了简便，将其称为，右边），按逆序访问由右边即可。</p>\n<p>当我们访问节点<code>root</code>的时候：</p>\n<ul>\n<li>如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为<code>root</code>（建立线索），并向左孩子移动。</li>\n<li>如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为<code>root</code>，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，<strong>逆序访问左子树的右边。</strong></li>\n<li>如果它没有左孩子，并向右子树移动。</li>\n</ul>\n<p>按上面的算法进行的话，会导致有一条右边没办法访问到，所以增加一个虚节点，该虚节点的左孩子为<code>root</code>,右孩子为空，即：</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28\" alt=\"Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">GetRightLeaf</span><span class=\"params\">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">reverse</span><span class=\"params\">(TreeNode *p, <span class=\"keyword\">const</span> function&lt;<span class=\"keyword\">void</span>(<span class=\"keyword\">int</span>)&gt; &amp;func)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode *prev, *next;</span><br><span class=\"line\">    prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p) &#123;</span><br><span class=\"line\">        func(p-&gt;val);</span><br><span class=\"line\">        next = p-&gt;right;</span><br><span class=\"line\">        p-&gt;right = prev;</span><br><span class=\"line\">        prev = p;</span><br><span class=\"line\">        p = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">postorderTraversal2</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">TreeNode <span class=\"title\">node</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    node.left = root;</span><br><span class=\"line\">    root = &amp;node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> func1 = [&amp;](<span class=\"keyword\">int</span> val) &#123;</span><br><span class=\"line\">        res.push_back(val);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> func2 = [](<span class=\"keyword\">int</span> val) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;right == root) &#123;</span><br><span class=\"line\">                p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                p = reverse(root-&gt;left, func2);</span><br><span class=\"line\">                reverse(p, func1);</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p-&gt;right = root;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了使得空间复杂度为<code>O(1)</code>，在逆序访问时，我们通过“翻转链表”的方式进行逆序访问，而不是用栈来实现。</p>\n"},{"title":"Binary Tree Pruning","date":"2019-12-11T02:47:58.000Z","_content":"\n> 第35天。\n\n今天的题目是[Binary Tree Pruning](https://leetcode.com/problems/binary-tree-pruning/):\n\n简单题，用先序遍历做就好了，而且不需要使用`flag`或`count`等额外的变量来判断是否要删除当前节点。\n\n大概逻辑如下：\n\n先序遍历时，用`left = pruneTree(left)`的方式去调用，在遍历完子树后，当前节点的子树都是只包含`1`的树了，我们可以通过判断指针是否为空来确定子树中是否有`1`，进而判断出是否要删除当前节点，所以我们不需要维护额外的变量来判断。\n\n```c++\nTreeNode* pruneTree(TreeNode* root) {\n    if (root == nullptr) return nullptr;\n    root->left = pruneTree(root->left);\n    root->right = pruneTree(root->right);\n    if (root->left || root->right || root->val == 1) return root;\n    delete root;\n    return nullptr;\n}\n```\n","source":"_posts/Binary-Tree-Pruning.md","raw":"---\ntitle: Binary Tree Pruning\ndate: 2019-12-11T10:47:58.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第35天。\n\n今天的题目是[Binary Tree Pruning](https://leetcode.com/problems/binary-tree-pruning/):\n\n简单题，用先序遍历做就好了，而且不需要使用`flag`或`count`等额外的变量来判断是否要删除当前节点。\n\n大概逻辑如下：\n\n先序遍历时，用`left = pruneTree(left)`的方式去调用，在遍历完子树后，当前节点的子树都是只包含`1`的树了，我们可以通过判断指针是否为空来确定子树中是否有`1`，进而判断出是否要删除当前节点，所以我们不需要维护额外的变量来判断。\n\n```c++\nTreeNode* pruneTree(TreeNode* root) {\n    if (root == nullptr) return nullptr;\n    root->left = pruneTree(root->left);\n    root->right = pruneTree(root->right);\n    if (root->left || root->right || root->val == 1) return root;\n    delete root;\n    return nullptr;\n}\n```\n","slug":"Binary-Tree-Pruning","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mx001sqmcm8xmf0quu","content":"<blockquote>\n<p>第35天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-pruning/\">Binary Tree Pruning</a>:</p>\n<p>简单题，用先序遍历做就好了，而且不需要使用<code>flag</code>或<code>count</code>等额外的变量来判断是否要删除当前节点。</p>\n<p>大概逻辑如下：</p>\n<p>先序遍历时，用<code>left = pruneTree(left)</code>的方式去调用，在遍历完子树后，当前节点的子树都是只包含<code>1</code>的树了，我们可以通过判断指针是否为空来确定子树中是否有<code>1</code>，进而判断出是否要删除当前节点，所以我们不需要维护额外的变量来判断。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">pruneTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    root-&gt;left = pruneTree(root-&gt;left);</span><br><span class=\"line\">    root-&gt;right = pruneTree(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left || root-&gt;right || root-&gt;val == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第35天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-pruning/\">Binary Tree Pruning</a>:</p>\n<p>简单题，用先序遍历做就好了，而且不需要使用<code>flag</code>或<code>count</code>等额外的变量来判断是否要删除当前节点。</p>\n<p>大概逻辑如下：</p>\n<p>先序遍历时，用<code>left = pruneTree(left)</code>的方式去调用，在遍历完子树后，当前节点的子树都是只包含<code>1</code>的树了，我们可以通过判断指针是否为空来确定子树中是否有<code>1</code>，进而判断出是否要删除当前节点，所以我们不需要维护额外的变量来判断。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">pruneTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    root-&gt;left = pruneTree(root-&gt;left);</span><br><span class=\"line\">    root-&gt;right = pruneTree(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left || root-&gt;right || root-&gt;val == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary-Tree-Right-Side-View","date":"2017-12-02T01:32:23.000Z","_content":"\n第66天。\n\n今天的题目是[Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/discuss/):\n\n> Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n>\n> For example:\n> Given the following binary tree,\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n\n> You should return [1, 3, 4].\n\n挺有趣的题目。\n\n简单的来讲，首先，我们肯定是要让右子树优先，然后还要保证在左子树比右子树高的情况下，它的节点也能被放到要返回的数组中。\n\n要比较高度，我们就需要在遍历的时候带上一个`height`,然后我们从按右子树优先进行先序遍历，这样就可以保证上面两个条件满足了，那，现在就是要计算什么时候将节点加入数组了。\n\n我们可以发现返回的数组的大小和树的高度是相同的，这样我们就可以通过当前节点的高度来决定是否要将值加入数组，又因为我们遍历的时候已经是右子树优先了，所以第一次遇到这个高度的节点的时候，我们就可以直接将其放入数组中。\n\n```c++\nvector<int> rightSideView1(TreeNode* root) {\n    vector<int> ret;\n    helper(root,0,ret);\n    return ret;\n}\nvoid helper(TreeNode *root,int height,vector<int> &ret) {\n    if (root == nullptr) return ;\n    if (height == ret.size()) ret.push_back(root->val);\n    helper(root->right,height + 1,ret);\n    helper(root->left,height+1,ret);\n}\n```\n\n然后是`dicuss`中用层次遍历做的:\n\n```java\npublic List<Integer> rightSideView(TreeNode root) {\n    // reverse level traversal\n    List<Integer> result = new ArrayList();\n    Queue<TreeNode> queue = new LinkedList();\n    if (root == null) return result;\n\n    queue.offer(root);\n    while (queue.size() != 0) {\n        int size = queue.size();\n        for (int i=0; i<size; i++) {\n            TreeNode cur = queue.poll();\n            if (i == 0) result.add(cur.val);\n            if (cur.right != null) queue.offer(cur.right);\n            if (cur.left != null) queue.offer(cur.left);\n        }\n\n    }\n    return result;\n}\n```\n","source":"_posts/Binary-Tree-Right-Side-View.md","raw":"---\ntitle: Binary-Tree-Right-Side-View\ndate: 2017-12-02T09:32:23.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第66天。\n\n今天的题目是[Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/discuss/):\n\n> Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n>\n> For example:\n> Given the following binary tree,\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n\n> You should return [1, 3, 4].\n\n挺有趣的题目。\n\n简单的来讲，首先，我们肯定是要让右子树优先，然后还要保证在左子树比右子树高的情况下，它的节点也能被放到要返回的数组中。\n\n要比较高度，我们就需要在遍历的时候带上一个`height`,然后我们从按右子树优先进行先序遍历，这样就可以保证上面两个条件满足了，那，现在就是要计算什么时候将节点加入数组了。\n\n我们可以发现返回的数组的大小和树的高度是相同的，这样我们就可以通过当前节点的高度来决定是否要将值加入数组，又因为我们遍历的时候已经是右子树优先了，所以第一次遇到这个高度的节点的时候，我们就可以直接将其放入数组中。\n\n```c++\nvector<int> rightSideView1(TreeNode* root) {\n    vector<int> ret;\n    helper(root,0,ret);\n    return ret;\n}\nvoid helper(TreeNode *root,int height,vector<int> &ret) {\n    if (root == nullptr) return ;\n    if (height == ret.size()) ret.push_back(root->val);\n    helper(root->right,height + 1,ret);\n    helper(root->left,height+1,ret);\n}\n```\n\n然后是`dicuss`中用层次遍历做的:\n\n```java\npublic List<Integer> rightSideView(TreeNode root) {\n    // reverse level traversal\n    List<Integer> result = new ArrayList();\n    Queue<TreeNode> queue = new LinkedList();\n    if (root == null) return result;\n\n    queue.offer(root);\n    while (queue.size() != 0) {\n        int size = queue.size();\n        for (int i=0; i<size; i++) {\n            TreeNode cur = queue.poll();\n            if (i == 0) result.add(cur.val);\n            if (cur.right != null) queue.offer(cur.right);\n            if (cur.left != null) queue.offer(cur.left);\n        }\n\n    }\n    return result;\n}\n```\n","slug":"Binary-Tree-Right-Side-View","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69my001wqmcmbm137rms","content":"<p>第66天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-right-side-view/discuss/\">Binary Tree Right Side View</a>:</p>\n<blockquote>\n<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>\n<p>For example:<br>Given the following binary tree,</p>\n</blockquote>\n<p>   1            &lt;—<br> /   <br>2     3         &lt;—<br> \\     <br>  5     4       &lt;—</p>\n<blockquote>\n<p>You should return [1, 3, 4].</p>\n</blockquote>\n<p>挺有趣的题目。</p>\n<p>简单的来讲，首先，我们肯定是要让右子树优先，然后还要保证在左子树比右子树高的情况下，它的节点也能被放到要返回的数组中。</p>\n<p>要比较高度，我们就需要在遍历的时候带上一个<code>height</code>,然后我们从按右子树优先进行先序遍历，这样就可以保证上面两个条件满足了，那，现在就是要计算什么时候将节点加入数组了。</p>\n<p>我们可以发现返回的数组的大小和树的高度是相同的，这样我们就可以通过当前节点的高度来决定是否要将值加入数组，又因为我们遍历的时候已经是右子树优先了，所以第一次遇到这个高度的节点的时候，我们就可以直接将其放入数组中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">rightSideView1</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    helper(root,<span class=\"number\">0</span>,ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> height,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;ret)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (height == ret.size()) ret.push_back(root-&gt;val);</span><br><span class=\"line\">    helper(root-&gt;right,height + <span class=\"number\">1</span>,ret);</span><br><span class=\"line\">    helper(root-&gt;left,height+<span class=\"number\">1</span>,ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中用层次遍历做的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">rightSideView</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// reverse level traversal</span></span><br><span class=\"line\">    List&lt;Integer&gt; result = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    queue.offer(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;size; i++) &#123;</span><br><span class=\"line\">            TreeNode cur = queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) result.add(cur.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.right != <span class=\"keyword\">null</span>) queue.offer(cur.right);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.left != <span class=\"keyword\">null</span>) queue.offer(cur.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第66天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-right-side-view/discuss/\">Binary Tree Right Side View</a>:</p>\n<blockquote>\n<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>\n<p>For example:<br>Given the following binary tree,</p>\n</blockquote>\n<p>   1            &lt;—<br> /   <br>2     3         &lt;—<br> \\     <br>  5     4       &lt;—</p>\n<blockquote>\n<p>You should return [1, 3, 4].</p>\n</blockquote>\n<p>挺有趣的题目。</p>\n<p>简单的来讲，首先，我们肯定是要让右子树优先，然后还要保证在左子树比右子树高的情况下，它的节点也能被放到要返回的数组中。</p>\n<p>要比较高度，我们就需要在遍历的时候带上一个<code>height</code>,然后我们从按右子树优先进行先序遍历，这样就可以保证上面两个条件满足了，那，现在就是要计算什么时候将节点加入数组了。</p>\n<p>我们可以发现返回的数组的大小和树的高度是相同的，这样我们就可以通过当前节点的高度来决定是否要将值加入数组，又因为我们遍历的时候已经是右子树优先了，所以第一次遇到这个高度的节点的时候，我们就可以直接将其放入数组中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">rightSideView1</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    helper(root,<span class=\"number\">0</span>,ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> height,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;ret)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (height == ret.size()) ret.push_back(root-&gt;val);</span><br><span class=\"line\">    helper(root-&gt;right,height + <span class=\"number\">1</span>,ret);</span><br><span class=\"line\">    helper(root-&gt;left,height+<span class=\"number\">1</span>,ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中用层次遍历做的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">rightSideView</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// reverse level traversal</span></span><br><span class=\"line\">    List&lt;Integer&gt; result = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    queue.offer(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;size; i++) &#123;</span><br><span class=\"line\">            TreeNode cur = queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) result.add(cur.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.right != <span class=\"keyword\">null</span>) queue.offer(cur.right);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.left != <span class=\"keyword\">null</span>) queue.offer(cur.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary-Tree-Zigzag-Level-Order-Traversal","date":"2018-02-11T14:45:59.000Z","_content":"\n第97天。\n\n今天的题目是[Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/):\n\n> Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n>\n> For example:\n> Given binary tree [3,9,20,null,null,15,7],\n\n```python\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n> return its zigzag level order traversal as:\n\n```python\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n```\n\n首先想到的是用层次遍历的方式来实现。\n\n简单的层次遍历：\n\n```c++\nvoid levelTra(TreeNode *root) {\n    if (root == nullptr) return ;\n    queue<TreeNode *> q;\n    q.push(root);\n    while(!q.empty()) {\n        root = q.front(); q.pop();\n        cout << root->val;\n        if (root->left) q.push(root->left);\n        if (root->right) q.push(root->right);\n    }\n}\n```\n\n但是上面的方法是没法区分层数的，我们通过`nullptr`来表示换行：\n\n```c++\nvoid levelTra(TreeNode *root) {\n    if (root == nullptr) return ;\n    queue<TreeNode *> q;\n    q.push(root);\n    q.push(nullptr);\n    while(true) {\n        root = q.top(); q.pop();\n\n        if (root == nullptr) {\n            cout << \"new level\" << endl;\n            if (q.empty()) break;\n            q.push(nullptr);\n        }\n\n        cout << root->val << endl;\n        if (root->left) q.push(root->left);\n        if (root->right) q.push(root->right);\n    }\n}\n```\n\n```c++\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    vector<vector<int> > ret;\n    vector<int> tmp;\n    if (root == nullptr) return ret;\n    //level tra\n    \n    bool flag = true; //判断遍历方向\n    \n    queue<TreeNode *> q;\n    q.push(root);\n    q.push(nullptr);\n    \n    while(true) {\n        root = q.front(); q.pop();\n        if (root == nullptr)  {\n            \n            if (flag) ret.push_back(tmp);\n            else ret.push_back(vector<int>(tmp.rbegin(), tmp.rend()));\n            \n            tmp.clear();\n            flag = !flag;\n            \n            if (q.empty()) break;\n            q.push(nullptr);\n            continue;\n        }\n        \n        \n        tmp.push_back(root->val);\n        if (root->left) q.push(root->left);\n        if (root->right) q.push(root->right);\n    }\n    \n    return ret;\n}\n```\n\n\n然后是`dicuss`中的方法，简单的来说就是通过深度优先遍历来生成获取层次遍历的每层的数组（好像之前写过？），然后就会比前面用`queue`的方法快。\n\n```c++\nvoid travel(TreeNode *root, vector<vector<int> > &ret, int level) {\n    if (root == nullptr) return ;\n    if (level >= ret.size()) ret.push_back(vector<int>());\n    \n    ret[level].push_back(root->val);\n    \n    travel(root->left, ret, level + 1);\n    travel(root->right, ret, level + 1);\n}\n\nvector<vector<int> > zigzagLevelOrder(TreeNode *root) {\n    vector<vector<int>> ret;\n    travel(root, ret, 0);\n    \n    for(int i = 0;i < ret.size();i++) {\n        if (i % 2) reverse(ret[i].begin(), ret[i].end());\n    }\n    \n    return ret;\n}\n\n```\n\n---\n\n> Update as 2020-03-28\n\n最近在总结 Stack Tag 的算法，然后发现这道题可以用双栈来解，和前面队列的做法有点类似，某种意义上也是在模拟层次遍历，但是因为栈后进先出的特性，所以很直接的实现了逆序的操作，不需要额外做`reverse`。\n\n```c++\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    vector<vector<int> > res;\n    int level = 0;\n    stack<TreeNode*> st_even, st_odd;\n    if (root) st_even.push(root);\n    while(!st_even.empty() || !st_odd.empty()) {\n        stack<TreeNode*> &st1 = level % 2 == 0 ? st_even : st_odd;\n        stack<TreeNode*> &st2 = level % 2 == 0 ? st_odd : st_even;\n        vector<int> temp;\n        for(int i = 0, size = st1.size(); i < size; i++) {\n            root = st1.top(); st1.pop();\n            temp.push_back(root->val);\n\n            TreeNode *left = root->left, *right = root->right;\n            if (level % 2) swap(left, right);\n            \n            if (left) st2.push(left);\n            if (right) st2.push(right);\n        }\n        //cout << st1.size() << \" \" << st2.size() << endl;\n        res.push_back(temp);\n        level++;\n    }\n    return res;\n}\n```\n","source":"_posts/Binary-Tree-Zigzag-Level-Order-Traversal.md","raw":"---\ntitle: Binary-Tree-Zigzag-Level-Order-Traversal\ndate: 2018-02-11T22:45:59.000Z\ntags:\n  - LeetCode\n  - Tree\n  - Queues\n  - Stack\n  - BFS\ncategories:\n  - LeetCode\n---\n\n第97天。\n\n今天的题目是[Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/):\n\n> Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n>\n> For example:\n> Given binary tree [3,9,20,null,null,15,7],\n\n```python\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n> return its zigzag level order traversal as:\n\n```python\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n```\n\n首先想到的是用层次遍历的方式来实现。\n\n简单的层次遍历：\n\n```c++\nvoid levelTra(TreeNode *root) {\n    if (root == nullptr) return ;\n    queue<TreeNode *> q;\n    q.push(root);\n    while(!q.empty()) {\n        root = q.front(); q.pop();\n        cout << root->val;\n        if (root->left) q.push(root->left);\n        if (root->right) q.push(root->right);\n    }\n}\n```\n\n但是上面的方法是没法区分层数的，我们通过`nullptr`来表示换行：\n\n```c++\nvoid levelTra(TreeNode *root) {\n    if (root == nullptr) return ;\n    queue<TreeNode *> q;\n    q.push(root);\n    q.push(nullptr);\n    while(true) {\n        root = q.top(); q.pop();\n\n        if (root == nullptr) {\n            cout << \"new level\" << endl;\n            if (q.empty()) break;\n            q.push(nullptr);\n        }\n\n        cout << root->val << endl;\n        if (root->left) q.push(root->left);\n        if (root->right) q.push(root->right);\n    }\n}\n```\n\n```c++\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    vector<vector<int> > ret;\n    vector<int> tmp;\n    if (root == nullptr) return ret;\n    //level tra\n    \n    bool flag = true; //判断遍历方向\n    \n    queue<TreeNode *> q;\n    q.push(root);\n    q.push(nullptr);\n    \n    while(true) {\n        root = q.front(); q.pop();\n        if (root == nullptr)  {\n            \n            if (flag) ret.push_back(tmp);\n            else ret.push_back(vector<int>(tmp.rbegin(), tmp.rend()));\n            \n            tmp.clear();\n            flag = !flag;\n            \n            if (q.empty()) break;\n            q.push(nullptr);\n            continue;\n        }\n        \n        \n        tmp.push_back(root->val);\n        if (root->left) q.push(root->left);\n        if (root->right) q.push(root->right);\n    }\n    \n    return ret;\n}\n```\n\n\n然后是`dicuss`中的方法，简单的来说就是通过深度优先遍历来生成获取层次遍历的每层的数组（好像之前写过？），然后就会比前面用`queue`的方法快。\n\n```c++\nvoid travel(TreeNode *root, vector<vector<int> > &ret, int level) {\n    if (root == nullptr) return ;\n    if (level >= ret.size()) ret.push_back(vector<int>());\n    \n    ret[level].push_back(root->val);\n    \n    travel(root->left, ret, level + 1);\n    travel(root->right, ret, level + 1);\n}\n\nvector<vector<int> > zigzagLevelOrder(TreeNode *root) {\n    vector<vector<int>> ret;\n    travel(root, ret, 0);\n    \n    for(int i = 0;i < ret.size();i++) {\n        if (i % 2) reverse(ret[i].begin(), ret[i].end());\n    }\n    \n    return ret;\n}\n\n```\n\n---\n\n> Update as 2020-03-28\n\n最近在总结 Stack Tag 的算法，然后发现这道题可以用双栈来解，和前面队列的做法有点类似，某种意义上也是在模拟层次遍历，但是因为栈后进先出的特性，所以很直接的实现了逆序的操作，不需要额外做`reverse`。\n\n```c++\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    vector<vector<int> > res;\n    int level = 0;\n    stack<TreeNode*> st_even, st_odd;\n    if (root) st_even.push(root);\n    while(!st_even.empty() || !st_odd.empty()) {\n        stack<TreeNode*> &st1 = level % 2 == 0 ? st_even : st_odd;\n        stack<TreeNode*> &st2 = level % 2 == 0 ? st_odd : st_even;\n        vector<int> temp;\n        for(int i = 0, size = st1.size(); i < size; i++) {\n            root = st1.top(); st1.pop();\n            temp.push_back(root->val);\n\n            TreeNode *left = root->left, *right = root->right;\n            if (level % 2) swap(left, right);\n            \n            if (left) st2.push(left);\n            if (right) st2.push(right);\n        }\n        //cout << st1.size() << \" \" << st2.size() << endl;\n        res.push_back(temp);\n        level++;\n    }\n    return res;\n}\n```\n","slug":"Binary-Tree-Zigzag-Level-Order-Traversal","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69mz001zqmcm2jf6485z","content":"<p>第97天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/\">Binary Tree Zigzag Level Order Traversal</a>:</p>\n<blockquote>\n<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>\n<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">3</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">9</span>  <span class=\"number\">20</span></span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> <span class=\"number\">15</span>   <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>return its zigzag level order traversal as:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">20</span>,<span class=\"number\">9</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>首先想到的是用层次遍历的方式来实现。</p>\n<p>简单的层次遍历：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">levelTra</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">        root = q.front(); q.pop();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是上面的方法是没法区分层数的，我们通过<code>nullptr</code>来表示换行：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">levelTra</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        root = q.top(); q.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;new level&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q.empty()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"comment\">//level tra</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>; <span class=\"comment\">//判断遍历方向</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        root = q.front(); q.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)  &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) ret.push_back(tmp);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ret.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(tmp.rbegin(), tmp.rend()));</span><br><span class=\"line\">            </span><br><span class=\"line\">            tmp.clear();</span><br><span class=\"line\">            flag = !flag;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q.empty()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        tmp.push_back(root-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>然后是<code>dicuss</code>中的方法，简单的来说就是通过深度优先遍历来生成获取层次遍历的每层的数组（好像之前写过？），然后就会比前面用<code>queue</code>的方法快。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">travel</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;ret, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level &gt;= ret.size()) ret.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    </span><br><span class=\"line\">    ret[level].push_back(root-&gt;val);</span><br><span class=\"line\">    </span><br><span class=\"line\">    travel(root-&gt;left, ret, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    travel(root-&gt;right, ret, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; zigzagLevelOrder(TreeNode *root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    travel(root, ret, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; ret.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span>) reverse(ret[i].begin(), ret[i].end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>Update as 2020-03-28</p>\n</blockquote>\n<p>最近在总结 Stack Tag 的算法，然后发现这道题可以用双栈来解，和前面队列的做法有点类似，某种意义上也是在模拟层次遍历，但是因为栈后进先出的特性，所以很直接的实现了逆序的操作，不需要额外做<code>reverse</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; st_even, st_odd;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) st_even.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st_even.empty() || !st_odd.empty()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; &amp;st1 = level % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? st_even : st_odd;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; &amp;st2 = level % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? st_odd : st_even;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = st1.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">            root = st1.top(); st1.pop();</span><br><span class=\"line\">            temp.push_back(root-&gt;val);</span><br><span class=\"line\"></span><br><span class=\"line\">            TreeNode *left = root-&gt;left, *right = root-&gt;right;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (level % <span class=\"number\">2</span>) swap(left, right);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left) st2.push(left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right) st2.push(right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; st1.size() &lt;&lt; &quot; &quot; &lt;&lt; st2.size() &lt;&lt; endl;</span></span><br><span class=\"line\">        res.push_back(temp);</span><br><span class=\"line\">        level++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第97天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/\">Binary Tree Zigzag Level Order Traversal</a>:</p>\n<blockquote>\n<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>\n<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">3</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">9</span>  <span class=\"number\">20</span></span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> <span class=\"number\">15</span>   <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>return its zigzag level order traversal as:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">20</span>,<span class=\"number\">9</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>首先想到的是用层次遍历的方式来实现。</p>\n<p>简单的层次遍历：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">levelTra</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">        root = q.front(); q.pop();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是上面的方法是没法区分层数的，我们通过<code>nullptr</code>来表示换行：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">levelTra</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        root = q.top(); q.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;new level&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q.empty()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"comment\">//level tra</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>; <span class=\"comment\">//判断遍历方向</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        root = q.front(); q.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)  &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) ret.push_back(tmp);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ret.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(tmp.rbegin(), tmp.rend()));</span><br><span class=\"line\">            </span><br><span class=\"line\">            tmp.clear();</span><br><span class=\"line\">            flag = !flag;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q.empty()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        tmp.push_back(root-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>然后是<code>dicuss</code>中的方法，简单的来说就是通过深度优先遍历来生成获取层次遍历的每层的数组（好像之前写过？），然后就会比前面用<code>queue</code>的方法快。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">travel</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;ret, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level &gt;= ret.size()) ret.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    </span><br><span class=\"line\">    ret[level].push_back(root-&gt;val);</span><br><span class=\"line\">    </span><br><span class=\"line\">    travel(root-&gt;left, ret, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    travel(root-&gt;right, ret, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; zigzagLevelOrder(TreeNode *root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    travel(root, ret, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; ret.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span>) reverse(ret[i].begin(), ret[i].end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>Update as 2020-03-28</p>\n</blockquote>\n<p>最近在总结 Stack Tag 的算法，然后发现这道题可以用双栈来解，和前面队列的做法有点类似，某种意义上也是在模拟层次遍历，但是因为栈后进先出的特性，所以很直接的实现了逆序的操作，不需要额外做<code>reverse</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; st_even, st_odd;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root) st_even.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st_even.empty() || !st_odd.empty()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; &amp;st1 = level % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? st_even : st_odd;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; &amp;st2 = level % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? st_odd : st_even;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = st1.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">            root = st1.top(); st1.pop();</span><br><span class=\"line\">            temp.push_back(root-&gt;val);</span><br><span class=\"line\"></span><br><span class=\"line\">            TreeNode *left = root-&gt;left, *right = root-&gt;right;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (level % <span class=\"number\">2</span>) swap(left, right);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left) st2.push(left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right) st2.push(right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; st1.size() &lt;&lt; &quot; &quot; &lt;&lt; st2.size() &lt;&lt; endl;</span></span><br><span class=\"line\">        res.push_back(temp);</span><br><span class=\"line\">        level++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Bitwise ORs of Subarrays","date":"2019-03-11T02:22:12.000Z","_content":"\n> 第11天，今天刷的是一道动态规划的题目。\n\n今天的题目是[Bitwise ORs of Subarrays](https://leetcode.com/problems/bitwise-ors-of-subarrays/):\n\n这道题的时间复杂度很高，我们用个例子来解释解法：\n\n首先输入是`[1, 2, 4]`,我们先看下能不能用`[1, 2]`的答案来推出`[1, 2, 4]`的答案：\n\n`[1, 2]`的答案是`1, 2, 3`如果都与`4`或一下的话，会得到的是`[5, 6, 7]`，而`[1, 2, 4]`的答案中应该是没有`5`的，那么问题出在哪里了呢？如果仔细想一下的话，会发现这里要求的是连续子数组，而以`4`为结尾的连续子数组只有：`[4], [2, 4], [1, 2, 4]`，对它们进行或也就是说其实`1`其实是不会和`4`进行或运算的。\n\n那么要和`4`进行或运算的数组是什么呢？答案是一个空数组和所有以`2`结尾的连续子数组的或运算结果，而进行完或运算后得到的结果就是所有以`4`结尾的或运算结果。\n\n这时候我们就很容易想到解法了：\n\n用一个`set`保存所有以`A[i-1]`结尾的或运算结果，记为`set[i-1]`，然后分别与`A[i]`进行或运算插入到另一个`set`中，并在最后插入一个`A[i]`就可以得到`set[i]`。\n\n故：\n\n```c++\nclass Solution {\npublic:\n    int subarrayBitwiseORs(vector<int>& A) {\n        int len = A.size();\n        if (len == 0) return 0;\n        \n        unordered_set<int> res, cur, cur2;\n        for(auto &i: A) {\n            cur2 = {i};\n            for(auto &j : cur) cur2.insert(i | j);\n            cur = cur2;\n            for(auto &j: cur) res.insert(j);\n        }\n        return res.size();\n    }\n};\n```\n","source":"_posts/Bitwise-ORs-of-Subarrays.md","raw":"---\ntitle: Bitwise ORs of Subarrays\ndate: 2019-03-11T10:22:12.000Z\ntags:\n  - LeetCode\n  - 动态规划\ncategories:\n  - LeetCode\n---\n\n> 第11天，今天刷的是一道动态规划的题目。\n\n今天的题目是[Bitwise ORs of Subarrays](https://leetcode.com/problems/bitwise-ors-of-subarrays/):\n\n这道题的时间复杂度很高，我们用个例子来解释解法：\n\n首先输入是`[1, 2, 4]`,我们先看下能不能用`[1, 2]`的答案来推出`[1, 2, 4]`的答案：\n\n`[1, 2]`的答案是`1, 2, 3`如果都与`4`或一下的话，会得到的是`[5, 6, 7]`，而`[1, 2, 4]`的答案中应该是没有`5`的，那么问题出在哪里了呢？如果仔细想一下的话，会发现这里要求的是连续子数组，而以`4`为结尾的连续子数组只有：`[4], [2, 4], [1, 2, 4]`，对它们进行或也就是说其实`1`其实是不会和`4`进行或运算的。\n\n那么要和`4`进行或运算的数组是什么呢？答案是一个空数组和所有以`2`结尾的连续子数组的或运算结果，而进行完或运算后得到的结果就是所有以`4`结尾的或运算结果。\n\n这时候我们就很容易想到解法了：\n\n用一个`set`保存所有以`A[i-1]`结尾的或运算结果，记为`set[i-1]`，然后分别与`A[i]`进行或运算插入到另一个`set`中，并在最后插入一个`A[i]`就可以得到`set[i]`。\n\n故：\n\n```c++\nclass Solution {\npublic:\n    int subarrayBitwiseORs(vector<int>& A) {\n        int len = A.size();\n        if (len == 0) return 0;\n        \n        unordered_set<int> res, cur, cur2;\n        for(auto &i: A) {\n            cur2 = {i};\n            for(auto &j : cur) cur2.insert(i | j);\n            cur = cur2;\n            for(auto &j: cur) res.insert(j);\n        }\n        return res.size();\n    }\n};\n```\n","slug":"Bitwise-ORs-of-Subarrays","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69n00023qmcmh7b1h3jd","content":"<blockquote>\n<p>第11天，今天刷的是一道动态规划的题目。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/bitwise-ors-of-subarrays/\">Bitwise ORs of Subarrays</a>:</p>\n<p>这道题的时间复杂度很高，我们用个例子来解释解法：</p>\n<p>首先输入是<code>[1, 2, 4]</code>,我们先看下能不能用<code>[1, 2]</code>的答案来推出<code>[1, 2, 4]</code>的答案：</p>\n<p><code>[1, 2]</code>的答案是<code>1, 2, 3</code>如果都与<code>4</code>或一下的话，会得到的是<code>[5, 6, 7]</code>，而<code>[1, 2, 4]</code>的答案中应该是没有<code>5</code>的，那么问题出在哪里了呢？如果仔细想一下的话，会发现这里要求的是连续子数组，而以<code>4</code>为结尾的连续子数组只有：<code>[4], [2, 4], [1, 2, 4]</code>，对它们进行或也就是说其实<code>1</code>其实是不会和<code>4</code>进行或运算的。</p>\n<p>那么要和<code>4</code>进行或运算的数组是什么呢？答案是一个空数组和所有以<code>2</code>结尾的连续子数组的或运算结果，而进行完或运算后得到的结果就是所有以<code>4</code>结尾的或运算结果。</p>\n<p>这时候我们就很容易想到解法了：</p>\n<p>用一个<code>set</code>保存所有以<code>A[i-1]</code>结尾的或运算结果，记为<code>set[i-1]</code>，然后分别与<code>A[i]</code>进行或运算插入到另一个<code>set</code>中，并在最后插入一个<code>A[i]</code>就可以得到<code>set[i]</code>。</p>\n<p>故：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">subarrayBitwiseORs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = A.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt; res, cur, cur2;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;i: A) &#123;</span><br><span class=\"line\">            cur2 = &#123;i&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;j : cur) cur2.insert(i | j);</span><br><span class=\"line\">            cur = cur2;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;j: cur) res.insert(j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第11天，今天刷的是一道动态规划的题目。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/bitwise-ors-of-subarrays/\">Bitwise ORs of Subarrays</a>:</p>\n<p>这道题的时间复杂度很高，我们用个例子来解释解法：</p>\n<p>首先输入是<code>[1, 2, 4]</code>,我们先看下能不能用<code>[1, 2]</code>的答案来推出<code>[1, 2, 4]</code>的答案：</p>\n<p><code>[1, 2]</code>的答案是<code>1, 2, 3</code>如果都与<code>4</code>或一下的话，会得到的是<code>[5, 6, 7]</code>，而<code>[1, 2, 4]</code>的答案中应该是没有<code>5</code>的，那么问题出在哪里了呢？如果仔细想一下的话，会发现这里要求的是连续子数组，而以<code>4</code>为结尾的连续子数组只有：<code>[4], [2, 4], [1, 2, 4]</code>，对它们进行或也就是说其实<code>1</code>其实是不会和<code>4</code>进行或运算的。</p>\n<p>那么要和<code>4</code>进行或运算的数组是什么呢？答案是一个空数组和所有以<code>2</code>结尾的连续子数组的或运算结果，而进行完或运算后得到的结果就是所有以<code>4</code>结尾的或运算结果。</p>\n<p>这时候我们就很容易想到解法了：</p>\n<p>用一个<code>set</code>保存所有以<code>A[i-1]</code>结尾的或运算结果，记为<code>set[i-1]</code>，然后分别与<code>A[i]</code>进行或运算插入到另一个<code>set</code>中，并在最后插入一个<code>A[i]</code>就可以得到<code>set[i]</code>。</p>\n<p>故：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">subarrayBitwiseORs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = A.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt; res, cur, cur2;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;i: A) &#123;</span><br><span class=\"line\">            cur2 = &#123;i&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;j : cur) cur2.insert(i | j);</span><br><span class=\"line\">            cur = cur2;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;j: cur) res.insert(j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Boats to Save People","date":"2019-11-17T02:24:21.000Z","_content":"\n> 第13天。\n\n今天的题目是[ Boats to Save People ]( https://leetcode.com/problems/boats-to-save-people/ ):\n\n---\n\nThe `i`-th person has weight `people[i]`, and each boat can carry a maximum weight of `limit`.\n\nEach boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most `limit`.\n\nReturn the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.)\n\n \n\n**Example 1:**\n\n```\nInput: people = [1,2], limit = 3\nOutput: 1\nExplanation: 1 boat (1, 2)\n```\n\n**Example 2:**\n\n```\nInput: people = [3,2,2,1], limit = 3\nOutput: 3\nExplanation: 3 boats (1, 2), (2) and (3)\n```\n\n**Example 3:**\n\n```\nInput: people = [3,5,3,4], limit = 5\nOutput: 4\nExplanation: 4 boats (3), (3), (4), (5)\n```\n\n**Note**:\n\n- `1 <= people.length <= 50000`\n- `1 <= people[i] <= limit <= 30000`\n\n---\n\n一道贪心的题目，仔细分析下题目就会发现，如果一个`weight`比较大的人要坐船，一定是和`weight`小的人坐船，才能保证做的船数最少。因此，只要先排序，然后在双指针判断是否能做两个人即可：\n\n```c++\nint numRescueBoats1(vector<int>& people, int limit) {\n    sort(people.begin(), people.end());\n    int res = 0;\n\n    int i = 0, j = people.size() -1;\n    while(i <= j) {\n        res += 1;\n        if (limit >= people[i] + people[j]) {\n            i++;\n        }\n        j--;\n    }\n\n    return res;\n}\n```\n\n","source":"_posts/Boats-to-Save-People.md","raw":"---\ntitle: Boats to Save People\ndate: 2019-11-17T10:24:21.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第13天。\n\n今天的题目是[ Boats to Save People ]( https://leetcode.com/problems/boats-to-save-people/ ):\n\n---\n\nThe `i`-th person has weight `people[i]`, and each boat can carry a maximum weight of `limit`.\n\nEach boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most `limit`.\n\nReturn the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.)\n\n \n\n**Example 1:**\n\n```\nInput: people = [1,2], limit = 3\nOutput: 1\nExplanation: 1 boat (1, 2)\n```\n\n**Example 2:**\n\n```\nInput: people = [3,2,2,1], limit = 3\nOutput: 3\nExplanation: 3 boats (1, 2), (2) and (3)\n```\n\n**Example 3:**\n\n```\nInput: people = [3,5,3,4], limit = 5\nOutput: 4\nExplanation: 4 boats (3), (3), (4), (5)\n```\n\n**Note**:\n\n- `1 <= people.length <= 50000`\n- `1 <= people[i] <= limit <= 30000`\n\n---\n\n一道贪心的题目，仔细分析下题目就会发现，如果一个`weight`比较大的人要坐船，一定是和`weight`小的人坐船，才能保证做的船数最少。因此，只要先排序，然后在双指针判断是否能做两个人即可：\n\n```c++\nint numRescueBoats1(vector<int>& people, int limit) {\n    sort(people.begin(), people.end());\n    int res = 0;\n\n    int i = 0, j = people.size() -1;\n    while(i <= j) {\n        res += 1;\n        if (limit >= people[i] + people[j]) {\n            i++;\n        }\n        j--;\n    }\n\n    return res;\n}\n```\n\n","slug":"Boats-to-Save-People","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69n10026qmcmah4ae1t3","content":"<blockquote>\n<p>第13天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/boats-to-save-people/\"> Boats to Save People </a>:</p>\n<hr>\n<p>The <code>i</code>-th person has weight <code>people[i]</code>, and each boat can carry a maximum weight of <code>limit</code>.</p>\n<p>Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most <code>limit</code>.</p>\n<p>Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.)</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: people &#x3D; [1,2], limit &#x3D; 3</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: 1 boat (1, 2)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: people &#x3D; [3,2,2,1], limit &#x3D; 3</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: 3 boats (1, 2), (2) and (3)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: people &#x3D; [3,5,3,4], limit &#x3D; 5</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: 4 boats (3), (3), (4), (5)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note</strong>:</p>\n<ul>\n<li><code>1 &lt;= people.length &lt;= 50000</code></li>\n<li><code>1 &lt;= people[i] &lt;= limit &lt;= 30000</code></li>\n</ul>\n<hr>\n<p>一道贪心的题目，仔细分析下题目就会发现，如果一个<code>weight</code>比较大的人要坐船，一定是和<code>weight</code>小的人坐船，才能保证做的船数最少。因此，只要先排序，然后在双指针判断是否能做两个人即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numRescueBoats1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; people, <span class=\"keyword\">int</span> limit)</span> </span>&#123;</span><br><span class=\"line\">    sort(people.begin(), people.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = people.size() <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= j) &#123;</span><br><span class=\"line\">        res += <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (limit &gt;= people[i] + people[j]) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第13天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/boats-to-save-people/\"> Boats to Save People </a>:</p>\n<hr>\n<p>The <code>i</code>-th person has weight <code>people[i]</code>, and each boat can carry a maximum weight of <code>limit</code>.</p>\n<p>Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most <code>limit</code>.</p>\n<p>Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.)</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: people &#x3D; [1,2], limit &#x3D; 3</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: 1 boat (1, 2)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: people &#x3D; [3,2,2,1], limit &#x3D; 3</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: 3 boats (1, 2), (2) and (3)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: people &#x3D; [3,5,3,4], limit &#x3D; 5</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: 4 boats (3), (3), (4), (5)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note</strong>:</p>\n<ul>\n<li><code>1 &lt;= people.length &lt;= 50000</code></li>\n<li><code>1 &lt;= people[i] &lt;= limit &lt;= 30000</code></li>\n</ul>\n<hr>\n<p>一道贪心的题目，仔细分析下题目就会发现，如果一个<code>weight</code>比较大的人要坐船，一定是和<code>weight</code>小的人坐船，才能保证做的船数最少。因此，只要先排序，然后在双指针判断是否能做两个人即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numRescueBoats1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; people, <span class=\"keyword\">int</span> limit)</span> </span>&#123;</span><br><span class=\"line\">    sort(people.begin(), people.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = people.size() <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= j) &#123;</span><br><span class=\"line\">        res += <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (limit &gt;= people[i] + people[j]) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Climbing Stairs","date":"2017-11-12T08:22:52.000Z","_content":"\n第46天。\n\n今天的题目是[Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/):\n\n> You are climbing a stair case. It takes n steps to reach to the top.\n>\n> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n>\n> Note: Given n will be a positive integer.\n>\n>\n> Example 1:\n>\n> Input: 2\n> Output:  2\n> Explanation:  There are two ways to climb to the top.\n>\n> 1. 1 step + 1 step\n> 1. 2 steps\n> Example 2:\n>\n> Input: 3\n> Output:  3\n> Explanation:  There are three ways to climb to the top.\n>\n> 1. 1 step + 1 step + 1 step\n> 1. 1 step + 2 steps\n> 1. 2 steps + 1 step\n\n首先，要到达第n个台阶，我们需要先到n-1或n-2台阶，只要到达n-1和n-2台阶处，我们就能够通过一步到达第n个台阶，这时可以写出这样的递推式:\n\n```c++\nclimbStairs(n) = climbStairs(n-1) + climbStairs(n-2);\nclimbStairs(0) = climbStairs(1) = 1;\n```\n\n熟悉的话，可以一眼看出这是斐波那契数列.\n\n这样的话，我们可以很容易写出:\n\n```c++\nint climbStairs(int n) {\n    if (n == 0 || n == 1) return 1;\n    return climbStairs(n-1) + climbStairs(n-2);\n}\n```\n\n但是这样会出现超时的情况，我们可以用一个数组来记录整个斐波那契数列，然后返回适当的值即可:\n\n```c++\nint climbStairs(int n) {\n    vector<int> vec(n+1,1);\n    for(int i = 2;i <= n;i++) {\n        vec[i] = vec[i-1] + vec[i-2];\n    }\n    return vec[n];\n}\n```\n\n这样的时间复杂度和空间复杂度都是`O(n)`.\n\n我们可以把空间复杂度降到`O(1)`:\n\n```c++\nint climbStairs(int n) {\n    int a = 0,b = 1,t;\n    while(n--) {\n        t = a+b;\n        a = b;\n        b = t;\n    }\n    return b;\n}\n```\n","source":"_posts/Climbing-Stairs.md","raw":"---\ntitle: Climbing Stairs\ndate: 2017-11-12T16:22:52.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第46天。\n\n今天的题目是[Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/):\n\n> You are climbing a stair case. It takes n steps to reach to the top.\n>\n> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n>\n> Note: Given n will be a positive integer.\n>\n>\n> Example 1:\n>\n> Input: 2\n> Output:  2\n> Explanation:  There are two ways to climb to the top.\n>\n> 1. 1 step + 1 step\n> 1. 2 steps\n> Example 2:\n>\n> Input: 3\n> Output:  3\n> Explanation:  There are three ways to climb to the top.\n>\n> 1. 1 step + 1 step + 1 step\n> 1. 1 step + 2 steps\n> 1. 2 steps + 1 step\n\n首先，要到达第n个台阶，我们需要先到n-1或n-2台阶，只要到达n-1和n-2台阶处，我们就能够通过一步到达第n个台阶，这时可以写出这样的递推式:\n\n```c++\nclimbStairs(n) = climbStairs(n-1) + climbStairs(n-2);\nclimbStairs(0) = climbStairs(1) = 1;\n```\n\n熟悉的话，可以一眼看出这是斐波那契数列.\n\n这样的话，我们可以很容易写出:\n\n```c++\nint climbStairs(int n) {\n    if (n == 0 || n == 1) return 1;\n    return climbStairs(n-1) + climbStairs(n-2);\n}\n```\n\n但是这样会出现超时的情况，我们可以用一个数组来记录整个斐波那契数列，然后返回适当的值即可:\n\n```c++\nint climbStairs(int n) {\n    vector<int> vec(n+1,1);\n    for(int i = 2;i <= n;i++) {\n        vec[i] = vec[i-1] + vec[i-2];\n    }\n    return vec[n];\n}\n```\n\n这样的时间复杂度和空间复杂度都是`O(n)`.\n\n我们可以把空间复杂度降到`O(1)`:\n\n```c++\nint climbStairs(int n) {\n    int a = 0,b = 1,t;\n    while(n--) {\n        t = a+b;\n        a = b;\n        b = t;\n    }\n    return b;\n}\n```\n","slug":"Climbing-Stairs","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69n2002aqmcm9pjw29f0","content":"<p>第46天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/climbing-stairs/description/\">Climbing Stairs</a>:</p>\n<blockquote>\n<p>You are climbing a stair case. It takes n steps to reach to the top.</p>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n<p>Note: Given n will be a positive integer.</p>\n<p>Example 1:</p>\n<p>Input: 2<br>Output:  2<br>Explanation:  There are two ways to climb to the top.</p>\n<ol>\n<li>1 step + 1 step</li>\n<li>2 steps<br>Example 2:</li>\n</ol>\n<p>Input: 3<br>Output:  3<br>Explanation:  There are three ways to climb to the top.</p>\n<ol>\n<li>1 step + 1 step + 1 step</li>\n<li>1 step + 2 steps</li>\n<li>2 steps + 1 step</li>\n</ol>\n</blockquote>\n<p>首先，要到达第n个台阶，我们需要先到n-1或n-2台阶，只要到达n-1和n-2台阶处，我们就能够通过一步到达第n个台阶，这时可以写出这样的递推式:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">climbStairs(n) = climbStairs(n<span class=\"number\">-1</span>) + climbStairs(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">climbStairs(<span class=\"number\">0</span>) = climbStairs(<span class=\"number\">1</span>) = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>熟悉的话，可以一眼看出这是斐波那契数列.</p>\n<p>这样的话，我们可以很容易写出:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> climbStairs(n<span class=\"number\">-1</span>) + climbStairs(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这样会出现超时的情况，我们可以用一个数组来记录整个斐波那契数列，然后返回适当的值即可:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(n+<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        vec[i] = vec[i<span class=\"number\">-1</span>] + vec[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vec[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的时间复杂度和空间复杂度都是<code>O(n)</code>.</p>\n<p>我们可以把空间复杂度降到<code>O(1)</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>,b = <span class=\"number\">1</span>,t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--) &#123;</span><br><span class=\"line\">        t = a+b;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">        b = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第46天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/climbing-stairs/description/\">Climbing Stairs</a>:</p>\n<blockquote>\n<p>You are climbing a stair case. It takes n steps to reach to the top.</p>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n<p>Note: Given n will be a positive integer.</p>\n<p>Example 1:</p>\n<p>Input: 2<br>Output:  2<br>Explanation:  There are two ways to climb to the top.</p>\n<ol>\n<li>1 step + 1 step</li>\n<li>2 steps<br>Example 2:</li>\n</ol>\n<p>Input: 3<br>Output:  3<br>Explanation:  There are three ways to climb to the top.</p>\n<ol>\n<li>1 step + 1 step + 1 step</li>\n<li>1 step + 2 steps</li>\n<li>2 steps + 1 step</li>\n</ol>\n</blockquote>\n<p>首先，要到达第n个台阶，我们需要先到n-1或n-2台阶，只要到达n-1和n-2台阶处，我们就能够通过一步到达第n个台阶，这时可以写出这样的递推式:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">climbStairs(n) = climbStairs(n<span class=\"number\">-1</span>) + climbStairs(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">climbStairs(<span class=\"number\">0</span>) = climbStairs(<span class=\"number\">1</span>) = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>熟悉的话，可以一眼看出这是斐波那契数列.</p>\n<p>这样的话，我们可以很容易写出:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> climbStairs(n<span class=\"number\">-1</span>) + climbStairs(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这样会出现超时的情况，我们可以用一个数组来记录整个斐波那契数列，然后返回适当的值即可:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(n+<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        vec[i] = vec[i<span class=\"number\">-1</span>] + vec[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vec[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的时间复杂度和空间复杂度都是<code>O(n)</code>.</p>\n<p>我们可以把空间复杂度降到<code>O(1)</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>,b = <span class=\"number\">1</span>,t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--) &#123;</span><br><span class=\"line\">        t = a+b;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">        b = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Combination-Sum","date":"2017-10-12T03:24:59.000Z","_content":"\n第19天\n\n这道题是在起床到去上课前AC出来的，emmm，大概就10多分钟的样子。。。\n\n虽然后来尝试优化了一下，但是感觉效果都不怎么好。。\n\n题目描述：\n\n> Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\n>\n> The same repeated number may be chosen from C unlimited number of times.\n>\n> Note:\n> * All numbers (including target) will be positive integers.\n> * The solution set must not contain duplicate combinations.\n> \n> For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: \n\n```python\n[\n  [7],\n  [2, 2, 3]\n]\n```\n\n其实想法很简单，我既然想求`combinationSum(7)`，通过遍历数组，我们现在有了一个`[2]`，我只需要在求`combinatiomSum(7-2)`即可，然后组合起来：\n\n```c++\nvector<int> cand;\nvector<vector<int> > ret;\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n    cand = candidates;\n    sort(cand.begin(),cand.end());\n    vector<int> now;\n    combinationSumIter(now,0,target);\n    return ret;\n}\nvoid combinationSumIter(vector<int> &now,int beg,int target){\n    //cout << \"target\" << target << endl;\n    for(int i = beg;i < cand.size();++i) {\n        if (target < cand[i])\n            break;\n        else if (target == cand[i]) {\n            vector<int> vec = now;\n            vec.push_back(cand[i]);\n            ret.push_back(vec);\n        } else if (target - cand[i] >= cand[0] ){\n            vector<int> vec = now;\n            vec.push_back(cand[i]);\n            combinationSumIter(vec,i,target-cand[i]);\n        }\n    }\n}\n```\n\n然后在`dicuss`中看到的也是类似的想法：\n\n```c++\nclass Solution {\npublic:\n    std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\n        std::sort(candidates.begin(), candidates.end());\n        std::vector<std::vector<int> > res;\n        std::vector<int> combination;\n        combinationSum(candidates, target, res, combination, 0);\n        return res;\n    }\nprivate:\n    void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\n        if (!target) {\n            res.push_back(combination);\n            return;\n        }\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\n            combination.push_back(candidates[i]);\n            combinationSum(candidates, target - candidates[i], res, combination, i);\n            combination.pop_back();\n        }\n    }\n};\n```\n","source":"_posts/Combination-Sum.md","raw":"---\ntitle: Combination-Sum\ndate: 2017-10-12T11:24:59.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第19天\n\n这道题是在起床到去上课前AC出来的，emmm，大概就10多分钟的样子。。。\n\n虽然后来尝试优化了一下，但是感觉效果都不怎么好。。\n\n题目描述：\n\n> Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\n>\n> The same repeated number may be chosen from C unlimited number of times.\n>\n> Note:\n> * All numbers (including target) will be positive integers.\n> * The solution set must not contain duplicate combinations.\n> \n> For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: \n\n```python\n[\n  [7],\n  [2, 2, 3]\n]\n```\n\n其实想法很简单，我既然想求`combinationSum(7)`，通过遍历数组，我们现在有了一个`[2]`，我只需要在求`combinatiomSum(7-2)`即可，然后组合起来：\n\n```c++\nvector<int> cand;\nvector<vector<int> > ret;\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n    cand = candidates;\n    sort(cand.begin(),cand.end());\n    vector<int> now;\n    combinationSumIter(now,0,target);\n    return ret;\n}\nvoid combinationSumIter(vector<int> &now,int beg,int target){\n    //cout << \"target\" << target << endl;\n    for(int i = beg;i < cand.size();++i) {\n        if (target < cand[i])\n            break;\n        else if (target == cand[i]) {\n            vector<int> vec = now;\n            vec.push_back(cand[i]);\n            ret.push_back(vec);\n        } else if (target - cand[i] >= cand[0] ){\n            vector<int> vec = now;\n            vec.push_back(cand[i]);\n            combinationSumIter(vec,i,target-cand[i]);\n        }\n    }\n}\n```\n\n然后在`dicuss`中看到的也是类似的想法：\n\n```c++\nclass Solution {\npublic:\n    std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\n        std::sort(candidates.begin(), candidates.end());\n        std::vector<std::vector<int> > res;\n        std::vector<int> combination;\n        combinationSum(candidates, target, res, combination, 0);\n        return res;\n    }\nprivate:\n    void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\n        if (!target) {\n            res.push_back(combination);\n            return;\n        }\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\n            combination.push_back(candidates[i]);\n            combinationSum(candidates, target - candidates[i], res, combination, i);\n            combination.pop_back();\n        }\n    }\n};\n```\n","slug":"Combination-Sum","published":1,"updated":"2021-03-10T13:47:05.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69n3002dqmcmcpv225ug","content":"<p>第19天</p>\n<p>这道题是在起床到去上课前AC出来的，emmm，大概就10多分钟的样子。。。</p>\n<p>虽然后来尝试优化了一下，但是感觉效果都不怎么好。。</p>\n<p>题目描述：</p>\n<blockquote>\n<p>Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>\n<p>The same repeated number may be chosen from C unlimited number of times.</p>\n<p>Note:</p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p>For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: </p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>其实想法很简单，我既然想求<code>combinationSum(7)</code>，通过遍历数组，我们现在有了一个<code>[2]</code>，我只需要在求<code>combinatiomSum(7-2)</code>即可，然后组合起来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; cand;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; combinationSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; candidates, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    cand = candidates;</span><br><span class=\"line\">    sort(cand.begin(),cand.end());</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; now;</span><br><span class=\"line\">    combinationSumIter(now,<span class=\"number\">0</span>,target);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">combinationSumIter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;now,<span class=\"keyword\">int</span> beg,<span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; &quot;target&quot; &lt;&lt; target &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg;i &lt; cand.size();++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &lt; cand[i])</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target == cand[i]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = now;</span><br><span class=\"line\">            vec.push_back(cand[i]);</span><br><span class=\"line\">            ret.push_back(vec);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target - cand[i] &gt;= cand[<span class=\"number\">0</span>] )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = now;</span><br><span class=\"line\">            vec.push_back(cand[i]);</span><br><span class=\"line\">            combinationSumIter(vec,i,target-cand[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>dicuss</code>中看到的也是类似的想法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; combinationSum(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;candidates, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::sort(candidates.begin(), candidates.end());</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; combination;</span><br><span class=\"line\">        combinationSum(candidates, target, res, combination, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">combinationSum</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;candidates, <span class=\"keyword\">int</span> target, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;res, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;combination, <span class=\"keyword\">int</span> begin)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!target) &#123;</span><br><span class=\"line\">            res.push_back(combination);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) &#123;</span><br><span class=\"line\">            combination.push_back(candidates[i]);</span><br><span class=\"line\">            combinationSum(candidates, target - candidates[i], res, combination, i);</span><br><span class=\"line\">            combination.pop_back();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第19天</p>\n<p>这道题是在起床到去上课前AC出来的，emmm，大概就10多分钟的样子。。。</p>\n<p>虽然后来尝试优化了一下，但是感觉效果都不怎么好。。</p>\n<p>题目描述：</p>\n<blockquote>\n<p>Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>\n<p>The same repeated number may be chosen from C unlimited number of times.</p>\n<p>Note:</p>\n<ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p>For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: </p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>其实想法很简单，我既然想求<code>combinationSum(7)</code>，通过遍历数组，我们现在有了一个<code>[2]</code>，我只需要在求<code>combinatiomSum(7-2)</code>即可，然后组合起来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; cand;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; combinationSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; candidates, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    cand = candidates;</span><br><span class=\"line\">    sort(cand.begin(),cand.end());</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; now;</span><br><span class=\"line\">    combinationSumIter(now,<span class=\"number\">0</span>,target);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">combinationSumIter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;now,<span class=\"keyword\">int</span> beg,<span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; &quot;target&quot; &lt;&lt; target &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg;i &lt; cand.size();++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &lt; cand[i])</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target == cand[i]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = now;</span><br><span class=\"line\">            vec.push_back(cand[i]);</span><br><span class=\"line\">            ret.push_back(vec);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target - cand[i] &gt;= cand[<span class=\"number\">0</span>] )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = now;</span><br><span class=\"line\">            vec.push_back(cand[i]);</span><br><span class=\"line\">            combinationSumIter(vec,i,target-cand[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>dicuss</code>中看到的也是类似的想法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; combinationSum(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;candidates, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::sort(candidates.begin(), candidates.end());</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; combination;</span><br><span class=\"line\">        combinationSum(candidates, target, res, combination, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">combinationSum</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;candidates, <span class=\"keyword\">int</span> target, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;res, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;combination, <span class=\"keyword\">int</span> begin)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!target) &#123;</span><br><span class=\"line\">            res.push_back(combination);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) &#123;</span><br><span class=\"line\">            combination.push_back(candidates[i]);</span><br><span class=\"line\">            combinationSum(candidates, target - candidates[i], res, combination, i);</span><br><span class=\"line\">            combination.pop_back();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Construct Binary Tree from Inorder and Postorder Traversal","date":"2020-01-07T01:29:42.000Z","_content":"\n> 第58天。\n\n今天的题目是[Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/):\n\n一道很久之前嫌麻烦没做的题目，因为之前做过从中序遍历和先序遍历中重构二叉树了，所以从中序遍历和后序遍历重构二叉树就之前换一下取值的位置而已：\n\n```c++\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n    return buildTree(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);\n}\nint search(vector<int> &inorder, int beg, int end, int val) {\n    while(beg <= end && inorder[beg] != val) beg++;\n    return beg;\n}\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder, int ibeg, int iend, int pbeg, int pend) {\n    if (ibeg > iend || pbeg > pend) return nullptr;\n    if (ibeg == iend || pbeg == pend) return new TreeNode(postorder[pend]);\n    int val = postorder[pend];\n    int mid = search(inorder, ibeg, iend, val);\n    TreeNode *node = new TreeNode(val);\n    int leftsize = mid - ibeg;\n    node->left = buildTree(inorder, postorder, ibeg, mid-1, pbeg, pbeg + leftsize-1);\n    node->right = buildTree(inorder, postorder, mid + 1, iend, pbeg + leftsize, pend-1);\n    return node;\n}\n```\n","source":"_posts/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal.md","raw":"---\ntitle: Construct Binary Tree from Inorder and Postorder Traversal\ndate: 2020-01-07T09:29:42.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第58天。\n\n今天的题目是[Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/):\n\n一道很久之前嫌麻烦没做的题目，因为之前做过从中序遍历和先序遍历中重构二叉树了，所以从中序遍历和后序遍历重构二叉树就之前换一下取值的位置而已：\n\n```c++\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n    return buildTree(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);\n}\nint search(vector<int> &inorder, int beg, int end, int val) {\n    while(beg <= end && inorder[beg] != val) beg++;\n    return beg;\n}\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder, int ibeg, int iend, int pbeg, int pend) {\n    if (ibeg > iend || pbeg > pend) return nullptr;\n    if (ibeg == iend || pbeg == pend) return new TreeNode(postorder[pend]);\n    int val = postorder[pend];\n    int mid = search(inorder, ibeg, iend, val);\n    TreeNode *node = new TreeNode(val);\n    int leftsize = mid - ibeg;\n    node->left = buildTree(inorder, postorder, ibeg, mid-1, pbeg, pbeg + leftsize-1);\n    node->right = buildTree(inorder, postorder, mid + 1, iend, pbeg + leftsize, pend-1);\n    return node;\n}\n```\n","slug":"Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69n4002hqmcmbdym273k","content":"<blockquote>\n<p>第58天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">Construct Binary Tree from Inorder and Postorder Traversal</a>:</p>\n<p>一道很久之前嫌麻烦没做的题目，因为之前做过从中序遍历和先序遍历中重构二叉树了，所以从中序遍历和后序遍历重构二叉树就之前换一下取值的位置而已：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildTree(inorder, postorder, <span class=\"number\">0</span>, inorder.size() - <span class=\"number\">1</span>, <span class=\"number\">0</span>, postorder.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inorder, <span class=\"keyword\">int</span> beg, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg &lt;= end &amp;&amp; inorder[beg] != val) beg++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; postorder, <span class=\"keyword\">int</span> ibeg, <span class=\"keyword\">int</span> iend, <span class=\"keyword\">int</span> pbeg, <span class=\"keyword\">int</span> pend)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ibeg &gt; iend || pbeg &gt; pend) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ibeg == iend || pbeg == pend) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(postorder[pend]);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val = postorder[pend];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = search(inorder, ibeg, iend, val);</span><br><span class=\"line\">    TreeNode *node = <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftsize = mid - ibeg;</span><br><span class=\"line\">    node-&gt;left = buildTree(inorder, postorder, ibeg, mid<span class=\"number\">-1</span>, pbeg, pbeg + leftsize<span class=\"number\">-1</span>);</span><br><span class=\"line\">    node-&gt;right = buildTree(inorder, postorder, mid + <span class=\"number\">1</span>, iend, pbeg + leftsize, pend<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第58天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">Construct Binary Tree from Inorder and Postorder Traversal</a>:</p>\n<p>一道很久之前嫌麻烦没做的题目，因为之前做过从中序遍历和先序遍历中重构二叉树了，所以从中序遍历和后序遍历重构二叉树就之前换一下取值的位置而已：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildTree(inorder, postorder, <span class=\"number\">0</span>, inorder.size() - <span class=\"number\">1</span>, <span class=\"number\">0</span>, postorder.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inorder, <span class=\"keyword\">int</span> beg, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg &lt;= end &amp;&amp; inorder[beg] != val) beg++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; postorder, <span class=\"keyword\">int</span> ibeg, <span class=\"keyword\">int</span> iend, <span class=\"keyword\">int</span> pbeg, <span class=\"keyword\">int</span> pend)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ibeg &gt; iend || pbeg &gt; pend) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ibeg == iend || pbeg == pend) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(postorder[pend]);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val = postorder[pend];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = search(inorder, ibeg, iend, val);</span><br><span class=\"line\">    TreeNode *node = <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftsize = mid - ibeg;</span><br><span class=\"line\">    node-&gt;left = buildTree(inorder, postorder, ibeg, mid<span class=\"number\">-1</span>, pbeg, pbeg + leftsize<span class=\"number\">-1</span>);</span><br><span class=\"line\">    node-&gt;right = buildTree(inorder, postorder, mid + <span class=\"number\">1</span>, iend, pbeg + leftsize, pend<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Construct Binary Tree from Preorder and Inorder Traversal","date":"2017-10-25T03:07:13.000Z","_content":"\n第32天。\n\n其实早在很久之前了就想着坚持了一个月之后要发票圈纪念一下的，后来想想其实也没啥必要的，感觉每天早上起来开电脑看题目已经成了习惯了，习惯有啥好纪念的（其实到100天的时候应该还是挺有意义的）。\n\n今天的题目是[Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)：\n\n> Given preorder and inorder traversal of a tree, construct the binary tree.\n>\n> Note:\n> You may assume that duplicates do not exist in the tree.\n\n一开始没看到`Note`，还觉得会有点麻烦，不过既然没有重复元素，写出一个递归解法就很简单了:\n\n```c++\nTreeNode* buildTree1(vector<int>& preorder, vector<int>& inorder) {\n    return bulidTreeIter(preorder.begin(),preorder.end(),inorder.begin(),inorder.end());\n}\nTreeNode *bulidTreeIter(vector<int>::iterator pBeg,vector<int>::iterator pEnd,vector<int>::iterator iBeg,vector<int>::iterator iEnd) {\n    if (pEnd == pBeg) return nullptr;\n    TreeNode *root = new TreeNode(*pBeg);\n    auto it = find(iBeg,iEnd,*pBeg);\n    int size = it - iBeg;\n    root->left = bulidTreeIter(pBeg+1,pBeg + size + 1,iBeg,it);\n    root->right = bulidTreeIter(pBeg+size+1,pEnd,it+1,iEnd);\n    return root;\n}\n```\n\n恩，貌似是第一次一次`Submit`就直接过。\n\n然后是在`dicuss`中看到的迭代算法，但是感觉很复杂的样子,而且效率也不一定比递归版的高。\n\n```c++\n    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n\n        if(preorder.size()==0)\n            return NULL;\n\n        stack<int> s;\n        stack<TreeNode *> st;\n        TreeNode *t,*r,*root;\n        int i,j,f;\n\n        f=i=j=0;\n        s.push(preorder[i]);\n\n        root = new TreeNode(preorder[i]);\n        st.push(root);\n        t = root;\n        i++;\n\n        while(i<preorder.size())\n        {\n            if(!st.empty() && st.top()->val==inorder[j])\n            {\n                t = st.top();\n                st.pop();\n                s.pop();\n                f = 1;\n                j++;\n            }\n            else\n            {\n                if(f==0)\n                {\n                    s.push(preorder[i]);\n                    t -> left = new TreeNode(preorder[i]);\n                    t = t -> left;\n                    st.push(t);\n                    i++;\n                }\n                else \n                {\n                    f = 0;\n                    s.push(preorder[i]);\n                    t -> right = new TreeNode(preorder[i]);\n                    t = t -> right;\n                    st.push(t);\n                    i++;\n                }\n            }\n        }\n        \n        return root;\n    }\n```\n","source":"_posts/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.md","raw":"---\ntitle: Construct Binary Tree from Preorder and Inorder Traversal\ndate: 2017-10-25T11:07:13.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第32天。\n\n其实早在很久之前了就想着坚持了一个月之后要发票圈纪念一下的，后来想想其实也没啥必要的，感觉每天早上起来开电脑看题目已经成了习惯了，习惯有啥好纪念的（其实到100天的时候应该还是挺有意义的）。\n\n今天的题目是[Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)：\n\n> Given preorder and inorder traversal of a tree, construct the binary tree.\n>\n> Note:\n> You may assume that duplicates do not exist in the tree.\n\n一开始没看到`Note`，还觉得会有点麻烦，不过既然没有重复元素，写出一个递归解法就很简单了:\n\n```c++\nTreeNode* buildTree1(vector<int>& preorder, vector<int>& inorder) {\n    return bulidTreeIter(preorder.begin(),preorder.end(),inorder.begin(),inorder.end());\n}\nTreeNode *bulidTreeIter(vector<int>::iterator pBeg,vector<int>::iterator pEnd,vector<int>::iterator iBeg,vector<int>::iterator iEnd) {\n    if (pEnd == pBeg) return nullptr;\n    TreeNode *root = new TreeNode(*pBeg);\n    auto it = find(iBeg,iEnd,*pBeg);\n    int size = it - iBeg;\n    root->left = bulidTreeIter(pBeg+1,pBeg + size + 1,iBeg,it);\n    root->right = bulidTreeIter(pBeg+size+1,pEnd,it+1,iEnd);\n    return root;\n}\n```\n\n恩，貌似是第一次一次`Submit`就直接过。\n\n然后是在`dicuss`中看到的迭代算法，但是感觉很复杂的样子,而且效率也不一定比递归版的高。\n\n```c++\n    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n\n        if(preorder.size()==0)\n            return NULL;\n\n        stack<int> s;\n        stack<TreeNode *> st;\n        TreeNode *t,*r,*root;\n        int i,j,f;\n\n        f=i=j=0;\n        s.push(preorder[i]);\n\n        root = new TreeNode(preorder[i]);\n        st.push(root);\n        t = root;\n        i++;\n\n        while(i<preorder.size())\n        {\n            if(!st.empty() && st.top()->val==inorder[j])\n            {\n                t = st.top();\n                st.pop();\n                s.pop();\n                f = 1;\n                j++;\n            }\n            else\n            {\n                if(f==0)\n                {\n                    s.push(preorder[i]);\n                    t -> left = new TreeNode(preorder[i]);\n                    t = t -> left;\n                    st.push(t);\n                    i++;\n                }\n                else \n                {\n                    f = 0;\n                    s.push(preorder[i]);\n                    t -> right = new TreeNode(preorder[i]);\n                    t = t -> right;\n                    st.push(t);\n                    i++;\n                }\n            }\n        }\n        \n        return root;\n    }\n```\n","slug":"Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69n5002kqmcm3eyu3ajy","content":"<p>第32天。</p>\n<p>其实早在很久之前了就想着坚持了一个月之后要发票圈纪念一下的，后来想想其实也没啥必要的，感觉每天早上起来开电脑看题目已经成了习惯了，习惯有啥好纪念的（其实到100天的时候应该还是挺有意义的）。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/\">Construct Binary Tree from Preorder and Inorder Traversal</a>：</p>\n<blockquote>\n<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>\n<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>\n</blockquote>\n<p>一开始没看到<code>Note</code>，还觉得会有点麻烦，不过既然没有重复元素，写出一个递归解法就很简单了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">buildTree1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; preorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bulidTreeIter(preorder.begin(),preorder.end(),inorder.begin(),inorder.end());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">bulidTreeIter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator pBeg,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator pEnd,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator iBeg,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator iEnd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pEnd == pBeg) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    TreeNode *root = <span class=\"keyword\">new</span> TreeNode(*pBeg);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = find(iBeg,iEnd,*pBeg);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = it - iBeg;</span><br><span class=\"line\">    root-&gt;left = bulidTreeIter(pBeg+<span class=\"number\">1</span>,pBeg + size + <span class=\"number\">1</span>,iBeg,it);</span><br><span class=\"line\">    root-&gt;right = bulidTreeIter(pBeg+size+<span class=\"number\">1</span>,pEnd,it+<span class=\"number\">1</span>,iEnd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，貌似是第一次一次<code>Submit</code>就直接过。</p>\n<p>然后是在<code>dicuss</code>中看到的迭代算法，但是感觉很复杂的样子,而且效率也不一定比递归版的高。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;preorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(preorder.size()==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    TreeNode *t,*r,*root;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j,f;</span><br><span class=\"line\"></span><br><span class=\"line\">    f=i=j=<span class=\"number\">0</span>;</span><br><span class=\"line\">    s.push(preorder[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = <span class=\"keyword\">new</span> TreeNode(preorder[i]);</span><br><span class=\"line\">    st.push(root);</span><br><span class=\"line\">    t = root;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;preorder.size())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!st.empty() &amp;&amp; st.top()-&gt;val==inorder[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            t = st.top();</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">            f = <span class=\"number\">1</span>;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(f==<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                s.push(preorder[i]);</span><br><span class=\"line\">                t -&gt; left = <span class=\"keyword\">new</span> TreeNode(preorder[i]);</span><br><span class=\"line\">                t = t -&gt; left;</span><br><span class=\"line\">                st.push(t);</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                f = <span class=\"number\">0</span>;</span><br><span class=\"line\">                s.push(preorder[i]);</span><br><span class=\"line\">                t -&gt; right = <span class=\"keyword\">new</span> TreeNode(preorder[i]);</span><br><span class=\"line\">                t = t -&gt; right;</span><br><span class=\"line\">                st.push(t);</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第32天。</p>\n<p>其实早在很久之前了就想着坚持了一个月之后要发票圈纪念一下的，后来想想其实也没啥必要的，感觉每天早上起来开电脑看题目已经成了习惯了，习惯有啥好纪念的（其实到100天的时候应该还是挺有意义的）。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/\">Construct Binary Tree from Preorder and Inorder Traversal</a>：</p>\n<blockquote>\n<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>\n<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>\n</blockquote>\n<p>一开始没看到<code>Note</code>，还觉得会有点麻烦，不过既然没有重复元素，写出一个递归解法就很简单了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">buildTree1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; preorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bulidTreeIter(preorder.begin(),preorder.end(),inorder.begin(),inorder.end());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">bulidTreeIter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator pBeg,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator pEnd,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator iBeg,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator iEnd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pEnd == pBeg) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    TreeNode *root = <span class=\"keyword\">new</span> TreeNode(*pBeg);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = find(iBeg,iEnd,*pBeg);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = it - iBeg;</span><br><span class=\"line\">    root-&gt;left = bulidTreeIter(pBeg+<span class=\"number\">1</span>,pBeg + size + <span class=\"number\">1</span>,iBeg,it);</span><br><span class=\"line\">    root-&gt;right = bulidTreeIter(pBeg+size+<span class=\"number\">1</span>,pEnd,it+<span class=\"number\">1</span>,iEnd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，貌似是第一次一次<code>Submit</code>就直接过。</p>\n<p>然后是在<code>dicuss</code>中看到的迭代算法，但是感觉很复杂的样子,而且效率也不一定比递归版的高。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;preorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(preorder.size()==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    TreeNode *t,*r,*root;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j,f;</span><br><span class=\"line\"></span><br><span class=\"line\">    f=i=j=<span class=\"number\">0</span>;</span><br><span class=\"line\">    s.push(preorder[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = <span class=\"keyword\">new</span> TreeNode(preorder[i]);</span><br><span class=\"line\">    st.push(root);</span><br><span class=\"line\">    t = root;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;preorder.size())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!st.empty() &amp;&amp; st.top()-&gt;val==inorder[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            t = st.top();</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">            f = <span class=\"number\">1</span>;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(f==<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                s.push(preorder[i]);</span><br><span class=\"line\">                t -&gt; left = <span class=\"keyword\">new</span> TreeNode(preorder[i]);</span><br><span class=\"line\">                t = t -&gt; left;</span><br><span class=\"line\">                st.push(t);</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                f = <span class=\"number\">0</span>;</span><br><span class=\"line\">                s.push(preorder[i]);</span><br><span class=\"line\">                t -&gt; right = <span class=\"keyword\">new</span> TreeNode(preorder[i]);</span><br><span class=\"line\">                t = t -&gt; right;</span><br><span class=\"line\">                st.push(t);</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Construct-the-Rectangle","date":"2018-01-24T04:36:36.000Z","_content":"\n第93天。\n\n今天的题目是[Construct the Rectangle](https://leetcode.com/problems/construct-the-rectangle/discuss/):\n\n> For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n\n> 1. The area of the rectangular web page you designed must equal to the given target area.\n>\n> 2. The width W should not be larger than the length L, which means L >= W.\n>\n> 3. The difference between length L and width W should be as small as possible.\n> You need to output the length L and the width W of the web page you designed in sequence.\n> Example:\n> Input: 4\n> Output: [2, 2]\n> Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \n> But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\n> Note:\n> The given area won't exceed 10,000,000 and is a positive integer\n> The web page's width and length you designed must be positive integers.\n\n比较简单的题目，但是题目有点长，总结一下就是，你要求出`L`,`W`满足一下条件：\n\n1. L, W is int\n1. L*W=Area\n1. L >= W > 0\n1. min |L-W|\n\n既然要使得`|L-W|`最小，那么显然，`L=W=sqrt(Area)`时，`L-W`是最小的，但是因为`L`和`W`限制成整数了,且`sqrt(Area)`不一定是整数，如果把它转换成`int`的话，`L*W`不一定等于`Area`了。所以我们必须调整`L`和`W`的值，简单的调整方法就是，如果`L*W < Area`,我们就加大`L`之所以是加大`L`而不是加大`W`的原因是需要满足`L >= W`，同理`L*W > Area`时，我们就减小`W`。这样子我们始终会找到一个`L,W`满足上面的条件：\n\n```c++\nvector<int> constructRectangle(int area) {\n    int L, W;\n    int sqrt_a = sqrt(area);\n    W = L = sqrt_a;\n    int a = W*L;\n    while(a != area) {\n        if (a < area) L++;\n        else if (a > area) W--;\n        a = W*L;\n    }\n    return {L, W};\n}\n```\n\n然后`dicuss`中的解法更巧妙一点，我们只求`W`，然后`L = Area/W`：\n\n```java\npublic int[] constructRectangle(int area) {\n    int w = (int)Math.sqrt(area);\n    while (area%w!=0) w--;\n    return new int[]{area/w, w};\n}\n```\n","source":"_posts/Construct-the-Rectangle.md","raw":"---\ntitle: Construct-the-Rectangle\ndate: 2018-01-24T12:36:36.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第93天。\n\n今天的题目是[Construct the Rectangle](https://leetcode.com/problems/construct-the-rectangle/discuss/):\n\n> For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n\n> 1. The area of the rectangular web page you designed must equal to the given target area.\n>\n> 2. The width W should not be larger than the length L, which means L >= W.\n>\n> 3. The difference between length L and width W should be as small as possible.\n> You need to output the length L and the width W of the web page you designed in sequence.\n> Example:\n> Input: 4\n> Output: [2, 2]\n> Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \n> But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\n> Note:\n> The given area won't exceed 10,000,000 and is a positive integer\n> The web page's width and length you designed must be positive integers.\n\n比较简单的题目，但是题目有点长，总结一下就是，你要求出`L`,`W`满足一下条件：\n\n1. L, W is int\n1. L*W=Area\n1. L >= W > 0\n1. min |L-W|\n\n既然要使得`|L-W|`最小，那么显然，`L=W=sqrt(Area)`时，`L-W`是最小的，但是因为`L`和`W`限制成整数了,且`sqrt(Area)`不一定是整数，如果把它转换成`int`的话，`L*W`不一定等于`Area`了。所以我们必须调整`L`和`W`的值，简单的调整方法就是，如果`L*W < Area`,我们就加大`L`之所以是加大`L`而不是加大`W`的原因是需要满足`L >= W`，同理`L*W > Area`时，我们就减小`W`。这样子我们始终会找到一个`L,W`满足上面的条件：\n\n```c++\nvector<int> constructRectangle(int area) {\n    int L, W;\n    int sqrt_a = sqrt(area);\n    W = L = sqrt_a;\n    int a = W*L;\n    while(a != area) {\n        if (a < area) L++;\n        else if (a > area) W--;\n        a = W*L;\n    }\n    return {L, W};\n}\n```\n\n然后`dicuss`中的解法更巧妙一点，我们只求`W`，然后`L = Area/W`：\n\n```java\npublic int[] constructRectangle(int area) {\n    int w = (int)Math.sqrt(area);\n    while (area%w!=0) w--;\n    return new int[]{area/w, w};\n}\n```\n","slug":"Construct-the-Rectangle","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69n6002oqmcmgvi6a3fl","content":"<p>第93天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/construct-the-rectangle/discuss/\">Construct the Rectangle</a>:</p>\n<blockquote>\n<p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p>\n</blockquote>\n<blockquote>\n<ol>\n<li><p>The area of the rectangular web page you designed must equal to the given target area.</p>\n</li>\n<li><p>The width W should not be larger than the length L, which means L &gt;= W.</p>\n</li>\n<li><p>The difference between length L and width W should be as small as possible.<br>You need to output the length L and the width W of the web page you designed in sequence.<br>Example:<br>Input: 4<br>Output: [2, 2]<br>Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].<br>But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.<br>Note:<br>The given area won’t exceed 10,000,000 and is a positive integer<br>The web page’s width and length you designed must be positive integers.</p>\n</li>\n</ol>\n</blockquote>\n<p>比较简单的题目，但是题目有点长，总结一下就是，你要求出<code>L</code>,<code>W</code>满足一下条件：</p>\n<ol>\n<li>L, W is int</li>\n<li>L*W=Area</li>\n<li>L &gt;= W &gt; 0</li>\n<li>min |L-W|</li>\n</ol>\n<p>既然要使得<code>|L-W|</code>最小，那么显然，<code>L=W=sqrt(Area)</code>时，<code>L-W</code>是最小的，但是因为<code>L</code>和<code>W</code>限制成整数了,且<code>sqrt(Area)</code>不一定是整数，如果把它转换成<code>int</code>的话，<code>L*W</code>不一定等于<code>Area</code>了。所以我们必须调整<code>L</code>和<code>W</code>的值，简单的调整方法就是，如果<code>L*W &lt; Area</code>,我们就加大<code>L</code>之所以是加大<code>L</code>而不是加大<code>W</code>的原因是需要满足<code>L &gt;= W</code>，同理<code>L*W &gt; Area</code>时，我们就减小<code>W</code>。这样子我们始终会找到一个<code>L,W</code>满足上面的条件：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">constructRectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> area)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> L, W;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sqrt_a = <span class=\"built_in\">sqrt</span>(area);</span><br><span class=\"line\">    W = L = sqrt_a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = W*L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a != area) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; area) L++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &gt; area) W--;</span><br><span class=\"line\">        a = W*L;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;L, W&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后<code>dicuss</code>中的解法更巧妙一点，我们只求<code>W</code>，然后<code>L = Area/W</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] constructRectangle(<span class=\"keyword\">int</span> area) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w = (<span class=\"keyword\">int</span>)Math.sqrt(area);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (area%w!=<span class=\"number\">0</span>) w--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;area/w, w&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第93天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/construct-the-rectangle/discuss/\">Construct the Rectangle</a>:</p>\n<blockquote>\n<p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p>\n</blockquote>\n<blockquote>\n<ol>\n<li><p>The area of the rectangular web page you designed must equal to the given target area.</p>\n</li>\n<li><p>The width W should not be larger than the length L, which means L &gt;= W.</p>\n</li>\n<li><p>The difference between length L and width W should be as small as possible.<br>You need to output the length L and the width W of the web page you designed in sequence.<br>Example:<br>Input: 4<br>Output: [2, 2]<br>Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].<br>But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.<br>Note:<br>The given area won’t exceed 10,000,000 and is a positive integer<br>The web page’s width and length you designed must be positive integers.</p>\n</li>\n</ol>\n</blockquote>\n<p>比较简单的题目，但是题目有点长，总结一下就是，你要求出<code>L</code>,<code>W</code>满足一下条件：</p>\n<ol>\n<li>L, W is int</li>\n<li>L*W=Area</li>\n<li>L &gt;= W &gt; 0</li>\n<li>min |L-W|</li>\n</ol>\n<p>既然要使得<code>|L-W|</code>最小，那么显然，<code>L=W=sqrt(Area)</code>时，<code>L-W</code>是最小的，但是因为<code>L</code>和<code>W</code>限制成整数了,且<code>sqrt(Area)</code>不一定是整数，如果把它转换成<code>int</code>的话，<code>L*W</code>不一定等于<code>Area</code>了。所以我们必须调整<code>L</code>和<code>W</code>的值，简单的调整方法就是，如果<code>L*W &lt; Area</code>,我们就加大<code>L</code>之所以是加大<code>L</code>而不是加大<code>W</code>的原因是需要满足<code>L &gt;= W</code>，同理<code>L*W &gt; Area</code>时，我们就减小<code>W</code>。这样子我们始终会找到一个<code>L,W</code>满足上面的条件：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">constructRectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> area)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> L, W;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sqrt_a = <span class=\"built_in\">sqrt</span>(area);</span><br><span class=\"line\">    W = L = sqrt_a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = W*L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a != area) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; area) L++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &gt; area) W--;</span><br><span class=\"line\">        a = W*L;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;L, W&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后<code>dicuss</code>中的解法更巧妙一点，我们只求<code>W</code>，然后<code>L = Area/W</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] constructRectangle(<span class=\"keyword\">int</span> area) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w = (<span class=\"keyword\">int</span>)Math.sqrt(area);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (area%w!=<span class=\"number\">0</span>) w--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;area/w, w&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Container With Most Water","date":"2017-09-27T05:47:00.000Z","_content":"\n打卡，第四天\n\n今天的题目是[Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/)\n\n> Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n> Note: You may not slant the container and n is at least 2.\n\n很烦，今天老是时间超限，就是不能想出一个时间复杂度小的算法来。\n\n先理解一下题目先，大概就是给你一个数组`height`，你要找出两个i，j使得`min(height[i],height[j])*(j - i)`最大。\n\n很容易写出一个$ O(n^{2}) $ 的算法出来：\n\n```c++\nint maxArea(vector<int> &height) {\n\tint water = 0;\n\tfor(int i = 0;i < height.size(); ++i)\n\t\tfor (int j = 0;j < height.size(); ++j) {\n\t\t\tint h = min(height[i],height[j]);\n\t\t\twater = max(water,h*(j - i));\n\t\t}\n\treturn water;\n}\n```\n\n但是这个算法是不能过最后一个测例的。\n\n想了一个小时都没想出一个好方法来减少他的复杂度,后来就去翻`dicuss`，看到这样一个算法：\n\n```c++\nint maxArea(vector<int> &height) {\n\tint water = 0;\n\tint i = 0,j = height.size() - 1;\n\twhile(i < j) {\n\t\tint h = min(height[i],height[j]);\n\t\twater = max(water,h*(j - i));\n\t\twhile(height[i] <= h && i < j) i++;\n\t\twhile(height[j] <= h && i < j) j++;\n\t}\n}\n```\n\n这里是先取最宽的容器，假设他就是我们要的结果。\n因为`i`不断变大,`j`不断变小，这样wide就不断变小，因为wide在变小，要比当前最大的容器还大的话就只能比当前高度高，这就是那两个`while`的作用，去除掉一个不可能的情况。\n\n\n啊，我真菜，为什么老是想不出来呢！\n\n","source":"_posts/Container_With_Most_Water.md","raw":"---\ntitle: Container With Most Water\ndate: 2017-09-27T13:47:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n打卡，第四天\n\n今天的题目是[Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/)\n\n> Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n> Note: You may not slant the container and n is at least 2.\n\n很烦，今天老是时间超限，就是不能想出一个时间复杂度小的算法来。\n\n先理解一下题目先，大概就是给你一个数组`height`，你要找出两个i，j使得`min(height[i],height[j])*(j - i)`最大。\n\n很容易写出一个$ O(n^{2}) $ 的算法出来：\n\n```c++\nint maxArea(vector<int> &height) {\n\tint water = 0;\n\tfor(int i = 0;i < height.size(); ++i)\n\t\tfor (int j = 0;j < height.size(); ++j) {\n\t\t\tint h = min(height[i],height[j]);\n\t\t\twater = max(water,h*(j - i));\n\t\t}\n\treturn water;\n}\n```\n\n但是这个算法是不能过最后一个测例的。\n\n想了一个小时都没想出一个好方法来减少他的复杂度,后来就去翻`dicuss`，看到这样一个算法：\n\n```c++\nint maxArea(vector<int> &height) {\n\tint water = 0;\n\tint i = 0,j = height.size() - 1;\n\twhile(i < j) {\n\t\tint h = min(height[i],height[j]);\n\t\twater = max(water,h*(j - i));\n\t\twhile(height[i] <= h && i < j) i++;\n\t\twhile(height[j] <= h && i < j) j++;\n\t}\n}\n```\n\n这里是先取最宽的容器，假设他就是我们要的结果。\n因为`i`不断变大,`j`不断变小，这样wide就不断变小，因为wide在变小，要比当前最大的容器还大的话就只能比当前高度高，这就是那两个`while`的作用，去除掉一个不可能的情况。\n\n\n啊，我真菜，为什么老是想不出来呢！\n\n","slug":"Container_With_Most_Water","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nb002rqmcm54dsczbe","content":"<p>打卡，第四天</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/container-with-most-water/description/\">Container With Most Water</a></p>\n<blockquote>\n<p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br>Note: You may not slant the container and n is at least 2.</p>\n</blockquote>\n<p>很烦，今天老是时间超限，就是不能想出一个时间复杂度小的算法来。</p>\n<p>先理解一下题目先，大概就是给你一个数组<code>height</code>，你要找出两个i，j使得<code>min(height[i],height[j])*(j - i)</code>最大。</p>\n<p>很容易写出一个$ O(n^{2}) $ 的算法出来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> water = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; height.size(); ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; height.size(); ++j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> h = min(height[i],height[j]);</span><br><span class=\"line\">\t\t\twater = max(water,h*(j - i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> water;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这个算法是不能过最后一个测例的。</p>\n<p>想了一个小时都没想出一个好方法来减少他的复杂度,后来就去翻<code>dicuss</code>，看到这样一个算法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> water = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = height.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt; j) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> h = min(height[i],height[j]);</span><br><span class=\"line\">\t\twater = max(water,h*(j - i));</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(height[i] &lt;= h &amp;&amp; i &lt; j) i++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(height[j] &lt;= h &amp;&amp; i &lt; j) j++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是先取最宽的容器，假设他就是我们要的结果。<br>因为<code>i</code>不断变大,<code>j</code>不断变小，这样wide就不断变小，因为wide在变小，要比当前最大的容器还大的话就只能比当前高度高，这就是那两个<code>while</code>的作用，去除掉一个不可能的情况。</p>\n<p>啊，我真菜，为什么老是想不出来呢！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第四天</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/container-with-most-water/description/\">Container With Most Water</a></p>\n<blockquote>\n<p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br>Note: You may not slant the container and n is at least 2.</p>\n</blockquote>\n<p>很烦，今天老是时间超限，就是不能想出一个时间复杂度小的算法来。</p>\n<p>先理解一下题目先，大概就是给你一个数组<code>height</code>，你要找出两个i，j使得<code>min(height[i],height[j])*(j - i)</code>最大。</p>\n<p>很容易写出一个$ O(n^{2}) $ 的算法出来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> water = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; height.size(); ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; height.size(); ++j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> h = min(height[i],height[j]);</span><br><span class=\"line\">\t\t\twater = max(water,h*(j - i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> water;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这个算法是不能过最后一个测例的。</p>\n<p>想了一个小时都没想出一个好方法来减少他的复杂度,后来就去翻<code>dicuss</code>，看到这样一个算法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> water = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = height.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt; j) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> h = min(height[i],height[j]);</span><br><span class=\"line\">\t\twater = max(water,h*(j - i));</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(height[i] &lt;= h &amp;&amp; i &lt; j) i++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(height[j] &lt;= h &amp;&amp; i &lt; j) j++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是先取最宽的容器，假设他就是我们要的结果。<br>因为<code>i</code>不断变大,<code>j</code>不断变小，这样wide就不断变小，因为wide在变小，要比当前最大的容器还大的话就只能比当前高度高，这就是那两个<code>while</code>的作用，去除掉一个不可能的情况。</p>\n<p>啊，我真菜，为什么老是想不出来呢！</p>\n"},{"title":"Contains-Duplicate-II","date":"2017-12-10T03:22:34.000Z","_content":"\n第74天。\n\n今天的题目是[Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/description/):\n\n> Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\n\n显然这道题目可以用两个循环去实现，但是这样会超时，效率不高。\n\n这里是用`Hash Table`去做的,`key`存储`nums[i]`,`value`存储`i`,这样我们用`O(n)`的时间就可以完成了。\n\n```c++\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_map<int,int> m;\n    for(int i = 0;i < nums.size();i++) {\n        if (m.find(nums[i]) != m.end() && m[nums[i]] + k >= i) return true;\n        m[nums[i]] = i;\n    }\n    return false;\n}\n```\n\n`dicuss`中的做法是用`unordered_set`去做的。\n\n```c++\nbool containsNearbyDuplicate(vector<int>& nums, int k)\n{\n    unordered_set<int> s;\n\n    if (k <= 0) return false;\n    if (k >= nums.size()) k = nums.size() - 1;\n\n    for (int i = 0; i < nums.size(); i++)\n    {\n        if (i > k) s.erase(nums[i - k - 1]);\n        if (s.find(nums[i]) != s.end()) return true;\n        s.insert(nums[i]);\n    }\n\n    return false;\n}\n```\n","source":"_posts/Contains-Duplicate-II.md","raw":"---\ntitle: Contains-Duplicate-II\ndate: 2017-12-10T11:22:34.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Hash\n---\n\n第74天。\n\n今天的题目是[Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/description/):\n\n> Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\n\n显然这道题目可以用两个循环去实现，但是这样会超时，效率不高。\n\n这里是用`Hash Table`去做的,`key`存储`nums[i]`,`value`存储`i`,这样我们用`O(n)`的时间就可以完成了。\n\n```c++\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_map<int,int> m;\n    for(int i = 0;i < nums.size();i++) {\n        if (m.find(nums[i]) != m.end() && m[nums[i]] + k >= i) return true;\n        m[nums[i]] = i;\n    }\n    return false;\n}\n```\n\n`dicuss`中的做法是用`unordered_set`去做的。\n\n```c++\nbool containsNearbyDuplicate(vector<int>& nums, int k)\n{\n    unordered_set<int> s;\n\n    if (k <= 0) return false;\n    if (k >= nums.size()) k = nums.size() - 1;\n\n    for (int i = 0; i < nums.size(); i++)\n    {\n        if (i > k) s.erase(nums[i - k - 1]);\n        if (s.find(nums[i]) != s.end()) return true;\n        s.insert(nums[i]);\n    }\n\n    return false;\n}\n```\n","slug":"Contains-Duplicate-II","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nc002uqmcm1rrsd65z","content":"<p>第74天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/contains-duplicate-ii/description/\">Contains Duplicate II</a>:</p>\n<blockquote>\n<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>\n</blockquote>\n<p>显然这道题目可以用两个循环去实现，但是这样会超时，效率不高。</p>\n<p>这里是用<code>Hash Table</code>去做的,<code>key</code>存储<code>nums[i]</code>,<code>value</code>存储<code>i</code>,这样我们用<code>O(n)</code>的时间就可以完成了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsNearbyDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m.find(nums[i]) != m.end() &amp;&amp; m[nums[i]] + k &gt;= i) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        m[nums[i]] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中的做法是用<code>unordered_set</code>去做的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsNearbyDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt; s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &gt;= nums.size()) k = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; k) s.erase(nums[i - k - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.find(nums[i]) != s.end()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        s.insert(nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第74天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/contains-duplicate-ii/description/\">Contains Duplicate II</a>:</p>\n<blockquote>\n<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>\n</blockquote>\n<p>显然这道题目可以用两个循环去实现，但是这样会超时，效率不高。</p>\n<p>这里是用<code>Hash Table</code>去做的,<code>key</code>存储<code>nums[i]</code>,<code>value</code>存储<code>i</code>,这样我们用<code>O(n)</code>的时间就可以完成了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsNearbyDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m.find(nums[i]) != m.end() &amp;&amp; m[nums[i]] + k &gt;= i) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        m[nums[i]] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中的做法是用<code>unordered_set</code>去做的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsNearbyDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt; s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &gt;= nums.size()) k = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; k) s.erase(nums[i - k - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.find(nums[i]) != s.end()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        s.insert(nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Convert Sorted Array to Binary Search Tree","date":"2017-11-30T10:08:21.000Z","_content":"\n第64天。\n\n要死了，天天晚睡早起的，今天一定要早睡晚起（或者等下就睡睡先）\n\n今天的题目是[Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/):\n\n> Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n\n这道题其实一开始没有思路的，感觉很难搞的样子，但是今天数据结构课上讲二分查找时提到了二分查找树（好像是这个名字），然后就觉得好像它就是一个`height balanced BST`.\n\n然后就仿照二分查找的递归算法解出了这道题，其实就是二分查找的逆过程：\n\n```c++\nTreeNode* sortedArrayToBST(vector<int>& nums) {\n    return sortedArrayToBST(nums,0,nums.size() - 1);\n}\nTreeNode *sortedArrayToBST(vector<int> &nums,int low,int high) {\n    if (low > high) return nullptr;\n    int mid = (low + high)/2;\n    TreeNode *root = new TreeNode(nums[mid]);\n    root->left = sortedArrayToBST(nums,low,mid-1);\n    root->right = sortedArrayToBST(nums,mid+1,high);\n    return root;\n}\n```\n","source":"_posts/Convert-Sorted-Array-to-Binary-Search-Tree.md","raw":"---\ntitle: Convert Sorted Array to Binary Search Tree\ndate: 2017-11-30T18:08:21.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第64天。\n\n要死了，天天晚睡早起的，今天一定要早睡晚起（或者等下就睡睡先）\n\n今天的题目是[Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/):\n\n> Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n\n这道题其实一开始没有思路的，感觉很难搞的样子，但是今天数据结构课上讲二分查找时提到了二分查找树（好像是这个名字），然后就觉得好像它就是一个`height balanced BST`.\n\n然后就仿照二分查找的递归算法解出了这道题，其实就是二分查找的逆过程：\n\n```c++\nTreeNode* sortedArrayToBST(vector<int>& nums) {\n    return sortedArrayToBST(nums,0,nums.size() - 1);\n}\nTreeNode *sortedArrayToBST(vector<int> &nums,int low,int high) {\n    if (low > high) return nullptr;\n    int mid = (low + high)/2;\n    TreeNode *root = new TreeNode(nums[mid]);\n    root->left = sortedArrayToBST(nums,low,mid-1);\n    root->right = sortedArrayToBST(nums,mid+1,high);\n    return root;\n}\n```\n","slug":"Convert-Sorted-Array-to-Binary-Search-Tree","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nd002yqmcmby9hgaut","content":"<p>第64天。</p>\n<p>要死了，天天晚睡早起的，今天一定要早睡晚起（或者等下就睡睡先）</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/\">Convert Sorted Array to Binary Search Tree</a>:</p>\n<blockquote>\n<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>\n</blockquote>\n<p>这道题其实一开始没有思路的，感觉很难搞的样子，但是今天数据结构课上讲二分查找时提到了二分查找树（好像是这个名字），然后就觉得好像它就是一个<code>height balanced BST</code>.</p>\n<p>然后就仿照二分查找的递归算法解出了这道题，其实就是二分查找的逆过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sortedArrayToBST(nums,<span class=\"number\">0</span>,nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt; high) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (low + high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    TreeNode *root = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">    root-&gt;left = sortedArrayToBST(nums,low,mid<span class=\"number\">-1</span>);</span><br><span class=\"line\">    root-&gt;right = sortedArrayToBST(nums,mid+<span class=\"number\">1</span>,high);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第64天。</p>\n<p>要死了，天天晚睡早起的，今天一定要早睡晚起（或者等下就睡睡先）</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/\">Convert Sorted Array to Binary Search Tree</a>:</p>\n<blockquote>\n<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>\n</blockquote>\n<p>这道题其实一开始没有思路的，感觉很难搞的样子，但是今天数据结构课上讲二分查找时提到了二分查找树（好像是这个名字），然后就觉得好像它就是一个<code>height balanced BST</code>.</p>\n<p>然后就仿照二分查找的递归算法解出了这道题，其实就是二分查找的逆过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sortedArrayToBST(nums,<span class=\"number\">0</span>,nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt; high) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (low + high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    TreeNode *root = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">    root-&gt;left = sortedArrayToBST(nums,low,mid<span class=\"number\">-1</span>);</span><br><span class=\"line\">    root-&gt;right = sortedArrayToBST(nums,mid+<span class=\"number\">1</span>,high);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Count-Numbers-with-Unique-Digits","date":"2017-12-06T03:14:01.000Z","_content":"\n第70天。\n\n今天的题目是[Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/description/):\n\n> Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10^n.\n>\n> Example:\n> Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x < 100, excluding [11,22,33,44,55,66,77,88,99])\n\n先解释一下题目，所谓的`unique digits`就是这个数字中不包含相同的数字。\n\n理解到这个的话，我们就从`n=2`开始考虑。\n\n其实只需要一点排列组合的知识就可以发现如果它是个2位数,那么就会有`9*9`,第一个之所以是9，是因为，`0`不能出现在最高位，后面的那个是就是因为他不能和前面那个数字相同。如果是个3位数，那就是`9*9*8`,那个8是因为不能和前面两位出现的数字。\n\n然后其实我们这里只得出来n位数的情况，但是它要的范围是`0 < x < 10^n`。这样的话，如果`n=3`,我们就需要求出1位数的个数、2位数的个数、3位数的个数，然后他们的和就是答案了。\n\n我们可以写成动态规划的形式：\n\n```c++\nint countNumbersWithUniqueDigits(int n) {\n    int *dp = new int[n+1];\n    dp[0] = 1;\n    int k = 9;\n    int a = 9;\n    for(int i = 1;i <= n && a > 0;i++) {\n        dp[i] = k + dp[i-1];\n        k *= a;\n        a--;\n    }\n    int ret = dp[n];\n    delete dp;\n    return ret;\n}\n```\n","source":"_posts/Count-Numbers-with-Unique-Digits.md","raw":"---\ntitle: Count-Numbers-with-Unique-Digits\ndate: 2017-12-06T11:14:01.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - DP\n---\n\n第70天。\n\n今天的题目是[Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/description/):\n\n> Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10^n.\n>\n> Example:\n> Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x < 100, excluding [11,22,33,44,55,66,77,88,99])\n\n先解释一下题目，所谓的`unique digits`就是这个数字中不包含相同的数字。\n\n理解到这个的话，我们就从`n=2`开始考虑。\n\n其实只需要一点排列组合的知识就可以发现如果它是个2位数,那么就会有`9*9`,第一个之所以是9，是因为，`0`不能出现在最高位，后面的那个是就是因为他不能和前面那个数字相同。如果是个3位数，那就是`9*9*8`,那个8是因为不能和前面两位出现的数字。\n\n然后其实我们这里只得出来n位数的情况，但是它要的范围是`0 < x < 10^n`。这样的话，如果`n=3`,我们就需要求出1位数的个数、2位数的个数、3位数的个数，然后他们的和就是答案了。\n\n我们可以写成动态规划的形式：\n\n```c++\nint countNumbersWithUniqueDigits(int n) {\n    int *dp = new int[n+1];\n    dp[0] = 1;\n    int k = 9;\n    int a = 9;\n    for(int i = 1;i <= n && a > 0;i++) {\n        dp[i] = k + dp[i-1];\n        k *= a;\n        a--;\n    }\n    int ret = dp[n];\n    delete dp;\n    return ret;\n}\n```\n","slug":"Count-Numbers-with-Unique-Digits","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ne0031qmcmb1ai04jo","content":"<p>第70天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/count-numbers-with-unique-digits/description/\">Count Numbers with Unique Digits</a>:</p>\n<blockquote>\n<p>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10^n.</p>\n<p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p>\n</blockquote>\n<p>先解释一下题目，所谓的<code>unique digits</code>就是这个数字中不包含相同的数字。</p>\n<p>理解到这个的话，我们就从<code>n=2</code>开始考虑。</p>\n<p>其实只需要一点排列组合的知识就可以发现如果它是个2位数,那么就会有<code>9*9</code>,第一个之所以是9，是因为，<code>0</code>不能出现在最高位，后面的那个是就是因为他不能和前面那个数字相同。如果是个3位数，那就是<code>9*9*8</code>,那个8是因为不能和前面两位出现的数字。</p>\n<p>然后其实我们这里只得出来n位数的情况，但是它要的范围是<code>0 &lt; x &lt; 10^n</code>。这样的话，如果<code>n=3</code>,我们就需要求出1位数的个数、2位数的个数、3位数的个数，然后他们的和就是答案了。</p>\n<p>我们可以写成动态规划的形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countNumbersWithUniqueDigits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n &amp;&amp; a &gt; <span class=\"number\">0</span>;i++) &#123;</span><br><span class=\"line\">        dp[i] = k + dp[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        k *= a;</span><br><span class=\"line\">        a--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> dp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第70天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/count-numbers-with-unique-digits/description/\">Count Numbers with Unique Digits</a>:</p>\n<blockquote>\n<p>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10^n.</p>\n<p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p>\n</blockquote>\n<p>先解释一下题目，所谓的<code>unique digits</code>就是这个数字中不包含相同的数字。</p>\n<p>理解到这个的话，我们就从<code>n=2</code>开始考虑。</p>\n<p>其实只需要一点排列组合的知识就可以发现如果它是个2位数,那么就会有<code>9*9</code>,第一个之所以是9，是因为，<code>0</code>不能出现在最高位，后面的那个是就是因为他不能和前面那个数字相同。如果是个3位数，那就是<code>9*9*8</code>,那个8是因为不能和前面两位出现的数字。</p>\n<p>然后其实我们这里只得出来n位数的情况，但是它要的范围是<code>0 &lt; x &lt; 10^n</code>。这样的话，如果<code>n=3</code>,我们就需要求出1位数的个数、2位数的个数、3位数的个数，然后他们的和就是答案了。</p>\n<p>我们可以写成动态规划的形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countNumbersWithUniqueDigits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n &amp;&amp; a &gt; <span class=\"number\">0</span>;i++) &#123;</span><br><span class=\"line\">        dp[i] = k + dp[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        k *= a;</span><br><span class=\"line\">        a--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> dp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Count Servers that Communicate","date":"2019-12-29T13:24:31.000Z","_content":"\n> 第52天，有点浪的一天。survey一点没动的我。\n\n今天的题目是[Count Servers that Communicate](https://leetcode.com/problems/count-servers-that-communicate/)。\n\n\n水题，只要遍历一次计算每一行和每一列之和，然后再遍历判断是否为1，且所在行或列不止一个节点即可。\n\n```c++\nint countServers(vector<vector<int>>& grid) {\n    int m = grid.size();\n    if (m == 0) return 0;\n    int n = grid[0].size(); \n    if (n == 0) return 0;\n    vector<int> a(m, 0);\n    vector<int> b(n, 0);\n    \n    for(int i = 0;i < m; i++) {\n        for(int j = 0;j < n; j++) {\n            if (grid[i][j]) {\n                a[i]++;\n                b[j]++;\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 0;i < m; i++) {\n        for(int j = 0;j < n; j++) {\n            if (grid[i][j] && (a[i] > 1 || b[j] > 1))\n                res++;\n        }\n    }\n    return res;\n    \n}\n```\n\n还看到一种做法，先遍历一遍，每一行都记录下值为1的grid的个数，如果个数大于一，则表示这些点都是能通信的点，如果等于一，则将该点位置记录下来。\n\n然后将对所有记录下来的点判断一次是否其所在列的点的个数大于2。\n\n```c++\nint countServers(vector<vector<int>>& grid) {\n    int m = grid.size();\n    if (m == 0) return 0;\n    int n = grid[0].size(); \n    if (n == 0) return 0;\n    vector<int> vec;\n    int res = 0;\n    for(int i = 0;i < m; i++) {\n        vector<int> temp;\n        for(int j = 0;j < n; j++) {\n            if (grid[i][j]) temp.push_back(j);\n        }\n        \n        if (temp.size() > 1) res += temp.size();\n        else if (temp.size() == 1) {\n            vec.push_back(temp[0]);\n        }\n    }\n    \n    for(auto &j: vec) {\n        int count = 0;\n        for(int i = 0;i < m; i++) {\n            if (grid[i][j]) count++;\n            if (count > 1) {\n                res += 1;\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\n```\n","source":"_posts/Count-Servers-that-Communicate.md","raw":"---\ntitle: Count Servers that Communicate\ndate: 2019-12-29T21:24:31.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第52天，有点浪的一天。survey一点没动的我。\n\n今天的题目是[Count Servers that Communicate](https://leetcode.com/problems/count-servers-that-communicate/)。\n\n\n水题，只要遍历一次计算每一行和每一列之和，然后再遍历判断是否为1，且所在行或列不止一个节点即可。\n\n```c++\nint countServers(vector<vector<int>>& grid) {\n    int m = grid.size();\n    if (m == 0) return 0;\n    int n = grid[0].size(); \n    if (n == 0) return 0;\n    vector<int> a(m, 0);\n    vector<int> b(n, 0);\n    \n    for(int i = 0;i < m; i++) {\n        for(int j = 0;j < n; j++) {\n            if (grid[i][j]) {\n                a[i]++;\n                b[j]++;\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 0;i < m; i++) {\n        for(int j = 0;j < n; j++) {\n            if (grid[i][j] && (a[i] > 1 || b[j] > 1))\n                res++;\n        }\n    }\n    return res;\n    \n}\n```\n\n还看到一种做法，先遍历一遍，每一行都记录下值为1的grid的个数，如果个数大于一，则表示这些点都是能通信的点，如果等于一，则将该点位置记录下来。\n\n然后将对所有记录下来的点判断一次是否其所在列的点的个数大于2。\n\n```c++\nint countServers(vector<vector<int>>& grid) {\n    int m = grid.size();\n    if (m == 0) return 0;\n    int n = grid[0].size(); \n    if (n == 0) return 0;\n    vector<int> vec;\n    int res = 0;\n    for(int i = 0;i < m; i++) {\n        vector<int> temp;\n        for(int j = 0;j < n; j++) {\n            if (grid[i][j]) temp.push_back(j);\n        }\n        \n        if (temp.size() > 1) res += temp.size();\n        else if (temp.size() == 1) {\n            vec.push_back(temp[0]);\n        }\n    }\n    \n    for(auto &j: vec) {\n        int count = 0;\n        for(int i = 0;i < m; i++) {\n            if (grid[i][j]) count++;\n            if (count > 1) {\n                res += 1;\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\n```\n","slug":"Count-Servers-that-Communicate","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nf0035qmcm52a61azq","content":"<blockquote>\n<p>第52天，有点浪的一天。survey一点没动的我。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/count-servers-that-communicate/\">Count Servers that Communicate</a>。</p>\n<p>水题，只要遍历一次计算每一行和每一列之和，然后再遍历判断是否为1，且所在行或列不止一个节点即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countServers</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = grid.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = grid[<span class=\"number\">0</span>].size(); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(m, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">b</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; m; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (grid[i][j]) &#123;</span><br><span class=\"line\">                a[i]++;</span><br><span class=\"line\">                b[j]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; m; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (grid[i][j] &amp;&amp; (a[i] &gt; <span class=\"number\">1</span> || b[j] &gt; <span class=\"number\">1</span>))</span><br><span class=\"line\">                res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还看到一种做法，先遍历一遍，每一行都记录下值为1的grid的个数，如果个数大于一，则表示这些点都是能通信的点，如果等于一，则将该点位置记录下来。</p>\n<p>然后将对所有记录下来的点判断一次是否其所在列的点的个数大于2。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countServers</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = grid.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = grid[<span class=\"number\">0</span>].size(); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; m; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (grid[i][j]) temp.push_back(j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp.size() &gt; <span class=\"number\">1</span>) res += temp.size();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (temp.size() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            vec.push_back(temp[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;j: vec) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (grid[i][j]) count++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res += <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第52天，有点浪的一天。survey一点没动的我。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/count-servers-that-communicate/\">Count Servers that Communicate</a>。</p>\n<p>水题，只要遍历一次计算每一行和每一列之和，然后再遍历判断是否为1，且所在行或列不止一个节点即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countServers</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = grid.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = grid[<span class=\"number\">0</span>].size(); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(m, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">b</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; m; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (grid[i][j]) &#123;</span><br><span class=\"line\">                a[i]++;</span><br><span class=\"line\">                b[j]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; m; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (grid[i][j] &amp;&amp; (a[i] &gt; <span class=\"number\">1</span> || b[j] &gt; <span class=\"number\">1</span>))</span><br><span class=\"line\">                res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还看到一种做法，先遍历一遍，每一行都记录下值为1的grid的个数，如果个数大于一，则表示这些点都是能通信的点，如果等于一，则将该点位置记录下来。</p>\n<p>然后将对所有记录下来的点判断一次是否其所在列的点的个数大于2。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countServers</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = grid.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = grid[<span class=\"number\">0</span>].size(); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; m; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (grid[i][j]) temp.push_back(j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp.size() &gt; <span class=\"number\">1</span>) res += temp.size();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (temp.size() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            vec.push_back(temp[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;j: vec) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (grid[i][j]) count++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res += <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Counting Bits","date":"2017-11-23T04:03:11.000Z","_content":"\n第57天。\n\n今天的题目是[Counting Bits](https://leetcode.com/problems/counting-bits/description/):\n\n> Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.\n>\n> Example:\n> For num = 5 you should return [0,1,1,2,1,2].\n>\n> Follow up:\n>\n> It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?\n> Space complexity should be O(n).\n> Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.\n\n和昨天的题目有点联系。\n\n我们知道要求一个数的二进制表示中`1`的个数大概需要`O(1)`的时间，但这里的`O(1)`其实是`O(sizeof(integer))`.这里的题目上要求直接用`O(n)`的算法，而不是`O(n*sizeof(int))`的算法，这说明我们不能用昨天的算法来对每个数进行求解，我们必须找到一个规律来快速的算出来。\n\n尝试把0~16二进制表示中`1`的个数算出来：\n\n> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n> 0 1 1 2 1 2 2 3 1 2 2  3  2  3  3  4  1\n\n可以观察到0-1的值和2-3的值刚好差1，4-7的值和0-4的值刚好差1，同样的8-16的值和0-7的值刚好差。\n\n因此，我们可以写出一下递推式：\n\n`numCount[i] = numCount[i-k]` 其中`k`表示`i`只保留最高位的`1`时所代表的数。\n\n比如说`i=20`时，20的二进制表示是`10100`,则`k`的二进制位`10000`,即`16`.\n\n知道这个之后，我们就可以很容易的求解出来：\n\n```c++\nvector<int> countBits(int num) {\n    vector<int> ret(num+1,0);\n    int k = 1;\n    for(int i = 1;i <= num;i++) {\n        if (i == k<<1) k<<=1;\n        ret[i] = ret[i - k] + 1;\n    }\n    return ret;\n}\n```\n\n`dicuss`中有一些更精妙的递推式：\n\n```c++\nvector<int> countBits(int num) {\n    vector<int> ret(num+1, 0);\n    for (int i = 1; i <= num; ++i)\n        ret[i] = ret[i&(i-1)] + 1;\n    return ret;\n}\n```\n","source":"_posts/Counting-Bits.md","raw":"---\ntitle: Counting Bits\ndate: 2017-11-23T12:03:11.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - DP\n---\n\n第57天。\n\n今天的题目是[Counting Bits](https://leetcode.com/problems/counting-bits/description/):\n\n> Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.\n>\n> Example:\n> For num = 5 you should return [0,1,1,2,1,2].\n>\n> Follow up:\n>\n> It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?\n> Space complexity should be O(n).\n> Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.\n\n和昨天的题目有点联系。\n\n我们知道要求一个数的二进制表示中`1`的个数大概需要`O(1)`的时间，但这里的`O(1)`其实是`O(sizeof(integer))`.这里的题目上要求直接用`O(n)`的算法，而不是`O(n*sizeof(int))`的算法，这说明我们不能用昨天的算法来对每个数进行求解，我们必须找到一个规律来快速的算出来。\n\n尝试把0~16二进制表示中`1`的个数算出来：\n\n> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n> 0 1 1 2 1 2 2 3 1 2 2  3  2  3  3  4  1\n\n可以观察到0-1的值和2-3的值刚好差1，4-7的值和0-4的值刚好差1，同样的8-16的值和0-7的值刚好差。\n\n因此，我们可以写出一下递推式：\n\n`numCount[i] = numCount[i-k]` 其中`k`表示`i`只保留最高位的`1`时所代表的数。\n\n比如说`i=20`时，20的二进制表示是`10100`,则`k`的二进制位`10000`,即`16`.\n\n知道这个之后，我们就可以很容易的求解出来：\n\n```c++\nvector<int> countBits(int num) {\n    vector<int> ret(num+1,0);\n    int k = 1;\n    for(int i = 1;i <= num;i++) {\n        if (i == k<<1) k<<=1;\n        ret[i] = ret[i - k] + 1;\n    }\n    return ret;\n}\n```\n\n`dicuss`中有一些更精妙的递推式：\n\n```c++\nvector<int> countBits(int num) {\n    vector<int> ret(num+1, 0);\n    for (int i = 1; i <= num; ++i)\n        ret[i] = ret[i&(i-1)] + 1;\n    return ret;\n}\n```\n","slug":"Counting-Bits","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nf0038qmcm0bs0gjga","content":"<p>第57天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/counting-bits/description/\">Counting Bits</a>:</p>\n<blockquote>\n<p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>\n<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>\n<p>Follow up:</p>\n<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.</p>\n</blockquote>\n<p>和昨天的题目有点联系。</p>\n<p>我们知道要求一个数的二进制表示中<code>1</code>的个数大概需要<code>O(1)</code>的时间，但这里的<code>O(1)</code>其实是<code>O(sizeof(integer))</code>.这里的题目上要求直接用<code>O(n)</code>的算法，而不是<code>O(n*sizeof(int))</code>的算法，这说明我们不能用昨天的算法来对每个数进行求解，我们必须找到一个规律来快速的算出来。</p>\n<p>尝试把0~16二进制表示中<code>1</code>的个数算出来：</p>\n<blockquote>\n<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>0 1 1 2 1 2 2 3 1 2 2  3  2  3  3  4  1</p>\n</blockquote>\n<p>可以观察到0-1的值和2-3的值刚好差1，4-7的值和0-4的值刚好差1，同样的8-16的值和0-7的值刚好差。</p>\n<p>因此，我们可以写出一下递推式：</p>\n<p><code>numCount[i] = numCount[i-k]</code> 其中<code>k</code>表示<code>i</code>只保留最高位的<code>1</code>时所代表的数。</p>\n<p>比如说<code>i=20</code>时，20的二进制表示是<code>10100</code>,则<code>k</code>的二进制位<code>10000</code>,即<code>16</code>.</p>\n<p>知道这个之后，我们就可以很容易的求解出来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">countBits</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(num+<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= num;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == k&lt;&lt;<span class=\"number\">1</span>) k&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">        ret[i] = ret[i - k] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中有一些更精妙的递推式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">countBits</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(num+<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= num; ++i)</span><br><span class=\"line\">        ret[i] = ret[i&amp;(i<span class=\"number\">-1</span>)] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第57天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/counting-bits/description/\">Counting Bits</a>:</p>\n<blockquote>\n<p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>\n<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>\n<p>Follow up:</p>\n<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.</p>\n</blockquote>\n<p>和昨天的题目有点联系。</p>\n<p>我们知道要求一个数的二进制表示中<code>1</code>的个数大概需要<code>O(1)</code>的时间，但这里的<code>O(1)</code>其实是<code>O(sizeof(integer))</code>.这里的题目上要求直接用<code>O(n)</code>的算法，而不是<code>O(n*sizeof(int))</code>的算法，这说明我们不能用昨天的算法来对每个数进行求解，我们必须找到一个规律来快速的算出来。</p>\n<p>尝试把0~16二进制表示中<code>1</code>的个数算出来：</p>\n<blockquote>\n<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>0 1 1 2 1 2 2 3 1 2 2  3  2  3  3  4  1</p>\n</blockquote>\n<p>可以观察到0-1的值和2-3的值刚好差1，4-7的值和0-4的值刚好差1，同样的8-16的值和0-7的值刚好差。</p>\n<p>因此，我们可以写出一下递推式：</p>\n<p><code>numCount[i] = numCount[i-k]</code> 其中<code>k</code>表示<code>i</code>只保留最高位的<code>1</code>时所代表的数。</p>\n<p>比如说<code>i=20</code>时，20的二进制表示是<code>10100</code>,则<code>k</code>的二进制位<code>10000</code>,即<code>16</code>.</p>\n<p>知道这个之后，我们就可以很容易的求解出来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">countBits</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(num+<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= num;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == k&lt;&lt;<span class=\"number\">1</span>) k&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">        ret[i] = ret[i - k] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中有一些更精妙的递推式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">countBits</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(num+<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= num; ++i)</span><br><span class=\"line\">        ret[i] = ret[i&amp;(i<span class=\"number\">-1</span>)] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Course-Schedule","date":"2017-11-18T08:35:54.000Z","_content":"\n第52天。\n\n---\n昨晚去见了一下一起做东西的研究生师兄师姐们，感觉很`nice`,不嫌弃我什么都不会还教了我很多东西，恩，等下开始学机器学习的东西。\n\n---\n\n今天的题目是[Course Schedule](https://leetcode.com/problems/course-schedule/description/):\n\n> There are a total of n courses you have to take, labeled from 0 to n - 1.\n>\n> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\n>\n> Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\n>\n> For example:\n>\n> 2, [[1,0]]\n> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.\n>\n> 2, [[1,0],[0,1]]\n> There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n>Note:\n> The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\n> You may assume that there are no duplicate edges in the input prerequisites.\n\n这个问题可以转化成——有向图是否有环路。\n\n这里是使用[拓扑排序](https://zh.wikipedia.org/zh-hans/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)做的.\n拓扑排序是只能在有向无环图中进行排序，如果它有环，那么它进会出错，我们对这个图进行一次拓扑排序就可以知道这个图是不是有环了。\n\n一开始是使用维护一个入度的数组，然后通过不断删除入度为0点的方式来完成拓扑排序的，但是超时了，所以这里用`DFS`的方法来实现，而且这种方法还比之前的要简单。\n\n原本的`DFS`需要一个`visited`，来表示某个节点是否被访问了，这里扩展一下`visited`，原本的`visited`只有两个状态：被访问了，未被访问。\n这里加入一个新的状态`访问中`,这里用`-1`来表示。\n\n之所以要加入这个状态，是因为我们需要判断这个图是否有环路。让我们看个例子。\n\n\n我们尝试着对这个图进行一次`DFS`:\n\n```python\n2\n3->8->9->10\n5->11\n7\n```\n\n从上面我们可以知道这个图，需要四次调用`DFS`的递归函数才能完成整个遍历，我们认为如果某个节点在某次递归中，那么它的状态就是`访问中`,也就是说在第二次调用`DFS`的递归函数时如果访问了`3,8`节点，准备访问`9`节点时，`3`,`8`就是被访问状态，一旦访问完所以节点（也就是访问完`10`,这是在这条链路中所以节点都被访问了，递归函数开始返回，然后我们可以依次把`10`,`9`,`8`,`3`的设为`已访问`的状态。\n\n讲了那么多，如果定义`访问中`状态，好像还没有提到他的用处，还是刚才的例子，如果上图加上一个`9->3`的边，那么我们是不是在访问`9`时，发现他可以通向一个`访问中`的节点（即`3`节点)，这时说明他们之间必定有回路。\n\n大概的思路就是这样吧，其实看代码会简单一点：\n\n```python\ndef helper(self,v,visited,graph):\n    visited[v] = -1 #设置为访问中\n    for i in graph[v]:\n        if visited[i] == -1: #访问中\n            return False\n        if visited[i] == 0: #未访问\n            if self.helper(i,visited,graph) == False:\n                return False\n    visited[v] = 1 # 递归函数开始返回了，设置为已访问的状态\n    return True\ndef canFinish(self, numCourses, prerequisites):\n    \"\"\"\n    :type numCourses: int\n    :type prerequisites: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    visited = [0]*numCourses #初始时，所有节点都未访问\n    #将边集转化成邻接表\n    graph = [[] for i in range(numCourses)] \n    for e in prerequisites:\n        graph[e[0]].append(e[1])\n\n    #DFS\n    for i in range(numCourses):\n        if visited[i] == False:\n            if self.helper(i,visited,graph) == False:\n                return False\n\n    return True\n```\n\n`dicuss`中的`BFS`解法：\n\n```c++\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {\n        vector<unordered_set<int>> graph = make_graph(numCourses, prerequisites);\n        vector<int> degrees = compute_indegree(graph);\n        for (int i = 0; i < numCourses; i++) {\n            int j = 0;\n            for (; j < numCourses; j++)\n                if (!degrees[j]) break;\n            if (j == numCourses) return false;\n            degrees[j] = -1;\n            for (int neigh : graph[j])\n                degrees[neigh]--;\n        }\n        return true;\n    }\nprivate:\n    vector<unordered_set<int>> make_graph(int numCourses, vector<pair<int, int>>& prerequisites) {\n        vector<unordered_set<int>> graph(numCourses);\n        for (auto pre : prerequisites)\n            graph[pre.second].insert(pre.first);\n        return graph;\n    }\n    vector<int> compute_indegree(vector<unordered_set<int>>& graph) {\n        vector<int> degrees(graph.size(), 0);\n        for (auto neighbors : graph)\n            for (int neigh : neighbors)\n                degrees[neigh]++;\n        return degrees;\n    }\n};\n```\n\n好像就是我一开始做的那种想法，但是为什么我的又没通过。\n","source":"_posts/Course-Schedule.md","raw":"---\ntitle: Course-Schedule\ndate: 2017-11-18T16:35:54.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 图\n---\n\n第52天。\n\n---\n昨晚去见了一下一起做东西的研究生师兄师姐们，感觉很`nice`,不嫌弃我什么都不会还教了我很多东西，恩，等下开始学机器学习的东西。\n\n---\n\n今天的题目是[Course Schedule](https://leetcode.com/problems/course-schedule/description/):\n\n> There are a total of n courses you have to take, labeled from 0 to n - 1.\n>\n> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\n>\n> Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\n>\n> For example:\n>\n> 2, [[1,0]]\n> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.\n>\n> 2, [[1,0],[0,1]]\n> There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n>Note:\n> The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\n> You may assume that there are no duplicate edges in the input prerequisites.\n\n这个问题可以转化成——有向图是否有环路。\n\n这里是使用[拓扑排序](https://zh.wikipedia.org/zh-hans/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)做的.\n拓扑排序是只能在有向无环图中进行排序，如果它有环，那么它进会出错，我们对这个图进行一次拓扑排序就可以知道这个图是不是有环了。\n\n一开始是使用维护一个入度的数组，然后通过不断删除入度为0点的方式来完成拓扑排序的，但是超时了，所以这里用`DFS`的方法来实现，而且这种方法还比之前的要简单。\n\n原本的`DFS`需要一个`visited`，来表示某个节点是否被访问了，这里扩展一下`visited`，原本的`visited`只有两个状态：被访问了，未被访问。\n这里加入一个新的状态`访问中`,这里用`-1`来表示。\n\n之所以要加入这个状态，是因为我们需要判断这个图是否有环路。让我们看个例子。\n\n\n我们尝试着对这个图进行一次`DFS`:\n\n```python\n2\n3->8->9->10\n5->11\n7\n```\n\n从上面我们可以知道这个图，需要四次调用`DFS`的递归函数才能完成整个遍历，我们认为如果某个节点在某次递归中，那么它的状态就是`访问中`,也就是说在第二次调用`DFS`的递归函数时如果访问了`3,8`节点，准备访问`9`节点时，`3`,`8`就是被访问状态，一旦访问完所以节点（也就是访问完`10`,这是在这条链路中所以节点都被访问了，递归函数开始返回，然后我们可以依次把`10`,`9`,`8`,`3`的设为`已访问`的状态。\n\n讲了那么多，如果定义`访问中`状态，好像还没有提到他的用处，还是刚才的例子，如果上图加上一个`9->3`的边，那么我们是不是在访问`9`时，发现他可以通向一个`访问中`的节点（即`3`节点)，这时说明他们之间必定有回路。\n\n大概的思路就是这样吧，其实看代码会简单一点：\n\n```python\ndef helper(self,v,visited,graph):\n    visited[v] = -1 #设置为访问中\n    for i in graph[v]:\n        if visited[i] == -1: #访问中\n            return False\n        if visited[i] == 0: #未访问\n            if self.helper(i,visited,graph) == False:\n                return False\n    visited[v] = 1 # 递归函数开始返回了，设置为已访问的状态\n    return True\ndef canFinish(self, numCourses, prerequisites):\n    \"\"\"\n    :type numCourses: int\n    :type prerequisites: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    visited = [0]*numCourses #初始时，所有节点都未访问\n    #将边集转化成邻接表\n    graph = [[] for i in range(numCourses)] \n    for e in prerequisites:\n        graph[e[0]].append(e[1])\n\n    #DFS\n    for i in range(numCourses):\n        if visited[i] == False:\n            if self.helper(i,visited,graph) == False:\n                return False\n\n    return True\n```\n\n`dicuss`中的`BFS`解法：\n\n```c++\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {\n        vector<unordered_set<int>> graph = make_graph(numCourses, prerequisites);\n        vector<int> degrees = compute_indegree(graph);\n        for (int i = 0; i < numCourses; i++) {\n            int j = 0;\n            for (; j < numCourses; j++)\n                if (!degrees[j]) break;\n            if (j == numCourses) return false;\n            degrees[j] = -1;\n            for (int neigh : graph[j])\n                degrees[neigh]--;\n        }\n        return true;\n    }\nprivate:\n    vector<unordered_set<int>> make_graph(int numCourses, vector<pair<int, int>>& prerequisites) {\n        vector<unordered_set<int>> graph(numCourses);\n        for (auto pre : prerequisites)\n            graph[pre.second].insert(pre.first);\n        return graph;\n    }\n    vector<int> compute_indegree(vector<unordered_set<int>>& graph) {\n        vector<int> degrees(graph.size(), 0);\n        for (auto neighbors : graph)\n            for (int neigh : neighbors)\n                degrees[neigh]++;\n        return degrees;\n    }\n};\n```\n\n好像就是我一开始做的那种想法，但是为什么我的又没通过。\n","slug":"Course-Schedule","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nh003cqmcm7s1s7216","content":"<p>第52天。</p>\n<hr>\n<p>昨晚去见了一下一起做东西的研究生师兄师姐们，感觉很<code>nice</code>,不嫌弃我什么都不会还教了我很多东西，恩，等下开始学机器学习的东西。</p>\n<hr>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/course-schedule/description/\">Course Schedule</a>:</p>\n<blockquote>\n<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>\n<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>\n<p>For example:</p>\n<p>2, [[1,0]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>\n<p>2, [[1,0],[0,1]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>\n</blockquote>\n<p>这个问题可以转化成——有向图是否有环路。</p>\n<p>这里是使用<a href=\"https://zh.wikipedia.org/zh-hans/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F\">拓扑排序</a>做的.<br>拓扑排序是只能在有向无环图中进行排序，如果它有环，那么它进会出错，我们对这个图进行一次拓扑排序就可以知道这个图是不是有环了。</p>\n<p>一开始是使用维护一个入度的数组，然后通过不断删除入度为0点的方式来完成拓扑排序的，但是超时了，所以这里用<code>DFS</code>的方法来实现，而且这种方法还比之前的要简单。</p>\n<p>原本的<code>DFS</code>需要一个<code>visited</code>，来表示某个节点是否被访问了，这里扩展一下<code>visited</code>，原本的<code>visited</code>只有两个状态：被访问了，未被访问。<br>这里加入一个新的状态<code>访问中</code>,这里用<code>-1</code>来表示。</p>\n<p>之所以要加入这个状态，是因为我们需要判断这个图是否有环路。让我们看个例子。</p>\n<p>我们尝试着对这个图进行一次<code>DFS</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">3-&gt;8-&gt;9-&gt;10</span><br><span class=\"line\">5-&gt;11</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>从上面我们可以知道这个图，需要四次调用<code>DFS</code>的递归函数才能完成整个遍历，我们认为如果某个节点在某次递归中，那么它的状态就是<code>访问中</code>,也就是说在第二次调用<code>DFS</code>的递归函数时如果访问了<code>3,8</code>节点，准备访问<code>9</code>节点时，<code>3</code>,<code>8</code>就是被访问状态，一旦访问完所以节点（也就是访问完<code>10</code>,这是在这条链路中所以节点都被访问了，递归函数开始返回，然后我们可以依次把<code>10</code>,<code>9</code>,<code>8</code>,<code>3</code>的设为<code>已访问</code>的状态。</p>\n<p>讲了那么多，如果定义<code>访问中</code>状态，好像还没有提到他的用处，还是刚才的例子，如果上图加上一个<code>9-&gt;3</code>的边，那么我们是不是在访问<code>9</code>时，发现他可以通向一个<code>访问中</code>的节点（即<code>3</code>节点)，这时说明他们之间必定有回路。</p>\n<p>大概的思路就是这样吧，其实看代码会简单一点：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span>(<span class=\"params\">self,v,visited,graph</span>):</span></span><br><span class=\"line\">    visited[v] = -<span class=\"number\">1</span> <span class=\"comment\">#设置为访问中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> graph[v]:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited[i] == -<span class=\"number\">1</span>: <span class=\"comment\">#访问中</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited[i] == <span class=\"number\">0</span>: <span class=\"comment\">#未访问</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.helper(i,visited,graph) == <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    visited[v] = <span class=\"number\">1</span> <span class=\"comment\"># 递归函数开始返回了，设置为已访问的状态</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canFinish</span>(<span class=\"params\">self, numCourses, prerequisites</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type numCourses: int</span></span><br><span class=\"line\"><span class=\"string\">    :type prerequisites: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    visited = [<span class=\"number\">0</span>]*numCourses <span class=\"comment\">#初始时，所有节点都未访问</span></span><br><span class=\"line\">    <span class=\"comment\">#将边集转化成邻接表</span></span><br><span class=\"line\">    graph = [[] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(numCourses)] </span><br><span class=\"line\">    <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> prerequisites:</span><br><span class=\"line\">        graph[e[<span class=\"number\">0</span>]].append(e[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#DFS</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(numCourses):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited[i] == <span class=\"literal\">False</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.helper(i,visited,graph) == <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中的<code>BFS</code>解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canFinish</span><span class=\"params\">(<span class=\"keyword\">int</span> numCourses, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; graph = make_graph(numCourses, prerequisites);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; degrees = compute_indegree(graph);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &lt; numCourses; j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!degrees[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == numCourses) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            degrees[j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> neigh : graph[j])</span><br><span class=\"line\">                degrees[neigh]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; make_graph(<span class=\"keyword\">int</span> numCourses, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; graph(numCourses);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> pre : prerequisites)</span><br><span class=\"line\">            graph[pre.second].insert(pre.first);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> graph;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">compute_indegree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">degrees</span><span class=\"params\">(graph.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> neighbors : graph)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> neigh : neighbors)</span><br><span class=\"line\">                degrees[neigh]++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> degrees;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>好像就是我一开始做的那种想法，但是为什么我的又没通过。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第52天。</p>\n<hr>\n<p>昨晚去见了一下一起做东西的研究生师兄师姐们，感觉很<code>nice</code>,不嫌弃我什么都不会还教了我很多东西，恩，等下开始学机器学习的东西。</p>\n<hr>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/course-schedule/description/\">Course Schedule</a>:</p>\n<blockquote>\n<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>\n<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>\n<p>For example:</p>\n<p>2, [[1,0]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>\n<p>2, [[1,0],[0,1]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>\n</blockquote>\n<p>这个问题可以转化成——有向图是否有环路。</p>\n<p>这里是使用<a href=\"https://zh.wikipedia.org/zh-hans/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F\">拓扑排序</a>做的.<br>拓扑排序是只能在有向无环图中进行排序，如果它有环，那么它进会出错，我们对这个图进行一次拓扑排序就可以知道这个图是不是有环了。</p>\n<p>一开始是使用维护一个入度的数组，然后通过不断删除入度为0点的方式来完成拓扑排序的，但是超时了，所以这里用<code>DFS</code>的方法来实现，而且这种方法还比之前的要简单。</p>\n<p>原本的<code>DFS</code>需要一个<code>visited</code>，来表示某个节点是否被访问了，这里扩展一下<code>visited</code>，原本的<code>visited</code>只有两个状态：被访问了，未被访问。<br>这里加入一个新的状态<code>访问中</code>,这里用<code>-1</code>来表示。</p>\n<p>之所以要加入这个状态，是因为我们需要判断这个图是否有环路。让我们看个例子。</p>\n<p>我们尝试着对这个图进行一次<code>DFS</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">3-&gt;8-&gt;9-&gt;10</span><br><span class=\"line\">5-&gt;11</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>从上面我们可以知道这个图，需要四次调用<code>DFS</code>的递归函数才能完成整个遍历，我们认为如果某个节点在某次递归中，那么它的状态就是<code>访问中</code>,也就是说在第二次调用<code>DFS</code>的递归函数时如果访问了<code>3,8</code>节点，准备访问<code>9</code>节点时，<code>3</code>,<code>8</code>就是被访问状态，一旦访问完所以节点（也就是访问完<code>10</code>,这是在这条链路中所以节点都被访问了，递归函数开始返回，然后我们可以依次把<code>10</code>,<code>9</code>,<code>8</code>,<code>3</code>的设为<code>已访问</code>的状态。</p>\n<p>讲了那么多，如果定义<code>访问中</code>状态，好像还没有提到他的用处，还是刚才的例子，如果上图加上一个<code>9-&gt;3</code>的边，那么我们是不是在访问<code>9</code>时，发现他可以通向一个<code>访问中</code>的节点（即<code>3</code>节点)，这时说明他们之间必定有回路。</p>\n<p>大概的思路就是这样吧，其实看代码会简单一点：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span>(<span class=\"params\">self,v,visited,graph</span>):</span></span><br><span class=\"line\">    visited[v] = -<span class=\"number\">1</span> <span class=\"comment\">#设置为访问中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> graph[v]:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited[i] == -<span class=\"number\">1</span>: <span class=\"comment\">#访问中</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited[i] == <span class=\"number\">0</span>: <span class=\"comment\">#未访问</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.helper(i,visited,graph) == <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    visited[v] = <span class=\"number\">1</span> <span class=\"comment\"># 递归函数开始返回了，设置为已访问的状态</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canFinish</span>(<span class=\"params\">self, numCourses, prerequisites</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type numCourses: int</span></span><br><span class=\"line\"><span class=\"string\">    :type prerequisites: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    visited = [<span class=\"number\">0</span>]*numCourses <span class=\"comment\">#初始时，所有节点都未访问</span></span><br><span class=\"line\">    <span class=\"comment\">#将边集转化成邻接表</span></span><br><span class=\"line\">    graph = [[] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(numCourses)] </span><br><span class=\"line\">    <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> prerequisites:</span><br><span class=\"line\">        graph[e[<span class=\"number\">0</span>]].append(e[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#DFS</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(numCourses):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited[i] == <span class=\"literal\">False</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.helper(i,visited,graph) == <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中的<code>BFS</code>解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canFinish</span><span class=\"params\">(<span class=\"keyword\">int</span> numCourses, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; graph = make_graph(numCourses, prerequisites);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; degrees = compute_indegree(graph);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &lt; numCourses; j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!degrees[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == numCourses) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            degrees[j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> neigh : graph[j])</span><br><span class=\"line\">                degrees[neigh]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; make_graph(<span class=\"keyword\">int</span> numCourses, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; graph(numCourses);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> pre : prerequisites)</span><br><span class=\"line\">            graph[pre.second].insert(pre.first);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> graph;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">compute_indegree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">degrees</span><span class=\"params\">(graph.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> neighbors : graph)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> neigh : neighbors)</span><br><span class=\"line\">                degrees[neigh]++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> degrees;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>好像就是我一开始做的那种想法，但是为什么我的又没通过。</p>\n"},{"title":"Daily Temperatures","date":"2019-03-20T03:17:39.000Z","_content":"\n> 第14天。\n\n今天的题目是[Daily Temperatures](https://leetcode.com/problems/daily-temperatures/).\n\n这道题会给我一个数组代表温度，如：`T = [73, 74, 75, 71, 69, 72, 76, 73]`\n\n我们返回一个数组来表示，多少天会回暖（即比当天温度要高），如`[1, 1, 4, 2, 1, 1, 0, 0]`\n\n如 74 比 73 高，则返回的数组中第一个数值应该为1，而对于 75 ，因为他后面只有76比他高，那么就得4天后才回暖，那么对应的位置应该放置4.\n\n简单的想法当然是对每一个数字，从前向后找啦，但是这样复杂度就是`O(N^2)`了，所以我们换钟思路，从后向前去获取答案，看看能不能通过这种方式来减少复杂度。\n\n之所以这样做，是想着能否利用之前已经求过的结果来推断当前的结果，比如求解 75 时，我们先猜答案是1，然后发现向前一天的温度是71，那么显然猜错了，这时我们要继续向前猜 69 吗？显然没必要啊，因为 69 都还没 71 大，我们应该利用之前求出的答案，发现比 71 大的数再他后面 2 天，所以我们直接猜答案是 1 + 2 即可，用这种方式就可以把前面的结果利用上了：\n\n```c++\nvector<int> dailyTemperatures(vector<int>& T) {\n\tint len = T.size();\n\t\n\tvector<int> res(len, 0);\n\tfor(int i = len-2; i>= 0; --i) {\n\t\tint t = 1;\n\t\twhile(T[i + t] <= T[i] && res[i+t] != 0)\n\t\t\tt += res[i+t];\n\t\tres[i] = (T[i+t] <= T[i])?0:t;\n\t}\n\t\n\treturn res;\n}\n```\n","source":"_posts/Daily-Temperatures.md","raw":"---\ntitle: Daily Temperatures\ndate: 2019-03-20T11:17:39.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第14天。\n\n今天的题目是[Daily Temperatures](https://leetcode.com/problems/daily-temperatures/).\n\n这道题会给我一个数组代表温度，如：`T = [73, 74, 75, 71, 69, 72, 76, 73]`\n\n我们返回一个数组来表示，多少天会回暖（即比当天温度要高），如`[1, 1, 4, 2, 1, 1, 0, 0]`\n\n如 74 比 73 高，则返回的数组中第一个数值应该为1，而对于 75 ，因为他后面只有76比他高，那么就得4天后才回暖，那么对应的位置应该放置4.\n\n简单的想法当然是对每一个数字，从前向后找啦，但是这样复杂度就是`O(N^2)`了，所以我们换钟思路，从后向前去获取答案，看看能不能通过这种方式来减少复杂度。\n\n之所以这样做，是想着能否利用之前已经求过的结果来推断当前的结果，比如求解 75 时，我们先猜答案是1，然后发现向前一天的温度是71，那么显然猜错了，这时我们要继续向前猜 69 吗？显然没必要啊，因为 69 都还没 71 大，我们应该利用之前求出的答案，发现比 71 大的数再他后面 2 天，所以我们直接猜答案是 1 + 2 即可，用这种方式就可以把前面的结果利用上了：\n\n```c++\nvector<int> dailyTemperatures(vector<int>& T) {\n\tint len = T.size();\n\t\n\tvector<int> res(len, 0);\n\tfor(int i = len-2; i>= 0; --i) {\n\t\tint t = 1;\n\t\twhile(T[i + t] <= T[i] && res[i+t] != 0)\n\t\t\tt += res[i+t];\n\t\tres[i] = (T[i+t] <= T[i])?0:t;\n\t}\n\t\n\treturn res;\n}\n```\n","slug":"Daily-Temperatures","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nh003fqmcm8rdt3g2u","content":"<blockquote>\n<p>第14天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/daily-temperatures/\">Daily Temperatures</a>.</p>\n<p>这道题会给我一个数组代表温度，如：<code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code></p>\n<p>我们返回一个数组来表示，多少天会回暖（即比当天温度要高），如<code>[1, 1, 4, 2, 1, 1, 0, 0]</code></p>\n<p>如 74 比 73 高，则返回的数组中第一个数值应该为1，而对于 75 ，因为他后面只有76比他高，那么就得4天后才回暖，那么对应的位置应该放置4.</p>\n<p>简单的想法当然是对每一个数字，从前向后找啦，但是这样复杂度就是<code>O(N^2)</code>了，所以我们换钟思路，从后向前去获取答案，看看能不能通过这种方式来减少复杂度。</p>\n<p>之所以这样做，是想着能否利用之前已经求过的结果来推断当前的结果，比如求解 75 时，我们先猜答案是1，然后发现向前一天的温度是71，那么显然猜错了，这时我们要继续向前猜 69 吗？显然没必要啊，因为 69 都还没 71 大，我们应该利用之前求出的答案，发现比 71 大的数再他后面 2 天，所以我们直接猜答案是 1 + 2 即可，用这种方式就可以把前面的结果利用上了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dailyTemperatures</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = T.size();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(len, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = len<span class=\"number\">-2</span>; i&gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> t = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(T[i + t] &lt;= T[i] &amp;&amp; res[i+t] != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tt += res[i+t];</span><br><span class=\"line\">\t\tres[i] = (T[i+t] &lt;= T[i])?<span class=\"number\">0</span>:t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第14天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/daily-temperatures/\">Daily Temperatures</a>.</p>\n<p>这道题会给我一个数组代表温度，如：<code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code></p>\n<p>我们返回一个数组来表示，多少天会回暖（即比当天温度要高），如<code>[1, 1, 4, 2, 1, 1, 0, 0]</code></p>\n<p>如 74 比 73 高，则返回的数组中第一个数值应该为1，而对于 75 ，因为他后面只有76比他高，那么就得4天后才回暖，那么对应的位置应该放置4.</p>\n<p>简单的想法当然是对每一个数字，从前向后找啦，但是这样复杂度就是<code>O(N^2)</code>了，所以我们换钟思路，从后向前去获取答案，看看能不能通过这种方式来减少复杂度。</p>\n<p>之所以这样做，是想着能否利用之前已经求过的结果来推断当前的结果，比如求解 75 时，我们先猜答案是1，然后发现向前一天的温度是71，那么显然猜错了，这时我们要继续向前猜 69 吗？显然没必要啊，因为 69 都还没 71 大，我们应该利用之前求出的答案，发现比 71 大的数再他后面 2 天，所以我们直接猜答案是 1 + 2 即可，用这种方式就可以把前面的结果利用上了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dailyTemperatures</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = T.size();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(len, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = len<span class=\"number\">-2</span>; i&gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> t = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(T[i + t] &lt;= T[i] &amp;&amp; res[i+t] != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tt += res[i+t];</span><br><span class=\"line\">\t\tres[i] = (T[i+t] &lt;= T[i])?<span class=\"number\">0</span>:t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Decode String","date":"2019-11-08T12:55:51.000Z","_content":"\n> 第四天。\n\n今天的题目是[Decode String](https://leetcode.com/problems/decode-string/)：\n\n---\n\nGiven an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the *encoded_string* inside the square brackets is being repeated exactly *k* times. Note that *k* is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, *k*. For example, there won't be input like `3a` or `2[4]`.\n\n**Examples:**\n\n```\ns = \"3[a]2[bc]\", return \"aaabcbc\".\ns = \"3[a2[c]]\", return \"accaccacc\".\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n```\n\n---\n\n比较简单的一道题，先分析一下题目，首先输入的格式是`k[encoded_string]`，要将其扩展成k 个 encoded_string 组成的字符串，我们暂且先不考虑嵌套的情况，我们通过一个简单的状态机就可以解决这个问题：\n\n![有限状态机](https://imagehosting.wuxiaobai24.fun/20191108204429.png)\n\n这个代码写起来也很简单：\n\n```c++\nstring decodeString(string s) {\n    string res;\n    string temp;\n    int num = 0;\n    for(int i = 0, size = s.size(); i < size; i++) {\n        if (isdigit(s[i])) {\n            num = num * 10 + s[i] - '0';\n        } else if (s[i] == '[') {\n            res += temp;\n           \ttemp = \"\";\n        } else if (s[i] == ']') {\n            for(int i = 0;i < num;i++)\n            \tres += temp;\n            temp = \"\";\n        } else { // charar\n            temp.push_back(s[i]);\n            num = 0;\n        }\n    }\n    return res;\n}\n```\n\n如果这道题不需要考虑嵌套问题的话，上面就是正确的答案了。虽然需要处理嵌套的问题，但是其实只需要用栈来模拟多个层次的嵌套即可：\n\n```c++\nstring decodeString(string s) {\n    int num = 0;\n\n    stack<string> sst;\n    stack<int> nst;\n    nst.push(1);\n    sst.push(string());\n\n    for(int i = 0, size = s.size(); i < size; i++) {\n        if (isdigit(s[i])) {\n            num = num * 10 + s[i] - '0';\n        } else if (s[i] == '[') {\n            beg = end = i + 1;\n            nst.push(num); num = 0;\n            sst.push(string());\n        } else if (s[i] == ']') {\n            string s = sst.top(); sst.pop();\n            int n = nst.top(); nst.pop();\n            for(int j = 0;j < n;j++) sst.top() += s;\n        } else { // char\n            sst.top().push_back(s[i]);\n        }\n    }\n    return sst.top();\n}\n```\n\n> update at 2020-04-04\n\n似乎最上面那个代码是有问题的，emmm，不管了，更新一个用一个`stack`的版本：\n\n```c++\nstring decodeString1(string s) {\n    stack<pair<int, string>> st;\n    st.push(make_pair(1, \"\"));\n    int num = 0;\n    for(auto c: s) {\n        if (isdigit(c)) {\n            num  = num * 10 + c - '0';\n        } else if (c == '[') {\n            st.push(make_pair(num, \"\"));\n            num = 0;\n        } else if (c == ']') {\n            auto p = st.top(); st.pop();\n            int n  = p.first;\n            auto s = p.second;\n            // cout << n << s << endl;\n            for(int i = 0; i < n; i++) st.top().second += s;\n        } else {\n            st.top().second.push_back(c);\n        }\n    }\n    return st.top().second;\n}\n```\n","source":"_posts/Decode-String.md","raw":"---\ntitle: Decode String\ntags:\n  - LeetCode\n  - Stack\n  - Depth-first Search\ncategories:\n  - LeetCode\ndate: 2019-11-08T20:55:51.000Z\n---\n\n> 第四天。\n\n今天的题目是[Decode String](https://leetcode.com/problems/decode-string/)：\n\n---\n\nGiven an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the *encoded_string* inside the square brackets is being repeated exactly *k* times. Note that *k* is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, *k*. For example, there won't be input like `3a` or `2[4]`.\n\n**Examples:**\n\n```\ns = \"3[a]2[bc]\", return \"aaabcbc\".\ns = \"3[a2[c]]\", return \"accaccacc\".\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n```\n\n---\n\n比较简单的一道题，先分析一下题目，首先输入的格式是`k[encoded_string]`，要将其扩展成k 个 encoded_string 组成的字符串，我们暂且先不考虑嵌套的情况，我们通过一个简单的状态机就可以解决这个问题：\n\n![有限状态机](https://imagehosting.wuxiaobai24.fun/20191108204429.png)\n\n这个代码写起来也很简单：\n\n```c++\nstring decodeString(string s) {\n    string res;\n    string temp;\n    int num = 0;\n    for(int i = 0, size = s.size(); i < size; i++) {\n        if (isdigit(s[i])) {\n            num = num * 10 + s[i] - '0';\n        } else if (s[i] == '[') {\n            res += temp;\n           \ttemp = \"\";\n        } else if (s[i] == ']') {\n            for(int i = 0;i < num;i++)\n            \tres += temp;\n            temp = \"\";\n        } else { // charar\n            temp.push_back(s[i]);\n            num = 0;\n        }\n    }\n    return res;\n}\n```\n\n如果这道题不需要考虑嵌套问题的话，上面就是正确的答案了。虽然需要处理嵌套的问题，但是其实只需要用栈来模拟多个层次的嵌套即可：\n\n```c++\nstring decodeString(string s) {\n    int num = 0;\n\n    stack<string> sst;\n    stack<int> nst;\n    nst.push(1);\n    sst.push(string());\n\n    for(int i = 0, size = s.size(); i < size; i++) {\n        if (isdigit(s[i])) {\n            num = num * 10 + s[i] - '0';\n        } else if (s[i] == '[') {\n            beg = end = i + 1;\n            nst.push(num); num = 0;\n            sst.push(string());\n        } else if (s[i] == ']') {\n            string s = sst.top(); sst.pop();\n            int n = nst.top(); nst.pop();\n            for(int j = 0;j < n;j++) sst.top() += s;\n        } else { // char\n            sst.top().push_back(s[i]);\n        }\n    }\n    return sst.top();\n}\n```\n\n> update at 2020-04-04\n\n似乎最上面那个代码是有问题的，emmm，不管了，更新一个用一个`stack`的版本：\n\n```c++\nstring decodeString1(string s) {\n    stack<pair<int, string>> st;\n    st.push(make_pair(1, \"\"));\n    int num = 0;\n    for(auto c: s) {\n        if (isdigit(c)) {\n            num  = num * 10 + c - '0';\n        } else if (c == '[') {\n            st.push(make_pair(num, \"\"));\n            num = 0;\n        } else if (c == ']') {\n            auto p = st.top(); st.pop();\n            int n  = p.first;\n            auto s = p.second;\n            // cout << n << s << endl;\n            for(int i = 0; i < n; i++) st.top().second += s;\n        } else {\n            st.top().second.push_back(c);\n        }\n    }\n    return st.top().second;\n}\n```\n","slug":"Decode-String","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ni003jqmcm937gb8oe","content":"<blockquote>\n<p>第四天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/decode-string/\">Decode String</a>：</p>\n<hr>\n<p>Given an encoded string, return its decoded string.</p>\n<p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p>\n<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\n<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p>\n<p><strong>Examples:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s &#x3D; &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</span><br><span class=\"line\">s &#x3D; &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</span><br><span class=\"line\">s &#x3D; &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>比较简单的一道题，先分析一下题目，首先输入的格式是<code>k[encoded_string]</code>，要将其扩展成k 个 encoded_string 组成的字符串，我们暂且先不考虑嵌套的情况，我们通过一个简单的状态机就可以解决这个问题：</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/20191108204429.png\" alt=\"有限状态机\"></p>\n<p>这个代码写起来也很简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">decodeString</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = s.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(s[i])) &#123;</span><br><span class=\"line\">            num = num * <span class=\"number\">10</span> + s[i] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">            res += temp;</span><br><span class=\"line\">           \ttemp = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; num;i++)</span><br><span class=\"line\">            \tres += temp;</span><br><span class=\"line\">            temp = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// charar</span></span><br><span class=\"line\">            temp.push_back(s[i]);</span><br><span class=\"line\">            num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果这道题不需要考虑嵌套问题的话，上面就是正确的答案了。虽然需要处理嵌套的问题，但是其实只需要用栈来模拟多个层次的嵌套即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">decodeString</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">string</span>&gt; sst;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; nst;</span><br><span class=\"line\">    nst.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    sst.push(<span class=\"built_in\">string</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = s.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(s[i])) &#123;</span><br><span class=\"line\">            num = num * <span class=\"number\">10</span> + s[i] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">            beg = end = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            nst.push(num); num = <span class=\"number\">0</span>;</span><br><span class=\"line\">            sst.push(<span class=\"built_in\">string</span>());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> s = sst.top(); sst.pop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = nst.top(); nst.pop();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n;j++) sst.top() += s;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// char</span></span><br><span class=\"line\">            sst.top().push_back(s[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sst.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>update at 2020-04-04</p>\n</blockquote>\n<p>似乎最上面那个代码是有问题的，emmm，不管了，更新一个用一个<code>stack</code>的版本：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">decodeString1</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"built_in\">string</span>&gt;&gt; st;</span><br><span class=\"line\">    st.push(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c: s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(c)) &#123;</span><br><span class=\"line\">            num  = num * <span class=\"number\">10</span> + c - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">            st.push(<span class=\"built_in\">make_pair</span>(num, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">            num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> p = st.top(); st.pop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n  = p.first;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> s = p.second;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; n &lt;&lt; s &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) st.top().second += s;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            st.top().second.push_back(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.top().second;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第四天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/decode-string/\">Decode String</a>：</p>\n<hr>\n<p>Given an encoded string, return its decoded string.</p>\n<p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p>\n<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\n<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p>\n<p><strong>Examples:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s &#x3D; &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</span><br><span class=\"line\">s &#x3D; &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</span><br><span class=\"line\">s &#x3D; &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>比较简单的一道题，先分析一下题目，首先输入的格式是<code>k[encoded_string]</code>，要将其扩展成k 个 encoded_string 组成的字符串，我们暂且先不考虑嵌套的情况，我们通过一个简单的状态机就可以解决这个问题：</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/20191108204429.png\" alt=\"有限状态机\"></p>\n<p>这个代码写起来也很简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">decodeString</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = s.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(s[i])) &#123;</span><br><span class=\"line\">            num = num * <span class=\"number\">10</span> + s[i] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">            res += temp;</span><br><span class=\"line\">           \ttemp = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; num;i++)</span><br><span class=\"line\">            \tres += temp;</span><br><span class=\"line\">            temp = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// charar</span></span><br><span class=\"line\">            temp.push_back(s[i]);</span><br><span class=\"line\">            num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果这道题不需要考虑嵌套问题的话，上面就是正确的答案了。虽然需要处理嵌套的问题，但是其实只需要用栈来模拟多个层次的嵌套即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">decodeString</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">string</span>&gt; sst;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; nst;</span><br><span class=\"line\">    nst.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    sst.push(<span class=\"built_in\">string</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = s.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(s[i])) &#123;</span><br><span class=\"line\">            num = num * <span class=\"number\">10</span> + s[i] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">            beg = end = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            nst.push(num); num = <span class=\"number\">0</span>;</span><br><span class=\"line\">            sst.push(<span class=\"built_in\">string</span>());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> s = sst.top(); sst.pop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = nst.top(); nst.pop();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n;j++) sst.top() += s;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// char</span></span><br><span class=\"line\">            sst.top().push_back(s[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sst.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>update at 2020-04-04</p>\n</blockquote>\n<p>似乎最上面那个代码是有问题的，emmm，不管了，更新一个用一个<code>stack</code>的版本：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">decodeString1</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"built_in\">string</span>&gt;&gt; st;</span><br><span class=\"line\">    st.push(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c: s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(c)) &#123;</span><br><span class=\"line\">            num  = num * <span class=\"number\">10</span> + c - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">            st.push(<span class=\"built_in\">make_pair</span>(num, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">            num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> p = st.top(); st.pop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n  = p.first;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> s = p.second;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; n &lt;&lt; s &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) st.top().second += s;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            st.top().second.push_back(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.top().second;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Deepest Leaves Sum","date":"2020-01-31T09:08:45.000Z","_content":"\n> 第62天。\n\n今天的题目是[Deepest Leaves Sum](https://leetcode.com/problems/deepest-leaves-sum/):\n\n比较简单的题目，只要用层次遍历即可，计算每一层的和，然后把最后一层返回即可。也可以用后序遍历来完成，不过要维护每个子树的高度。\n\n```c++\nint deepestLeavesSum(TreeNode* root) {\n\tif (root == nullptr) return 0;\n\tqueue<TreeNode *> q;\n\tq.push(root);\n\tint sum = 0;\n\twhile(!q.empty()) {\n\t\tsum = 0;\n\t\tfor(int i = 0, size = q.size(); i < size; i++) {\n\t\t\troot = q.front(); q.pop();\n\t\t\tsum += root->val;\n\t\t\tif (root->left) q.push(root->left);\n\t\t\tif (root->right) q.push(root->right);\n\t\t}\n\t}\n\treturn sum;\n}\n```\n","source":"_posts/Deepest-Leaves-Sum.md","raw":"---\ntitle: Deepest Leaves Sum\ndate: 2020-01-31T17:08:45.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第62天。\n\n今天的题目是[Deepest Leaves Sum](https://leetcode.com/problems/deepest-leaves-sum/):\n\n比较简单的题目，只要用层次遍历即可，计算每一层的和，然后把最后一层返回即可。也可以用后序遍历来完成，不过要维护每个子树的高度。\n\n```c++\nint deepestLeavesSum(TreeNode* root) {\n\tif (root == nullptr) return 0;\n\tqueue<TreeNode *> q;\n\tq.push(root);\n\tint sum = 0;\n\twhile(!q.empty()) {\n\t\tsum = 0;\n\t\tfor(int i = 0, size = q.size(); i < size; i++) {\n\t\t\troot = q.front(); q.pop();\n\t\t\tsum += root->val;\n\t\t\tif (root->left) q.push(root->left);\n\t\t\tif (root->right) q.push(root->right);\n\t\t}\n\t}\n\treturn sum;\n}\n```\n","slug":"Deepest-Leaves-Sum","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nj003mqmcmdhfp9edi","content":"<blockquote>\n<p>第62天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/deepest-leaves-sum/\">Deepest Leaves Sum</a>:</p>\n<p>比较简单的题目，只要用层次遍历即可，计算每一层的和，然后把最后一层返回即可。也可以用后序遍历来完成，不过要维护每个子树的高度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deepestLeavesSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">\tq.push(root);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">\t\tsum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = q.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\t\troot = q.front(); q.pop();</span><br><span class=\"line\">\t\t\tsum += root-&gt;val;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第62天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/deepest-leaves-sum/\">Deepest Leaves Sum</a>:</p>\n<p>比较简单的题目，只要用层次遍历即可，计算每一层的和，然后把最后一层返回即可。也可以用后序遍历来完成，不过要维护每个子树的高度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deepestLeavesSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">\tq.push(root);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">\t\tsum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = q.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\t\troot = q.front(); q.pop();</span><br><span class=\"line\">\t\t\tsum += root-&gt;val;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Delete Leaves With a Given Value Medium","date":"2020-02-02T07:03:20.000Z","_content":"\n> 第63天。\n\n水题。\n\n今天的题目是[Delete Leaves With a Given Value Medium](https://leetcode.com/problems/delete-leaves-with-a-given-value/):\n\n太水了，不解释了。\n\n```c++\nTreeNode* removeLeafNodes(TreeNode* root, int target) {\n\tif (root == nullptr) return nullptr;\n\troot->left = removeLeafNodes(root->left, target);\n\troot->right = removeLeafNodes(root->right, target);\n\tif (!root->left && !root->right && target == root->val)\n\t\treturn nullptr;\n\telse \n\t\treturn root;\n}\n```\n","source":"_posts/Delete-Leaves-With-a-Given-ValueMedium.md","raw":"---\ntitle: Delete Leaves With a Given Value Medium\ndate: 2020-02-02T15:03:20.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第63天。\n\n水题。\n\n今天的题目是[Delete Leaves With a Given Value Medium](https://leetcode.com/problems/delete-leaves-with-a-given-value/):\n\n太水了，不解释了。\n\n```c++\nTreeNode* removeLeafNodes(TreeNode* root, int target) {\n\tif (root == nullptr) return nullptr;\n\troot->left = removeLeafNodes(root->left, target);\n\troot->right = removeLeafNodes(root->right, target);\n\tif (!root->left && !root->right && target == root->val)\n\t\treturn nullptr;\n\telse \n\t\treturn root;\n}\n```\n","slug":"Delete-Leaves-With-a-Given-ValueMedium","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nk003pqmcmg6at2ijo","content":"<blockquote>\n<p>第63天。</p>\n</blockquote>\n<p>水题。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/delete-leaves-with-a-given-value/\">Delete Leaves With a Given Value Medium</a>:</p>\n<p>太水了，不解释了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">removeLeafNodes</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\troot-&gt;left = removeLeafNodes(root-&gt;left, target);</span><br><span class=\"line\">\troot-&gt;right = removeLeafNodes(root-&gt;right, target);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == root-&gt;val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第63天。</p>\n</blockquote>\n<p>水题。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/delete-leaves-with-a-given-value/\">Delete Leaves With a Given Value Medium</a>:</p>\n<p>太水了，不解释了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">removeLeafNodes</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\troot-&gt;left = removeLeafNodes(root-&gt;left, target);</span><br><span class=\"line\">\troot-&gt;right = removeLeafNodes(root-&gt;right, target);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == root-&gt;val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Delete Node in a BST","date":"2019-11-28T02:06:14.000Z","_content":"\n> 第24天。\n\n今天的题目是[ Delete Node in a BST ]( https://leetcode.com/problems/delete-node-in-a-bst/ ):\n\n---\n\nGiven a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n\nBasically, the deletion can be divided into two stages:\n\n1. Search for a node to remove.\n2. If the node is found, delete the node.\n\n\n\n**Note:** Time complexity should be O(height of tree).\n\n**Example:**\n\n```\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n```\n\n---\n\n水题，只要先在`BST`上做搜索，然后删除就好了，因为只是`BST`，所以可以不考虑平衡的问题：\n\n- `left`和`right`都为空：直接删除，返回`nullptr`即可\n- `left`和`right`都不为空：默认采用把右子树的节点拉上来的方式，即把左子树插入到右子树中，然后再返回`right`即可。\n- `left`和`right`有一个不为空，则返回不为空的子树即可。\n\n则代码如下：\n\n```c++\n    TreeNode* deleteNode(TreeNode *node) {\n        auto left = node->left, right = node->right;\n        delete node;\n        if (left && right) {\n            auto temp = right;\n            while(temp->left) {\n                temp = temp->left;\n            }\n            temp->left = left;\n            return right;\n        } \n        return (left ? left : (right ? right : nullptr));\n    }\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (root == nullptr) return nullptr;\n        else if (root->val == key) {\n            return deleteNode(root);\n        } else if (key >  root->val) {\n            root->right = deleteNode(root->right, key);    \n        } else \n            root->left = deleteNode(root->left, key);\n        \n        return root;\n    }\n```\n\n","source":"_posts/Delete-Node-in-a-BST.md","raw":"---\ntitle: Delete Node in a BST\ndate: 2019-11-28T10:06:14.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第24天。\n\n今天的题目是[ Delete Node in a BST ]( https://leetcode.com/problems/delete-node-in-a-bst/ ):\n\n---\n\nGiven a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n\nBasically, the deletion can be divided into two stages:\n\n1. Search for a node to remove.\n2. If the node is found, delete the node.\n\n\n\n**Note:** Time complexity should be O(height of tree).\n\n**Example:**\n\n```\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n```\n\n---\n\n水题，只要先在`BST`上做搜索，然后删除就好了，因为只是`BST`，所以可以不考虑平衡的问题：\n\n- `left`和`right`都为空：直接删除，返回`nullptr`即可\n- `left`和`right`都不为空：默认采用把右子树的节点拉上来的方式，即把左子树插入到右子树中，然后再返回`right`即可。\n- `left`和`right`有一个不为空，则返回不为空的子树即可。\n\n则代码如下：\n\n```c++\n    TreeNode* deleteNode(TreeNode *node) {\n        auto left = node->left, right = node->right;\n        delete node;\n        if (left && right) {\n            auto temp = right;\n            while(temp->left) {\n                temp = temp->left;\n            }\n            temp->left = left;\n            return right;\n        } \n        return (left ? left : (right ? right : nullptr));\n    }\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (root == nullptr) return nullptr;\n        else if (root->val == key) {\n            return deleteNode(root);\n        } else if (key >  root->val) {\n            root->right = deleteNode(root->right, key);    \n        } else \n            root->left = deleteNode(root->left, key);\n        \n        return root;\n    }\n```\n\n","slug":"Delete-Node-in-a-BST","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nl003tqmcmaf6p8zmo","content":"<blockquote>\n<p>第24天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/delete-node-in-a-bst/\"> Delete Node in a BST </a>:</p>\n<hr>\n<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>\n<p>Basically, the deletion can be divided into two stages:</p>\n<ol>\n<li>Search for a node to remove.</li>\n<li>If the node is found, delete the node.</li>\n</ol>\n<p><strong>Note:</strong> Time complexity should be O(height of tree).</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root &#x3D; [5,3,6,2,4,null,7]</span><br><span class=\"line\">key &#x3D; 3</span><br><span class=\"line\"></span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  3   6</span><br><span class=\"line\"> &#x2F; \\   \\</span><br><span class=\"line\">2   4   7</span><br><span class=\"line\"></span><br><span class=\"line\">Given key to delete is 3. So we find the node with value 3 and delete it.</span><br><span class=\"line\"></span><br><span class=\"line\">One valid answer is [5,4,6,2,null,null,7], shown in the following BST.</span><br><span class=\"line\"></span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  4   6</span><br><span class=\"line\"> &#x2F;     \\</span><br><span class=\"line\">2       7</span><br><span class=\"line\"></span><br><span class=\"line\">Another valid answer is [5,2,6,null,4,null,7].</span><br><span class=\"line\"></span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  2   6</span><br><span class=\"line\">   \\   \\</span><br><span class=\"line\">    4   7</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>水题，只要先在<code>BST</code>上做搜索，然后删除就好了，因为只是<code>BST</code>，所以可以不考虑平衡的问题：</p>\n<ul>\n<li><code>left</code>和<code>right</code>都为空：直接删除，返回<code>nullptr</code>即可</li>\n<li><code>left</code>和<code>right</code>都不为空：默认采用把右子树的节点拉上来的方式，即把左子树插入到右子树中，然后再返回<code>right</code>即可。</li>\n<li><code>left</code>和<code>right</code>有一个不为空，则返回不为空的子树即可。</li>\n</ul>\n<p>则代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">deleteNode</span><span class=\"params\">(TreeNode *node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = node-&gt;left, right = node-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> node;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &amp;&amp; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> temp = right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(temp-&gt;left) &#123;</span><br><span class=\"line\">            temp = temp-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp-&gt;left = left;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (left ? left : (right ? right : <span class=\"literal\">nullptr</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">deleteNode</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val == key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> deleteNode(root);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt;  root-&gt;val) &#123;</span><br><span class=\"line\">        root-&gt;right = deleteNode(root-&gt;right, key);    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> </span><br><span class=\"line\">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第24天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/delete-node-in-a-bst/\"> Delete Node in a BST </a>:</p>\n<hr>\n<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>\n<p>Basically, the deletion can be divided into two stages:</p>\n<ol>\n<li>Search for a node to remove.</li>\n<li>If the node is found, delete the node.</li>\n</ol>\n<p><strong>Note:</strong> Time complexity should be O(height of tree).</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root &#x3D; [5,3,6,2,4,null,7]</span><br><span class=\"line\">key &#x3D; 3</span><br><span class=\"line\"></span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  3   6</span><br><span class=\"line\"> &#x2F; \\   \\</span><br><span class=\"line\">2   4   7</span><br><span class=\"line\"></span><br><span class=\"line\">Given key to delete is 3. So we find the node with value 3 and delete it.</span><br><span class=\"line\"></span><br><span class=\"line\">One valid answer is [5,4,6,2,null,null,7], shown in the following BST.</span><br><span class=\"line\"></span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  4   6</span><br><span class=\"line\"> &#x2F;     \\</span><br><span class=\"line\">2       7</span><br><span class=\"line\"></span><br><span class=\"line\">Another valid answer is [5,2,6,null,4,null,7].</span><br><span class=\"line\"></span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  2   6</span><br><span class=\"line\">   \\   \\</span><br><span class=\"line\">    4   7</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>水题，只要先在<code>BST</code>上做搜索，然后删除就好了，因为只是<code>BST</code>，所以可以不考虑平衡的问题：</p>\n<ul>\n<li><code>left</code>和<code>right</code>都为空：直接删除，返回<code>nullptr</code>即可</li>\n<li><code>left</code>和<code>right</code>都不为空：默认采用把右子树的节点拉上来的方式，即把左子树插入到右子树中，然后再返回<code>right</code>即可。</li>\n<li><code>left</code>和<code>right</code>有一个不为空，则返回不为空的子树即可。</li>\n</ul>\n<p>则代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">deleteNode</span><span class=\"params\">(TreeNode *node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = node-&gt;left, right = node-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> node;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &amp;&amp; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> temp = right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(temp-&gt;left) &#123;</span><br><span class=\"line\">            temp = temp-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp-&gt;left = left;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (left ? left : (right ? right : <span class=\"literal\">nullptr</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">deleteNode</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val == key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> deleteNode(root);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt;  root-&gt;val) &#123;</span><br><span class=\"line\">        root-&gt;right = deleteNode(root-&gt;right, key);    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> </span><br><span class=\"line\">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Delete Nodes And Return Forest","date":"2019-11-18T02:07:28.000Z","_content":"\n> 第14天。\n\n今天的题目是[Delete Nodes And Return Forest](https://leetcode.com/problems/delete-nodes-and-return-forest/)：\n\n---\n\nGiven the `root` of a binary tree, each node in the tree has a distinct value.\n\nAfter deleting all nodes with a value in `to_delete`, we are left with a forest (a disjoint union of trees).\n\nReturn the roots of the trees in the remaining forest. You may return the result in any order.\n\n \n\n**Example 1:**\n\n**![img](https://assets.leetcode.com/uploads/2019/07/01/screen-shot-2019-07-01-at-53836-pm.png)**\n\n```\nInput: root = [1,2,3,4,5,6,7], to_delete = [3,5]\nOutput: [[1,2,null,4],[6],[7]]\n```\n\n \n\n**Constraints:**\n\n- The number of nodes in the given tree is at most `1000`.\n- Each node has a distinct value between `1` and `1000`.\n- `to_delete.length <= 1000`\n- `to_delete` contains distinct values between `1` and `1000`.\n\n---\n\n这道题的题意很简单，就是要通过删节点来把分割树，关键的问题是，删除一个节点既需要对子节点进行处理，还要在父节点中删除对应的指针，为了方便，我们这里采用后续遍历的方法来实现：\n\n先递归调用函数，使得子树中的节点已经完成遍历和删除，然后通过返回值来判断该子节点是否需要删除，如果需要删除，则将对于的指针置空。然后在判断当前节点是否需要删除，就将非空的子节点插入到返回数组中（全局变量）。\n\n还有一点就是，因为节点的值在`1-1000`间，所以我们可以用一个长度为1000的数组来加快对要删除节点的判断。\n\n代码如下：\n\n```c++\nvector<TreeNode *> res;\nvector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\n    if (root == nullptr) return res;\n\n    vector<bool> delmap(1001, false);\n    for(int i = 0;i < to_delete.size(); i++) {\n        delmap[to_delete[i]] = true;\n    }\n\n    if (!toDelNodes(root, delmap)) {\n        res.push_back(root);\n    }\n\n    return res;\n}\n\nbool toDelNodes(TreeNode *root, vector<bool>& delmap) {\n    if (root == nullptr) return false;\n\n    if (toDelNodes(root->left, delmap)) {\n        root->left = nullptr;\n    }\n    if (toDelNodes(root->right, delmap)) {\n        root->right = nullptr;\n    }\n\n    if (delmap[root->val]) {\n        if (root->left) res.push_back(root->left);\n        if (root->right) res.push_back(root->right);\n        return true;\n    }\n    return false;        \n}\n```\n\n","source":"_posts/Delete-Nodes-And-Return-Forest.md","raw":"---\ntitle: Delete Nodes And Return Forest\ndate: 2019-11-18T10:07:28.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第14天。\n\n今天的题目是[Delete Nodes And Return Forest](https://leetcode.com/problems/delete-nodes-and-return-forest/)：\n\n---\n\nGiven the `root` of a binary tree, each node in the tree has a distinct value.\n\nAfter deleting all nodes with a value in `to_delete`, we are left with a forest (a disjoint union of trees).\n\nReturn the roots of the trees in the remaining forest. You may return the result in any order.\n\n \n\n**Example 1:**\n\n**![img](https://assets.leetcode.com/uploads/2019/07/01/screen-shot-2019-07-01-at-53836-pm.png)**\n\n```\nInput: root = [1,2,3,4,5,6,7], to_delete = [3,5]\nOutput: [[1,2,null,4],[6],[7]]\n```\n\n \n\n**Constraints:**\n\n- The number of nodes in the given tree is at most `1000`.\n- Each node has a distinct value between `1` and `1000`.\n- `to_delete.length <= 1000`\n- `to_delete` contains distinct values between `1` and `1000`.\n\n---\n\n这道题的题意很简单，就是要通过删节点来把分割树，关键的问题是，删除一个节点既需要对子节点进行处理，还要在父节点中删除对应的指针，为了方便，我们这里采用后续遍历的方法来实现：\n\n先递归调用函数，使得子树中的节点已经完成遍历和删除，然后通过返回值来判断该子节点是否需要删除，如果需要删除，则将对于的指针置空。然后在判断当前节点是否需要删除，就将非空的子节点插入到返回数组中（全局变量）。\n\n还有一点就是，因为节点的值在`1-1000`间，所以我们可以用一个长度为1000的数组来加快对要删除节点的判断。\n\n代码如下：\n\n```c++\nvector<TreeNode *> res;\nvector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\n    if (root == nullptr) return res;\n\n    vector<bool> delmap(1001, false);\n    for(int i = 0;i < to_delete.size(); i++) {\n        delmap[to_delete[i]] = true;\n    }\n\n    if (!toDelNodes(root, delmap)) {\n        res.push_back(root);\n    }\n\n    return res;\n}\n\nbool toDelNodes(TreeNode *root, vector<bool>& delmap) {\n    if (root == nullptr) return false;\n\n    if (toDelNodes(root->left, delmap)) {\n        root->left = nullptr;\n    }\n    if (toDelNodes(root->right, delmap)) {\n        root->right = nullptr;\n    }\n\n    if (delmap[root->val]) {\n        if (root->left) res.push_back(root->left);\n        if (root->right) res.push_back(root->right);\n        return true;\n    }\n    return false;        \n}\n```\n\n","slug":"Delete-Nodes-And-Return-Forest","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nl003wqmcm2b7r5hmd","content":"<blockquote>\n<p>第14天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/delete-nodes-and-return-forest/\">Delete Nodes And Return Forest</a>：</p>\n<hr>\n<p>Given the <code>root</code> of a binary tree, each node in the tree has a distinct value.</p>\n<p>After deleting all nodes with a value in <code>to_delete</code>, we are left with a forest (a disjoint union of trees).</p>\n<p>Return the roots of the trees in the remaining forest. You may return the result in any order.</p>\n<p><strong>Example 1:</strong></p>\n<p><strong><img src=\"https://assets.leetcode.com/uploads/2019/07/01/screen-shot-2019-07-01-at-53836-pm.png\" alt=\"img\"></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,2,3,4,5,6,7], to_delete &#x3D; [3,5]</span><br><span class=\"line\">Output: [[1,2,null,4],[6],[7]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Constraints:</strong></p>\n<ul>\n<li>The number of nodes in the given tree is at most <code>1000</code>.</li>\n<li>Each node has a distinct value between <code>1</code> and <code>1000</code>.</li>\n<li><code>to_delete.length &lt;= 1000</code></li>\n<li><code>to_delete</code> contains distinct values between <code>1</code> and <code>1000</code>.</li>\n</ul>\n<hr>\n<p>这道题的题意很简单，就是要通过删节点来把分割树，关键的问题是，删除一个节点既需要对子节点进行处理，还要在父节点中删除对应的指针，为了方便，我们这里采用后续遍历的方法来实现：</p>\n<p>先递归调用函数，使得子树中的节点已经完成遍历和删除，然后通过返回值来判断该子节点是否需要删除，如果需要删除，则将对于的指针置空。然后在判断当前节点是否需要删除，就将非空的子节点插入到返回数组中（全局变量）。</p>\n<p>还有一点就是，因为节点的值在<code>1-1000</code>间，所以我们可以用一个长度为1000的数组来加快对要删除节点的判断。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;TreeNode *&gt; res;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">delNodes</span><span class=\"params\">(TreeNode* root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">delmap</span><span class=\"params\">(<span class=\"number\">1001</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; to_delete.size(); i++) &#123;</span><br><span class=\"line\">        delmap[to_delete[i]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!toDelNodes(root, delmap)) &#123;</span><br><span class=\"line\">        res.push_back(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">toDelNodes</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt;&amp; delmap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (toDelNodes(root-&gt;left, delmap)) &#123;</span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (toDelNodes(root-&gt;right, delmap)) &#123;</span><br><span class=\"line\">        root-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delmap[root-&gt;val]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) res.push_back(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) res.push_back(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第14天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/delete-nodes-and-return-forest/\">Delete Nodes And Return Forest</a>：</p>\n<hr>\n<p>Given the <code>root</code> of a binary tree, each node in the tree has a distinct value.</p>\n<p>After deleting all nodes with a value in <code>to_delete</code>, we are left with a forest (a disjoint union of trees).</p>\n<p>Return the roots of the trees in the remaining forest. You may return the result in any order.</p>\n<p><strong>Example 1:</strong></p>\n<p><strong><img src=\"https://assets.leetcode.com/uploads/2019/07/01/screen-shot-2019-07-01-at-53836-pm.png\" alt=\"img\"></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,2,3,4,5,6,7], to_delete &#x3D; [3,5]</span><br><span class=\"line\">Output: [[1,2,null,4],[6],[7]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Constraints:</strong></p>\n<ul>\n<li>The number of nodes in the given tree is at most <code>1000</code>.</li>\n<li>Each node has a distinct value between <code>1</code> and <code>1000</code>.</li>\n<li><code>to_delete.length &lt;= 1000</code></li>\n<li><code>to_delete</code> contains distinct values between <code>1</code> and <code>1000</code>.</li>\n</ul>\n<hr>\n<p>这道题的题意很简单，就是要通过删节点来把分割树，关键的问题是，删除一个节点既需要对子节点进行处理，还要在父节点中删除对应的指针，为了方便，我们这里采用后续遍历的方法来实现：</p>\n<p>先递归调用函数，使得子树中的节点已经完成遍历和删除，然后通过返回值来判断该子节点是否需要删除，如果需要删除，则将对于的指针置空。然后在判断当前节点是否需要删除，就将非空的子节点插入到返回数组中（全局变量）。</p>\n<p>还有一点就是，因为节点的值在<code>1-1000</code>间，所以我们可以用一个长度为1000的数组来加快对要删除节点的判断。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;TreeNode *&gt; res;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;TreeNode*&gt; <span class=\"title\">delNodes</span><span class=\"params\">(TreeNode* root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">delmap</span><span class=\"params\">(<span class=\"number\">1001</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; to_delete.size(); i++) &#123;</span><br><span class=\"line\">        delmap[to_delete[i]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!toDelNodes(root, delmap)) &#123;</span><br><span class=\"line\">        res.push_back(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">toDelNodes</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt;&amp; delmap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (toDelNodes(root-&gt;left, delmap)) &#123;</span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (toDelNodes(root-&gt;right, delmap)) &#123;</span><br><span class=\"line\">        root-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delmap[root-&gt;val]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) res.push_back(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) res.push_back(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Diagonal Traverse","date":"2019-11-16T02:16:52.000Z","_content":"\n> 第12天。\n\n今天的题目是[Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)：\n\n---\n\nGiven a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.\n\n \n\n**Example:**\n\n```\nInput:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\nOutput:  [1,2,4,7,5,3,6,8,9]\n\nExplanation:\n```\n\n ![](https://assets.leetcode.com/uploads/2018/10/12/diagonal_traverse.png)\n\n**Note:**\n\nThe total number of elements of the given matrix will not exceed 10,000.\n\n---\n\n这道题好像是之前没做出来的。\n\n题意很好理解，这道题的关键就在于如何处理在边界时的移动。\n\n首先，常规的移动就分为两种：\n\n- 向右上移动\n- 向左下移动\n\n实现常规移动，这里就不赘述了。\n\n然后就是在边界时如何移动了，经过观察移动的情况，我们可以总结出：\n\n- 边界时，只有向右移动和向下移动两种情况\n- 在向右上移动时遇到边界，优先向右移动\n- 在向左下移动时遇到边界，优先向左移动\n\n根据上面的结论，我们就可以写出代码了：\n\n```c++\nbool nextRightUp(int &i, int &j, int &m, int &n) {\n\n    if (i - 1 >= 0 && j + 1 < n) { // move right up\n        i--; j++; return true;\n    } else if (j + 1 < n) { // move right\n        j++; return false;\n    } else if (i  + 1 < m){ // move down\n        i++; return false;\n    }\n    return false; // mean in the last elem\n}\nbool nextLeftDown(int &i, int &j, int &m, int &n) {\n    if (i + 1 < m && j -1 >= 0) { // move right up\n        i++; j--; return true;\n    } else if (i + 1 < m) { // move down \n        i++; return false;\n    } else if (j + 1  < n) { // move right\n        j++; return false;\n    }\n    return false; \n}\nvector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\n    int m = matrix.size();\n    vector<int> res;\n    if (m == 0) return res;\n    int n = matrix[0].size();\n    int i = 0, j = 0;\n    bool up = true;\n\n    for(int k = 0;k < m*n;k++) {\n        res.push_back(matrix[i][j]);\n        if (up) {\n            up = nextRightUp(i, j, m, n);\n        } else {\n            up = !nextLeftDown(i, j, m, n);\n        }\n    }\n\n    return res;\n}\n```\n\n","source":"_posts/Diagonal-Traverse.md","raw":"---\ntitle: Diagonal Traverse\ndate: 2019-11-16T10:16:52.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第12天。\n\n今天的题目是[Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)：\n\n---\n\nGiven a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.\n\n \n\n**Example:**\n\n```\nInput:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\nOutput:  [1,2,4,7,5,3,6,8,9]\n\nExplanation:\n```\n\n ![](https://assets.leetcode.com/uploads/2018/10/12/diagonal_traverse.png)\n\n**Note:**\n\nThe total number of elements of the given matrix will not exceed 10,000.\n\n---\n\n这道题好像是之前没做出来的。\n\n题意很好理解，这道题的关键就在于如何处理在边界时的移动。\n\n首先，常规的移动就分为两种：\n\n- 向右上移动\n- 向左下移动\n\n实现常规移动，这里就不赘述了。\n\n然后就是在边界时如何移动了，经过观察移动的情况，我们可以总结出：\n\n- 边界时，只有向右移动和向下移动两种情况\n- 在向右上移动时遇到边界，优先向右移动\n- 在向左下移动时遇到边界，优先向左移动\n\n根据上面的结论，我们就可以写出代码了：\n\n```c++\nbool nextRightUp(int &i, int &j, int &m, int &n) {\n\n    if (i - 1 >= 0 && j + 1 < n) { // move right up\n        i--; j++; return true;\n    } else if (j + 1 < n) { // move right\n        j++; return false;\n    } else if (i  + 1 < m){ // move down\n        i++; return false;\n    }\n    return false; // mean in the last elem\n}\nbool nextLeftDown(int &i, int &j, int &m, int &n) {\n    if (i + 1 < m && j -1 >= 0) { // move right up\n        i++; j--; return true;\n    } else if (i + 1 < m) { // move down \n        i++; return false;\n    } else if (j + 1  < n) { // move right\n        j++; return false;\n    }\n    return false; \n}\nvector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\n    int m = matrix.size();\n    vector<int> res;\n    if (m == 0) return res;\n    int n = matrix[0].size();\n    int i = 0, j = 0;\n    bool up = true;\n\n    for(int k = 0;k < m*n;k++) {\n        res.push_back(matrix[i][j]);\n        if (up) {\n            up = nextRightUp(i, j, m, n);\n        } else {\n            up = !nextLeftDown(i, j, m, n);\n        }\n    }\n\n    return res;\n}\n```\n\n","slug":"Diagonal-Traverse","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nm003zqmcmdgf8ay6s","content":"<blockquote>\n<p>第12天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/diagonal-traverse/\">Diagonal Traverse</a>：</p>\n<hr>\n<p>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[</span><br><span class=\"line\"> [ 1, 2, 3 ],</span><br><span class=\"line\"> [ 4, 5, 6 ],</span><br><span class=\"line\"> [ 7, 8, 9 ]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">Output:  [1,2,4,7,5,3,6,8,9]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br></pre></td></tr></table></figure>\n\n<p> <img src=\"https://assets.leetcode.com/uploads/2018/10/12/diagonal_traverse.png\"></p>\n<p><strong>Note:</strong></p>\n<p>The total number of elements of the given matrix will not exceed 10,000.</p>\n<hr>\n<p>这道题好像是之前没做出来的。</p>\n<p>题意很好理解，这道题的关键就在于如何处理在边界时的移动。</p>\n<p>首先，常规的移动就分为两种：</p>\n<ul>\n<li>向右上移动</li>\n<li>向左下移动</li>\n</ul>\n<p>实现常规移动，这里就不赘述了。</p>\n<p>然后就是在边界时如何移动了，经过观察移动的情况，我们可以总结出：</p>\n<ul>\n<li>边界时，只有向右移动和向下移动两种情况</li>\n<li>在向右上移动时遇到边界，优先向右移动</li>\n<li>在向左下移动时遇到边界，优先向左移动</li>\n</ul>\n<p>根据上面的结论，我们就可以写出代码了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">nextRightUp</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;i, <span class=\"keyword\">int</span> &amp;j, <span class=\"keyword\">int</span> &amp;m, <span class=\"keyword\">int</span> &amp;n)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; j + <span class=\"number\">1</span> &lt; n) &#123; <span class=\"comment\">// move right up</span></span><br><span class=\"line\">        i--; j++; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n) &#123; <span class=\"comment\">// move right</span></span><br><span class=\"line\">        j++; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i  + <span class=\"number\">1</span> &lt; m)&#123; <span class=\"comment\">// move down</span></span><br><span class=\"line\">        i++; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// mean in the last elem</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">nextLeftDown</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;i, <span class=\"keyword\">int</span> &amp;j, <span class=\"keyword\">int</span> &amp;m, <span class=\"keyword\">int</span> &amp;n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m &amp;&amp; j <span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// move right up</span></span><br><span class=\"line\">        i++; j--; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m) &#123; <span class=\"comment\">// move down </span></span><br><span class=\"line\">        i++; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span>  &lt; n) &#123; <span class=\"comment\">// move right</span></span><br><span class=\"line\">        j++; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findDiagonalOrder</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = matrix.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = matrix[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> up = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;k &lt; m*n;k++) &#123;</span><br><span class=\"line\">        res.push_back(matrix[i][j]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (up) &#123;</span><br><span class=\"line\">            up = nextRightUp(i, j, m, n);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            up = !nextLeftDown(i, j, m, n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第12天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/diagonal-traverse/\">Diagonal Traverse</a>：</p>\n<hr>\n<p>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[</span><br><span class=\"line\"> [ 1, 2, 3 ],</span><br><span class=\"line\"> [ 4, 5, 6 ],</span><br><span class=\"line\"> [ 7, 8, 9 ]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">Output:  [1,2,4,7,5,3,6,8,9]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br></pre></td></tr></table></figure>\n\n<p> <img src=\"https://assets.leetcode.com/uploads/2018/10/12/diagonal_traverse.png\"></p>\n<p><strong>Note:</strong></p>\n<p>The total number of elements of the given matrix will not exceed 10,000.</p>\n<hr>\n<p>这道题好像是之前没做出来的。</p>\n<p>题意很好理解，这道题的关键就在于如何处理在边界时的移动。</p>\n<p>首先，常规的移动就分为两种：</p>\n<ul>\n<li>向右上移动</li>\n<li>向左下移动</li>\n</ul>\n<p>实现常规移动，这里就不赘述了。</p>\n<p>然后就是在边界时如何移动了，经过观察移动的情况，我们可以总结出：</p>\n<ul>\n<li>边界时，只有向右移动和向下移动两种情况</li>\n<li>在向右上移动时遇到边界，优先向右移动</li>\n<li>在向左下移动时遇到边界，优先向左移动</li>\n</ul>\n<p>根据上面的结论，我们就可以写出代码了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">nextRightUp</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;i, <span class=\"keyword\">int</span> &amp;j, <span class=\"keyword\">int</span> &amp;m, <span class=\"keyword\">int</span> &amp;n)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; j + <span class=\"number\">1</span> &lt; n) &#123; <span class=\"comment\">// move right up</span></span><br><span class=\"line\">        i--; j++; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n) &#123; <span class=\"comment\">// move right</span></span><br><span class=\"line\">        j++; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i  + <span class=\"number\">1</span> &lt; m)&#123; <span class=\"comment\">// move down</span></span><br><span class=\"line\">        i++; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// mean in the last elem</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">nextLeftDown</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;i, <span class=\"keyword\">int</span> &amp;j, <span class=\"keyword\">int</span> &amp;m, <span class=\"keyword\">int</span> &amp;n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m &amp;&amp; j <span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// move right up</span></span><br><span class=\"line\">        i++; j--; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m) &#123; <span class=\"comment\">// move down </span></span><br><span class=\"line\">        i++; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span>  &lt; n) &#123; <span class=\"comment\">// move right</span></span><br><span class=\"line\">        j++; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findDiagonalOrder</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = matrix.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = matrix[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> up = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;k &lt; m*n;k++) &#123;</span><br><span class=\"line\">        res.push_back(matrix[i][j]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (up) &#123;</span><br><span class=\"line\">            up = nextRightUp(i, j, m, n);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            up = !nextLeftDown(i, j, m, n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Diameter of Binary Tree","date":"2017-11-24T00:58:25.000Z","_content":"\n第58天。\n\n今天的题目是[Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/description/):\n\n> Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n>\n> Example:\n> Given a binary tree \n\n          1\n         / \\\n        2   3\n       / \\\n      4   5\n\n> Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n>\n> Note: The length of path between two nodes is represented by the number of edges between them.\n\n很显然，题目已经给出提示了,这个path要么经过`root`要么不经过`root`.\n\n如果经过`root`,那么就是左子树和右子树的高度之和加上2.\n如果不经过`root`,就是左子树的`diameter`或者是右子树的`diameter`.\n\n那么如何分辨是否经过`root`呢？\n\n其实也很简单，反正就要求最大的嘛，我们就把两种情况都算一遍，然后求个`max`即可。大概可以写出一下递推式：\n\n```c++\nleftH = heightOfHeight(root->left)\nrightH = heightOrHeight(root->right)\nd = diameterOfBinaryTree(root->left) + diameterOfBinaryTree(root->right)\nreturn max(d,leftH+rightH+2)\n```\n\n然后我们发现求高度也是类似的需要递归的方式，所以我们可以将他们合并起来：\n\n```c++\nint diameterOfBinaryTree(TreeNode* root) {\n    int h;\n    return diameterOfBinaryTree(root,h);\n}\nint diameterOfBinaryTree(TreeNode *root,int &height) {\n    if (root == nullptr) {\n        height = -1;\n        return 0;\n    }\n    int leftH,rightH;\n    int leftD = diameterOfBinaryTree(root->left,leftH);\n    int rightD = diameterOfBinaryTree(root->right,rightH);\n\n    height = max(leftH,rightH) + 1;\n    return max(leftH + rightH + 2,max(leftD,rightD) );\n}\n```\n","source":"_posts/Diameter-of-Binary-Tree.md","raw":"---\ntitle: Diameter of Binary Tree\ndate: 2017-11-24T08:58:25.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第58天。\n\n今天的题目是[Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/description/):\n\n> Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n>\n> Example:\n> Given a binary tree \n\n          1\n         / \\\n        2   3\n       / \\\n      4   5\n\n> Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n>\n> Note: The length of path between two nodes is represented by the number of edges between them.\n\n很显然，题目已经给出提示了,这个path要么经过`root`要么不经过`root`.\n\n如果经过`root`,那么就是左子树和右子树的高度之和加上2.\n如果不经过`root`,就是左子树的`diameter`或者是右子树的`diameter`.\n\n那么如何分辨是否经过`root`呢？\n\n其实也很简单，反正就要求最大的嘛，我们就把两种情况都算一遍，然后求个`max`即可。大概可以写出一下递推式：\n\n```c++\nleftH = heightOfHeight(root->left)\nrightH = heightOrHeight(root->right)\nd = diameterOfBinaryTree(root->left) + diameterOfBinaryTree(root->right)\nreturn max(d,leftH+rightH+2)\n```\n\n然后我们发现求高度也是类似的需要递归的方式，所以我们可以将他们合并起来：\n\n```c++\nint diameterOfBinaryTree(TreeNode* root) {\n    int h;\n    return diameterOfBinaryTree(root,h);\n}\nint diameterOfBinaryTree(TreeNode *root,int &height) {\n    if (root == nullptr) {\n        height = -1;\n        return 0;\n    }\n    int leftH,rightH;\n    int leftD = diameterOfBinaryTree(root->left,leftH);\n    int rightD = diameterOfBinaryTree(root->right,rightH);\n\n    height = max(leftH,rightH) + 1;\n    return max(leftH + rightH + 2,max(leftD,rightD) );\n}\n```\n","slug":"Diameter-of-Binary-Tree","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nn0042qmcm1wrx6c2p","content":"<p>第58天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/diameter-of-binary-tree/description/\">Diameter of Binary Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>\n<p>Example:<br>Given a binary tree </p>\n</blockquote>\n<pre><code>      1\n     / \\\n    2   3\n   / \\\n  4   5\n</code></pre>\n<blockquote>\n<p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>\n<p>Note: The length of path between two nodes is represented by the number of edges between them.</p>\n</blockquote>\n<p>很显然，题目已经给出提示了,这个path要么经过<code>root</code>要么不经过<code>root</code>.</p>\n<p>如果经过<code>root</code>,那么就是左子树和右子树的高度之和加上2.<br>如果不经过<code>root</code>,就是左子树的<code>diameter</code>或者是右子树的<code>diameter</code>.</p>\n<p>那么如何分辨是否经过<code>root</code>呢？</p>\n<p>其实也很简单，反正就要求最大的嘛，我们就把两种情况都算一遍，然后求个<code>max</code>即可。大概可以写出一下递推式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">leftH = heightOfHeight(root-&gt;left)</span><br><span class=\"line\">rightH = heightOrHeight(root-&gt;right)</span><br><span class=\"line\">d = diameterOfBinaryTree(root-&gt;left) + diameterOfBinaryTree(root-&gt;right)</span><br><span class=\"line\"><span class=\"keyword\">return</span> max(d,leftH+rightH+<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>然后我们发现求高度也是类似的需要递归的方式，所以我们可以将他们合并起来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> diameterOfBinaryTree(root,h);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> &amp;height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        height = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftH,rightH;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftD = diameterOfBinaryTree(root-&gt;left,leftH);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rightD = diameterOfBinaryTree(root-&gt;right,rightH);</span><br><span class=\"line\"></span><br><span class=\"line\">    height = max(leftH,rightH) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(leftH + rightH + <span class=\"number\">2</span>,max(leftD,rightD) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第58天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/diameter-of-binary-tree/description/\">Diameter of Binary Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>\n<p>Example:<br>Given a binary tree </p>\n</blockquote>\n<pre><code>      1\n     / \\\n    2   3\n   / \\\n  4   5\n</code></pre>\n<blockquote>\n<p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>\n<p>Note: The length of path between two nodes is represented by the number of edges between them.</p>\n</blockquote>\n<p>很显然，题目已经给出提示了,这个path要么经过<code>root</code>要么不经过<code>root</code>.</p>\n<p>如果经过<code>root</code>,那么就是左子树和右子树的高度之和加上2.<br>如果不经过<code>root</code>,就是左子树的<code>diameter</code>或者是右子树的<code>diameter</code>.</p>\n<p>那么如何分辨是否经过<code>root</code>呢？</p>\n<p>其实也很简单，反正就要求最大的嘛，我们就把两种情况都算一遍，然后求个<code>max</code>即可。大概可以写出一下递推式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">leftH = heightOfHeight(root-&gt;left)</span><br><span class=\"line\">rightH = heightOrHeight(root-&gt;right)</span><br><span class=\"line\">d = diameterOfBinaryTree(root-&gt;left) + diameterOfBinaryTree(root-&gt;right)</span><br><span class=\"line\"><span class=\"keyword\">return</span> max(d,leftH+rightH+<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>然后我们发现求高度也是类似的需要递归的方式，所以我们可以将他们合并起来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> diameterOfBinaryTree(root,h);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> &amp;height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        height = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftH,rightH;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftD = diameterOfBinaryTree(root-&gt;left,leftH);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rightD = diameterOfBinaryTree(root-&gt;right,rightH);</span><br><span class=\"line\"></span><br><span class=\"line\">    height = max(leftH,rightH) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(leftH + rightH + <span class=\"number\">2</span>,max(leftD,rightD) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Evaluate Division","date":"2020-01-13T07:33:54.000Z","_content":"\n> 第59天，有好几天没做了，太咸鱼了我。\n\n今天的题目是[Evaluate Division](https://leetcode.com/problems/evaluate-division/):\n\n一道写起来比较麻烦，但是总体来看还是比较简单的。就是分为两步走即可：\n\n1. 利用`equations`和`value`构造一个图\n2. 然后通过在图上遍历的方式计算得到`queries`的值。\n\n```c++\nvector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n    vector<double> res(queries.size());\n    \n    // calc elem set\n    unordered_map<string, int> smap;\n    int index = 0;\n    for(auto &vec: equations) {\n        auto it = smap.find(vec[0]);\n        if (it == smap.end()) smap[vec[0]] = index++;\n        it = smap.find(vec[1]);\n        if (it == smap.end()) smap[vec[1]] = index++;\n    }\n    \n    // for(auto p: smap) cout << p.second << endl;\n    \n    // build graph\n    vector<vector<double>> graph(index, vector<double>(index, -1.0));\n    for(int k = 0, size = equations.size(); k < size; k++) {\n        int i = smap[equations[k][0]], j = smap[equations[k][1]];\n        graph[i][j] = values[k];\n        graph[j][i] = 1 / values[k];\n    }\n\n    for(int k = 0, size = queries.size(); k < size; k++) {\n        auto it1 = smap.find(queries[k][0]);\n        auto it2 = smap.find(queries[k][1]);\n        if (it1 == smap.end() || it2 == smap.end()) {\n            res[k] = -1.0;\n            continue;\n        }\n            \n        if (queries[k][0] == queries[k][1]) {\n            res[k] = 1.0;\n            continue;\n        }\n        \n        int i = it1->second, j = it2->second;\n        vector<bool> visited(index, false);\n        if (dfs(graph, visited,i, j, res[k]) == false) {\n            res[k] = -1.0;\n        }\n    }\n    return res;\n}\n\nbool dfs(vector<vector<double>> &graph, vector<bool> &visited, int s, int e, double &res) {\n    if (s == e) { res = 1.0; return true; }\n    visited[s] = true;\n    for(int i = 0;i < graph.size(); i++) {\n        double temp;\n        if (visited[i] == false && graph[s][i] > 0 && dfs(graph, visited, i, e, temp)) {\n            res = temp * graph[s][i];\n            return true;\n        }\n    }\n    return false;\n}\n```\n","source":"_posts/Evaluate-Division.md","raw":"---\ntitle: Evaluate Division\ndate: 2020-01-13T15:33:54.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第59天，有好几天没做了，太咸鱼了我。\n\n今天的题目是[Evaluate Division](https://leetcode.com/problems/evaluate-division/):\n\n一道写起来比较麻烦，但是总体来看还是比较简单的。就是分为两步走即可：\n\n1. 利用`equations`和`value`构造一个图\n2. 然后通过在图上遍历的方式计算得到`queries`的值。\n\n```c++\nvector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n    vector<double> res(queries.size());\n    \n    // calc elem set\n    unordered_map<string, int> smap;\n    int index = 0;\n    for(auto &vec: equations) {\n        auto it = smap.find(vec[0]);\n        if (it == smap.end()) smap[vec[0]] = index++;\n        it = smap.find(vec[1]);\n        if (it == smap.end()) smap[vec[1]] = index++;\n    }\n    \n    // for(auto p: smap) cout << p.second << endl;\n    \n    // build graph\n    vector<vector<double>> graph(index, vector<double>(index, -1.0));\n    for(int k = 0, size = equations.size(); k < size; k++) {\n        int i = smap[equations[k][0]], j = smap[equations[k][1]];\n        graph[i][j] = values[k];\n        graph[j][i] = 1 / values[k];\n    }\n\n    for(int k = 0, size = queries.size(); k < size; k++) {\n        auto it1 = smap.find(queries[k][0]);\n        auto it2 = smap.find(queries[k][1]);\n        if (it1 == smap.end() || it2 == smap.end()) {\n            res[k] = -1.0;\n            continue;\n        }\n            \n        if (queries[k][0] == queries[k][1]) {\n            res[k] = 1.0;\n            continue;\n        }\n        \n        int i = it1->second, j = it2->second;\n        vector<bool> visited(index, false);\n        if (dfs(graph, visited,i, j, res[k]) == false) {\n            res[k] = -1.0;\n        }\n    }\n    return res;\n}\n\nbool dfs(vector<vector<double>> &graph, vector<bool> &visited, int s, int e, double &res) {\n    if (s == e) { res = 1.0; return true; }\n    visited[s] = true;\n    for(int i = 0;i < graph.size(); i++) {\n        double temp;\n        if (visited[i] == false && graph[s][i] > 0 && dfs(graph, visited, i, e, temp)) {\n            res = temp * graph[s][i];\n            return true;\n        }\n    }\n    return false;\n}\n```\n","slug":"Evaluate-Division","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nn0045qmcmgwd3e6nx","content":"<blockquote>\n<p>第59天，有好几天没做了，太咸鱼了我。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/evaluate-division/\">Evaluate Division</a>:</p>\n<p>一道写起来比较麻烦，但是总体来看还是比较简单的。就是分为两步走即可：</p>\n<ol>\n<li>利用<code>equations</code>和<code>value</code>构造一个图</li>\n<li>然后通过在图上遍历的方式计算得到<code>queries</code>的值。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">calcEquation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;&amp; equations, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;&amp; values, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">res</span><span class=\"params\">(queries.size())</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// calc elem set</span></span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt; smap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;vec: equations) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = smap.find(vec[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it == smap.end()) smap[vec[<span class=\"number\">0</span>]] = index++;</span><br><span class=\"line\">        it = smap.find(vec[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it == smap.end()) smap[vec[<span class=\"number\">1</span>]] = index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// for(auto p: smap) cout &lt;&lt; p.second &lt;&lt; endl;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// build graph</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;&gt; graph(index, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;(index, <span class=\"number\">-1.0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>, size = equations.size(); k &lt; size; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = smap[equations[k][<span class=\"number\">0</span>]], j = smap[equations[k][<span class=\"number\">1</span>]];</span><br><span class=\"line\">        graph[i][j] = values[k];</span><br><span class=\"line\">        graph[j][i] = <span class=\"number\">1</span> / values[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>, size = queries.size(); k &lt; size; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it1 = smap.find(queries[k][<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it2 = smap.find(queries[k][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it1 == smap.end() || it2 == smap.end()) &#123;</span><br><span class=\"line\">            res[k] = <span class=\"number\">-1.0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queries[k][<span class=\"number\">0</span>] == queries[k][<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            res[k] = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = it1-&gt;second, j = it2-&gt;second;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(index, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dfs(graph, visited,i, j, res[k]) == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">            res[k] = <span class=\"number\">-1.0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;&gt; &amp;graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &amp;visited, <span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e, <span class=\"keyword\">double</span> &amp;res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == e) &#123; res = <span class=\"number\">1.0</span>; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">    visited[s] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; graph.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"literal\">false</span> &amp;&amp; graph[s][i] &gt; <span class=\"number\">0</span> &amp;&amp; dfs(graph, visited, i, e, temp)) &#123;</span><br><span class=\"line\">            res = temp * graph[s][i];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第59天，有好几天没做了，太咸鱼了我。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/evaluate-division/\">Evaluate Division</a>:</p>\n<p>一道写起来比较麻烦，但是总体来看还是比较简单的。就是分为两步走即可：</p>\n<ol>\n<li>利用<code>equations</code>和<code>value</code>构造一个图</li>\n<li>然后通过在图上遍历的方式计算得到<code>queries</code>的值。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">calcEquation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;&amp; equations, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;&amp; values, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">res</span><span class=\"params\">(queries.size())</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// calc elem set</span></span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt; smap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;vec: equations) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = smap.find(vec[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it == smap.end()) smap[vec[<span class=\"number\">0</span>]] = index++;</span><br><span class=\"line\">        it = smap.find(vec[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it == smap.end()) smap[vec[<span class=\"number\">1</span>]] = index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// for(auto p: smap) cout &lt;&lt; p.second &lt;&lt; endl;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// build graph</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;&gt; graph(index, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;(index, <span class=\"number\">-1.0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>, size = equations.size(); k &lt; size; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = smap[equations[k][<span class=\"number\">0</span>]], j = smap[equations[k][<span class=\"number\">1</span>]];</span><br><span class=\"line\">        graph[i][j] = values[k];</span><br><span class=\"line\">        graph[j][i] = <span class=\"number\">1</span> / values[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>, size = queries.size(); k &lt; size; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it1 = smap.find(queries[k][<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it2 = smap.find(queries[k][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it1 == smap.end() || it2 == smap.end()) &#123;</span><br><span class=\"line\">            res[k] = <span class=\"number\">-1.0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queries[k][<span class=\"number\">0</span>] == queries[k][<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            res[k] = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = it1-&gt;second, j = it2-&gt;second;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(index, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dfs(graph, visited,i, j, res[k]) == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">            res[k] = <span class=\"number\">-1.0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;&gt; &amp;graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &amp;visited, <span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e, <span class=\"keyword\">double</span> &amp;res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == e) &#123; res = <span class=\"number\">1.0</span>; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">    visited[s] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; graph.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"literal\">false</span> &amp;&amp; graph[s][i] &gt; <span class=\"number\">0</span> &amp;&amp; dfs(graph, visited, i, e, temp)) &#123;</span><br><span class=\"line\">            res = temp * graph[s][i];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Evaluate Reverse Polish Notation","date":"2020-03-31T01:29:10.000Z","_content":"\n> 因为最近在总结 LeetCode 中 `Stack` 标签下做过的题目，然后这道题做了但是没有写题解，所以补充一下。\n\n一道`Medium`的题目，但是数据结构课上提到栈时，都会举这个例子才对，所以这道题挺简单的。\n\n因为输入的已经是解析好的`token`了，所以不用额外的做 parse 的工作。我们只需要用一个栈来保存操作树即可。\n\n- 当遇到一个操作数时，就压入栈中。\n- 当遇到一个操作符时，就弹出两个操作数，然后根据操作符对这两个操作数进行操作，并将结果压入栈中。\n\n由于题目保证了输入一定是正确的，所以很多判断都可以省略掉。然后又一个需要主要的就是栈是后进先出的，所以操作数的顺序不要弄反了就好了。\n\n```c++\nbool isOp(const string &s) {\n\treturn s.size() == 1 && (s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == '/');\n}\nint calc(int a, char op, int b) {\n\tswitch(op) {\n\t\tcase '+': return a + b;\n\t\tcase '-': return a - b;\n\t\tcase '*': return a * b;\n\t\tcase '/': return a / b;\n\t}\n\treturn -1;\n}\nint evalRPN(vector<string>& tokens) {\n\tstack<int> st;\n\tfor(auto &s: tokens) {\n\t\tif (!isOp(s)) {\n\t\t\tst.push(atoi(s.c_str()));\n\t\t} else {\n\t\t\tint b = st.top(); st.pop();\n\t\t\tint a = st.top(); st.pop(); \n\t\t\tst.push(calc(a, s[0], b));\n\t\t}  // else return -1;\n\t}\n\treturn st.top();\n}\n```\n","source":"_posts/Evaluate-Reverse-Polish-Notation.md","raw":"---\ntitle: Evaluate Reverse Polish Notation\ndate: 2020-03-31T09:29:10.000Z\ntags:\n  - LeetCode\n  - Stack\ncategories:\n  - LeetCode\n---\n\n> 因为最近在总结 LeetCode 中 `Stack` 标签下做过的题目，然后这道题做了但是没有写题解，所以补充一下。\n\n一道`Medium`的题目，但是数据结构课上提到栈时，都会举这个例子才对，所以这道题挺简单的。\n\n因为输入的已经是解析好的`token`了，所以不用额外的做 parse 的工作。我们只需要用一个栈来保存操作树即可。\n\n- 当遇到一个操作数时，就压入栈中。\n- 当遇到一个操作符时，就弹出两个操作数，然后根据操作符对这两个操作数进行操作，并将结果压入栈中。\n\n由于题目保证了输入一定是正确的，所以很多判断都可以省略掉。然后又一个需要主要的就是栈是后进先出的，所以操作数的顺序不要弄反了就好了。\n\n```c++\nbool isOp(const string &s) {\n\treturn s.size() == 1 && (s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == '/');\n}\nint calc(int a, char op, int b) {\n\tswitch(op) {\n\t\tcase '+': return a + b;\n\t\tcase '-': return a - b;\n\t\tcase '*': return a * b;\n\t\tcase '/': return a / b;\n\t}\n\treturn -1;\n}\nint evalRPN(vector<string>& tokens) {\n\tstack<int> st;\n\tfor(auto &s: tokens) {\n\t\tif (!isOp(s)) {\n\t\t\tst.push(atoi(s.c_str()));\n\t\t} else {\n\t\t\tint b = st.top(); st.pop();\n\t\t\tint a = st.top(); st.pop(); \n\t\t\tst.push(calc(a, s[0], b));\n\t\t}  // else return -1;\n\t}\n\treturn st.top();\n}\n```\n","slug":"Evaluate-Reverse-Polish-Notation","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69no0048qmcm5x9x214g","content":"<blockquote>\n<p>因为最近在总结 LeetCode 中 <code>Stack</code> 标签下做过的题目，然后这道题做了但是没有写题解，所以补充一下。</p>\n</blockquote>\n<p>一道<code>Medium</code>的题目，但是数据结构课上提到栈时，都会举这个例子才对，所以这道题挺简单的。</p>\n<p>因为输入的已经是解析好的<code>token</code>了，所以不用额外的做 parse 的工作。我们只需要用一个栈来保存操作树即可。</p>\n<ul>\n<li>当遇到一个操作数时，就压入栈中。</li>\n<li>当遇到一个操作符时，就弹出两个操作数，然后根据操作符对这两个操作数进行操作，并将结果压入栈中。</li>\n</ul>\n<p>由于题目保证了输入一定是正确的，所以很多判断都可以省略掉。然后又一个需要主要的就是栈是后进先出的，所以操作数的顺序不要弄反了就好了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isOp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.size() == <span class=\"number\">1</span> &amp;&amp; (s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;+&#x27;</span> || s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;-&#x27;</span> || s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span> || s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">calc</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">char</span> op, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(op) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>: <span class=\"keyword\">return</span> a / b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">evalRPN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s: tokens) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isOp(s)) &#123;</span><br><span class=\"line\">\t\t\tst.push(atoi(s.c_str()));</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> b = st.top(); st.pop();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> a = st.top(); st.pop(); </span><br><span class=\"line\">\t\t\tst.push(calc(a, s[<span class=\"number\">0</span>], b));</span><br><span class=\"line\">\t\t&#125;  <span class=\"comment\">// else return -1;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> st.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>因为最近在总结 LeetCode 中 <code>Stack</code> 标签下做过的题目，然后这道题做了但是没有写题解，所以补充一下。</p>\n</blockquote>\n<p>一道<code>Medium</code>的题目，但是数据结构课上提到栈时，都会举这个例子才对，所以这道题挺简单的。</p>\n<p>因为输入的已经是解析好的<code>token</code>了，所以不用额外的做 parse 的工作。我们只需要用一个栈来保存操作树即可。</p>\n<ul>\n<li>当遇到一个操作数时，就压入栈中。</li>\n<li>当遇到一个操作符时，就弹出两个操作数，然后根据操作符对这两个操作数进行操作，并将结果压入栈中。</li>\n</ul>\n<p>由于题目保证了输入一定是正确的，所以很多判断都可以省略掉。然后又一个需要主要的就是栈是后进先出的，所以操作数的顺序不要弄反了就好了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isOp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.size() == <span class=\"number\">1</span> &amp;&amp; (s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;+&#x27;</span> || s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;-&#x27;</span> || s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span> || s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">calc</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">char</span> op, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(op) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>: <span class=\"keyword\">return</span> a / b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">evalRPN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s: tokens) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isOp(s)) &#123;</span><br><span class=\"line\">\t\t\tst.push(atoi(s.c_str()));</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> b = st.top(); st.pop();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> a = st.top(); st.pop(); </span><br><span class=\"line\">\t\t\tst.push(calc(a, s[<span class=\"number\">0</span>], b));</span><br><span class=\"line\">\t\t&#125;  <span class=\"comment\">// else return -1;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> st.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Find-Bottom-Left-Tree","date":"2017-12-07T01:01:56.000Z","_content":"\n第71天。\n\n今天的题目是[Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/description/):\n\n> Given a binary tree, find the leftmost value in the last row of the tree.\n>\n> Example 1:\n> Input:\n\n    2\n   / \\\n  1   3\n\n> Output:\n> 1\n> Example 2:\n> Input:\n\n        1\n       / \\\n      2   3\n     /   / \\\n    4   5   6\n       /\n      7\n\n> Output:\n> 7\n> Note: You may assume the tree (i.e., the given root node) is not NULL.\n\n显然这可以用带高度的深度优先去做：\n\n```c++\nint findBottomLeftValue(TreeNode *root,int &height) {\n    if (root == nullptr) {\n        height = -1;\n        return -1;\n    }\n    if (root->left == nullptr && root->right == nullptr)\n        return root->val;\n    int lefth,righth;\n    lefth = righth = height + 1;\n    int left = findBottomLeftValue(root->left,lefth);\n    int right = findBottomLeftValue(root->right,righth);\n    if (lefth >= righth) {\n        height = lefth;\n        return left;\n    } else{\n        height = righth;\n        return right;\n    }\n}\nint findBottomLeftValue(TreeNode* root) {\n    int h = 0;\n    return findBottomLeftValue(root,h);\n}\n```\n\n看起来就不优雅，而且很繁琐的样子,下面是`dicuss`中用广度优先去做的：\n\n```java\npublic int findLeftMostNode(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        root = queue.poll();\n        if (root.right != null)\n            queue.add(root.right);\n        if (root.left != null)\n            queue.add(root.left);\n    }\n    return root.val;\n}\n```\n\n以及`python`版本：\n\n```python\ndef findLeftMostNode(self, root):\n    queue = [root]\n    for node in queue:\n        queue += filter(None, (node.right, node.left))\n    return node.val\n```\n","source":"_posts/Find-Bottom-Left-Tree.md","raw":"---\ntitle: Find-Bottom-Left-Tree\ndate: 2017-12-07T09:01:56.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第71天。\n\n今天的题目是[Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/description/):\n\n> Given a binary tree, find the leftmost value in the last row of the tree.\n>\n> Example 1:\n> Input:\n\n    2\n   / \\\n  1   3\n\n> Output:\n> 1\n> Example 2:\n> Input:\n\n        1\n       / \\\n      2   3\n     /   / \\\n    4   5   6\n       /\n      7\n\n> Output:\n> 7\n> Note: You may assume the tree (i.e., the given root node) is not NULL.\n\n显然这可以用带高度的深度优先去做：\n\n```c++\nint findBottomLeftValue(TreeNode *root,int &height) {\n    if (root == nullptr) {\n        height = -1;\n        return -1;\n    }\n    if (root->left == nullptr && root->right == nullptr)\n        return root->val;\n    int lefth,righth;\n    lefth = righth = height + 1;\n    int left = findBottomLeftValue(root->left,lefth);\n    int right = findBottomLeftValue(root->right,righth);\n    if (lefth >= righth) {\n        height = lefth;\n        return left;\n    } else{\n        height = righth;\n        return right;\n    }\n}\nint findBottomLeftValue(TreeNode* root) {\n    int h = 0;\n    return findBottomLeftValue(root,h);\n}\n```\n\n看起来就不优雅，而且很繁琐的样子,下面是`dicuss`中用广度优先去做的：\n\n```java\npublic int findLeftMostNode(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        root = queue.poll();\n        if (root.right != null)\n            queue.add(root.right);\n        if (root.left != null)\n            queue.add(root.left);\n    }\n    return root.val;\n}\n```\n\n以及`python`版本：\n\n```python\ndef findLeftMostNode(self, root):\n    queue = [root]\n    for node in queue:\n        queue += filter(None, (node.right, node.left))\n    return node.val\n```\n","slug":"Find-Bottom-Left-Tree","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69np004bqmcm3c2y6evx","content":"<p>第71天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-bottom-left-tree-value/description/\">Find Bottom Left Tree Value</a>:</p>\n<blockquote>\n<p>Given a binary tree, find the leftmost value in the last row of the tree.</p>\n<p>Example 1:<br>Input:</p>\n</blockquote>\n<pre><code>2\n</code></pre>\n<p>   / <br>  1   3</p>\n<blockquote>\n<p>Output:<br>1<br>Example 2:<br>Input:</p>\n</blockquote>\n<pre><code>    1\n   / \\\n  2   3\n /   / \\\n4   5   6\n   /\n  7\n</code></pre>\n<blockquote>\n<p>Output:<br>7<br>Note: You may assume the tree (i.e., the given root node) is not NULL.</p>\n</blockquote>\n<p>显然这可以用带高度的深度优先去做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> &amp;height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        height = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;val;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lefth,righth;</span><br><span class=\"line\">    lefth = righth = height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = findBottomLeftValue(root-&gt;left,lefth);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = findBottomLeftValue(root-&gt;right,righth);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lefth &gt;= righth) &#123;</span><br><span class=\"line\">        height = lefth;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        height = righth;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findBottomLeftValue(root,h);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来就不优雅，而且很繁琐的样子,下面是<code>dicuss</code>中用广度优先去做的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findLeftMostNode</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    queue.add(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">        root = queue.poll();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            queue.add(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            queue.add(root.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root.val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及<code>python</code>版本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLeftMostNode</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">    queue = [root]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> queue:</span><br><span class=\"line\">        queue += <span class=\"built_in\">filter</span>(<span class=\"literal\">None</span>, (node.right, node.left))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.val</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第71天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-bottom-left-tree-value/description/\">Find Bottom Left Tree Value</a>:</p>\n<blockquote>\n<p>Given a binary tree, find the leftmost value in the last row of the tree.</p>\n<p>Example 1:<br>Input:</p>\n</blockquote>\n<pre><code>2\n</code></pre>\n<p>   / <br>  1   3</p>\n<blockquote>\n<p>Output:<br>1<br>Example 2:<br>Input:</p>\n</blockquote>\n<pre><code>    1\n   / \\\n  2   3\n /   / \\\n4   5   6\n   /\n  7\n</code></pre>\n<blockquote>\n<p>Output:<br>7<br>Note: You may assume the tree (i.e., the given root node) is not NULL.</p>\n</blockquote>\n<p>显然这可以用带高度的深度优先去做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> &amp;height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        height = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;val;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lefth,righth;</span><br><span class=\"line\">    lefth = righth = height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = findBottomLeftValue(root-&gt;left,lefth);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = findBottomLeftValue(root-&gt;right,righth);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lefth &gt;= righth) &#123;</span><br><span class=\"line\">        height = lefth;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        height = righth;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findBottomLeftValue(root,h);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来就不优雅，而且很繁琐的样子,下面是<code>dicuss</code>中用广度优先去做的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findLeftMostNode</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    queue.add(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">        root = queue.poll();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            queue.add(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            queue.add(root.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root.val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及<code>python</code>版本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLeftMostNode</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">    queue = [root]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> queue:</span><br><span class=\"line\">        queue += <span class=\"built_in\">filter</span>(<span class=\"literal\">None</span>, (node.right, node.left))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.val</span><br></pre></td></tr></table></figure>\n"},{"title":"Find Eventual Safe States","date":"2019-12-20T04:53:23.000Z","_content":"\n> 第44天。\n\n今天的题目是[Find Eventual Safe States](https://leetcode.com/problems/find-eventual-safe-states/):\n\n最开始的想法是，从安全的节点开始在图中进行扩散，当一个节点所有边都指向一个安全的节点时，那它也是一个安全的节点，但是这样复杂度挺高的，所以虽然能过：\n\n```c++\nbool check(vector<vector<int>>& graph, vector<bool> &color, int i) {\n    for(auto &j: graph[i]) {\n        if (!color[j]) return false;\n    }\n    return true;\n}\nvector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n    int size = graph.size();\n    vector<int> res;\n    if (size == 0) return res;\n    \n    vector<bool> color(size, false);\n    bool change = false;\n    for(int i = 0;i < size; i++) \n        if (graph[i].size() == 0) {\n            color[i] = true;\n            change = true;\n        }\n    \n    while(change) {\n        change = false;\n        for(int i = 0;i < size; i++) {\n            if (color[i] == false && check(graph, color, i)) {\n                color[i] = true;\n                change = true;\n            }\n        }\n    }\n    \n    for(int i = 0;i < size; i++) {\n        if (color[i]) res.push_back(i);\n    }\n    return res;\n}\n```\n\n后来发现好像可以用深度优先来做，主要的想法是，一个环中所有的节点都是不安全的，我们把不安全的节点都筛选出来，即可得到所有安全的节点。\n因此就把问题变成了找到图中所有在环中的节点。在DFS时，维护一个状态，这个状态可能为：\n\n- 0：未访问（初始状态）\n- 1：访问中\n- 2：访问完成（安全状态）\n- 3：在环中（不安全状态）\n\n先把所有节点的状态都初始化为`0`,当对第 i 个节点调用 dfs 时，则将其转换为`1`,然后遍历该节点所有能走的边，\n如果下一个节点的状态为`0`，则对其调用dfs，如果下一个节点的状态为`1`或`2`，则该节点出现在环中，将状态转换为`3`，并直接返回为`3`。\n当 i 节点对 j 节点调用 dfs 后，返回值如果为3的话，则 i 节点状态也变为 `3`, 并直接返回`3`。\n\n如果第 `i` 个节点对所有路径都调用了 dfs 后，没有遇到返回值为 `3` 的情况，则该节点为安全的，所以将其状态转换为 `2`。\n\n代码如下：\n\n```c++\nvector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n    int size = graph.size();\n    vector<int> res;\n    if (size == 0) return res;\n    \n    vector<int> color(size, 0); // 0 mean unvisit\n    for(int i = 0;i < size; i++) {\n        if (color[i] == 0) dfs(graph, color, i);\n    }\n    \n    for(int i = 0;i < size; i++) {\n        if (color[i] == 2) res.push_back(i);\n    }\n    return res;\n    \n}\n\nint dfs(vector<vector<int>> &graph, vector<int> &color, int node) {\n    // cout << \"visit\" << node << endl;\n    color[node] = 1; // in dfs\n    for(int j = 0;j < graph[node].size(); j++) {\n        int i = graph[node][j];\n        if ( (color[i] == 0 && dfs(graph, color, i) == 3) ||\n            color[i] == 1 || color[i] == 3\n            ) {\n            color[node] = 3;\n            return 3;\n        }\n    }\n    color[node] = 2;// safe node\n    return color[node];\n}\n```\n","source":"_posts/Find-Eventual-Safe-States.md","raw":"---\ntitle: Find Eventual Safe States\ndate: 2019-12-20T12:53:23.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第44天。\n\n今天的题目是[Find Eventual Safe States](https://leetcode.com/problems/find-eventual-safe-states/):\n\n最开始的想法是，从安全的节点开始在图中进行扩散，当一个节点所有边都指向一个安全的节点时，那它也是一个安全的节点，但是这样复杂度挺高的，所以虽然能过：\n\n```c++\nbool check(vector<vector<int>>& graph, vector<bool> &color, int i) {\n    for(auto &j: graph[i]) {\n        if (!color[j]) return false;\n    }\n    return true;\n}\nvector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n    int size = graph.size();\n    vector<int> res;\n    if (size == 0) return res;\n    \n    vector<bool> color(size, false);\n    bool change = false;\n    for(int i = 0;i < size; i++) \n        if (graph[i].size() == 0) {\n            color[i] = true;\n            change = true;\n        }\n    \n    while(change) {\n        change = false;\n        for(int i = 0;i < size; i++) {\n            if (color[i] == false && check(graph, color, i)) {\n                color[i] = true;\n                change = true;\n            }\n        }\n    }\n    \n    for(int i = 0;i < size; i++) {\n        if (color[i]) res.push_back(i);\n    }\n    return res;\n}\n```\n\n后来发现好像可以用深度优先来做，主要的想法是，一个环中所有的节点都是不安全的，我们把不安全的节点都筛选出来，即可得到所有安全的节点。\n因此就把问题变成了找到图中所有在环中的节点。在DFS时，维护一个状态，这个状态可能为：\n\n- 0：未访问（初始状态）\n- 1：访问中\n- 2：访问完成（安全状态）\n- 3：在环中（不安全状态）\n\n先把所有节点的状态都初始化为`0`,当对第 i 个节点调用 dfs 时，则将其转换为`1`,然后遍历该节点所有能走的边，\n如果下一个节点的状态为`0`，则对其调用dfs，如果下一个节点的状态为`1`或`2`，则该节点出现在环中，将状态转换为`3`，并直接返回为`3`。\n当 i 节点对 j 节点调用 dfs 后，返回值如果为3的话，则 i 节点状态也变为 `3`, 并直接返回`3`。\n\n如果第 `i` 个节点对所有路径都调用了 dfs 后，没有遇到返回值为 `3` 的情况，则该节点为安全的，所以将其状态转换为 `2`。\n\n代码如下：\n\n```c++\nvector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n    int size = graph.size();\n    vector<int> res;\n    if (size == 0) return res;\n    \n    vector<int> color(size, 0); // 0 mean unvisit\n    for(int i = 0;i < size; i++) {\n        if (color[i] == 0) dfs(graph, color, i);\n    }\n    \n    for(int i = 0;i < size; i++) {\n        if (color[i] == 2) res.push_back(i);\n    }\n    return res;\n    \n}\n\nint dfs(vector<vector<int>> &graph, vector<int> &color, int node) {\n    // cout << \"visit\" << node << endl;\n    color[node] = 1; // in dfs\n    for(int j = 0;j < graph[node].size(); j++) {\n        int i = graph[node][j];\n        if ( (color[i] == 0 && dfs(graph, color, i) == 3) ||\n            color[i] == 1 || color[i] == 3\n            ) {\n            color[node] = 3;\n            return 3;\n        }\n    }\n    color[node] = 2;// safe node\n    return color[node];\n}\n```\n","slug":"Find-Eventual-Safe-States","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69np004eqmcmblsy1adk","content":"<blockquote>\n<p>第44天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-eventual-safe-states/\">Find Eventual Safe States</a>:</p>\n<p>最开始的想法是，从安全的节点开始在图中进行扩散，当一个节点所有边都指向一个安全的节点时，那它也是一个安全的节点，但是这样复杂度挺高的，所以虽然能过：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &amp;color, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;j: graph[i]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!color[j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">eventualSafeNodes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = graph.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">color</span><span class=\"params\">(size, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> change = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (graph[i].size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            color[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            change = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(change) &#123;</span><br><span class=\"line\">        change = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (color[i] == <span class=\"literal\">false</span> &amp;&amp; check(graph, color, i)) &#123;</span><br><span class=\"line\">                color[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                change = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (color[i]) res.push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后来发现好像可以用深度优先来做，主要的想法是，一个环中所有的节点都是不安全的，我们把不安全的节点都筛选出来，即可得到所有安全的节点。<br>因此就把问题变成了找到图中所有在环中的节点。在DFS时，维护一个状态，这个状态可能为：</p>\n<ul>\n<li>0：未访问（初始状态）</li>\n<li>1：访问中</li>\n<li>2：访问完成（安全状态）</li>\n<li>3：在环中（不安全状态）</li>\n</ul>\n<p>先把所有节点的状态都初始化为<code>0</code>,当对第 i 个节点调用 dfs 时，则将其转换为<code>1</code>,然后遍历该节点所有能走的边，<br>如果下一个节点的状态为<code>0</code>，则对其调用dfs，如果下一个节点的状态为<code>1</code>或<code>2</code>，则该节点出现在环中，将状态转换为<code>3</code>，并直接返回为<code>3</code>。<br>当 i 节点对 j 节点调用 dfs 后，返回值如果为3的话，则 i 节点状态也变为 <code>3</code>, 并直接返回<code>3</code>。</p>\n<p>如果第 <code>i</code> 个节点对所有路径都调用了 dfs 后，没有遇到返回值为 <code>3</code> 的情况，则该节点为安全的，所以将其状态转换为 <code>2</code>。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">eventualSafeNodes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = graph.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">color</span><span class=\"params\">(size, <span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// 0 mean unvisit</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (color[i] == <span class=\"number\">0</span>) dfs(graph, color, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (color[i] == <span class=\"number\">2</span>) res.push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;color, <span class=\"keyword\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; &quot;visit&quot; &lt;&lt; node &lt;&lt; endl;</span></span><br><span class=\"line\">    color[node] = <span class=\"number\">1</span>; <span class=\"comment\">// in dfs</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; graph[node].size(); j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = graph[node][j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (color[i] == <span class=\"number\">0</span> &amp;&amp; dfs(graph, color, i) == <span class=\"number\">3</span>) ||</span><br><span class=\"line\">            color[i] == <span class=\"number\">1</span> || color[i] == <span class=\"number\">3</span></span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">            color[node] = <span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[node] = <span class=\"number\">2</span>;<span class=\"comment\">// safe node</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> color[node];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第44天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-eventual-safe-states/\">Find Eventual Safe States</a>:</p>\n<p>最开始的想法是，从安全的节点开始在图中进行扩散，当一个节点所有边都指向一个安全的节点时，那它也是一个安全的节点，但是这样复杂度挺高的，所以虽然能过：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &amp;color, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;j: graph[i]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!color[j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">eventualSafeNodes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = graph.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">color</span><span class=\"params\">(size, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> change = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (graph[i].size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            color[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            change = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(change) &#123;</span><br><span class=\"line\">        change = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (color[i] == <span class=\"literal\">false</span> &amp;&amp; check(graph, color, i)) &#123;</span><br><span class=\"line\">                color[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                change = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (color[i]) res.push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后来发现好像可以用深度优先来做，主要的想法是，一个环中所有的节点都是不安全的，我们把不安全的节点都筛选出来，即可得到所有安全的节点。<br>因此就把问题变成了找到图中所有在环中的节点。在DFS时，维护一个状态，这个状态可能为：</p>\n<ul>\n<li>0：未访问（初始状态）</li>\n<li>1：访问中</li>\n<li>2：访问完成（安全状态）</li>\n<li>3：在环中（不安全状态）</li>\n</ul>\n<p>先把所有节点的状态都初始化为<code>0</code>,当对第 i 个节点调用 dfs 时，则将其转换为<code>1</code>,然后遍历该节点所有能走的边，<br>如果下一个节点的状态为<code>0</code>，则对其调用dfs，如果下一个节点的状态为<code>1</code>或<code>2</code>，则该节点出现在环中，将状态转换为<code>3</code>，并直接返回为<code>3</code>。<br>当 i 节点对 j 节点调用 dfs 后，返回值如果为3的话，则 i 节点状态也变为 <code>3</code>, 并直接返回<code>3</code>。</p>\n<p>如果第 <code>i</code> 个节点对所有路径都调用了 dfs 后，没有遇到返回值为 <code>3</code> 的情况，则该节点为安全的，所以将其状态转换为 <code>2</code>。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">eventualSafeNodes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = graph.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">color</span><span class=\"params\">(size, <span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// 0 mean unvisit</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (color[i] == <span class=\"number\">0</span>) dfs(graph, color, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (color[i] == <span class=\"number\">2</span>) res.push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;color, <span class=\"keyword\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; &quot;visit&quot; &lt;&lt; node &lt;&lt; endl;</span></span><br><span class=\"line\">    color[node] = <span class=\"number\">1</span>; <span class=\"comment\">// in dfs</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; graph[node].size(); j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = graph[node][j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (color[i] == <span class=\"number\">0</span> &amp;&amp; dfs(graph, color, i) == <span class=\"number\">3</span>) ||</span><br><span class=\"line\">            color[i] == <span class=\"number\">1</span> || color[i] == <span class=\"number\">3</span></span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">            color[node] = <span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[node] = <span class=\"number\">2</span>;<span class=\"comment\">// safe node</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> color[node];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Find Largest Value in Each Tree Row","date":"2019-12-18T03:08:25.000Z","_content":"\n> 第42天。\n\n今天的题目是[Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/):\n\n水题，用队列做树的层次遍历即可：\n\n```c++\nvector<int> largestValues(TreeNode* root) {\n    vector<int> res;\n    if (root == nullptr) return res;\n    queue<TreeNode *> q;\n    q.push(root);\n    \n    while(!q.empty()) {\n        int max_v = INT_MIN;\n        for(int i = 0, size = q.size(); i < size; i++) {\n            root = q.front(); q.pop();\n            max_v = max(max_v, root->val);\n            if (root->left) q.push(root->left);\n            if (root->right) q.push(root->right);\n        }\n        res.push_back(max_v);\n    }\n    \n    return res;\n}\n```\n","source":"_posts/Find-Largest-Value-in-Each-Tree-Row.md","raw":"---\ntitle: Find Largest Value in Each Tree Row\ndate: 2019-12-18T11:08:25.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第42天。\n\n今天的题目是[Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/):\n\n水题，用队列做树的层次遍历即可：\n\n```c++\nvector<int> largestValues(TreeNode* root) {\n    vector<int> res;\n    if (root == nullptr) return res;\n    queue<TreeNode *> q;\n    q.push(root);\n    \n    while(!q.empty()) {\n        int max_v = INT_MIN;\n        for(int i = 0, size = q.size(); i < size; i++) {\n            root = q.front(); q.pop();\n            max_v = max(max_v, root->val);\n            if (root->left) q.push(root->left);\n            if (root->right) q.push(root->right);\n        }\n        res.push_back(max_v);\n    }\n    \n    return res;\n}\n```\n","slug":"Find-Largest-Value-in-Each-Tree-Row","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nq004hqmcm16q594zq","content":"<blockquote>\n<p>第42天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-largest-value-in-each-tree-row/\">Find Largest Value in Each Tree Row</a>:</p>\n<p>水题，用队列做树的层次遍历即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">largestValues</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max_v = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = q.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">            root = q.front(); q.pop();</span><br><span class=\"line\">            max_v = max(max_v, root-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.push_back(max_v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第42天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-largest-value-in-each-tree-row/\">Find Largest Value in Each Tree Row</a>:</p>\n<p>水题，用队列做树的层次遍历即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">largestValues</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max_v = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = q.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">            root = q.front(); q.pop();</span><br><span class=\"line\">            max_v = max(max_v, root-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.push_back(max_v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Find-Peak-Element","date":"2017-12-08T01:37:52.000Z","_content":"\n第72天。\n\n今天的题目是[Find Peak Element](https://leetcode.com/problems/find-peak-element/description/):\n\n> A peak element is an element that is greater than its neighbors.\n>\n> Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.\n>\n> The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\n>\n> You may imagine that num[-1] = num[n] = -∞.\n>\n> For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.\n\n显然这道题写出一个`O(n)`的解法很简单。\n\n这里的用二分法去求解，可以用`O(logn)`解出，`分`和`合`两个步骤都是`O(1)`的时间复杂度。\n\n```c++\nint findPeakElement(vector<int>& nums) {\n    return findPeakElement(nums,0,nums.size() - 1);\n}\nint findPeakElement1(vector<int> &nums,int first,int last) {\n    if (first > last) return -1;\n    int mid = (first + last)/2;\n    int a = 0;\n    if ( (mid+1 == nums.size() || nums[mid] > nums[mid + 1]) &&\n            (mid-1 < 0 || nums[mid] > nums[mid-1]) )\n        return mid;\n    int left = findPeakElement(nums,first,mid-1);\n    if (left != -1) return left;\n    return findPeakElement(nums,mid+1,last);\n}\n```\n\n当然这不是最好的解法，这里其实是用二分查找去做的：\n\n```c++\nint findPeakElement(const vector<int> &num) {\n    return Helper(num, 0, num.size()-1);\n}\nint Helper(const vector<int> &num, int low, int high){\n    if(low == high)\n        return low;\n    else\n    {\n        int mid1 = (low+high)/2;\n        int mid2 = mid1+1;\n        if(num[mid1] > num[mid2])\n            return Helper(num, low, mid1);\n        else\n            return Helper(num, mid2, high);\n    }\n}\n```\n\n或者\n\n```c++\nint findPeakElement(const vector<int> &num) \n{\n    int low = 0;\n    int high = num.size()-1;\n\n    while(low < high)\n    {\n        int mid1 = (low+high)/2;\n        int mid2 = mid1+1;\n        if(num[mid1] < num[mid2])\n            low = mid2;\n        else\n            high = mid1;\n    }\n    return low;\n}\n```\n","source":"_posts/Find-Peak-Element.md","raw":"---\ntitle: Find-Peak-Element\ndate: 2017-12-08T09:37:52.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第72天。\n\n今天的题目是[Find Peak Element](https://leetcode.com/problems/find-peak-element/description/):\n\n> A peak element is an element that is greater than its neighbors.\n>\n> Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.\n>\n> The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\n>\n> You may imagine that num[-1] = num[n] = -∞.\n>\n> For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.\n\n显然这道题写出一个`O(n)`的解法很简单。\n\n这里的用二分法去求解，可以用`O(logn)`解出，`分`和`合`两个步骤都是`O(1)`的时间复杂度。\n\n```c++\nint findPeakElement(vector<int>& nums) {\n    return findPeakElement(nums,0,nums.size() - 1);\n}\nint findPeakElement1(vector<int> &nums,int first,int last) {\n    if (first > last) return -1;\n    int mid = (first + last)/2;\n    int a = 0;\n    if ( (mid+1 == nums.size() || nums[mid] > nums[mid + 1]) &&\n            (mid-1 < 0 || nums[mid] > nums[mid-1]) )\n        return mid;\n    int left = findPeakElement(nums,first,mid-1);\n    if (left != -1) return left;\n    return findPeakElement(nums,mid+1,last);\n}\n```\n\n当然这不是最好的解法，这里其实是用二分查找去做的：\n\n```c++\nint findPeakElement(const vector<int> &num) {\n    return Helper(num, 0, num.size()-1);\n}\nint Helper(const vector<int> &num, int low, int high){\n    if(low == high)\n        return low;\n    else\n    {\n        int mid1 = (low+high)/2;\n        int mid2 = mid1+1;\n        if(num[mid1] > num[mid2])\n            return Helper(num, low, mid1);\n        else\n            return Helper(num, mid2, high);\n    }\n}\n```\n\n或者\n\n```c++\nint findPeakElement(const vector<int> &num) \n{\n    int low = 0;\n    int high = num.size()-1;\n\n    while(low < high)\n    {\n        int mid1 = (low+high)/2;\n        int mid2 = mid1+1;\n        if(num[mid1] < num[mid2])\n            low = mid2;\n        else\n            high = mid1;\n    }\n    return low;\n}\n```\n","slug":"Find-Peak-Element","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nr004kqmcm01zzdbey","content":"<p>第72天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-peak-element/description/\">Find Peak Element</a>:</p>\n<blockquote>\n<p>A peak element is an element that is greater than its neighbors.</p>\n<p>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.</p>\n<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>\n<p>You may imagine that num[-1] = num[n] = -∞.</p>\n<p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>\n</blockquote>\n<p>显然这道题写出一个<code>O(n)</code>的解法很简单。</p>\n<p>这里的用二分法去求解，可以用<code>O(logn)</code>解出，<code>分</code>和<code>合</code>两个步骤都是<code>O(1)</code>的时间复杂度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findPeakElement(nums,<span class=\"number\">0</span>,nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findPeakElement1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &gt; last) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (first + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (mid+<span class=\"number\">1</span> == nums.size() || nums[mid] &gt; nums[mid + <span class=\"number\">1</span>]) &amp;&amp;</span><br><span class=\"line\">            (mid<span class=\"number\">-1</span> &lt; <span class=\"number\">0</span> || nums[mid] &gt; nums[mid<span class=\"number\">-1</span>]) )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = findPeakElement(nums,first,mid<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left != <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findPeakElement(nums,mid+<span class=\"number\">1</span>,last);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这不是最好的解法，这里其实是用二分查找去做的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Helper(num, <span class=\"number\">0</span>, num.size()<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Helper</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low == high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid1 = (low+high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid2 = mid1+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[mid1] &gt; num[mid2])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Helper(num, low, mid1);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Helper(num, mid2, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = num.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(low &lt; high)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid1 = (low+high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid2 = mid1+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[mid1] &lt; num[mid2])</span><br><span class=\"line\">            low = mid2;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            high = mid1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第72天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-peak-element/description/\">Find Peak Element</a>:</p>\n<blockquote>\n<p>A peak element is an element that is greater than its neighbors.</p>\n<p>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.</p>\n<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>\n<p>You may imagine that num[-1] = num[n] = -∞.</p>\n<p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>\n</blockquote>\n<p>显然这道题写出一个<code>O(n)</code>的解法很简单。</p>\n<p>这里的用二分法去求解，可以用<code>O(logn)</code>解出，<code>分</code>和<code>合</code>两个步骤都是<code>O(1)</code>的时间复杂度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findPeakElement(nums,<span class=\"number\">0</span>,nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findPeakElement1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &gt; last) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (first + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (mid+<span class=\"number\">1</span> == nums.size() || nums[mid] &gt; nums[mid + <span class=\"number\">1</span>]) &amp;&amp;</span><br><span class=\"line\">            (mid<span class=\"number\">-1</span> &lt; <span class=\"number\">0</span> || nums[mid] &gt; nums[mid<span class=\"number\">-1</span>]) )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = findPeakElement(nums,first,mid<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left != <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findPeakElement(nums,mid+<span class=\"number\">1</span>,last);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这不是最好的解法，这里其实是用二分查找去做的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Helper(num, <span class=\"number\">0</span>, num.size()<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Helper</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low == high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid1 = (low+high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid2 = mid1+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[mid1] &gt; num[mid2])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Helper(num, low, mid1);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Helper(num, mid2, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = num.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(low &lt; high)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid1 = (low+high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid2 = mid1+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[mid1] &lt; num[mid2])</span><br><span class=\"line\">            low = mid2;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            high = mid1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Find the Duplicate Number","date":"2017-11-21T05:17:18.000Z","_content":"\n第55天。\n\n今天的题目是[Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/description/):\n\n> Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n>\n> Note:\n> You must not modify the array (assume the array is read only).\n> You must use only constant, O(1) extra space.\n> Your runtime complexity should be less than O(n2).\n> There is only one duplicate number in the array, but it could be repeated more than once.\n\n一开始，没看到说要用`O(1)`的空间复杂度，就直接用计数的方法去写了：\n\n```c++\nint findDuplicate1(vector<int>& nums) {\n    vector<int> count(nums.size(),0);\n    for(auto i:nums) {\n        count[i]++;\n        if (count[i]>1) return i;\n    }\n    return -1;\n}\n```\n\n然后是后来想了很久，想着利用异或的方法去做，就是先将`nums`中的数字进行异或，然后在对`[1,n]`的数字进行异或，然后就直接是答案了，但是这种问题要限定在重复数字只重复一次的情况下，即需要保证`[1:n]`的数字都存在：\n\n```c++\nint findDuplicate2(vector<int>& nums) {\n    int t = 0;\n    int n = nums.size() - 1;\n    for(auto i:nums) {\n        t ^= i;\n    }\n    for(int i = 1;i <= n;i++)\n        t ^= i;\n    return t;\n}\n```\n\n最后。。。最后就实在想不出了，只好去看`dicuss`了：\n\n他是用了一个`List Cycle`中找环点的方式，这里的链表中的`nxet`就是用nums的值来表示的。\n\n```c++\nint findDuplicate(vector<int>& nums) {\n    int n = nums.size();\n    int slow = n;\n    int fast = n;\n    do {\n        slow = nums[slow-1];\n        fast = nums[nums[fast-1]-1];\n    }while(slow != fast);\n    slow = n;\n    while(slow != fast) {\n        slow = nums[slow - 1];\n        fast = nums[fast - 1];\n    }\n    return slow;\n}\n```\n\n\n","source":"_posts/Find-the-Duplicate-Number.md","raw":"---\ntitle: Find the Duplicate Number\ndate: 2017-11-21T13:17:18.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第55天。\n\n今天的题目是[Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/description/):\n\n> Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n>\n> Note:\n> You must not modify the array (assume the array is read only).\n> You must use only constant, O(1) extra space.\n> Your runtime complexity should be less than O(n2).\n> There is only one duplicate number in the array, but it could be repeated more than once.\n\n一开始，没看到说要用`O(1)`的空间复杂度，就直接用计数的方法去写了：\n\n```c++\nint findDuplicate1(vector<int>& nums) {\n    vector<int> count(nums.size(),0);\n    for(auto i:nums) {\n        count[i]++;\n        if (count[i]>1) return i;\n    }\n    return -1;\n}\n```\n\n然后是后来想了很久，想着利用异或的方法去做，就是先将`nums`中的数字进行异或，然后在对`[1,n]`的数字进行异或，然后就直接是答案了，但是这种问题要限定在重复数字只重复一次的情况下，即需要保证`[1:n]`的数字都存在：\n\n```c++\nint findDuplicate2(vector<int>& nums) {\n    int t = 0;\n    int n = nums.size() - 1;\n    for(auto i:nums) {\n        t ^= i;\n    }\n    for(int i = 1;i <= n;i++)\n        t ^= i;\n    return t;\n}\n```\n\n最后。。。最后就实在想不出了，只好去看`dicuss`了：\n\n他是用了一个`List Cycle`中找环点的方式，这里的链表中的`nxet`就是用nums的值来表示的。\n\n```c++\nint findDuplicate(vector<int>& nums) {\n    int n = nums.size();\n    int slow = n;\n    int fast = n;\n    do {\n        slow = nums[slow-1];\n        fast = nums[nums[fast-1]-1];\n    }while(slow != fast);\n    slow = n;\n    while(slow != fast) {\n        slow = nums[slow - 1];\n        fast = nums[fast - 1];\n    }\n    return slow;\n}\n```\n\n\n","slug":"Find-the-Duplicate-Number","published":1,"updated":"2021-03-10T13:47:05.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ns004nqmcmb6k9hs6b","content":"<p>第55天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-the-duplicate-number/description/\">Find the Duplicate Number</a>:</p>\n<blockquote>\n<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>\n<p>Note:<br>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p>\n</blockquote>\n<p>一开始，没看到说要用<code>O(1)</code>的空间复杂度，就直接用计数的方法去写了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findDuplicate1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">count</span><span class=\"params\">(nums.size(),<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) &#123;</span><br><span class=\"line\">        count[i]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count[i]&gt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是后来想了很久，想着利用异或的方法去做，就是先将<code>nums</code>中的数字进行异或，然后在对<code>[1,n]</code>的数字进行异或，然后就直接是答案了，但是这种问题要限定在重复数字只重复一次的情况下，即需要保证<code>[1:n]</code>的数字都存在：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findDuplicate2</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) &#123;</span><br><span class=\"line\">        t ^= i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++)</span><br><span class=\"line\">        t ^= i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后。。。最后就实在想不出了，只好去看<code>dicuss</code>了：</p>\n<p>他是用了一个<code>List Cycle</code>中找环点的方式，这里的链表中的<code>nxet</code>就是用nums的值来表示的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> slow = n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fast = n;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        slow = nums[slow<span class=\"number\">-1</span>];</span><br><span class=\"line\">        fast = nums[nums[fast<span class=\"number\">-1</span>]<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(slow != fast);</span><br><span class=\"line\">    slow = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(slow != fast) &#123;</span><br><span class=\"line\">        slow = nums[slow - <span class=\"number\">1</span>];</span><br><span class=\"line\">        fast = nums[fast - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>第55天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/find-the-duplicate-number/description/\">Find the Duplicate Number</a>:</p>\n<blockquote>\n<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>\n<p>Note:<br>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p>\n</blockquote>\n<p>一开始，没看到说要用<code>O(1)</code>的空间复杂度，就直接用计数的方法去写了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findDuplicate1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">count</span><span class=\"params\">(nums.size(),<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) &#123;</span><br><span class=\"line\">        count[i]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count[i]&gt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是后来想了很久，想着利用异或的方法去做，就是先将<code>nums</code>中的数字进行异或，然后在对<code>[1,n]</code>的数字进行异或，然后就直接是答案了，但是这种问题要限定在重复数字只重复一次的情况下，即需要保证<code>[1:n]</code>的数字都存在：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findDuplicate2</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) &#123;</span><br><span class=\"line\">        t ^= i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++)</span><br><span class=\"line\">        t ^= i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后。。。最后就实在想不出了，只好去看<code>dicuss</code>了：</p>\n<p>他是用了一个<code>List Cycle</code>中找环点的方式，这里的链表中的<code>nxet</code>就是用nums的值来表示的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> slow = n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fast = n;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        slow = nums[slow<span class=\"number\">-1</span>];</span><br><span class=\"line\">        fast = nums[nums[fast<span class=\"number\">-1</span>]<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(slow != fast);</span><br><span class=\"line\">    slow = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(slow != fast) &#123;</span><br><span class=\"line\">        slow = nums[slow - <span class=\"number\">1</span>];</span><br><span class=\"line\">        fast = nums[fast - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Flatten Binary Tree to Linked List","date":"2017-10-26T03:02:31.000Z","_content":"\n第32天。\n\n今天的题目是[Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/):\n\n> Given a binary tree, flatten it to a linked list in-place.\n>\n> For example,\n> Given\n\n```python\n        1\n        / \\\n       2   5\n      / \\   \\\n     3   4   6\n```\n\n> The flattened tree should look like:\n\n```python\n   1\n    \\\n     2\n      \\\n       3\n        \\\n         4\n          \\\n           5\n            \\\n             6\n```\n\n\n通过观察结果，我们可以发现它的顺序其实是一个先序遍历,那么我们可以先对树做一个先序遍历并记录节点指针，然后我们只需要将所有节点连接起来即可\n\n```c++\nvoid flatten2(TreeNode *root) {\n    if (root == nullptr) return ;\n    stack<TreeNode *> st;\n    vector<TreeNode *> tvec;\n    while(true) {\n        while(root){\n            st.push(root);\n            tvec.push_back(root);\n            root = root->left;\n        }\n        if (st.empty() ) break;\n        root = st.top();\n        st.pop();\n        root = root->right;\n    }\n    int i;\n    for(i = 0;i < tvec.size() - 1;i++) {\n        tvec[i]->left = nullptr;\n        tvec[i]->right = tvec[i+1];\n    }\n    tvec[i]->left = nullptr;\n    tvec[i]->right = nullptr;\n}\n```\n\n考虑一下递归的去完成整个问题，我们可以先对左孩子和右孩子做一次`flatten`,然后再讲他们按照适当的顺序连接起来:\n\n```c++\nvoid flatten(TreeNode* root) {\n    if (root==NULL) return ;\n    flatten(root->left);\n    flatten(root->right);\n    auto right = root->right;\n    auto left = root->left;\n    if (left){\n        root->right = left;\n        root->left = NULL;\n        while(left->right)\n            left = left->right;\n        left->right = right;\n    }\n}\n```\n\n上面的做法由于每次都需要对左孩子有一个一直往右的遍历，所以耗时还是挺大的，可以加入一个last指针，去表示最后一个被访问的节点的位置,为了保证正确性，我们必须先对右孩子进行`flatten`再对左孩子进行`flatten`.\n\n```c++\nTreeNode *last;\nvoid flatten(TreeNode* root) {\n    if (root==NULL) return ;\n    flatten(root->right);\n    flatten(root->left);\n    root->right = last;\n    root->left = nullptr;\n    last = root;\n}\n```\n\n然后是在`dicuss`中看到的迭代算法：\n\n```c++\nvoid flatten(TreeNode *root) {\n    while (root) {\n        if (root->left && root->right) {\n            TreeNode* t = root->left;\n            while (t->right)\n                t = t->right;\n            t->right = root->right;\n        }\n\n        if(root->left)\n            root->right = root->left;\n        root->left = NULL;\n        root = root->right;\n    }\n}\n```\n","source":"_posts/Flatten-Binary-Tree-to-Linked-List.md","raw":"---\ntitle: Flatten Binary Tree to Linked List\ndate: 2017-10-26T11:02:31.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第32天。\n\n今天的题目是[Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/):\n\n> Given a binary tree, flatten it to a linked list in-place.\n>\n> For example,\n> Given\n\n```python\n        1\n        / \\\n       2   5\n      / \\   \\\n     3   4   6\n```\n\n> The flattened tree should look like:\n\n```python\n   1\n    \\\n     2\n      \\\n       3\n        \\\n         4\n          \\\n           5\n            \\\n             6\n```\n\n\n通过观察结果，我们可以发现它的顺序其实是一个先序遍历,那么我们可以先对树做一个先序遍历并记录节点指针，然后我们只需要将所有节点连接起来即可\n\n```c++\nvoid flatten2(TreeNode *root) {\n    if (root == nullptr) return ;\n    stack<TreeNode *> st;\n    vector<TreeNode *> tvec;\n    while(true) {\n        while(root){\n            st.push(root);\n            tvec.push_back(root);\n            root = root->left;\n        }\n        if (st.empty() ) break;\n        root = st.top();\n        st.pop();\n        root = root->right;\n    }\n    int i;\n    for(i = 0;i < tvec.size() - 1;i++) {\n        tvec[i]->left = nullptr;\n        tvec[i]->right = tvec[i+1];\n    }\n    tvec[i]->left = nullptr;\n    tvec[i]->right = nullptr;\n}\n```\n\n考虑一下递归的去完成整个问题，我们可以先对左孩子和右孩子做一次`flatten`,然后再讲他们按照适当的顺序连接起来:\n\n```c++\nvoid flatten(TreeNode* root) {\n    if (root==NULL) return ;\n    flatten(root->left);\n    flatten(root->right);\n    auto right = root->right;\n    auto left = root->left;\n    if (left){\n        root->right = left;\n        root->left = NULL;\n        while(left->right)\n            left = left->right;\n        left->right = right;\n    }\n}\n```\n\n上面的做法由于每次都需要对左孩子有一个一直往右的遍历，所以耗时还是挺大的，可以加入一个last指针，去表示最后一个被访问的节点的位置,为了保证正确性，我们必须先对右孩子进行`flatten`再对左孩子进行`flatten`.\n\n```c++\nTreeNode *last;\nvoid flatten(TreeNode* root) {\n    if (root==NULL) return ;\n    flatten(root->right);\n    flatten(root->left);\n    root->right = last;\n    root->left = nullptr;\n    last = root;\n}\n```\n\n然后是在`dicuss`中看到的迭代算法：\n\n```c++\nvoid flatten(TreeNode *root) {\n    while (root) {\n        if (root->left && root->right) {\n            TreeNode* t = root->left;\n            while (t->right)\n                t = t->right;\n            t->right = root->right;\n        }\n\n        if(root->left)\n            root->right = root->left;\n        root->left = NULL;\n        root = root->right;\n    }\n}\n```\n","slug":"Flatten-Binary-Tree-to-Linked-List","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nt004qqmcmdg4h5yx0","content":"<p>第32天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/\">Flatten Binary Tree to Linked List</a>:</p>\n<blockquote>\n<p>Given a binary tree, flatten it to a linked list in-place.</p>\n<p>For example,<br>Given</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"number\">1</span></span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  <span class=\"number\">2</span>   <span class=\"number\">5</span></span><br><span class=\"line\"> / \\   \\</span><br><span class=\"line\"><span class=\"number\">3</span>   <span class=\"number\">4</span>   <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>The flattened tree should look like:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"> \\</span><br><span class=\"line\">  <span class=\"number\">2</span></span><br><span class=\"line\">   \\</span><br><span class=\"line\">    <span class=\"number\">3</span></span><br><span class=\"line\">     \\</span><br><span class=\"line\">      <span class=\"number\">4</span></span><br><span class=\"line\">       \\</span><br><span class=\"line\">        <span class=\"number\">5</span></span><br><span class=\"line\">         \\</span><br><span class=\"line\">          <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n\n<p>通过观察结果，我们可以发现它的顺序其实是一个先序遍历,那么我们可以先对树做一个先序遍历并记录节点指针，然后我们只需要将所有节点连接起来即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten2</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode *&gt; tvec;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root)&#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            tvec.push_back(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st.empty() ) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        root = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; tvec.size() - <span class=\"number\">1</span>;i++) &#123;</span><br><span class=\"line\">        tvec[i]-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        tvec[i]-&gt;right = tvec[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tvec[i]-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    tvec[i]-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>考虑一下递归的去完成整个问题，我们可以先对左孩子和右孩子做一次<code>flatten</code>,然后再讲他们按照适当的顺序连接起来:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    flatten(root-&gt;left);</span><br><span class=\"line\">    flatten(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> right = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = root-&gt;left;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left)&#123;</span><br><span class=\"line\">        root-&gt;right = left;</span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left-&gt;right)</span><br><span class=\"line\">            left = left-&gt;right;</span><br><span class=\"line\">        left-&gt;right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的做法由于每次都需要对左孩子有一个一直往右的遍历，所以耗时还是挺大的，可以加入一个last指针，去表示最后一个被访问的节点的位置,为了保证正确性，我们必须先对右孩子进行<code>flatten</code>再对左孩子进行<code>flatten</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TreeNode *last;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    flatten(root-&gt;right);</span><br><span class=\"line\">    flatten(root-&gt;left);</span><br><span class=\"line\">    root-&gt;right = last;</span><br><span class=\"line\">    root-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    last = root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的迭代算法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class=\"line\">            TreeNode* t = root-&gt;left;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (t-&gt;right)</span><br><span class=\"line\">                t = t-&gt;right;</span><br><span class=\"line\">            t-&gt;right = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;left)</span><br><span class=\"line\">            root-&gt;right = root-&gt;left;</span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第32天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/\">Flatten Binary Tree to Linked List</a>:</p>\n<blockquote>\n<p>Given a binary tree, flatten it to a linked list in-place.</p>\n<p>For example,<br>Given</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"number\">1</span></span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  <span class=\"number\">2</span>   <span class=\"number\">5</span></span><br><span class=\"line\"> / \\   \\</span><br><span class=\"line\"><span class=\"number\">3</span>   <span class=\"number\">4</span>   <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>The flattened tree should look like:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"> \\</span><br><span class=\"line\">  <span class=\"number\">2</span></span><br><span class=\"line\">   \\</span><br><span class=\"line\">    <span class=\"number\">3</span></span><br><span class=\"line\">     \\</span><br><span class=\"line\">      <span class=\"number\">4</span></span><br><span class=\"line\">       \\</span><br><span class=\"line\">        <span class=\"number\">5</span></span><br><span class=\"line\">         \\</span><br><span class=\"line\">          <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n\n<p>通过观察结果，我们可以发现它的顺序其实是一个先序遍历,那么我们可以先对树做一个先序遍历并记录节点指针，然后我们只需要将所有节点连接起来即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten2</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;TreeNode *&gt; tvec;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root)&#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            tvec.push_back(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st.empty() ) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        root = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; tvec.size() - <span class=\"number\">1</span>;i++) &#123;</span><br><span class=\"line\">        tvec[i]-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        tvec[i]-&gt;right = tvec[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tvec[i]-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    tvec[i]-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>考虑一下递归的去完成整个问题，我们可以先对左孩子和右孩子做一次<code>flatten</code>,然后再讲他们按照适当的顺序连接起来:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    flatten(root-&gt;left);</span><br><span class=\"line\">    flatten(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> right = root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = root-&gt;left;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left)&#123;</span><br><span class=\"line\">        root-&gt;right = left;</span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left-&gt;right)</span><br><span class=\"line\">            left = left-&gt;right;</span><br><span class=\"line\">        left-&gt;right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的做法由于每次都需要对左孩子有一个一直往右的遍历，所以耗时还是挺大的，可以加入一个last指针，去表示最后一个被访问的节点的位置,为了保证正确性，我们必须先对右孩子进行<code>flatten</code>再对左孩子进行<code>flatten</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TreeNode *last;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    flatten(root-&gt;right);</span><br><span class=\"line\">    flatten(root-&gt;left);</span><br><span class=\"line\">    root-&gt;right = last;</span><br><span class=\"line\">    root-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    last = root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的迭代算法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class=\"line\">            TreeNode* t = root-&gt;left;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (t-&gt;right)</span><br><span class=\"line\">                t = t-&gt;right;</span><br><span class=\"line\">            t-&gt;right = root-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;left)</span><br><span class=\"line\">            root-&gt;right = root-&gt;left;</span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Flatten-Nested-List-Iterator","date":"2018-02-14T07:27:39.000Z","_content":"\n第100天。\n\n今天的题目是[flatten-Nested-List-Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/description/):\n\n> Given a nested list of integers, implement an iterator to flatten it.\n>\n> Each element is either an integer, or a list -- whose elements may also be integers or other lists.\n>\n> Example 1:\n> Given the list [[1,1],2,[1,1]],\n>\n> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n>\n> Example 2:\n> Given the list [1,[4,[6]]],\n>\n> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n\n挺有趣的题目，主要是要实现一个嵌套列表的迭代器，大概是三个函数：\n\n```c++\nclass NestedIterator {\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        \n    }\n\n    int next() {\n        \n    }\n\n    bool hasNext() {\n        \n    }\n};\n```\n\n然后他也提供了`NestedInteger`的接口和一些说明，算是对题目的补充：\n```c++\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */\n```\n\n从补充中我们可以看到，在调用`next`前一定会先调用`hasNext`,有了这个前提我们写起来会方便一点。\n\n我的解法是，`NestedIterator`只保存构造函数中传入的`nestedList`的两个迭代器，之所以是两个，是因为要保存`end`迭代器，然后要实现嵌套，我们还要一个`NestedIterator`的指针，利用这个指针来对下一级列表的元素进行迭代：\n\n```c++\nclass NestedIterator {\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        _it = nestedList.begin(); _end_it = nestedList.end();\n        _tmp_it = nullptr;\n    }\n\n    int next() {\n        if (_it->isInteger()) { int ret = _it->getInteger(); ++_it; return ret; }\n        return _tmp_it->next();\n    }\n\n    bool hasNext() {\n        if (_it == _end_it) return false;\n        if (_it->isInteger()) return true;\n        \n        if (_tmp_it == nullptr) {\n            _tmp_it = new NestedIterator(_it->getList());\n        }\n        if (_tmp_it->hasNext()) return true;\n        delete _tmp_it; _tmp_it = nullptr; ++_it;\n        return hasNext();\n    }\nprivate:\n    vector<NestedInteger>::iterator _it, _end_it;\n    NestedIterator *_tmp_it;\n};\n```\n\n\n然后这里的实现虽然比较简单，简洁，但是在遇到一些特殊情况的时候会对性能造成极大的影响,比如说`[[[[[1,2,3]]]]]`,虽然只有三个元素，但是因为有5层的嵌套，我们要有5个迭代器，每次调用`next`和`hasNext`都需要递归调用5次才能返回，这样效率就有点低了.\n\n`dicuss`中的解法会比较好一点，类别`DFS`来做，先用`stack`保存所有的元素，在调用`hasNext`的时候，如果栈顶是列表就将其展开并压栈（倒序），然后在递归调用`hasNext`，直到栈顶为数字时,然后调用`next`就直接返回栈顶即可：\n\n```c++\nclass NestedIterator {\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        begins.push(nestedList.begin());\n        ends.push(nestedList.end());\n    }\n\n    int next() {\n        hasNext();\n        return (begins.top()++)->getInteger();\n    }\n\n    bool hasNext() {\n        while (begins.size()) {\n            if (begins.top() == ends.top()) {\n                begins.pop();\n                ends.pop();\n            } else {\n                auto x = begins.top();\n                if (x->isInteger())\n                    return true;\n                begins.top()++;\n                begins.push(x->getList().begin());\n                ends.push(x->getList().end());\n            }\n        }\n        return false;\n    }\n\nprivate:\n    stack<vector<NestedInteger>::iterator> begins, ends;\n};\n```\n\n---\n\n> update at 2020-04-03\n\n和第二个解法有点像，但是只需要一个栈即可：\n\n```c++\nclass NestedIterator {\npublic:\n    stack<vector<NestedInteger>::iterator> st;\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        reversePush(nestedList);\n    }\n    \n    void reversePush(vector<NestedInteger> &nestedList) {\n        auto beg = nestedList.begin();\n        for(int i = nestedList.size() - 1; i >= 0; --i) {\n            st.push(beg + i);\n        }\n    }\n\n    int next() {\n        auto top = st.top(); st.pop();\n        return top->getInteger();\n    }\n    \n    bool hasNext() {\n        while(!st.empty() && !st.top()->isInteger()) {\n            auto top = st.top(); st.pop();\n            reversePush(top->getList());\n        }\n        return !st.empty();\n    }\n};\n```\n","source":"_posts/Flatten-Nested-List-Iterator.md","raw":"---\ntitle: Flatten-Nested-List-Iterator\ndate: 2018-02-14T15:27:39.000Z\ntags:\n  - LeetCode\n  - Stack\n  - Design\ncategories:\n  - LeetCode\n---\n\n第100天。\n\n今天的题目是[flatten-Nested-List-Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/description/):\n\n> Given a nested list of integers, implement an iterator to flatten it.\n>\n> Each element is either an integer, or a list -- whose elements may also be integers or other lists.\n>\n> Example 1:\n> Given the list [[1,1],2,[1,1]],\n>\n> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n>\n> Example 2:\n> Given the list [1,[4,[6]]],\n>\n> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n\n挺有趣的题目，主要是要实现一个嵌套列表的迭代器，大概是三个函数：\n\n```c++\nclass NestedIterator {\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        \n    }\n\n    int next() {\n        \n    }\n\n    bool hasNext() {\n        \n    }\n};\n```\n\n然后他也提供了`NestedInteger`的接口和一些说明，算是对题目的补充：\n```c++\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */\n```\n\n从补充中我们可以看到，在调用`next`前一定会先调用`hasNext`,有了这个前提我们写起来会方便一点。\n\n我的解法是，`NestedIterator`只保存构造函数中传入的`nestedList`的两个迭代器，之所以是两个，是因为要保存`end`迭代器，然后要实现嵌套，我们还要一个`NestedIterator`的指针，利用这个指针来对下一级列表的元素进行迭代：\n\n```c++\nclass NestedIterator {\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        _it = nestedList.begin(); _end_it = nestedList.end();\n        _tmp_it = nullptr;\n    }\n\n    int next() {\n        if (_it->isInteger()) { int ret = _it->getInteger(); ++_it; return ret; }\n        return _tmp_it->next();\n    }\n\n    bool hasNext() {\n        if (_it == _end_it) return false;\n        if (_it->isInteger()) return true;\n        \n        if (_tmp_it == nullptr) {\n            _tmp_it = new NestedIterator(_it->getList());\n        }\n        if (_tmp_it->hasNext()) return true;\n        delete _tmp_it; _tmp_it = nullptr; ++_it;\n        return hasNext();\n    }\nprivate:\n    vector<NestedInteger>::iterator _it, _end_it;\n    NestedIterator *_tmp_it;\n};\n```\n\n\n然后这里的实现虽然比较简单，简洁，但是在遇到一些特殊情况的时候会对性能造成极大的影响,比如说`[[[[[1,2,3]]]]]`,虽然只有三个元素，但是因为有5层的嵌套，我们要有5个迭代器，每次调用`next`和`hasNext`都需要递归调用5次才能返回，这样效率就有点低了.\n\n`dicuss`中的解法会比较好一点，类别`DFS`来做，先用`stack`保存所有的元素，在调用`hasNext`的时候，如果栈顶是列表就将其展开并压栈（倒序），然后在递归调用`hasNext`，直到栈顶为数字时,然后调用`next`就直接返回栈顶即可：\n\n```c++\nclass NestedIterator {\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        begins.push(nestedList.begin());\n        ends.push(nestedList.end());\n    }\n\n    int next() {\n        hasNext();\n        return (begins.top()++)->getInteger();\n    }\n\n    bool hasNext() {\n        while (begins.size()) {\n            if (begins.top() == ends.top()) {\n                begins.pop();\n                ends.pop();\n            } else {\n                auto x = begins.top();\n                if (x->isInteger())\n                    return true;\n                begins.top()++;\n                begins.push(x->getList().begin());\n                ends.push(x->getList().end());\n            }\n        }\n        return false;\n    }\n\nprivate:\n    stack<vector<NestedInteger>::iterator> begins, ends;\n};\n```\n\n---\n\n> update at 2020-04-03\n\n和第二个解法有点像，但是只需要一个栈即可：\n\n```c++\nclass NestedIterator {\npublic:\n    stack<vector<NestedInteger>::iterator> st;\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        reversePush(nestedList);\n    }\n    \n    void reversePush(vector<NestedInteger> &nestedList) {\n        auto beg = nestedList.begin();\n        for(int i = nestedList.size() - 1; i >= 0; --i) {\n            st.push(beg + i);\n        }\n    }\n\n    int next() {\n        auto top = st.top(); st.pop();\n        return top->getInteger();\n    }\n    \n    bool hasNext() {\n        while(!st.empty() && !st.top()->isInteger()) {\n            auto top = st.top(); st.pop();\n            reversePush(top->getList());\n        }\n        return !st.empty();\n    }\n};\n```\n","slug":"Flatten-Nested-List-Iterator","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nt004tqmcmedvzf1mj","content":"<p>第100天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flatten-nested-list-iterator/description/\">flatten-Nested-List-Iterator</a>:</p>\n<blockquote>\n<p>Given a nested list of integers, implement an iterator to flatten it.</p>\n<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>\n<p>Example 1:<br>Given the list [[1,1],2,[1,1]],</p>\n<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</p>\n<p>Example 2:<br>Given the list [1,[4,[6]]],</p>\n<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</p>\n</blockquote>\n<p>挺有趣的题目，主要是要实现一个嵌套列表的迭代器，大概是三个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    NestedIterator(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后他也提供了<code>NestedInteger</code>的接口和一些说明，算是对题目的补充：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // This is the interface that allows for creating nested lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * // You should not implement it, or speculate about its implementation</span></span><br><span class=\"line\"><span class=\"comment\"> * class NestedInteger &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *   public:</span></span><br><span class=\"line\"><span class=\"comment\"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class=\"line\"><span class=\"comment\"> *     bool isInteger() const;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class=\"line\"><span class=\"comment\"> *     int getInteger() const;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class=\"line\"><span class=\"comment\"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * NestedIterator i(nestedList);</span></span><br><span class=\"line\"><span class=\"comment\"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>从补充中我们可以看到，在调用<code>next</code>前一定会先调用<code>hasNext</code>,有了这个前提我们写起来会方便一点。</p>\n<p>我的解法是，<code>NestedIterator</code>只保存构造函数中传入的<code>nestedList</code>的两个迭代器，之所以是两个，是因为要保存<code>end</code>迭代器，然后要实现嵌套，我们还要一个<code>NestedIterator</code>的指针，利用这个指针来对下一级列表的元素进行迭代：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    NestedIterator(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class=\"line\">        _it = nestedList.begin(); _end_it = nestedList.end();</span><br><span class=\"line\">        _tmp_it = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_it-&gt;isInteger()) &#123; <span class=\"keyword\">int</span> ret = _it-&gt;getInteger(); ++_it; <span class=\"keyword\">return</span> ret; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _tmp_it-&gt;next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_it == _end_it) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_it-&gt;isInteger()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_tmp_it == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _tmp_it = <span class=\"keyword\">new</span> NestedIterator(_it-&gt;getList());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_tmp_it-&gt;hasNext()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> _tmp_it; _tmp_it = <span class=\"literal\">nullptr</span>; ++_it;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasNext();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;NestedInteger&gt;::iterator _it, _end_it;</span><br><span class=\"line\">    NestedIterator *_tmp_it;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>然后这里的实现虽然比较简单，简洁，但是在遇到一些特殊情况的时候会对性能造成极大的影响,比如说<code>[[[[[1,2,3]]]]]</code>,虽然只有三个元素，但是因为有5层的嵌套，我们要有5个迭代器，每次调用<code>next</code>和<code>hasNext</code>都需要递归调用5次才能返回，这样效率就有点低了.</p>\n<p><code>dicuss</code>中的解法会比较好一点，类别<code>DFS</code>来做，先用<code>stack</code>保存所有的元素，在调用<code>hasNext</code>的时候，如果栈顶是列表就将其展开并压栈（倒序），然后在递归调用<code>hasNext</code>，直到栈顶为数字时,然后调用<code>next</code>就直接返回栈顶即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    NestedIterator(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class=\"line\">        begins.push(nestedList.begin());</span><br><span class=\"line\">        ends.push(nestedList.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        hasNext();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (begins.top()++)-&gt;getInteger();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (begins.size()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (begins.top() == ends.top()) &#123;</span><br><span class=\"line\">                begins.pop();</span><br><span class=\"line\">                ends.pop();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> x = begins.top();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x-&gt;isInteger())</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                begins.top()++;</span><br><span class=\"line\">                begins.push(x-&gt;getList().begin());</span><br><span class=\"line\">                ends.push(x-&gt;getList().end());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">vector</span>&lt;NestedInteger&gt;::iterator&gt; begins, ends;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>update at 2020-04-03</p>\n</blockquote>\n<p>和第二个解法有点像，但是只需要一个栈即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">vector</span>&lt;NestedInteger&gt;::iterator&gt; st;</span><br><span class=\"line\">    NestedIterator(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class=\"line\">        reversePush(nestedList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reversePush</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> beg = nestedList.begin();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nestedList.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            st.push(beg + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> top = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> top-&gt;getInteger();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.empty() &amp;&amp; !st.top()-&gt;isInteger()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> top = st.top(); st.pop();</span><br><span class=\"line\">            reversePush(top-&gt;getList());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !st.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第100天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flatten-nested-list-iterator/description/\">flatten-Nested-List-Iterator</a>:</p>\n<blockquote>\n<p>Given a nested list of integers, implement an iterator to flatten it.</p>\n<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>\n<p>Example 1:<br>Given the list [[1,1],2,[1,1]],</p>\n<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</p>\n<p>Example 2:<br>Given the list [1,[4,[6]]],</p>\n<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</p>\n</blockquote>\n<p>挺有趣的题目，主要是要实现一个嵌套列表的迭代器，大概是三个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    NestedIterator(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后他也提供了<code>NestedInteger</code>的接口和一些说明，算是对题目的补充：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // This is the interface that allows for creating nested lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * // You should not implement it, or speculate about its implementation</span></span><br><span class=\"line\"><span class=\"comment\"> * class NestedInteger &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *   public:</span></span><br><span class=\"line\"><span class=\"comment\"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class=\"line\"><span class=\"comment\"> *     bool isInteger() const;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class=\"line\"><span class=\"comment\"> *     int getInteger() const;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class=\"line\"><span class=\"comment\"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * NestedIterator i(nestedList);</span></span><br><span class=\"line\"><span class=\"comment\"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>从补充中我们可以看到，在调用<code>next</code>前一定会先调用<code>hasNext</code>,有了这个前提我们写起来会方便一点。</p>\n<p>我的解法是，<code>NestedIterator</code>只保存构造函数中传入的<code>nestedList</code>的两个迭代器，之所以是两个，是因为要保存<code>end</code>迭代器，然后要实现嵌套，我们还要一个<code>NestedIterator</code>的指针，利用这个指针来对下一级列表的元素进行迭代：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    NestedIterator(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class=\"line\">        _it = nestedList.begin(); _end_it = nestedList.end();</span><br><span class=\"line\">        _tmp_it = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_it-&gt;isInteger()) &#123; <span class=\"keyword\">int</span> ret = _it-&gt;getInteger(); ++_it; <span class=\"keyword\">return</span> ret; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _tmp_it-&gt;next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_it == _end_it) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_it-&gt;isInteger()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_tmp_it == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            _tmp_it = <span class=\"keyword\">new</span> NestedIterator(_it-&gt;getList());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_tmp_it-&gt;hasNext()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> _tmp_it; _tmp_it = <span class=\"literal\">nullptr</span>; ++_it;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasNext();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;NestedInteger&gt;::iterator _it, _end_it;</span><br><span class=\"line\">    NestedIterator *_tmp_it;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>然后这里的实现虽然比较简单，简洁，但是在遇到一些特殊情况的时候会对性能造成极大的影响,比如说<code>[[[[[1,2,3]]]]]</code>,虽然只有三个元素，但是因为有5层的嵌套，我们要有5个迭代器，每次调用<code>next</code>和<code>hasNext</code>都需要递归调用5次才能返回，这样效率就有点低了.</p>\n<p><code>dicuss</code>中的解法会比较好一点，类别<code>DFS</code>来做，先用<code>stack</code>保存所有的元素，在调用<code>hasNext</code>的时候，如果栈顶是列表就将其展开并压栈（倒序），然后在递归调用<code>hasNext</code>，直到栈顶为数字时,然后调用<code>next</code>就直接返回栈顶即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    NestedIterator(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class=\"line\">        begins.push(nestedList.begin());</span><br><span class=\"line\">        ends.push(nestedList.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        hasNext();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (begins.top()++)-&gt;getInteger();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (begins.size()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (begins.top() == ends.top()) &#123;</span><br><span class=\"line\">                begins.pop();</span><br><span class=\"line\">                ends.pop();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> x = begins.top();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x-&gt;isInteger())</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                begins.top()++;</span><br><span class=\"line\">                begins.push(x-&gt;getList().begin());</span><br><span class=\"line\">                ends.push(x-&gt;getList().end());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">vector</span>&lt;NestedInteger&gt;::iterator&gt; begins, ends;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>update at 2020-04-03</p>\n</blockquote>\n<p>和第二个解法有点像，但是只需要一个栈即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">vector</span>&lt;NestedInteger&gt;::iterator&gt; st;</span><br><span class=\"line\">    NestedIterator(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class=\"line\">        reversePush(nestedList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reversePush</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;NestedInteger&gt; &amp;nestedList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> beg = nestedList.begin();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nestedList.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            st.push(beg + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> top = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> top-&gt;getInteger();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.empty() &amp;&amp; !st.top()-&gt;isInteger()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> top = st.top(); st.pop();</span><br><span class=\"line\">            reversePush(top-&gt;getList());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !st.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Flatten a Multilevel Doubly Linked List","date":"2019-12-19T02:11:29.000Z","_content":"\n> 第43天。\n\n今天的题目是[Flatten a Multilevel Doubly Linked List](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/):\n\n蛮好玩的一道题。\n\n本来想用递归做的，但是发现好像需要一层一层的返回最后一个指针，觉得有点麻烦，就直接用栈做了。\n\n这个栈是用来保存上一层的指针的，而且看起来每一层最多一个节点有`child`，所以我们可以这样做：\n\n- 遍历当前层，如果有孩子，则把当前节点压入栈中，并跳到下一层去遍历\n- 如果遍历完当前层，则从栈中取出`parent`，然后进行`flatten`,为了避免没有必要的重复遍历，当前层最后一个节点压入栈中,这样下一次遍历时，就从上一层中第一个未被遍历的节点开始了。\n\n代码如下：\n\n```c++\nNode* flatten(Node* head) {\n    if (head == nullptr) return nullptr;\n    stack<Node*> st;\n    st.push(head);\n    // if (head->child) st.push(head->child);\n    while(!st.empty()) {\n        Node *p = st.top(); st.pop();\n        while(!p->child && p->next) {\n            p = p->next;\n        }\n        if (p->child) {\n            st.push(p);\n            st.push(p->child);\n        } else if (!st.empty()) {\n            Node *parent = st.top(); st.pop();\n            p->next = parent->next;\n            if (p->next) p->next->prev = p;\n            parent->next = parent->child;\n            parent->next->prev = parent;\n            parent->child = nullptr;\n            st.push(p);\n        }\n    }\n    return head;\n}\n```\n","source":"_posts/Flatten-a-Multilevel-Doubly-Linked-List.md","raw":"---\ntitle: Flatten a Multilevel Doubly Linked List\ndate: 2019-12-19T10:11:29.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第43天。\n\n今天的题目是[Flatten a Multilevel Doubly Linked List](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/):\n\n蛮好玩的一道题。\n\n本来想用递归做的，但是发现好像需要一层一层的返回最后一个指针，觉得有点麻烦，就直接用栈做了。\n\n这个栈是用来保存上一层的指针的，而且看起来每一层最多一个节点有`child`，所以我们可以这样做：\n\n- 遍历当前层，如果有孩子，则把当前节点压入栈中，并跳到下一层去遍历\n- 如果遍历完当前层，则从栈中取出`parent`，然后进行`flatten`,为了避免没有必要的重复遍历，当前层最后一个节点压入栈中,这样下一次遍历时，就从上一层中第一个未被遍历的节点开始了。\n\n代码如下：\n\n```c++\nNode* flatten(Node* head) {\n    if (head == nullptr) return nullptr;\n    stack<Node*> st;\n    st.push(head);\n    // if (head->child) st.push(head->child);\n    while(!st.empty()) {\n        Node *p = st.top(); st.pop();\n        while(!p->child && p->next) {\n            p = p->next;\n        }\n        if (p->child) {\n            st.push(p);\n            st.push(p->child);\n        } else if (!st.empty()) {\n            Node *parent = st.top(); st.pop();\n            p->next = parent->next;\n            if (p->next) p->next->prev = p;\n            parent->next = parent->child;\n            parent->next->prev = parent;\n            parent->child = nullptr;\n            st.push(p);\n        }\n    }\n    return head;\n}\n```\n","slug":"Flatten-a-Multilevel-Doubly-Linked-List","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nv004wqmcmc1f600e9","content":"<blockquote>\n<p>第43天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/\">Flatten a Multilevel Doubly Linked List</a>:</p>\n<p>蛮好玩的一道题。</p>\n<p>本来想用递归做的，但是发现好像需要一层一层的返回最后一个指针，觉得有点麻烦，就直接用栈做了。</p>\n<p>这个栈是用来保存上一层的指针的，而且看起来每一层最多一个节点有<code>child</code>，所以我们可以这样做：</p>\n<ul>\n<li>遍历当前层，如果有孩子，则把当前节点压入栈中，并跳到下一层去遍历</li>\n<li>如果遍历完当前层，则从栈中取出<code>parent</code>，然后进行<code>flatten</code>,为了避免没有必要的重复遍历，当前层最后一个节点压入栈中,这样下一次遍历时，就从上一层中第一个未被遍历的节点开始了。</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">flatten</span><span class=\"params\">(Node* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;Node*&gt; st;</span><br><span class=\"line\">    st.push(head);</span><br><span class=\"line\">    <span class=\"comment\">// if (head-&gt;child) st.push(head-&gt;child);</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">        Node *p = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!p-&gt;child &amp;&amp; p-&gt;next) &#123;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;child) &#123;</span><br><span class=\"line\">            st.push(p);</span><br><span class=\"line\">            st.push(p-&gt;child);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!st.empty()) &#123;</span><br><span class=\"line\">            Node *parent = st.top(); st.pop();</span><br><span class=\"line\">            p-&gt;next = parent-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;next) p-&gt;next-&gt;prev = p;</span><br><span class=\"line\">            parent-&gt;next = parent-&gt;child;</span><br><span class=\"line\">            parent-&gt;next-&gt;prev = parent;</span><br><span class=\"line\">            parent-&gt;child = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            st.push(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第43天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/\">Flatten a Multilevel Doubly Linked List</a>:</p>\n<p>蛮好玩的一道题。</p>\n<p>本来想用递归做的，但是发现好像需要一层一层的返回最后一个指针，觉得有点麻烦，就直接用栈做了。</p>\n<p>这个栈是用来保存上一层的指针的，而且看起来每一层最多一个节点有<code>child</code>，所以我们可以这样做：</p>\n<ul>\n<li>遍历当前层，如果有孩子，则把当前节点压入栈中，并跳到下一层去遍历</li>\n<li>如果遍历完当前层，则从栈中取出<code>parent</code>，然后进行<code>flatten</code>,为了避免没有必要的重复遍历，当前层最后一个节点压入栈中,这样下一次遍历时，就从上一层中第一个未被遍历的节点开始了。</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">flatten</span><span class=\"params\">(Node* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;Node*&gt; st;</span><br><span class=\"line\">    st.push(head);</span><br><span class=\"line\">    <span class=\"comment\">// if (head-&gt;child) st.push(head-&gt;child);</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">        Node *p = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!p-&gt;child &amp;&amp; p-&gt;next) &#123;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;child) &#123;</span><br><span class=\"line\">            st.push(p);</span><br><span class=\"line\">            st.push(p-&gt;child);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!st.empty()) &#123;</span><br><span class=\"line\">            Node *parent = st.top(); st.pop();</span><br><span class=\"line\">            p-&gt;next = parent-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;next) p-&gt;next-&gt;prev = p;</span><br><span class=\"line\">            parent-&gt;next = parent-&gt;child;</span><br><span class=\"line\">            parent-&gt;next-&gt;prev = parent;</span><br><span class=\"line\">            parent-&gt;child = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            st.push(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Flip Equivalent Binary Trees","date":"2020-01-05T13:16:03.000Z","_content":"\n> 第56天。\n\n今天的题目是[Flip Equivalent Binary Trees](https://leetcode.com/problems/flip-equivalent-binary-trees/):\n\n简单题，先序遍历判断当前节点的值是否相等，如果不相等则返回`false`，如果相等的话，判断两个子树是否`filpEquiv`：\n\n```c++\nbool flipEquiv(TreeNode* root1, TreeNode* root2) {\n    if (!root1 && !root2) return true;\n    else if (root1 && root2 && root1->val == root2->val) {\n        return (flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right))\n                || (flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left));    \n    } else return false;\n}\n```\n","source":"_posts/Flip-Equivalent-Binary-Trees.md","raw":"---\ntitle: Flip Equivalent Binary Trees\ndate: 2020-01-05T21:16:03.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第56天。\n\n今天的题目是[Flip Equivalent Binary Trees](https://leetcode.com/problems/flip-equivalent-binary-trees/):\n\n简单题，先序遍历判断当前节点的值是否相等，如果不相等则返回`false`，如果相等的话，判断两个子树是否`filpEquiv`：\n\n```c++\nbool flipEquiv(TreeNode* root1, TreeNode* root2) {\n    if (!root1 && !root2) return true;\n    else if (root1 && root2 && root1->val == root2->val) {\n        return (flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right))\n                || (flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left));    \n    } else return false;\n}\n```\n","slug":"Flip-Equivalent-Binary-Trees","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nv004zqmcmgjm1687z","content":"<blockquote>\n<p>第56天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flip-equivalent-binary-trees/\">Flip Equivalent Binary Trees</a>:</p>\n<p>简单题，先序遍历判断当前节点的值是否相等，如果不相等则返回<code>false</code>，如果相等的话，判断两个子树是否<code>filpEquiv</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">flipEquiv</span><span class=\"params\">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root1 &amp;&amp; !root2) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root1 &amp;&amp; root2 &amp;&amp; root1-&gt;val == root2-&gt;val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (flipEquiv(root1-&gt;left, root2-&gt;left) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;right))</span><br><span class=\"line\">                || (flipEquiv(root1-&gt;left, root2-&gt;right) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;left));    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第56天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flip-equivalent-binary-trees/\">Flip Equivalent Binary Trees</a>:</p>\n<p>简单题，先序遍历判断当前节点的值是否相等，如果不相等则返回<code>false</code>，如果相等的话，判断两个子树是否<code>filpEquiv</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">flipEquiv</span><span class=\"params\">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root1 &amp;&amp; !root2) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root1 &amp;&amp; root2 &amp;&amp; root1-&gt;val == root2-&gt;val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (flipEquiv(root1-&gt;left, root2-&gt;left) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;right))</span><br><span class=\"line\">                || (flipEquiv(root1-&gt;left, root2-&gt;right) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;left));    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Flipping an Image","date":"2019-12-23T01:52:11.000Z","_content":"\n> 第47天\n\n今天的题目是[Flipping an Image](https://leetcode.com/problems/flipping-an-image/):\n\n考试周，做一道`Easy`题。\n\n```c++\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\n    int t;\n    for(auto &v: A) {\n        for(int i = 0, j = v.size() - 1;i <= j; i++, j--) {\n            t = (v[j]==1) ? 0 : 1;\n            v[j] = (v[i]==1) ? 0 : 1;\n            v[i] = t;\n        }\n    }\n    return A;\n}\n```\n","source":"_posts/Flipping-an-Image.md","raw":"---\ntitle: Flipping an Image\ndate: 2019-12-23T09:52:11.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第47天\n\n今天的题目是[Flipping an Image](https://leetcode.com/problems/flipping-an-image/):\n\n考试周，做一道`Easy`题。\n\n```c++\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\n    int t;\n    for(auto &v: A) {\n        for(int i = 0, j = v.size() - 1;i <= j; i++, j--) {\n            t = (v[j]==1) ? 0 : 1;\n            v[j] = (v[i]==1) ? 0 : 1;\n            v[i] = t;\n        }\n    }\n    return A;\n}\n```\n","slug":"Flipping-an-Image","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nw0052qmcm8dx685xu","content":"<blockquote>\n<p>第47天</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flipping-an-image/\">Flipping an Image</a>:</p>\n<p>考试周，做一道<code>Easy</code>题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; flipAndInvertImage(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;v: A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = v.size() - <span class=\"number\">1</span>;i &lt;= j; i++, j--) &#123;</span><br><span class=\"line\">            t = (v[j]==<span class=\"number\">1</span>) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">            v[j] = (v[i]==<span class=\"number\">1</span>) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">            v[i] = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第47天</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/flipping-an-image/\">Flipping an Image</a>:</p>\n<p>考试周，做一道<code>Easy</code>题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; flipAndInvertImage(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;v: A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = v.size() - <span class=\"number\">1</span>;i &lt;= j; i++, j--) &#123;</span><br><span class=\"line\">            t = (v[j]==<span class=\"number\">1</span>) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">            v[j] = (v[i]==<span class=\"number\">1</span>) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">            v[i] = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Friend Circles","date":"2019-12-10T05:34:41.000Z","_content":"\n> 第34天。\n\n今天的题目是[Friend Circles](https://leetcode.com/problems/friend-circles/):\n\n一道图论的题目，求连通分量的个数。这道题之前考研复试面试时遇到过。\n\n用并查集去做会比较快，但是需要对并查集做一定修改。\n\n简单来说，并查集的数组全初始化为0，然后在遍历到`M[i][j]==true`时进行`union`操作.\n\n遍历完后，`arr`中值为`-1`的元素的个数就是连通分量的个数：\n\n```c++\nvector<int> arr;\nint root(vector<int> &arr, int i) {\n    int root = i;\n    while(arr[root] != -1) root = arr[root];\n    return root;\n}\nvoid unionFunc(int i, int j) {\n    i = root(arr, i); \n    j = root(arr, j);\n    if (i == j) return;\n    arr[j] = i;\n}\nint findCircleNum(vector<vector<int>>& M) {\n    if (M.size() == 0) return 0;\n    \n    int size = M.size();\n    arr = vector<int>(size, -1);\n    \n    for(int i = 0;i < size; i++) {\n        for(int j = i+1;j < size; j++) {\n            if (M[i][j]) {\n                unionFunc(i, j);\n            }   \n        }\n    }\n    \n    int res = 0;\n    for(int i = 0;i < size; i++) res += (arr[i] == -1);\n    return res;\n}\n```\n","source":"_posts/Friend-Circles.md","raw":"---\ntitle: Friend Circles\ndate: 2019-12-10T13:34:41.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第34天。\n\n今天的题目是[Friend Circles](https://leetcode.com/problems/friend-circles/):\n\n一道图论的题目，求连通分量的个数。这道题之前考研复试面试时遇到过。\n\n用并查集去做会比较快，但是需要对并查集做一定修改。\n\n简单来说，并查集的数组全初始化为0，然后在遍历到`M[i][j]==true`时进行`union`操作.\n\n遍历完后，`arr`中值为`-1`的元素的个数就是连通分量的个数：\n\n```c++\nvector<int> arr;\nint root(vector<int> &arr, int i) {\n    int root = i;\n    while(arr[root] != -1) root = arr[root];\n    return root;\n}\nvoid unionFunc(int i, int j) {\n    i = root(arr, i); \n    j = root(arr, j);\n    if (i == j) return;\n    arr[j] = i;\n}\nint findCircleNum(vector<vector<int>>& M) {\n    if (M.size() == 0) return 0;\n    \n    int size = M.size();\n    arr = vector<int>(size, -1);\n    \n    for(int i = 0;i < size; i++) {\n        for(int j = i+1;j < size; j++) {\n            if (M[i][j]) {\n                unionFunc(i, j);\n            }   \n        }\n    }\n    \n    int res = 0;\n    for(int i = 0;i < size; i++) res += (arr[i] == -1);\n    return res;\n}\n```\n","slug":"Friend-Circles","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nx0055qmcmgo7whsso","content":"<blockquote>\n<p>第34天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/friend-circles/\">Friend Circles</a>:</p>\n<p>一道图论的题目，求连通分量的个数。这道题之前考研复试面试时遇到过。</p>\n<p>用并查集去做会比较快，但是需要对并查集做一定修改。</p>\n<p>简单来说，并查集的数组全初始化为0，然后在遍历到<code>M[i][j]==true</code>时进行<code>union</code>操作.</p>\n<p>遍历完后，<code>arr</code>中值为<code>-1</code>的元素的个数就是连通分量的个数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; arr;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;arr, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> root = i;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(arr[root] != <span class=\"number\">-1</span>) root = arr[root];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unionFunc</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    i = root(arr, i); </span><br><span class=\"line\">    j = root(arr, j);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == j) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    arr[j] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (M.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = M.size();</span><br><span class=\"line\">    arr = <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(size, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>;j &lt; size; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (M[i][j]) &#123;</span><br><span class=\"line\">                unionFunc(i, j);</span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) res += (arr[i] == <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第34天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/friend-circles/\">Friend Circles</a>:</p>\n<p>一道图论的题目，求连通分量的个数。这道题之前考研复试面试时遇到过。</p>\n<p>用并查集去做会比较快，但是需要对并查集做一定修改。</p>\n<p>简单来说，并查集的数组全初始化为0，然后在遍历到<code>M[i][j]==true</code>时进行<code>union</code>操作.</p>\n<p>遍历完后，<code>arr</code>中值为<code>-1</code>的元素的个数就是连通分量的个数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; arr;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;arr, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> root = i;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(arr[root] != <span class=\"number\">-1</span>) root = arr[root];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unionFunc</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    i = root(arr, i); </span><br><span class=\"line\">    j = root(arr, j);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == j) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    arr[j] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (M.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = M.size();</span><br><span class=\"line\">    arr = <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(size, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>;j &lt; size; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (M[i][j]) &#123;</span><br><span class=\"line\">                unionFunc(i, j);</span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) res += (arr[i] == <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Generate Parentheses","date":"2017-10-08T03:16:45.000Z","_content":"\n打卡，第15天\n\n今天做了一道比较好玩的题，之前有做个一个括号匹配的题目，今天的题目刚好反过来，不是验证括号是否正确，而是生成正确括号——[Generate Parentheses](https://leetcode.com/problems/generate-parentheses/description/).\n\n题目描述：\n\n> Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n> \n> For example, given n = 3, a solution set is:\n\n```python\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n```\n\n\n再看看`n = 2`时：\n\n```python\n[\n    \"(())\",\n    \"()()\",\n]\n```\n\n\n我们观察上面的例子，可以发现n=3,其实是由n=2加上一个`()`组合起来的，可以分成三种情况：\n\n* 在前面加上`()`,\n* 在后面加上`()`,\n* 在前面加上`(`后面加上`)`\n\n我们大概可以写出这样的代码：\n\n```c++\nvector<string> generateParenthesis1(int n) {\n    if (n == 1) return {\"()\"};\n    set<string> ret;\n\n    vector<string> r = generateParenthesis(n-1);\n    for(auto s:r){\n        ret.insert(s+\"()\");\n        ret.insert(\"()\" + s);\n        ret.insert(\"(\" + s + \")\");\n    }\n\n    return {ret.begin(),ret.end()};\n}\n```\n\n这样在`n <= 3`时是ok的，但是如果`n = 4`还有一种可能，就是`(())(())`,这时由两个`n=2`的括号组合而成的，以及`n = 5`时，可以由`n = 3`和`n = 2`组合而成，也可以由`n = 1`和`n = 4`组合而成。\n\n故我们可以做以下改进，得到正确答案：\n\n```c++\nvector<string> generateParenthesis1(int n) {\n    if (n == 1) return {\"()\"};\n    set<string> ret;\n\n    vector<string> r = generateParenthesis(n-1);\n    for(auto s:r){\n        ret.insert(s+\"()\");\n        ret.insert(\"()\" + s);\n        ret.insert(\"(\" + s + \")\");\n    }\n\n    for(int i = n/2;i > 1;i--) {\n        vector<string> r1 = generateParenthesis(n - i);\n        vector<string> r2 = generateParenthesis(i);\n        for(auto s1:r1)\n            for(auto s2:r2) {\n                ret.insert(s1+s2);\n                ret.insert(s2+s1);\n            }\n    }\n\n    return {ret.begin(),ret.end()};\n}\n```\n\n可以发现，这里出现了很多次重复计算，可以用动态规划去做：\n\n```c++\nvector<string> generateParenthesis(int n) {\n    vector<vector<string> > par{\n        {\"\"}\n    };\n\n    for(int i = 1;i <= n;i++) {\n        set<string> now;\n        for(auto s:par[i-1]) {\n            now.insert(s + \"()\");\n            now.insert(\"()\" + s);\n            now.insert(\"(\" + s + \")\");\n        }\n        int l = 1;\n        int r = i - l;\n        while(r >= l) {\n            //cout << l << \" \" << r << endl;\n            for(auto s1:par[l])\n                for(auto s2:par[r]){\n                    //cout << s1 << \" \" << s2 << endl;\n                    now.insert(s1+s2);\n                    now.insert(s2+s1);\n                }\n            l++;\n            r--;\n        }\n        par.push_back({now.begin(),now.end()});\n    }\n    return par[n];\n}\n```\n\n然后是在`discuss`中看到的另一种思路：\n\n```c++\nvector<string> result;\nvector<string> generateParenthesis(int n) {\n    helper(\"\", n, 0);\n    return result;\n}\n\n/*  this hepler function insert result strings to \"vector<string> result\"\n    When number of '(' less than \"n\", can append '(';\n    When number of '(' is more than number of ')', can append ')';\n\n    string s : current string;\n    int leftpare_need : number of '(' that have not put into \"string s\";\n    int moreleft : number of '(' minus number of ')' in the \"string s\";\n*/\n\nvoid helper(string s, int leftpare_need, int moreleft)\n{\n    if(leftpare_need == 0 && moreleft == 0)\n    {\n        result.push_back(s);\n        return;\n    }\n    if(leftpare_need > 0)\n        helper(s + \"(\", leftpare_need - 1, moreleft+1);\n    if(moreleft > 0)\n        helper(s + \")\", leftpare_need, moreleft - 1);\n}\n```\n\n这个的想法是，不断的生成左括号，有左括号，后面就一定会生成一个右括号。\n","source":"_posts/Generate-Parentheses.md","raw":"---\ntitle: Generate Parentheses\ndate: 2017-10-08T11:16:45.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n打卡，第15天\n\n今天做了一道比较好玩的题，之前有做个一个括号匹配的题目，今天的题目刚好反过来，不是验证括号是否正确，而是生成正确括号——[Generate Parentheses](https://leetcode.com/problems/generate-parentheses/description/).\n\n题目描述：\n\n> Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n> \n> For example, given n = 3, a solution set is:\n\n```python\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n```\n\n\n再看看`n = 2`时：\n\n```python\n[\n    \"(())\",\n    \"()()\",\n]\n```\n\n\n我们观察上面的例子，可以发现n=3,其实是由n=2加上一个`()`组合起来的，可以分成三种情况：\n\n* 在前面加上`()`,\n* 在后面加上`()`,\n* 在前面加上`(`后面加上`)`\n\n我们大概可以写出这样的代码：\n\n```c++\nvector<string> generateParenthesis1(int n) {\n    if (n == 1) return {\"()\"};\n    set<string> ret;\n\n    vector<string> r = generateParenthesis(n-1);\n    for(auto s:r){\n        ret.insert(s+\"()\");\n        ret.insert(\"()\" + s);\n        ret.insert(\"(\" + s + \")\");\n    }\n\n    return {ret.begin(),ret.end()};\n}\n```\n\n这样在`n <= 3`时是ok的，但是如果`n = 4`还有一种可能，就是`(())(())`,这时由两个`n=2`的括号组合而成的，以及`n = 5`时，可以由`n = 3`和`n = 2`组合而成，也可以由`n = 1`和`n = 4`组合而成。\n\n故我们可以做以下改进，得到正确答案：\n\n```c++\nvector<string> generateParenthesis1(int n) {\n    if (n == 1) return {\"()\"};\n    set<string> ret;\n\n    vector<string> r = generateParenthesis(n-1);\n    for(auto s:r){\n        ret.insert(s+\"()\");\n        ret.insert(\"()\" + s);\n        ret.insert(\"(\" + s + \")\");\n    }\n\n    for(int i = n/2;i > 1;i--) {\n        vector<string> r1 = generateParenthesis(n - i);\n        vector<string> r2 = generateParenthesis(i);\n        for(auto s1:r1)\n            for(auto s2:r2) {\n                ret.insert(s1+s2);\n                ret.insert(s2+s1);\n            }\n    }\n\n    return {ret.begin(),ret.end()};\n}\n```\n\n可以发现，这里出现了很多次重复计算，可以用动态规划去做：\n\n```c++\nvector<string> generateParenthesis(int n) {\n    vector<vector<string> > par{\n        {\"\"}\n    };\n\n    for(int i = 1;i <= n;i++) {\n        set<string> now;\n        for(auto s:par[i-1]) {\n            now.insert(s + \"()\");\n            now.insert(\"()\" + s);\n            now.insert(\"(\" + s + \")\");\n        }\n        int l = 1;\n        int r = i - l;\n        while(r >= l) {\n            //cout << l << \" \" << r << endl;\n            for(auto s1:par[l])\n                for(auto s2:par[r]){\n                    //cout << s1 << \" \" << s2 << endl;\n                    now.insert(s1+s2);\n                    now.insert(s2+s1);\n                }\n            l++;\n            r--;\n        }\n        par.push_back({now.begin(),now.end()});\n    }\n    return par[n];\n}\n```\n\n然后是在`discuss`中看到的另一种思路：\n\n```c++\nvector<string> result;\nvector<string> generateParenthesis(int n) {\n    helper(\"\", n, 0);\n    return result;\n}\n\n/*  this hepler function insert result strings to \"vector<string> result\"\n    When number of '(' less than \"n\", can append '(';\n    When number of '(' is more than number of ')', can append ')';\n\n    string s : current string;\n    int leftpare_need : number of '(' that have not put into \"string s\";\n    int moreleft : number of '(' minus number of ')' in the \"string s\";\n*/\n\nvoid helper(string s, int leftpare_need, int moreleft)\n{\n    if(leftpare_need == 0 && moreleft == 0)\n    {\n        result.push_back(s);\n        return;\n    }\n    if(leftpare_need > 0)\n        helper(s + \"(\", leftpare_need - 1, moreleft+1);\n    if(moreleft > 0)\n        helper(s + \")\", leftpare_need, moreleft - 1);\n}\n```\n\n这个的想法是，不断的生成左括号，有左括号，后面就一定会生成一个右括号。\n","slug":"Generate-Parentheses","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ny0058qmcmgp9t30ks","content":"<p>打卡，第15天</p>\n<p>今天做了一道比较好玩的题，之前有做个一个括号匹配的题目，今天的题目刚好反过来，不是验证括号是否正确，而是生成正确括号——<a href=\"https://leetcode.com/problems/generate-parentheses/description/\">Generate Parentheses</a>.</p>\n<p>题目描述：</p>\n<blockquote>\n<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>\n<p>For example, given n = 3, a solution set is:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  <span class=\"string\">&quot;((()))&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;(()())&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;(())()&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;()(())&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;()()()&quot;</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n<p>再看看<code>n = 2</code>时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    <span class=\"string\">&quot;(())&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;()()&quot;</span>,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n<p>我们观察上面的例子，可以发现n=3,其实是由n=2加上一个<code>()</code>组合起来的，可以分成三种情况：</p>\n<ul>\n<li>在前面加上<code>()</code>,</li>\n<li>在后面加上<code>()</code>,</li>\n<li>在前面加上<code>(</code>后面加上<code>)</code></li>\n</ul>\n<p>我们大概可以写出这样的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">generateParenthesis1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> &#123;<span class=\"string\">&quot;()&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; r = generateParenthesis(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:r)&#123;</span><br><span class=\"line\">        ret.insert(s+<span class=\"string\">&quot;()&quot;</span>);</span><br><span class=\"line\">        ret.insert(<span class=\"string\">&quot;()&quot;</span> + s);</span><br><span class=\"line\">        ret.insert(<span class=\"string\">&quot;(&quot;</span> + s + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;ret.begin(),ret.end()&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在<code>n &lt;= 3</code>时是ok的，但是如果<code>n = 4</code>还有一种可能，就是<code>(())(())</code>,这时由两个<code>n=2</code>的括号组合而成的，以及<code>n = 5</code>时，可以由<code>n = 3</code>和<code>n = 2</code>组合而成，也可以由<code>n = 1</code>和<code>n = 4</code>组合而成。</p>\n<p>故我们可以做以下改进，得到正确答案：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">generateParenthesis1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> &#123;<span class=\"string\">&quot;()&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; r = generateParenthesis(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:r)&#123;</span><br><span class=\"line\">        ret.insert(s+<span class=\"string\">&quot;()&quot;</span>);</span><br><span class=\"line\">        ret.insert(<span class=\"string\">&quot;()&quot;</span> + s);</span><br><span class=\"line\">        ret.insert(<span class=\"string\">&quot;(&quot;</span> + s + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n/<span class=\"number\">2</span>;i &gt; <span class=\"number\">1</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; r1 = generateParenthesis(n - i);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; r2 = generateParenthesis(i);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s1:r1)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s2:r2) &#123;</span><br><span class=\"line\">                ret.insert(s1+s2);</span><br><span class=\"line\">                ret.insert(s2+s1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;ret.begin(),ret.end()&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，这里出现了很多次重复计算，可以用动态规划去做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">generateParenthesis</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; par&#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;&quot;</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; now;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:par[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">            now.insert(s + <span class=\"string\">&quot;()&quot;</span>);</span><br><span class=\"line\">            now.insert(<span class=\"string\">&quot;()&quot;</span> + s);</span><br><span class=\"line\">            now.insert(<span class=\"string\">&quot;(&quot;</span> + s + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = i - l;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r &gt;= l) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s1:par[l])</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s2:par[r])&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//cout &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; s2 &lt;&lt; endl;</span></span><br><span class=\"line\">                    now.insert(s1+s2);</span><br><span class=\"line\">                    now.insert(s2+s1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">            r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        par.push_back(&#123;now.begin(),now.end()&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> par[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>discuss</code>中看到的另一种思路：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; result;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">generateParenthesis</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    helper(<span class=\"string\">&quot;&quot;</span>, n, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  this hepler function insert result strings to &quot;vector&lt;string&gt; result&quot;</span></span><br><span class=\"line\"><span class=\"comment\">    When number of &#x27;(&#x27; less than &quot;n&quot;, can append &#x27;(&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">    When number of &#x27;(&#x27; is more than number of &#x27;)&#x27;, can append &#x27;)&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    string s : current string;</span></span><br><span class=\"line\"><span class=\"comment\">    int leftpare_need : number of &#x27;(&#x27; that have not put into &quot;string s&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">    int moreleft : number of &#x27;(&#x27; minus number of &#x27;)&#x27; in the &quot;string s&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> leftpare_need, <span class=\"keyword\">int</span> moreleft)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(leftpare_need == <span class=\"number\">0</span> &amp;&amp; moreleft == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        result.push_back(s);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(leftpare_need &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        helper(s + <span class=\"string\">&quot;(&quot;</span>, leftpare_need - <span class=\"number\">1</span>, moreleft+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moreleft &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        helper(s + <span class=\"string\">&quot;)&quot;</span>, leftpare_need, moreleft - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个的想法是，不断的生成左括号，有左括号，后面就一定会生成一个右括号。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第15天</p>\n<p>今天做了一道比较好玩的题，之前有做个一个括号匹配的题目，今天的题目刚好反过来，不是验证括号是否正确，而是生成正确括号——<a href=\"https://leetcode.com/problems/generate-parentheses/description/\">Generate Parentheses</a>.</p>\n<p>题目描述：</p>\n<blockquote>\n<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>\n<p>For example, given n = 3, a solution set is:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  <span class=\"string\">&quot;((()))&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;(()())&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;(())()&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;()(())&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;()()()&quot;</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n<p>再看看<code>n = 2</code>时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    <span class=\"string\">&quot;(())&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;()()&quot;</span>,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n<p>我们观察上面的例子，可以发现n=3,其实是由n=2加上一个<code>()</code>组合起来的，可以分成三种情况：</p>\n<ul>\n<li>在前面加上<code>()</code>,</li>\n<li>在后面加上<code>()</code>,</li>\n<li>在前面加上<code>(</code>后面加上<code>)</code></li>\n</ul>\n<p>我们大概可以写出这样的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">generateParenthesis1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> &#123;<span class=\"string\">&quot;()&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; r = generateParenthesis(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:r)&#123;</span><br><span class=\"line\">        ret.insert(s+<span class=\"string\">&quot;()&quot;</span>);</span><br><span class=\"line\">        ret.insert(<span class=\"string\">&quot;()&quot;</span> + s);</span><br><span class=\"line\">        ret.insert(<span class=\"string\">&quot;(&quot;</span> + s + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;ret.begin(),ret.end()&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在<code>n &lt;= 3</code>时是ok的，但是如果<code>n = 4</code>还有一种可能，就是<code>(())(())</code>,这时由两个<code>n=2</code>的括号组合而成的，以及<code>n = 5</code>时，可以由<code>n = 3</code>和<code>n = 2</code>组合而成，也可以由<code>n = 1</code>和<code>n = 4</code>组合而成。</p>\n<p>故我们可以做以下改进，得到正确答案：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">generateParenthesis1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> &#123;<span class=\"string\">&quot;()&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; r = generateParenthesis(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:r)&#123;</span><br><span class=\"line\">        ret.insert(s+<span class=\"string\">&quot;()&quot;</span>);</span><br><span class=\"line\">        ret.insert(<span class=\"string\">&quot;()&quot;</span> + s);</span><br><span class=\"line\">        ret.insert(<span class=\"string\">&quot;(&quot;</span> + s + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n/<span class=\"number\">2</span>;i &gt; <span class=\"number\">1</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; r1 = generateParenthesis(n - i);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; r2 = generateParenthesis(i);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s1:r1)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s2:r2) &#123;</span><br><span class=\"line\">                ret.insert(s1+s2);</span><br><span class=\"line\">                ret.insert(s2+s1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;ret.begin(),ret.end()&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，这里出现了很多次重复计算，可以用动态规划去做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">generateParenthesis</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; par&#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;&quot;</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; now;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:par[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">            now.insert(s + <span class=\"string\">&quot;()&quot;</span>);</span><br><span class=\"line\">            now.insert(<span class=\"string\">&quot;()&quot;</span> + s);</span><br><span class=\"line\">            now.insert(<span class=\"string\">&quot;(&quot;</span> + s + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = i - l;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r &gt;= l) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s1:par[l])</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s2:par[r])&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//cout &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; s2 &lt;&lt; endl;</span></span><br><span class=\"line\">                    now.insert(s1+s2);</span><br><span class=\"line\">                    now.insert(s2+s1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">            r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        par.push_back(&#123;now.begin(),now.end()&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> par[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>discuss</code>中看到的另一种思路：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; result;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">generateParenthesis</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    helper(<span class=\"string\">&quot;&quot;</span>, n, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  this hepler function insert result strings to &quot;vector&lt;string&gt; result&quot;</span></span><br><span class=\"line\"><span class=\"comment\">    When number of &#x27;(&#x27; less than &quot;n&quot;, can append &#x27;(&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">    When number of &#x27;(&#x27; is more than number of &#x27;)&#x27;, can append &#x27;)&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    string s : current string;</span></span><br><span class=\"line\"><span class=\"comment\">    int leftpare_need : number of &#x27;(&#x27; that have not put into &quot;string s&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">    int moreleft : number of &#x27;(&#x27; minus number of &#x27;)&#x27; in the &quot;string s&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> leftpare_need, <span class=\"keyword\">int</span> moreleft)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(leftpare_need == <span class=\"number\">0</span> &amp;&amp; moreleft == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        result.push_back(s);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(leftpare_need &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        helper(s + <span class=\"string\">&quot;(&quot;</span>, leftpare_need - <span class=\"number\">1</span>, moreleft+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moreleft &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        helper(s + <span class=\"string\">&quot;)&quot;</span>, leftpare_need, moreleft - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个的想法是，不断的生成左括号，有左括号，后面就一定会生成一个右括号。</p>\n"},{"title":"Global and Local Inversions","date":"2019-12-02T02:11:09.000Z","_content":"\n> 第26天\n\n今天的题目是[Global and Local Inversions](https://leetcode.com/problems/global-and-local-inversions/)：\n\n看上去挺复杂的题目，但是我们可以从题目中知道，输入的数组是一个 `[0,1,...,N-1]` 的一个排列，所以A中的元素是有限定的，\n\n多举几个例子就可以发现如果一个排列要满足 `local inversion` 和 `global inversion` 个数相同的话，必须满足：\n\n- `A[i] == i`\n- `A[i] == i+1 && A[i+1] == i`\n\n所以我们就可以写出这段代码：\n\n```c++\nbool isIdealPermutation(vector<int>& A) {\n    int minLimit = INT_MIN;\n    for(int i = 0, size = A.size() - 1; i < size; i++) {\n        if (A[i] == i) ;\n        else if (A[i] == i + 1 && A[i+1] == i) {\n            i++;\n        } else return false;\n    }\n    return true;\n}\n```\n","source":"_posts/Global-and-Local-Inversions.md","raw":"---\ntitle: Global and Local Inversions\ndate: 2019-12-02T10:11:09.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第26天\n\n今天的题目是[Global and Local Inversions](https://leetcode.com/problems/global-and-local-inversions/)：\n\n看上去挺复杂的题目，但是我们可以从题目中知道，输入的数组是一个 `[0,1,...,N-1]` 的一个排列，所以A中的元素是有限定的，\n\n多举几个例子就可以发现如果一个排列要满足 `local inversion` 和 `global inversion` 个数相同的话，必须满足：\n\n- `A[i] == i`\n- `A[i] == i+1 && A[i+1] == i`\n\n所以我们就可以写出这段代码：\n\n```c++\nbool isIdealPermutation(vector<int>& A) {\n    int minLimit = INT_MIN;\n    for(int i = 0, size = A.size() - 1; i < size; i++) {\n        if (A[i] == i) ;\n        else if (A[i] == i + 1 && A[i+1] == i) {\n            i++;\n        } else return false;\n    }\n    return true;\n}\n```\n","slug":"Global-and-Local-Inversions","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ny005bqmcmgggt7mqa","content":"<blockquote>\n<p>第26天</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/global-and-local-inversions/\">Global and Local Inversions</a>：</p>\n<p>看上去挺复杂的题目，但是我们可以从题目中知道，输入的数组是一个 <code>[0,1,...,N-1]</code> 的一个排列，所以A中的元素是有限定的，</p>\n<p>多举几个例子就可以发现如果一个排列要满足 <code>local inversion</code> 和 <code>global inversion</code> 个数相同的话，必须满足：</p>\n<ul>\n<li><code>A[i] == i</code></li>\n<li><code>A[i] == i+1 &amp;&amp; A[i+1] == i</code></li>\n</ul>\n<p>所以我们就可以写出这段代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isIdealPermutation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minLimit = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = A.size() - <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[i] == i) ;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (A[i] == i + <span class=\"number\">1</span> &amp;&amp; A[i+<span class=\"number\">1</span>] == i) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第26天</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/global-and-local-inversions/\">Global and Local Inversions</a>：</p>\n<p>看上去挺复杂的题目，但是我们可以从题目中知道，输入的数组是一个 <code>[0,1,...,N-1]</code> 的一个排列，所以A中的元素是有限定的，</p>\n<p>多举几个例子就可以发现如果一个排列要满足 <code>local inversion</code> 和 <code>global inversion</code> 个数相同的话，必须满足：</p>\n<ul>\n<li><code>A[i] == i</code></li>\n<li><code>A[i] == i+1 &amp;&amp; A[i+1] == i</code></li>\n</ul>\n<p>所以我们就可以写出这段代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isIdealPermutation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minLimit = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = A.size() - <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[i] == i) ;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (A[i] == i + <span class=\"number\">1</span> &amp;&amp; A[i+<span class=\"number\">1</span>] == i) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Group-Anagrams","date":"2017-10-15T02:32:00.000Z","_content":"\n第22天，今天刷回了`Medium`，果然这个难度才适合我。\n\n> Given an array of strings, group anagrams together.\n>\n> For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \n> Return:\n\n```python\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n```\n\n> Note: All inputs will be in lower-case.\n\n题目很简短，主要的难点是怎样判断两个字符串是同组的（即`s1`是`s2`的一个置换），我的想法是利用`hash`来区分，不过这个`hash`函数写起来就比较麻烦了，主要是要考虑碰撞：\n\n```c++\nunsigned hashString(string &s) {\n    int sum = 1;\n    int count[26]{0};\n    for(auto c:s)\n        count[c-'a']++;\n    for(int i = 0;i < 26;i++){\n        sum = sum*133 + count[i];\n    }\n    return sum;\n}\n```\n\n然后就是一些细节问题了：\n\n```c++\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\n    vector<vector<string> > ret;\n    unordered_map<unsigned,int> mRet;\n    int now = 0;\n    for(auto &s:strs) {\n        unsigned h = hashString(s);\n        cout << h << endl;\n        if (mRet.find(h) == mRet.end()){\n            ret.push_back({});\n            mRet[h] = now;\n            now++;\n        }\n        ret[mRet[h]].push_back(s);\n    }\n    return ret;\n}\n```\n\n`dicuss`中有另外一种`hash`的方法:\n\n```java\npublic static List<List<String>> groupAnagrams(String[] strs) { \n   int[] prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103};//最多10609个z\n            List<List<String>> res = new ArrayList<>();\n            HashMap<Integer, Integer> map = new HashMap<>();\n            for (String s : strs) {\n                int key = 1;\n                for (char c : s.toCharArray()) {\n                    key *= prime[c - 'a'];\n                }\n                List<String> t;\n                if (map.containsKey(key)) {\n                    t = res.get(map.get(key));\n                } else {\n                    t = new ArrayList<>();\n                    res.add(t);\n                    map.put(key, res.size() - 1);\n                }\n                t.add(s);\n            }\n            return res;\n    }\n```\n\n额，说实话，里面的数学依据我没看懂，是因为素数只能被1和它本身整除吗？\n\n然后同样是在`dicuss`中看到的，对字符串`sort`来判断是否在同一组的方法：\n\n```c++\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\n    unordered_map<string, vector<string> > anagrams;\n    for (string s: strs) {\n        string sorted = s;\n        sort(sorted.begin(), sorted.end());\n        anagrams[sorted].push_back(s);\n    }\n    vector<vector<string> > res;\n    for (auto p: anagrams) res.push_back(p.second);\n    return res;\n}\n```\n\n没想到这道题还有`solution`,里面有两个方法，一个是用sort的，和上面的差不多。另一个有趣点，通过计数来生成一个新的字符串，然后在`hash`:\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    if (strs.length == 0) return new ArrayList();\n    Map<String, List> ans = new HashMap<String, List>();\n    int[] count = new int[26];\n    for (String s : strs) {\n        Arrays.fill(count, 0);\n        for (char c : s.toCharArray()) count[c - 'a']++;\n\n        StringBuilder sb = new StringBuilder(\"\");\n        for (int i = 0; i < 26; i++) {\n            sb.append('#');\n            sb.append(count[i]);\n        }\n        String key = sb.toString();\n        if (!ans.containsKey(key)) ans.put(key, new ArrayList());\n        ans.get(key).add(s);\n    }\n    return new ArrayList(ans.values());\n}\n```\n\n","source":"_posts/Group-Anagrams.md","raw":"---\ntitle: Group-Anagrams\ndate: 2017-10-15T10:32:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第22天，今天刷回了`Medium`，果然这个难度才适合我。\n\n> Given an array of strings, group anagrams together.\n>\n> For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \n> Return:\n\n```python\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n```\n\n> Note: All inputs will be in lower-case.\n\n题目很简短，主要的难点是怎样判断两个字符串是同组的（即`s1`是`s2`的一个置换），我的想法是利用`hash`来区分，不过这个`hash`函数写起来就比较麻烦了，主要是要考虑碰撞：\n\n```c++\nunsigned hashString(string &s) {\n    int sum = 1;\n    int count[26]{0};\n    for(auto c:s)\n        count[c-'a']++;\n    for(int i = 0;i < 26;i++){\n        sum = sum*133 + count[i];\n    }\n    return sum;\n}\n```\n\n然后就是一些细节问题了：\n\n```c++\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\n    vector<vector<string> > ret;\n    unordered_map<unsigned,int> mRet;\n    int now = 0;\n    for(auto &s:strs) {\n        unsigned h = hashString(s);\n        cout << h << endl;\n        if (mRet.find(h) == mRet.end()){\n            ret.push_back({});\n            mRet[h] = now;\n            now++;\n        }\n        ret[mRet[h]].push_back(s);\n    }\n    return ret;\n}\n```\n\n`dicuss`中有另外一种`hash`的方法:\n\n```java\npublic static List<List<String>> groupAnagrams(String[] strs) { \n   int[] prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103};//最多10609个z\n            List<List<String>> res = new ArrayList<>();\n            HashMap<Integer, Integer> map = new HashMap<>();\n            for (String s : strs) {\n                int key = 1;\n                for (char c : s.toCharArray()) {\n                    key *= prime[c - 'a'];\n                }\n                List<String> t;\n                if (map.containsKey(key)) {\n                    t = res.get(map.get(key));\n                } else {\n                    t = new ArrayList<>();\n                    res.add(t);\n                    map.put(key, res.size() - 1);\n                }\n                t.add(s);\n            }\n            return res;\n    }\n```\n\n额，说实话，里面的数学依据我没看懂，是因为素数只能被1和它本身整除吗？\n\n然后同样是在`dicuss`中看到的，对字符串`sort`来判断是否在同一组的方法：\n\n```c++\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\n    unordered_map<string, vector<string> > anagrams;\n    for (string s: strs) {\n        string sorted = s;\n        sort(sorted.begin(), sorted.end());\n        anagrams[sorted].push_back(s);\n    }\n    vector<vector<string> > res;\n    for (auto p: anagrams) res.push_back(p.second);\n    return res;\n}\n```\n\n没想到这道题还有`solution`,里面有两个方法，一个是用sort的，和上面的差不多。另一个有趣点，通过计数来生成一个新的字符串，然后在`hash`:\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    if (strs.length == 0) return new ArrayList();\n    Map<String, List> ans = new HashMap<String, List>();\n    int[] count = new int[26];\n    for (String s : strs) {\n        Arrays.fill(count, 0);\n        for (char c : s.toCharArray()) count[c - 'a']++;\n\n        StringBuilder sb = new StringBuilder(\"\");\n        for (int i = 0; i < 26; i++) {\n            sb.append('#');\n            sb.append(count[i]);\n        }\n        String key = sb.toString();\n        if (!ans.containsKey(key)) ans.put(key, new ArrayList());\n        ans.get(key).add(s);\n    }\n    return new ArrayList(ans.values());\n}\n```\n\n","slug":"Group-Anagrams","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69nz005eqmcm0j140b16","content":"<p>第22天，今天刷回了<code>Medium</code>，果然这个难度才适合我。</p>\n<blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"string\">&quot;ate&quot;</span>, <span class=\"string\">&quot;eat&quot;</span>,<span class=\"string\">&quot;tea&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;nat&quot;</span>,<span class=\"string\">&quot;tan&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;bat&quot;</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Note: All inputs will be in lower-case.</p>\n</blockquote>\n<p>题目很简短，主要的难点是怎样判断两个字符串是同组的（即<code>s1</code>是<code>s2</code>的一个置换），我的想法是利用<code>hash</code>来区分，不过这个<code>hash</code>函数写起来就比较麻烦了，主要是要考虑碰撞：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">hashString</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count[<span class=\"number\">26</span>]&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:s)</span><br><span class=\"line\">        count[c-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">        sum = sum*<span class=\"number\">133</span> + count[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就是一些细节问题了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; groupAnagrams(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; ret;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">unsigned</span>,<span class=\"keyword\">int</span>&gt; mRet;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s:strs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> h = hashString(s);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; h &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRet.find(h) == mRet.end())&#123;</span><br><span class=\"line\">            ret.push_back(&#123;&#125;);</span><br><span class=\"line\">            mRet[h] = now;</span><br><span class=\"line\">            now++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret[mRet[h]].push_back(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中有另外一种<code>hash</code>的方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; </span><br><span class=\"line\">   <span class=\"keyword\">int</span>[] prime = &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>, <span class=\"number\">23</span>, <span class=\"number\">29</span>, <span class=\"number\">31</span>, <span class=\"number\">41</span>, <span class=\"number\">43</span>, <span class=\"number\">47</span>, <span class=\"number\">53</span>, <span class=\"number\">59</span>, <span class=\"number\">61</span>, <span class=\"number\">67</span>, <span class=\"number\">71</span>, <span class=\"number\">73</span>, <span class=\"number\">79</span>, <span class=\"number\">83</span>, <span class=\"number\">89</span>, <span class=\"number\">97</span>, <span class=\"number\">101</span>, <span class=\"number\">103</span>&#125;;<span class=\"comment\">//最多10609个z</span></span><br><span class=\"line\">            List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String s : strs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> key = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">                    key *= prime[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                List&lt;String&gt; t;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.containsKey(key)) &#123;</span><br><span class=\"line\">                    t = res.get(map.get(key));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    t = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">                    res.add(t);</span><br><span class=\"line\">                    map.put(key, res.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                t.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>额，说实话，里面的数学依据我没看懂，是因为素数只能被1和它本身整除吗？</p>\n<p>然后同样是在<code>dicuss</code>中看到的，对字符串<code>sort</code>来判断是否在同一组的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; groupAnagrams(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; anagrams;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> s: strs) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> sorted = s;</span><br><span class=\"line\">        sort(sorted.begin(), sorted.end());</span><br><span class=\"line\">        anagrams[sorted].push_back(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> p: anagrams) res.push_back(p.second);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没想到这道题还有<code>solution</code>,里面有两个方法，一个是用sort的，和上面的差不多。另一个有趣点，通过计数来生成一个新的字符串，然后在<code>hash</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (strs.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    Map&lt;String, List&gt; ans = <span class=\"keyword\">new</span> HashMap&lt;String, List&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : strs) &#123;</span><br><span class=\"line\">        Arrays.fill(count, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) count[c - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\"></span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            sb.append(<span class=\"string\">&#x27;#&#x27;</span>);</span><br><span class=\"line\">            sb.append(count[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String key = sb.toString();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ans.containsKey(key)) ans.put(key, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        ans.get(key).add(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(ans.values());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>第22天，今天刷回了<code>Medium</code>，果然这个难度才适合我。</p>\n<blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"string\">&quot;ate&quot;</span>, <span class=\"string\">&quot;eat&quot;</span>,<span class=\"string\">&quot;tea&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;nat&quot;</span>,<span class=\"string\">&quot;tan&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;bat&quot;</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Note: All inputs will be in lower-case.</p>\n</blockquote>\n<p>题目很简短，主要的难点是怎样判断两个字符串是同组的（即<code>s1</code>是<code>s2</code>的一个置换），我的想法是利用<code>hash</code>来区分，不过这个<code>hash</code>函数写起来就比较麻烦了，主要是要考虑碰撞：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">hashString</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count[<span class=\"number\">26</span>]&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:s)</span><br><span class=\"line\">        count[c-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">        sum = sum*<span class=\"number\">133</span> + count[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就是一些细节问题了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; groupAnagrams(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; ret;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">unsigned</span>,<span class=\"keyword\">int</span>&gt; mRet;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s:strs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> h = hashString(s);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; h &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRet.find(h) == mRet.end())&#123;</span><br><span class=\"line\">            ret.push_back(&#123;&#125;);</span><br><span class=\"line\">            mRet[h] = now;</span><br><span class=\"line\">            now++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret[mRet[h]].push_back(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中有另外一种<code>hash</code>的方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; </span><br><span class=\"line\">   <span class=\"keyword\">int</span>[] prime = &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>, <span class=\"number\">23</span>, <span class=\"number\">29</span>, <span class=\"number\">31</span>, <span class=\"number\">41</span>, <span class=\"number\">43</span>, <span class=\"number\">47</span>, <span class=\"number\">53</span>, <span class=\"number\">59</span>, <span class=\"number\">61</span>, <span class=\"number\">67</span>, <span class=\"number\">71</span>, <span class=\"number\">73</span>, <span class=\"number\">79</span>, <span class=\"number\">83</span>, <span class=\"number\">89</span>, <span class=\"number\">97</span>, <span class=\"number\">101</span>, <span class=\"number\">103</span>&#125;;<span class=\"comment\">//最多10609个z</span></span><br><span class=\"line\">            List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String s : strs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> key = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">                    key *= prime[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                List&lt;String&gt; t;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.containsKey(key)) &#123;</span><br><span class=\"line\">                    t = res.get(map.get(key));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    t = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">                    res.add(t);</span><br><span class=\"line\">                    map.put(key, res.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                t.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>额，说实话，里面的数学依据我没看懂，是因为素数只能被1和它本身整除吗？</p>\n<p>然后同样是在<code>dicuss</code>中看到的，对字符串<code>sort</code>来判断是否在同一组的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; groupAnagrams(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; anagrams;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> s: strs) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> sorted = s;</span><br><span class=\"line\">        sort(sorted.begin(), sorted.end());</span><br><span class=\"line\">        anagrams[sorted].push_back(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> p: anagrams) res.push_back(p.second);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没想到这道题还有<code>solution</code>,里面有两个方法，一个是用sort的，和上面的差不多。另一个有趣点，通过计数来生成一个新的字符串，然后在<code>hash</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (strs.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    Map&lt;String, List&gt; ans = <span class=\"keyword\">new</span> HashMap&lt;String, List&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : strs) &#123;</span><br><span class=\"line\">        Arrays.fill(count, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) count[c - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\"></span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            sb.append(<span class=\"string\">&#x27;#&#x27;</span>);</span><br><span class=\"line\">            sb.append(count[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String key = sb.toString();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ans.containsKey(key)) ans.put(key, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        ans.get(key).add(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(ans.values());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Hamming Distance","date":"2017-11-22T11:38:40.000Z","_content":"\n第56天。\n\n刷道水题[Hamming Distance](https://leetcode.com/problems/hamming-distance/description/):\n\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Given two integers x and y, calculate the Hamming distance.\n>\n> Note:\n> 0 ≤ x, y < 231.\n>\n> Example:\n>\n> Input: x = 1, y = 4\n>\n> Output: 2\n>\n> Explanation:\n> 1   (0 0 0 1)\n> 4   (0 1 0 0)\n> _     ↑   ↑\n> The above arrows point to positions where the corresponding bits are different.\n\n所谓的`humming distance`就是两个数在bit位上不同的个数，就`int`来说，最多就是全部不相同，也就是每个bit位都不一样，即`humming distance`.\n\n我们可以利用异或来很快的求出来，异或可以让bit位不相同时置1，相同时置0.则两数异或后所得到的数中有bit位中1的个数就是`humming distance`:\n\n```c++\nint hammingDistance(int x, int y) {\n    int t = x^y;\n    int ret = 0;\n    while(t!=0) {\n        ret += (t&1);\n        t >>= 1;\n    }\n    return ret;\n}\n```\n","source":"_posts/Hamming-Distance.md","raw":"---\ntitle: Hamming Distance\ndate: 2017-11-22T19:38:40.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第56天。\n\n刷道水题[Hamming Distance](https://leetcode.com/problems/hamming-distance/description/):\n\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Given two integers x and y, calculate the Hamming distance.\n>\n> Note:\n> 0 ≤ x, y < 231.\n>\n> Example:\n>\n> Input: x = 1, y = 4\n>\n> Output: 2\n>\n> Explanation:\n> 1   (0 0 0 1)\n> 4   (0 1 0 0)\n> _     ↑   ↑\n> The above arrows point to positions where the corresponding bits are different.\n\n所谓的`humming distance`就是两个数在bit位上不同的个数，就`int`来说，最多就是全部不相同，也就是每个bit位都不一样，即`humming distance`.\n\n我们可以利用异或来很快的求出来，异或可以让bit位不相同时置1，相同时置0.则两数异或后所得到的数中有bit位中1的个数就是`humming distance`:\n\n```c++\nint hammingDistance(int x, int y) {\n    int t = x^y;\n    int ret = 0;\n    while(t!=0) {\n        ret += (t&1);\n        t >>= 1;\n    }\n    return ret;\n}\n```\n","slug":"Hamming-Distance","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o0005hqmcm95kb46dk","content":"<p>第56天。</p>\n<p>刷道水题<a href=\"https://leetcode.com/problems/hamming-distance/description/\">Hamming Distance</a>:</p>\n<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Given two integers x and y, calculate the Hamming distance.</p>\n<p>Note:<br>0 ≤ x, y &lt; 231.</p>\n<p>Example:</p>\n<p>Input: x = 1, y = 4</p>\n<p>Output: 2</p>\n<p>Explanation:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>_     ↑   ↑<br>The above arrows point to positions where the corresponding bits are different.</p>\n</blockquote>\n<p>所谓的<code>humming distance</code>就是两个数在bit位上不同的个数，就<code>int</code>来说，最多就是全部不相同，也就是每个bit位都不一样，即<code>humming distance</code>.</p>\n<p>我们可以利用异或来很快的求出来，异或可以让bit位不相同时置1，相同时置0.则两数异或后所得到的数中有bit位中1的个数就是<code>humming distance</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = x^y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t!=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ret += (t&amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">        t &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第56天。</p>\n<p>刷道水题<a href=\"https://leetcode.com/problems/hamming-distance/description/\">Hamming Distance</a>:</p>\n<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Given two integers x and y, calculate the Hamming distance.</p>\n<p>Note:<br>0 ≤ x, y &lt; 231.</p>\n<p>Example:</p>\n<p>Input: x = 1, y = 4</p>\n<p>Output: 2</p>\n<p>Explanation:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>_     ↑   ↑<br>The above arrows point to positions where the corresponding bits are different.</p>\n</blockquote>\n<p>所谓的<code>humming distance</code>就是两个数在bit位上不同的个数，就<code>int</code>来说，最多就是全部不相同，也就是每个bit位都不一样，即<code>humming distance</code>.</p>\n<p>我们可以利用异或来很快的求出来，异或可以让bit位不相同时置1，相同时置0.则两数异或后所得到的数中有bit位中1的个数就是<code>humming distance</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = x^y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t!=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ret += (t&amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">        t &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"House-Robber-III","date":"2017-11-26T01:08:22.000Z","_content":"\n第60天。\n\n今天的题目是[House Robber III](https://leetcode.com/problems/house-robber-iii/description/)：\n\n> The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n>\n> Determine the maximum amount of money the thief can rob tonight without alerting the police.\n>\n> Example 1:\n\n     3\n    / \\\n   2   3\n    \\   \\\n     3   1\n\n> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n> Example 2:\n\n     3\n    / \\\n   4   5\n  / \\   \\\n 1   3   1\n\n> Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n之前有刷过`House robber`,上次是一道`dp`的题目，这次看起来有点像是`dp`的题目，但是其实不是。\n\n我们考虑当前节点`root`,我们有两种选择：\n\n- 不偷`root`:这意味着我们对`root`的孩子没有限制（即可以偷也可以不偷）。\n- 偷`root`：这意味着我们不能偷`root`的孩子。\n\n从上面的分析可以看出，对于一个节点，我们可能需要返回两个值，一个是偷了`root`所得到的`money`,一个是不偷`root`所得到的`money`.我们可以用一个结构体来表示:\n\n```c++\ntypedef struct {\n    int rob;\n    int norob;\n}Ret;\n```\n\n假设我们现在得到了`root`左孩子和右孩子的`Ret`了，我们现在要构建`root`本身的`Ret`.显然`rob = left.norob + right.norob + root->val`.然后还有`norob`,这个很容易就写成`norob = left.rob + right.rob`,这样写就假定了`rob > norob`的，在上面的分析中，我们是说我们对`root`的孩子没有限制，既然没有限制，就可以偷也可以不偷，所以`norob = max(left.rob,left.norob) + max(right.rob,right.norob)`.\n\n```c++\nint rob(TreeNode* root) {\n    Ret ret = robRec(root);\n    return max(ret.rob,ret.norob);\n}\nRet robRec(TreeNode *root) {\n    Ret ret = {0,0};\n    if (root == nullptr) return ret;\n    Ret left = robRec(root->left);\n    Ret right = robRec(root->right);\n    ret.rob = left.norob + right.norob + root->val;\n    ret.norob = max(left.rob,left.norob) + max(right.rob,right.norob);\n    return ret;\n}\n```\n\n`dicuss`中的解法大都是这个思路，只是写法不同而已，有一个写法比较有趣：\n\n```java\npublic int rob(TreeNode root) {\n    if (root == null) return 0;\n    return Math.max(robInclude(root), robExclude(root));\n}\n\npublic int robInclude(TreeNode node) {\n    if(node == null) return 0;\n    return robExclude(node.left) + robExclude(node.right) + node.val;\n}\n\npublic int robExclude(TreeNode node) {\n    if(node == null) return 0;\n    return rob(node.left) + rob(node.right);\n}\n```\n","source":"_posts/House-Robber-III.md","raw":"---\ntitle: House-Robber-III\ndate: 2017-11-26T09:08:22.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第60天。\n\n今天的题目是[House Robber III](https://leetcode.com/problems/house-robber-iii/description/)：\n\n> The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n>\n> Determine the maximum amount of money the thief can rob tonight without alerting the police.\n>\n> Example 1:\n\n     3\n    / \\\n   2   3\n    \\   \\\n     3   1\n\n> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n> Example 2:\n\n     3\n    / \\\n   4   5\n  / \\   \\\n 1   3   1\n\n> Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n之前有刷过`House robber`,上次是一道`dp`的题目，这次看起来有点像是`dp`的题目，但是其实不是。\n\n我们考虑当前节点`root`,我们有两种选择：\n\n- 不偷`root`:这意味着我们对`root`的孩子没有限制（即可以偷也可以不偷）。\n- 偷`root`：这意味着我们不能偷`root`的孩子。\n\n从上面的分析可以看出，对于一个节点，我们可能需要返回两个值，一个是偷了`root`所得到的`money`,一个是不偷`root`所得到的`money`.我们可以用一个结构体来表示:\n\n```c++\ntypedef struct {\n    int rob;\n    int norob;\n}Ret;\n```\n\n假设我们现在得到了`root`左孩子和右孩子的`Ret`了，我们现在要构建`root`本身的`Ret`.显然`rob = left.norob + right.norob + root->val`.然后还有`norob`,这个很容易就写成`norob = left.rob + right.rob`,这样写就假定了`rob > norob`的，在上面的分析中，我们是说我们对`root`的孩子没有限制，既然没有限制，就可以偷也可以不偷，所以`norob = max(left.rob,left.norob) + max(right.rob,right.norob)`.\n\n```c++\nint rob(TreeNode* root) {\n    Ret ret = robRec(root);\n    return max(ret.rob,ret.norob);\n}\nRet robRec(TreeNode *root) {\n    Ret ret = {0,0};\n    if (root == nullptr) return ret;\n    Ret left = robRec(root->left);\n    Ret right = robRec(root->right);\n    ret.rob = left.norob + right.norob + root->val;\n    ret.norob = max(left.rob,left.norob) + max(right.rob,right.norob);\n    return ret;\n}\n```\n\n`dicuss`中的解法大都是这个思路，只是写法不同而已，有一个写法比较有趣：\n\n```java\npublic int rob(TreeNode root) {\n    if (root == null) return 0;\n    return Math.max(robInclude(root), robExclude(root));\n}\n\npublic int robInclude(TreeNode node) {\n    if(node == null) return 0;\n    return robExclude(node.left) + robExclude(node.right) + node.val;\n}\n\npublic int robExclude(TreeNode node) {\n    if(node == null) return 0;\n    return rob(node.left) + rob(node.right);\n}\n```\n","slug":"House-Robber-III","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o0005kqmcmanpvge2q","content":"<p>第60天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/house-robber-iii/description/\">House Robber III</a>：</p>\n<blockquote>\n<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\n<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>\n<p>Example 1:</p>\n</blockquote>\n<pre><code> 3\n/ \\\n</code></pre>\n<p>   2   3<br>    \\   <br>     3   1</p>\n<blockquote>\n<p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br>Example 2:</p>\n</blockquote>\n<pre><code> 3\n/ \\\n</code></pre>\n<p>   4   5<br>  / \\   <br> 1   3   1</p>\n<blockquote>\n<p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>\n</blockquote>\n<p>之前有刷过<code>House robber</code>,上次是一道<code>dp</code>的题目，这次看起来有点像是<code>dp</code>的题目，但是其实不是。</p>\n<p>我们考虑当前节点<code>root</code>,我们有两种选择：</p>\n<ul>\n<li>不偷<code>root</code>:这意味着我们对<code>root</code>的孩子没有限制（即可以偷也可以不偷）。</li>\n<li>偷<code>root</code>：这意味着我们不能偷<code>root</code>的孩子。</li>\n</ul>\n<p>从上面的分析可以看出，对于一个节点，我们可能需要返回两个值，一个是偷了<code>root</code>所得到的<code>money</code>,一个是不偷<code>root</code>所得到的<code>money</code>.我们可以用一个结构体来表示:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rob;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> norob;</span><br><span class=\"line\">&#125;Ret;</span><br></pre></td></tr></table></figure>\n\n<p>假设我们现在得到了<code>root</code>左孩子和右孩子的<code>Ret</code>了，我们现在要构建<code>root</code>本身的<code>Ret</code>.显然<code>rob = left.norob + right.norob + root-&gt;val</code>.然后还有<code>norob</code>,这个很容易就写成<code>norob = left.rob + right.rob</code>,这样写就假定了<code>rob &gt; norob</code>的，在上面的分析中，我们是说我们对<code>root</code>的孩子没有限制，既然没有限制，就可以偷也可以不偷，所以<code>norob = max(left.rob,left.norob) + max(right.rob,right.norob)</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    Ret ret = robRec(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(ret.rob,ret.norob);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Ret <span class=\"title\">robRec</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    Ret ret = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    Ret left = robRec(root-&gt;left);</span><br><span class=\"line\">    Ret right = robRec(root-&gt;right);</span><br><span class=\"line\">    ret.rob = left.norob + right.norob + root-&gt;val;</span><br><span class=\"line\">    ret.norob = max(left.rob,left.norob) + max(right.rob,right.norob);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中的解法大都是这个思路，只是写法不同而已，有一个写法比较有趣：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(robInclude(root), robExclude(root));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">robInclude</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> robExclude(node.left) + robExclude(node.right) + node.val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">robExclude</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rob(node.left) + rob(node.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第60天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/house-robber-iii/description/\">House Robber III</a>：</p>\n<blockquote>\n<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\n<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>\n<p>Example 1:</p>\n</blockquote>\n<pre><code> 3\n/ \\\n</code></pre>\n<p>   2   3<br>    \\   <br>     3   1</p>\n<blockquote>\n<p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br>Example 2:</p>\n</blockquote>\n<pre><code> 3\n/ \\\n</code></pre>\n<p>   4   5<br>  / \\   <br> 1   3   1</p>\n<blockquote>\n<p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>\n</blockquote>\n<p>之前有刷过<code>House robber</code>,上次是一道<code>dp</code>的题目，这次看起来有点像是<code>dp</code>的题目，但是其实不是。</p>\n<p>我们考虑当前节点<code>root</code>,我们有两种选择：</p>\n<ul>\n<li>不偷<code>root</code>:这意味着我们对<code>root</code>的孩子没有限制（即可以偷也可以不偷）。</li>\n<li>偷<code>root</code>：这意味着我们不能偷<code>root</code>的孩子。</li>\n</ul>\n<p>从上面的分析可以看出，对于一个节点，我们可能需要返回两个值，一个是偷了<code>root</code>所得到的<code>money</code>,一个是不偷<code>root</code>所得到的<code>money</code>.我们可以用一个结构体来表示:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rob;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> norob;</span><br><span class=\"line\">&#125;Ret;</span><br></pre></td></tr></table></figure>\n\n<p>假设我们现在得到了<code>root</code>左孩子和右孩子的<code>Ret</code>了，我们现在要构建<code>root</code>本身的<code>Ret</code>.显然<code>rob = left.norob + right.norob + root-&gt;val</code>.然后还有<code>norob</code>,这个很容易就写成<code>norob = left.rob + right.rob</code>,这样写就假定了<code>rob &gt; norob</code>的，在上面的分析中，我们是说我们对<code>root</code>的孩子没有限制，既然没有限制，就可以偷也可以不偷，所以<code>norob = max(left.rob,left.norob) + max(right.rob,right.norob)</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    Ret ret = robRec(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(ret.rob,ret.norob);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Ret <span class=\"title\">robRec</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    Ret ret = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    Ret left = robRec(root-&gt;left);</span><br><span class=\"line\">    Ret right = robRec(root-&gt;right);</span><br><span class=\"line\">    ret.rob = left.norob + right.norob + root-&gt;val;</span><br><span class=\"line\">    ret.norob = max(left.rob,left.norob) + max(right.rob,right.norob);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中的解法大都是这个思路，只是写法不同而已，有一个写法比较有趣：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(robInclude(root), robExclude(root));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">robInclude</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> robExclude(node.left) + robExclude(node.right) + node.val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">robExclude</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rob(node.left) + rob(node.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"House Robber","date":"2017-11-19T03:07:15.000Z","_content":"\n第53天。\n\n今天的题目是[House Robber](https://leetcode.com/problems/house-robber/description/):\n\n> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n>\n> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n\n题目很长，大概的意思是给你一组非负数，代表每个房间中有的金额，你可以去任意一个房间取钱，但是不能在两个相邻的房间取，求出能取出的最大金额。\n\n一开始想的很简单，直接在单数号的房间取或者在双数号的房间取，这样的话，我就取了最多次，只要遍历求个和即可，然而这样会有一个问题，例如序列是这样的`[2,1,1,2]`,这样的话，应该是取第一个房间和最后一个房间才对。\n\n突然觉得好像很难求出来才是，因为可能性太多了，而且也不好构造这种可能性，突然想到这会不会是一道`dp`的题目，然后用`dp`的思路去想。\n\n如果有k个房间可以取钱，那么是不是对于第k个房间就只有两种可能，即取或不取：\n\n- 取，那么k-1我们就不能取了，我们只能取k-2个房间的钱，问题转换成求前k-2个房间能取多少\n- 不取，那么问题变成了求前k-1个房间能不能取。\n\n我们可以得到以下递推式：\n\n> rob(nums,k) = max(rob(num,k-1),rob(nums,k-2) + nums[k])\n\n这样我们就可以很轻松的写出：\n\n```python\ndef rob1(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    dp = [0]*(len(nums)+2)\n    for i in range(len(nums)):\n        dp[i+2] = max(dp[i+1],dp[i]+nums[i])\n    return dp[-1]\n```\n\n很显然我们可以将空间复杂度从`O(n)`降到`O(1)`:\n\n```python\ndef rob2(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    #dp = [0]*(len(nums)+2)\n    dp1,dp2,dp3 = 0,0,0\n    for i in nums:\n        dp3 = max(dp2,dp1+i)\n        dp1,dp2 = dp2,dp3\n    return dp3\n```\n\n我们还可以在减少一点，但是时间复杂度还是`O(1)`:\n\n```python\ndef rob(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    #dp = [0]*(len(nums)+2)\n    dp1,dp2 = 0,0\n    for i in nums:\n        dp1,dp2 = dp2,max(dp2,dp1+i)\n    return dp2\n```\n","source":"_posts/House-Robber.md","raw":"---\ntitle: House Robber\ndate: 2017-11-19T11:07:15.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第53天。\n\n今天的题目是[House Robber](https://leetcode.com/problems/house-robber/description/):\n\n> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n>\n> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n\n题目很长，大概的意思是给你一组非负数，代表每个房间中有的金额，你可以去任意一个房间取钱，但是不能在两个相邻的房间取，求出能取出的最大金额。\n\n一开始想的很简单，直接在单数号的房间取或者在双数号的房间取，这样的话，我就取了最多次，只要遍历求个和即可，然而这样会有一个问题，例如序列是这样的`[2,1,1,2]`,这样的话，应该是取第一个房间和最后一个房间才对。\n\n突然觉得好像很难求出来才是，因为可能性太多了，而且也不好构造这种可能性，突然想到这会不会是一道`dp`的题目，然后用`dp`的思路去想。\n\n如果有k个房间可以取钱，那么是不是对于第k个房间就只有两种可能，即取或不取：\n\n- 取，那么k-1我们就不能取了，我们只能取k-2个房间的钱，问题转换成求前k-2个房间能取多少\n- 不取，那么问题变成了求前k-1个房间能不能取。\n\n我们可以得到以下递推式：\n\n> rob(nums,k) = max(rob(num,k-1),rob(nums,k-2) + nums[k])\n\n这样我们就可以很轻松的写出：\n\n```python\ndef rob1(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    dp = [0]*(len(nums)+2)\n    for i in range(len(nums)):\n        dp[i+2] = max(dp[i+1],dp[i]+nums[i])\n    return dp[-1]\n```\n\n很显然我们可以将空间复杂度从`O(n)`降到`O(1)`:\n\n```python\ndef rob2(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    #dp = [0]*(len(nums)+2)\n    dp1,dp2,dp3 = 0,0,0\n    for i in nums:\n        dp3 = max(dp2,dp1+i)\n        dp1,dp2 = dp2,dp3\n    return dp3\n```\n\n我们还可以在减少一点，但是时间复杂度还是`O(1)`:\n\n```python\ndef rob(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    #dp = [0]*(len(nums)+2)\n    dp1,dp2 = 0,0\n    for i in nums:\n        dp1,dp2 = dp2,max(dp2,dp1+i)\n    return dp2\n```\n","slug":"House-Robber","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o1005nqmcmefmv5rbv","content":"<p>第53天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/house-robber/description/\">House Robber</a>:</p>\n<blockquote>\n<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>\n</blockquote>\n<p>题目很长，大概的意思是给你一组非负数，代表每个房间中有的金额，你可以去任意一个房间取钱，但是不能在两个相邻的房间取，求出能取出的最大金额。</p>\n<p>一开始想的很简单，直接在单数号的房间取或者在双数号的房间取，这样的话，我就取了最多次，只要遍历求个和即可，然而这样会有一个问题，例如序列是这样的<code>[2,1,1,2]</code>,这样的话，应该是取第一个房间和最后一个房间才对。</p>\n<p>突然觉得好像很难求出来才是，因为可能性太多了，而且也不好构造这种可能性，突然想到这会不会是一道<code>dp</code>的题目，然后用<code>dp</code>的思路去想。</p>\n<p>如果有k个房间可以取钱，那么是不是对于第k个房间就只有两种可能，即取或不取：</p>\n<ul>\n<li>取，那么k-1我们就不能取了，我们只能取k-2个房间的钱，问题转换成求前k-2个房间能取多少</li>\n<li>不取，那么问题变成了求前k-1个房间能不能取。</li>\n</ul>\n<p>我们可以得到以下递推式：</p>\n<blockquote>\n<p>rob(nums,k) = max(rob(num,k-1),rob(nums,k-2) + nums[k])</p>\n</blockquote>\n<p>这样我们就可以很轻松的写出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob1</span>(<span class=\"params\">self, nums</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>]*(<span class=\"built_in\">len</span>(nums)+<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">        dp[i+<span class=\"number\">2</span>] = <span class=\"built_in\">max</span>(dp[i+<span class=\"number\">1</span>],dp[i]+nums[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>很显然我们可以将空间复杂度从<code>O(n)</code>降到<code>O(1)</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob2</span>(<span class=\"params\">self, nums</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">#dp = [0]*(len(nums)+2)</span></span><br><span class=\"line\">    dp1,dp2,dp3 = <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        dp3 = <span class=\"built_in\">max</span>(dp2,dp1+i)</span><br><span class=\"line\">        dp1,dp2 = dp2,dp3</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp3</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以在减少一点，但是时间复杂度还是<code>O(1)</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span>(<span class=\"params\">self, nums</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">#dp = [0]*(len(nums)+2)</span></span><br><span class=\"line\">    dp1,dp2 = <span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        dp1,dp2 = dp2,<span class=\"built_in\">max</span>(dp2,dp1+i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp2</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第53天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/house-robber/description/\">House Robber</a>:</p>\n<blockquote>\n<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>\n</blockquote>\n<p>题目很长，大概的意思是给你一组非负数，代表每个房间中有的金额，你可以去任意一个房间取钱，但是不能在两个相邻的房间取，求出能取出的最大金额。</p>\n<p>一开始想的很简单，直接在单数号的房间取或者在双数号的房间取，这样的话，我就取了最多次，只要遍历求个和即可，然而这样会有一个问题，例如序列是这样的<code>[2,1,1,2]</code>,这样的话，应该是取第一个房间和最后一个房间才对。</p>\n<p>突然觉得好像很难求出来才是，因为可能性太多了，而且也不好构造这种可能性，突然想到这会不会是一道<code>dp</code>的题目，然后用<code>dp</code>的思路去想。</p>\n<p>如果有k个房间可以取钱，那么是不是对于第k个房间就只有两种可能，即取或不取：</p>\n<ul>\n<li>取，那么k-1我们就不能取了，我们只能取k-2个房间的钱，问题转换成求前k-2个房间能取多少</li>\n<li>不取，那么问题变成了求前k-1个房间能不能取。</li>\n</ul>\n<p>我们可以得到以下递推式：</p>\n<blockquote>\n<p>rob(nums,k) = max(rob(num,k-1),rob(nums,k-2) + nums[k])</p>\n</blockquote>\n<p>这样我们就可以很轻松的写出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob1</span>(<span class=\"params\">self, nums</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>]*(<span class=\"built_in\">len</span>(nums)+<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">        dp[i+<span class=\"number\">2</span>] = <span class=\"built_in\">max</span>(dp[i+<span class=\"number\">1</span>],dp[i]+nums[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>很显然我们可以将空间复杂度从<code>O(n)</code>降到<code>O(1)</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob2</span>(<span class=\"params\">self, nums</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">#dp = [0]*(len(nums)+2)</span></span><br><span class=\"line\">    dp1,dp2,dp3 = <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        dp3 = <span class=\"built_in\">max</span>(dp2,dp1+i)</span><br><span class=\"line\">        dp1,dp2 = dp2,dp3</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp3</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以在减少一点，但是时间复杂度还是<code>O(1)</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span>(<span class=\"params\">self, nums</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">#dp = [0]*(len(nums)+2)</span></span><br><span class=\"line\">    dp1,dp2 = <span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        dp1,dp2 = dp2,<span class=\"built_in\">max</span>(dp2,dp1+i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp2</span><br></pre></td></tr></table></figure>\n"},{"title":"Implement Rand10() Using Rand7()","date":"2020-01-02T06:52:19.000Z","_content":"\n> 第53天。\n\n今天的题目是[Implement Rand10() Using Rand7()](https://leetcode.com/problems/implement-rand10-using-rand7/)\n\n如果我们是用`Rand10()`去实现`Rand7()`的话就简单，因为 10 比 7 大，所以：\n\n```c++\nint rand7() {\n    int r;\n    while((r = rand10) > 7);\n    return r;\n}\n```\n\n但是题目是用`Rand7()`去实现`Rand10`，所以我们需要转换一下。\n\n由于`1/10 = 1/2 * 1/5`，所以我们可以用`rand5()`和`rand2()`来实现`rand10()`，而`rand5()`和`rand2()`又可以用`rand7()`来实现，所以：\n\n```c++\nint rand10() {\n    return rand5() + 5 * (rand2() - 1);\n}\nint rand2() {\n    int r;\n    while((r = rand7()) > 2) {\n    }\n    return r;\n}\nint rand5() {\n    int r;\n    while((r = rand7()) > 5) {\n    }\n    return r;\n}\n```\n\n其期望为`7/2 + 7/5`，所以调用`rand7()`的次数会比较大，我们可以用`rand7()`去实现`rand49()`，由于`49 = 7 * 7`，所以我们只需要调用两次`rand7()`即可实现出`rand49()`\n然后用`rand49()`去实现一个`rand40()`，而`rand40() % 10 + 1`即实现了`rand10()`:\n\n```c++\nint rand10() {\n    int r;\n    while((r = rand49()) > 40);\n    return r % 10 + 1;\n}\nint rand49() {\n    return (rand7()-1)*7 + rand7();\n}\n```\n","source":"_posts/Implement-Rand10-Using-Rand7.md","raw":"---\ntitle: Implement Rand10() Using Rand7()\ndate: 2020-01-02T14:52:19.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第53天。\n\n今天的题目是[Implement Rand10() Using Rand7()](https://leetcode.com/problems/implement-rand10-using-rand7/)\n\n如果我们是用`Rand10()`去实现`Rand7()`的话就简单，因为 10 比 7 大，所以：\n\n```c++\nint rand7() {\n    int r;\n    while((r = rand10) > 7);\n    return r;\n}\n```\n\n但是题目是用`Rand7()`去实现`Rand10`，所以我们需要转换一下。\n\n由于`1/10 = 1/2 * 1/5`，所以我们可以用`rand5()`和`rand2()`来实现`rand10()`，而`rand5()`和`rand2()`又可以用`rand7()`来实现，所以：\n\n```c++\nint rand10() {\n    return rand5() + 5 * (rand2() - 1);\n}\nint rand2() {\n    int r;\n    while((r = rand7()) > 2) {\n    }\n    return r;\n}\nint rand5() {\n    int r;\n    while((r = rand7()) > 5) {\n    }\n    return r;\n}\n```\n\n其期望为`7/2 + 7/5`，所以调用`rand7()`的次数会比较大，我们可以用`rand7()`去实现`rand49()`，由于`49 = 7 * 7`，所以我们只需要调用两次`rand7()`即可实现出`rand49()`\n然后用`rand49()`去实现一个`rand40()`，而`rand40() % 10 + 1`即实现了`rand10()`:\n\n```c++\nint rand10() {\n    int r;\n    while((r = rand49()) > 40);\n    return r % 10 + 1;\n}\nint rand49() {\n    return (rand7()-1)*7 + rand7();\n}\n```\n","slug":"Implement-Rand10-Using-Rand7","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o1005qqmcm5r65cebs","content":"<blockquote>\n<p>第53天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/implement-rand10-using-rand7/\">Implement Rand10() Using Rand7()</a></p>\n<p>如果我们是用<code>Rand10()</code>去实现<code>Rand7()</code>的话就简单，因为 10 比 7 大，所以：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand7</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((r = rand10) &gt; <span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是题目是用<code>Rand7()</code>去实现<code>Rand10</code>，所以我们需要转换一下。</p>\n<p>由于<code>1/10 = 1/2 * 1/5</code>，所以我们可以用<code>rand5()</code>和<code>rand2()</code>来实现<code>rand10()</code>，而<code>rand5()</code>和<code>rand2()</code>又可以用<code>rand7()</code>来实现，所以：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand10</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rand5() + <span class=\"number\">5</span> * (rand2() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((r = rand7()) &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand5</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((r = rand7()) &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其期望为<code>7/2 + 7/5</code>，所以调用<code>rand7()</code>的次数会比较大，我们可以用<code>rand7()</code>去实现<code>rand49()</code>，由于<code>49 = 7 * 7</code>，所以我们只需要调用两次<code>rand7()</code>即可实现出<code>rand49()</code><br>然后用<code>rand49()</code>去实现一个<code>rand40()</code>，而<code>rand40() % 10 + 1</code>即实现了<code>rand10()</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand10</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((r = rand49()) &gt; <span class=\"number\">40</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r % <span class=\"number\">10</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand49</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (rand7()<span class=\"number\">-1</span>)*<span class=\"number\">7</span> + rand7();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第53天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/implement-rand10-using-rand7/\">Implement Rand10() Using Rand7()</a></p>\n<p>如果我们是用<code>Rand10()</code>去实现<code>Rand7()</code>的话就简单，因为 10 比 7 大，所以：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand7</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((r = rand10) &gt; <span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是题目是用<code>Rand7()</code>去实现<code>Rand10</code>，所以我们需要转换一下。</p>\n<p>由于<code>1/10 = 1/2 * 1/5</code>，所以我们可以用<code>rand5()</code>和<code>rand2()</code>来实现<code>rand10()</code>，而<code>rand5()</code>和<code>rand2()</code>又可以用<code>rand7()</code>来实现，所以：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand10</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rand5() + <span class=\"number\">5</span> * (rand2() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((r = rand7()) &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand5</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((r = rand7()) &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其期望为<code>7/2 + 7/5</code>，所以调用<code>rand7()</code>的次数会比较大，我们可以用<code>rand7()</code>去实现<code>rand49()</code>，由于<code>49 = 7 * 7</code>，所以我们只需要调用两次<code>rand7()</code>即可实现出<code>rand49()</code><br>然后用<code>rand49()</code>去实现一个<code>rand40()</code>，而<code>rand40() % 10 + 1</code>即实现了<code>rand10()</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand10</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((r = rand49()) &gt; <span class=\"number\">40</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r % <span class=\"number\">10</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rand49</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (rand7()<span class=\"number\">-1</span>)*<span class=\"number\">7</span> + rand7();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Implement Trie(Prefix Tree)","date":"2017-11-17T01:47:05.000Z","_content":"\n第51天。\n\n今天的题目是[Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/description/):\n\n> Implement a trie with insert, search, and startsWith methods.\n>\n> Note:\n> You may assume that all inputs are consist of lowercase letters a-z.\n\n[Tire](https://zh.wikipedia.org/wiki/Trie)也就是前缀树，也叫字典树。\n\n它大概是是这样子的：\n\n- 除了root节点以外，每个节点都有一个字符。\n- 从根节点到**某个节点（可以不是叶子节点）**的一条路径表示一个字符串。\n- 对于某个节点其孩子节点的字符不唯一\n\n每个节点都可以唯一对应一个字符串，即使每个节点只存放一个字符，但是`root`节点到这个节点的路径可以唯一确定一个字符串。\n\n既然说它是前缀树，那肯定和前缀有关啦。两个节点所代表的字符串用公共前缀，那么`root`节点到他们的路径肯定有公共路径。\n\n```python\nclass TrieNode:\n\n        def __init__(self):\n            \"\"\"\n            Initialize the TireNode.\n            \"\"\"\n            self.child = {}\n            self.count = 0\n\nclass Trie:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TrieNode()\n\n\n    def insert(self, word):\n        \"\"\"\n        Inserts a word into the trie.\n        :type word: str\n        :rtype: void\n        \"\"\"\n        p = self.root\n        for c in word:\n            q = p.child.get(c,None)\n            if q is None:\n                p.child[c] = TrieNode()\n                q = p.child[c]\n            p = q\n        p.count += 1\n\n    def search(self, word):\n        \"\"\"\n        Returns if the word is in the trie.\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        p = self.root\n        for c in word:   \n            q = p.child.get(c,None)\n            if q is None:\n                return False\n            p = q\n        return p.count > 0\n\n\n    def startsWith(self, prefix):\n        \"\"\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        :type prefix: str\n        :rtype: bool\n        \"\"\"\n        p = self.root\n        for c in prefix:\n            q = p.child.get(c,None)\n            if q is None:\n                return False\n            p = q\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n```\n\n因为`python`中有一些好用的数据结构，比如说`dict`，所以实现起来并不难。\n\n贴一个`dicuss`中的`c++`解法吧，因为他这里限定了字符只是26个，所以写起来也挺方便的：\n\n```c++\nclass TrieNode\n{\npublic:\n    TrieNode *next[26];\n    bool is_word;\n\n    // Initialize your data structure here.\n    TrieNode(bool b = false)\n    {\n        memset(next, 0, sizeof(next));\n        is_word = b;\n    }\n};\n\nclass Trie\n{\n    TrieNode *root;\npublic:\n    Trie()\n    {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the trie.\n    void insert(string s)\n    {\n        TrieNode *p = root;\n        for(int i = 0; i < s.size(); ++ i)\n        {\n            if(p -> next[s[i] - 'a'] == NULL)\n                p -> next[s[i] - 'a'] = new TrieNode();\n            p = p -> next[s[i] - 'a'];\n        }\n        p -> is_word = true;\n    }\n\n    // Returns if the word is in the trie.\n    bool search(string key)\n    {\n        TrieNode *p = find(key);\n        return p != NULL && p -> is_word;\n    }\n\n    // Returns if there is any word in the trie\n    // that starts with the given prefix.\n    bool startsWith(string prefix)\n    {\n        return find(prefix) != NULL;\n    }\n\nprivate:\n    TrieNode* find(string key)\n    {\n        TrieNode *p = root;\n        for(int i = 0; i < key.size() && p != NULL; ++ i)\n            p = p -> next[key[i] - 'a'];\n        return p;\n    }\n};\n```\n","source":"_posts/Implement-Trie-Prefix-Tree.md","raw":"---\ntitle: Implement Trie(Prefix Tree)\ndate: 2017-11-17T09:47:05.000Z\ncategories:\n  - LeetCode\ntags:\n  - Tree\n---\n\n第51天。\n\n今天的题目是[Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/description/):\n\n> Implement a trie with insert, search, and startsWith methods.\n>\n> Note:\n> You may assume that all inputs are consist of lowercase letters a-z.\n\n[Tire](https://zh.wikipedia.org/wiki/Trie)也就是前缀树，也叫字典树。\n\n它大概是是这样子的：\n\n- 除了root节点以外，每个节点都有一个字符。\n- 从根节点到**某个节点（可以不是叶子节点）**的一条路径表示一个字符串。\n- 对于某个节点其孩子节点的字符不唯一\n\n每个节点都可以唯一对应一个字符串，即使每个节点只存放一个字符，但是`root`节点到这个节点的路径可以唯一确定一个字符串。\n\n既然说它是前缀树，那肯定和前缀有关啦。两个节点所代表的字符串用公共前缀，那么`root`节点到他们的路径肯定有公共路径。\n\n```python\nclass TrieNode:\n\n        def __init__(self):\n            \"\"\"\n            Initialize the TireNode.\n            \"\"\"\n            self.child = {}\n            self.count = 0\n\nclass Trie:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TrieNode()\n\n\n    def insert(self, word):\n        \"\"\"\n        Inserts a word into the trie.\n        :type word: str\n        :rtype: void\n        \"\"\"\n        p = self.root\n        for c in word:\n            q = p.child.get(c,None)\n            if q is None:\n                p.child[c] = TrieNode()\n                q = p.child[c]\n            p = q\n        p.count += 1\n\n    def search(self, word):\n        \"\"\"\n        Returns if the word is in the trie.\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        p = self.root\n        for c in word:   \n            q = p.child.get(c,None)\n            if q is None:\n                return False\n            p = q\n        return p.count > 0\n\n\n    def startsWith(self, prefix):\n        \"\"\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        :type prefix: str\n        :rtype: bool\n        \"\"\"\n        p = self.root\n        for c in prefix:\n            q = p.child.get(c,None)\n            if q is None:\n                return False\n            p = q\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n```\n\n因为`python`中有一些好用的数据结构，比如说`dict`，所以实现起来并不难。\n\n贴一个`dicuss`中的`c++`解法吧，因为他这里限定了字符只是26个，所以写起来也挺方便的：\n\n```c++\nclass TrieNode\n{\npublic:\n    TrieNode *next[26];\n    bool is_word;\n\n    // Initialize your data structure here.\n    TrieNode(bool b = false)\n    {\n        memset(next, 0, sizeof(next));\n        is_word = b;\n    }\n};\n\nclass Trie\n{\n    TrieNode *root;\npublic:\n    Trie()\n    {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the trie.\n    void insert(string s)\n    {\n        TrieNode *p = root;\n        for(int i = 0; i < s.size(); ++ i)\n        {\n            if(p -> next[s[i] - 'a'] == NULL)\n                p -> next[s[i] - 'a'] = new TrieNode();\n            p = p -> next[s[i] - 'a'];\n        }\n        p -> is_word = true;\n    }\n\n    // Returns if the word is in the trie.\n    bool search(string key)\n    {\n        TrieNode *p = find(key);\n        return p != NULL && p -> is_word;\n    }\n\n    // Returns if there is any word in the trie\n    // that starts with the given prefix.\n    bool startsWith(string prefix)\n    {\n        return find(prefix) != NULL;\n    }\n\nprivate:\n    TrieNode* find(string key)\n    {\n        TrieNode *p = root;\n        for(int i = 0; i < key.size() && p != NULL; ++ i)\n            p = p -> next[key[i] - 'a'];\n        return p;\n    }\n};\n```\n","slug":"Implement-Trie-Prefix-Tree","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o2005tqmcmdvax4y07","content":"<p>第51天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\">Implement Trie (Prefix Tree)</a>:</p>\n<blockquote>\n<p>Implement a trie with insert, search, and startsWith methods.</p>\n<p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p>\n</blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/Trie\">Tire</a>也就是前缀树，也叫字典树。</p>\n<p>它大概是是这样子的：</p>\n<ul>\n<li>除了root节点以外，每个节点都有一个字符。</li>\n<li>从根节点到<strong>某个节点（可以不是叶子节点）</strong>的一条路径表示一个字符串。</li>\n<li>对于某个节点其孩子节点的字符不唯一</li>\n</ul>\n<p>每个节点都可以唯一对应一个字符串，即使每个节点只存放一个字符，但是<code>root</code>节点到这个节点的路径可以唯一确定一个字符串。</p>\n<p>既然说它是前缀树，那肯定和前缀有关啦。两个节点所代表的字符串用公共前缀，那么<code>root</code>节点到他们的路径肯定有公共路径。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">            <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            Initialize the TireNode.</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span></span><br><span class=\"line\">            self.child = &#123;&#125;</span><br><span class=\"line\">            self.count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Initialize your data structure here.</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        self.root = TrieNode()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span>(<span class=\"params\">self, word</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Inserts a word into the trie.</span></span><br><span class=\"line\"><span class=\"string\">        :type word: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        p = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">            q = p.child.get(c,<span class=\"literal\">None</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> q <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                p.child[c] = TrieNode()</span><br><span class=\"line\">                q = p.child[c]</span><br><span class=\"line\">            p = q</span><br><span class=\"line\">        p.count += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span>(<span class=\"params\">self, word</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Returns if the word is in the trie.</span></span><br><span class=\"line\"><span class=\"string\">        :type word: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        p = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> word:   </span><br><span class=\"line\">            q = p.child.get(c,<span class=\"literal\">None</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> q <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            p = q</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.count &gt; <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">startsWith</span>(<span class=\"params\">self, prefix</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class=\"line\"><span class=\"string\">        :type prefix: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        p = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> prefix:</span><br><span class=\"line\">            q = p.child.get(c,<span class=\"literal\">None</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> q <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            p = q</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Your Trie object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"># obj = Trie()</span></span><br><span class=\"line\"><span class=\"comment\"># obj.insert(word)</span></span><br><span class=\"line\"><span class=\"comment\"># param_2 = obj.search(word)</span></span><br><span class=\"line\"><span class=\"comment\"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>\n\n<p>因为<code>python</code>中有一些好用的数据结构，比如说<code>dict</code>，所以实现起来并不难。</p>\n<p>贴一个<code>dicuss</code>中的<code>c++</code>解法吧，因为他这里限定了字符只是26个，所以写起来也挺方便的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TrieNode *next[<span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> is_word;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize your data structure here.</span></span><br><span class=\"line\">    TrieNode(<span class=\"keyword\">bool</span> b = <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(next, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(next));</span><br><span class=\"line\">        is_word = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TrieNode *root;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Trie()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TrieNode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Inserts a word into the trie.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        TrieNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); ++ i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p -&gt; next[s[i] - <span class=\"string\">&#x27;a&#x27;</span>] == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                p -&gt; next[s[i] - <span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"keyword\">new</span> TrieNode();</span><br><span class=\"line\">            p = p -&gt; next[s[i] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p -&gt; is_word = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns if the word is in the trie.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">string</span> key)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        TrieNode *p = find(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p != <span class=\"literal\">NULL</span> &amp;&amp; p -&gt; is_word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns if there is any word in the trie</span></span><br><span class=\"line\">    <span class=\"comment\">// that starts with the given prefix.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">startsWith</span><span class=\"params\">(<span class=\"built_in\">string</span> prefix)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(prefix) != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\">TrieNode* <span class=\"title\">find</span><span class=\"params\">(<span class=\"built_in\">string</span> key)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        TrieNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; key.size() &amp;&amp; p != <span class=\"literal\">NULL</span>; ++ i)</span><br><span class=\"line\">            p = p -&gt; next[key[i] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第51天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\">Implement Trie (Prefix Tree)</a>:</p>\n<blockquote>\n<p>Implement a trie with insert, search, and startsWith methods.</p>\n<p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p>\n</blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/Trie\">Tire</a>也就是前缀树，也叫字典树。</p>\n<p>它大概是是这样子的：</p>\n<ul>\n<li>除了root节点以外，每个节点都有一个字符。</li>\n<li>从根节点到<strong>某个节点（可以不是叶子节点）</strong>的一条路径表示一个字符串。</li>\n<li>对于某个节点其孩子节点的字符不唯一</li>\n</ul>\n<p>每个节点都可以唯一对应一个字符串，即使每个节点只存放一个字符，但是<code>root</code>节点到这个节点的路径可以唯一确定一个字符串。</p>\n<p>既然说它是前缀树，那肯定和前缀有关啦。两个节点所代表的字符串用公共前缀，那么<code>root</code>节点到他们的路径肯定有公共路径。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">            <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            Initialize the TireNode.</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span></span><br><span class=\"line\">            self.child = &#123;&#125;</span><br><span class=\"line\">            self.count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Initialize your data structure here.</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        self.root = TrieNode()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span>(<span class=\"params\">self, word</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Inserts a word into the trie.</span></span><br><span class=\"line\"><span class=\"string\">        :type word: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        p = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">            q = p.child.get(c,<span class=\"literal\">None</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> q <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                p.child[c] = TrieNode()</span><br><span class=\"line\">                q = p.child[c]</span><br><span class=\"line\">            p = q</span><br><span class=\"line\">        p.count += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span>(<span class=\"params\">self, word</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Returns if the word is in the trie.</span></span><br><span class=\"line\"><span class=\"string\">        :type word: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        p = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> word:   </span><br><span class=\"line\">            q = p.child.get(c,<span class=\"literal\">None</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> q <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            p = q</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.count &gt; <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">startsWith</span>(<span class=\"params\">self, prefix</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class=\"line\"><span class=\"string\">        :type prefix: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        p = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> prefix:</span><br><span class=\"line\">            q = p.child.get(c,<span class=\"literal\">None</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> q <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            p = q</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Your Trie object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"># obj = Trie()</span></span><br><span class=\"line\"><span class=\"comment\"># obj.insert(word)</span></span><br><span class=\"line\"><span class=\"comment\"># param_2 = obj.search(word)</span></span><br><span class=\"line\"><span class=\"comment\"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>\n\n<p>因为<code>python</code>中有一些好用的数据结构，比如说<code>dict</code>，所以实现起来并不难。</p>\n<p>贴一个<code>dicuss</code>中的<code>c++</code>解法吧，因为他这里限定了字符只是26个，所以写起来也挺方便的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TrieNode *next[<span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> is_word;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize your data structure here.</span></span><br><span class=\"line\">    TrieNode(<span class=\"keyword\">bool</span> b = <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(next, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(next));</span><br><span class=\"line\">        is_word = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TrieNode *root;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Trie()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TrieNode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Inserts a word into the trie.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        TrieNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); ++ i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p -&gt; next[s[i] - <span class=\"string\">&#x27;a&#x27;</span>] == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                p -&gt; next[s[i] - <span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"keyword\">new</span> TrieNode();</span><br><span class=\"line\">            p = p -&gt; next[s[i] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p -&gt; is_word = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns if the word is in the trie.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">string</span> key)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        TrieNode *p = find(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p != <span class=\"literal\">NULL</span> &amp;&amp; p -&gt; is_word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns if there is any word in the trie</span></span><br><span class=\"line\">    <span class=\"comment\">// that starts with the given prefix.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">startsWith</span><span class=\"params\">(<span class=\"built_in\">string</span> prefix)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(prefix) != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\">TrieNode* <span class=\"title\">find</span><span class=\"params\">(<span class=\"built_in\">string</span> key)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        TrieNode *p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; key.size() &amp;&amp; p != <span class=\"literal\">NULL</span>; ++ i)</span><br><span class=\"line\">            p = p -&gt; next[key[i] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Insert into a binary search tree","date":"2019-12-01T02:41:18.000Z","_content":"\n> 第25天。\n\n今天的题目是[Insert into a binary search tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/submissions/):\n\n看名字就知道是水题，就是在BST中插入一个节点罢了，所以只需要递归查找到插入的位置，然后 new 一个 TreeNode即可：\n\n```c++\nTreeNode* insertIntoBST(TreeNode* root, int val) {\n    if (root == nullptr) {\n        return new TreeNode(val);\n    }\n    else if (root->val > val) root->left = insertIntoBST(root->left, val);\n    else if (root->val < val) root->right = insertIntoBST(root->right, val);\n    return root;\n}\n```\n","source":"_posts/Insert-into-a-binary-search-tree.md","raw":"---\ntitle: Insert into a binary search tree\ndate: 2019-12-01T10:41:18.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第25天。\n\n今天的题目是[Insert into a binary search tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/submissions/):\n\n看名字就知道是水题，就是在BST中插入一个节点罢了，所以只需要递归查找到插入的位置，然后 new 一个 TreeNode即可：\n\n```c++\nTreeNode* insertIntoBST(TreeNode* root, int val) {\n    if (root == nullptr) {\n        return new TreeNode(val);\n    }\n    else if (root->val > val) root->left = insertIntoBST(root->left, val);\n    else if (root->val < val) root->right = insertIntoBST(root->right, val);\n    return root;\n}\n```\n","slug":"Insert-into-a-binary-search-tree","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o2005wqmcmd6pd5px3","content":"<blockquote>\n<p>第25天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/insert-into-a-binary-search-tree/submissions/\">Insert into a binary search tree</a>:</p>\n<p>看名字就知道是水题，就是在BST中插入一个节点罢了，所以只需要递归查找到插入的位置，然后 new 一个 TreeNode即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">insertIntoBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第25天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/insert-into-a-binary-search-tree/submissions/\">Insert into a binary search tree</a>:</p>\n<p>看名字就知道是水题，就是在BST中插入一个节点罢了，所以只需要递归查找到插入的位置，然后 new 一个 TreeNode即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">insertIntoBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Intersection-of-Two-Arrays-II","date":"2017-12-13T23:57:29.000Z","_content":"\n第78天。\n\n又是`hash`,为什么每次都随机到`hash`.\n\n今天的题目是[Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/):\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n>\n> Note:\n> Each element in the result should appear as many times as it shows in both arrays.\n> The result can be in any order.\n> Follow up:\n> What if the given array is already sorted? How would you optimize your algorithm?\n> What if nums1's size is small compared to nums2's size? Which algorithm is better?\n> What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n和昨天的解法有点想,先遍历一个数组，用`hash table`进行计数，然后再遍历第二个数组，然后实时的更新`hash table`就好了：\n\n```c++\nvector<int> intersec1t(vector<int>& nums1, vector<int>& nums2) {\n    unordered_map<int,int> m;\n    for(auto i:nums1) m[i]++;\n    vector<int> ret;\n    for(auto i:nums2) {\n        if (m[i] != 0) {\n            ret.push_back(i);\n            m[i]--;\n        }\n    }\n    return ret;\n}\n```\n\n还有就是可以用`sort`来做：\n\n```c++\nvector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    sort(nums1.begin(),nums1.end());\n    sort(nums2.begin(),nums2.end());\n    int i1,i2;\n    vector<int> ret;\n    for(i1=0,i2=0;i1 < nums1.size() && i2 < nums2.size();) {\n        if (nums1[i1] == nums2[i2]) {\n            ret.push_back(nums1[i1]);\n            i1++; i2++;\n        } else if (nums1[i1] > nums2[i2]) i2++;\n        else i1++;\n    }\n    return ret;\n}\n```\n","source":"_posts/Intersection-of-Two-Arrays-II.md","raw":"---\ntitle: Intersection-of-Two-Arrays-II\ndate: 2017-12-14T07:57:29.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第78天。\n\n又是`hash`,为什么每次都随机到`hash`.\n\n今天的题目是[Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/):\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n>\n> Note:\n> Each element in the result should appear as many times as it shows in both arrays.\n> The result can be in any order.\n> Follow up:\n> What if the given array is already sorted? How would you optimize your algorithm?\n> What if nums1's size is small compared to nums2's size? Which algorithm is better?\n> What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n和昨天的解法有点想,先遍历一个数组，用`hash table`进行计数，然后再遍历第二个数组，然后实时的更新`hash table`就好了：\n\n```c++\nvector<int> intersec1t(vector<int>& nums1, vector<int>& nums2) {\n    unordered_map<int,int> m;\n    for(auto i:nums1) m[i]++;\n    vector<int> ret;\n    for(auto i:nums2) {\n        if (m[i] != 0) {\n            ret.push_back(i);\n            m[i]--;\n        }\n    }\n    return ret;\n}\n```\n\n还有就是可以用`sort`来做：\n\n```c++\nvector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    sort(nums1.begin(),nums1.end());\n    sort(nums2.begin(),nums2.end());\n    int i1,i2;\n    vector<int> ret;\n    for(i1=0,i2=0;i1 < nums1.size() && i2 < nums2.size();) {\n        if (nums1[i1] == nums2[i2]) {\n            ret.push_back(nums1[i1]);\n            i1++; i2++;\n        } else if (nums1[i1] > nums2[i2]) i2++;\n        else i1++;\n    }\n    return ret;\n}\n```\n","slug":"Intersection-of-Two-Arrays-II","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o3005zqmcm6s7ebs5o","content":"<p>第78天。</p>\n<p>又是<code>hash</code>,为什么每次都随机到<code>hash</code>.</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/intersection-of-two-arrays-ii/description/\">Intersection of Two Arrays II</a>:</p>\n<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>\n<p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.<br>Follow up:<br>What if the given array is already sorted? How would you optimize your algorithm?<br>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p>\n</blockquote>\n<p>和昨天的解法有点想,先遍历一个数组，用<code>hash table</code>进行计数，然后再遍历第二个数组，然后实时的更新<code>hash table</code>就好了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersec1t</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums1) m[i]++;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ret.push_back(i);</span><br><span class=\"line\">            m[i]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有就是可以用<code>sort</code>来做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersect</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums1.begin(),nums1.end());</span><br><span class=\"line\">    sort(nums2.begin(),nums2.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i1,i2;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i1=<span class=\"number\">0</span>,i2=<span class=\"number\">0</span>;i1 &lt; nums1.size() &amp;&amp; i2 &lt; nums2.size();) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums1[i1] == nums2[i2]) &#123;</span><br><span class=\"line\">            ret.push_back(nums1[i1]);</span><br><span class=\"line\">            i1++; i2++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i1] &gt; nums2[i2]) i2++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> i1++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第78天。</p>\n<p>又是<code>hash</code>,为什么每次都随机到<code>hash</code>.</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/intersection-of-two-arrays-ii/description/\">Intersection of Two Arrays II</a>:</p>\n<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>\n<p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.<br>Follow up:<br>What if the given array is already sorted? How would you optimize your algorithm?<br>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p>\n</blockquote>\n<p>和昨天的解法有点想,先遍历一个数组，用<code>hash table</code>进行计数，然后再遍历第二个数组，然后实时的更新<code>hash table</code>就好了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersec1t</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums1) m[i]++;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ret.push_back(i);</span><br><span class=\"line\">            m[i]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有就是可以用<code>sort</code>来做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersect</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums1.begin(),nums1.end());</span><br><span class=\"line\">    sort(nums2.begin(),nums2.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i1,i2;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i1=<span class=\"number\">0</span>,i2=<span class=\"number\">0</span>;i1 &lt; nums1.size() &amp;&amp; i2 &lt; nums2.size();) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums1[i1] == nums2[i2]) &#123;</span><br><span class=\"line\">            ret.push_back(nums1[i1]);</span><br><span class=\"line\">            i1++; i2++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i1] &gt; nums2[i2]) i2++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> i1++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Intersection-of-Two-Arrays","date":"2017-12-18T05:00:24.000Z","_content":"\n第82天。\n\n今天的题目是[Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/description/):\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].\n>\n> Note:\n> Each element in the result must be unique.\n> The result can be in any order.\n\n可以用排序做，也可以用`hash`做：\n\n排序的做法：\n\n```c++\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n    sort(nums1.begin(),nums1.end());\n    sort(nums2.begin(),nums2.end());\n    auto beg1 = nums1.begin();\n    auto beg2 = nums2.begin();\n    vector<int> ret;\n    while(beg1 < nums1.end() && beg2 < nums2.end()) {\n        if (*beg1 == *beg2) {\n            int t  = *beg1;\n            ret.push_back(t);\n            while(beg1 < nums1.end() && *beg1 == t) beg1++;\n            while(beg2 < nums2.end() && *beg2 == t) beg2++;\n        } else if (*beg1 < *beg2) beg1++;\n        else beg2++;\n    }\n    return ret;\n}\n```\n\n`hash`的做法：\n\n```c++\nvector<int> intersection1(vector<int>& nums1, vector<int>& nums2) {\n    unordered_map<int,int> m;\n    vector<int> ret;\n    for(auto i:nums1) m[i]++;\n    for(auto i:nums2) \n        if (m.find(i) != m.end() && m[i]) {\n            m[i] = 0;\n            ret.push_back(i);\n        }\n    return ret;\n}\n```\n\n`dicuss`还有用`set`做的:\n\n```c++\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n    set<int> s(nums1.begin(), nums1.end());\n    vector<int> out;\n    for (int x : nums2)\n        if (s.erase(x))\n            out.push_back(x);\n    return out;\n}\n```\n","source":"_posts/Intersection-of-Two-Arrays.md","raw":"---\ntitle: Intersection-of-Two-Arrays\ndate: 2017-12-18T13:00:24.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第82天。\n\n今天的题目是[Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/description/):\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].\n>\n> Note:\n> Each element in the result must be unique.\n> The result can be in any order.\n\n可以用排序做，也可以用`hash`做：\n\n排序的做法：\n\n```c++\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n    sort(nums1.begin(),nums1.end());\n    sort(nums2.begin(),nums2.end());\n    auto beg1 = nums1.begin();\n    auto beg2 = nums2.begin();\n    vector<int> ret;\n    while(beg1 < nums1.end() && beg2 < nums2.end()) {\n        if (*beg1 == *beg2) {\n            int t  = *beg1;\n            ret.push_back(t);\n            while(beg1 < nums1.end() && *beg1 == t) beg1++;\n            while(beg2 < nums2.end() && *beg2 == t) beg2++;\n        } else if (*beg1 < *beg2) beg1++;\n        else beg2++;\n    }\n    return ret;\n}\n```\n\n`hash`的做法：\n\n```c++\nvector<int> intersection1(vector<int>& nums1, vector<int>& nums2) {\n    unordered_map<int,int> m;\n    vector<int> ret;\n    for(auto i:nums1) m[i]++;\n    for(auto i:nums2) \n        if (m.find(i) != m.end() && m[i]) {\n            m[i] = 0;\n            ret.push_back(i);\n        }\n    return ret;\n}\n```\n\n`dicuss`还有用`set`做的:\n\n```c++\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n    set<int> s(nums1.begin(), nums1.end());\n    vector<int> out;\n    for (int x : nums2)\n        if (s.erase(x))\n            out.push_back(x);\n    return out;\n}\n```\n","slug":"Intersection-of-Two-Arrays","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o40062qmcm2e39ezn0","content":"<p>第82天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/intersection-of-two-arrays/description/\">Intersection of Two Arrays</a>:</p>\n<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>\n<p>Note:<br>Each element in the result must be unique.<br>The result can be in any order.</p>\n</blockquote>\n<p>可以用排序做，也可以用<code>hash</code>做：</p>\n<p>排序的做法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersection</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums1.begin(),nums1.end());</span><br><span class=\"line\">    sort(nums2.begin(),nums2.end());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> beg1 = nums1.begin();</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> beg2 = nums2.begin();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg1 &lt; nums1.end() &amp;&amp; beg2 &lt; nums2.end()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*beg1 == *beg2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t  = *beg1;</span><br><span class=\"line\">            ret.push_back(t);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(beg1 &lt; nums1.end() &amp;&amp; *beg1 == t) beg1++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(beg2 &lt; nums2.end() &amp;&amp; *beg2 == t) beg2++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*beg1 &lt; *beg2) beg1++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> beg2++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>hash</code>的做法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersection1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums1) m[i]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums2) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m.find(i) != m.end() &amp;&amp; m[i]) &#123;</span><br><span class=\"line\">            m[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            ret.push_back(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>还有用<code>set</code>做的:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersection</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">s</span><span class=\"params\">(nums1.begin(), nums1.end())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; out;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x : nums2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.erase(x))</span><br><span class=\"line\">            out.push_back(x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第82天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/intersection-of-two-arrays/description/\">Intersection of Two Arrays</a>:</p>\n<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>\n<p>Note:<br>Each element in the result must be unique.<br>The result can be in any order.</p>\n</blockquote>\n<p>可以用排序做，也可以用<code>hash</code>做：</p>\n<p>排序的做法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersection</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums1.begin(),nums1.end());</span><br><span class=\"line\">    sort(nums2.begin(),nums2.end());</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> beg1 = nums1.begin();</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> beg2 = nums2.begin();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg1 &lt; nums1.end() &amp;&amp; beg2 &lt; nums2.end()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*beg1 == *beg2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t  = *beg1;</span><br><span class=\"line\">            ret.push_back(t);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(beg1 &lt; nums1.end() &amp;&amp; *beg1 == t) beg1++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(beg2 &lt; nums2.end() &amp;&amp; *beg2 == t) beg2++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*beg1 &lt; *beg2) beg1++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> beg2++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>hash</code>的做法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersection1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums1) m[i]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums2) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m.find(i) != m.end() &amp;&amp; m[i]) &#123;</span><br><span class=\"line\">            m[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            ret.push_back(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>还有用<code>set</code>做的:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">intersection</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">s</span><span class=\"params\">(nums1.begin(), nums1.end())</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; out;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x : nums2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.erase(x))</span><br><span class=\"line\">            out.push_back(x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Intersection of Two Linked Lists","date":"2017-11-02T12:29:24.000Z","_content":"\n第38天。\n\n今天课贼多，突然发现贼多作业没写完。。。\n\n今天的题目是[Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/description/):\n> Write a program to find the node at which the intersection of two singly linked lists begins.\n>\n>\n> For example, the following two linked lists:\n\n```python\nA:          a1 → a2\n                   ↘\n                     c1 → c2 → c3\n                   ↗\nB:     b1 → b2 → b3\n```\n\n> begin to intersect at node c1.\n>\n>\n> Notes:\n>\n> If the two linked lists have no intersection at all, return null.\n> The linked lists must retain their original structure after the function returns.\n> You may assume there are no cycles anywhere in the entire linked structure.\n> Your code should preferably run in O(n) time and use only O(1) memory.\n\n最简单的方法就是先遍历一遍第一个链表所有的节点，然后记录下来，然后在遍历第二个链表节点的使用进行 查找即可，虽然很简单，但是时间复杂度很高和空间复杂度都挺高的：\n\n```c++\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    vector<ListNode *> vec;\n    while(headA) {\n        vec.push_back(headA);\n        headA = headA->next;\n    }\n    while(headB) {\n        if (find(vec.begin(),vec.end(),headB) != vec.end()) return headB;\n        headB = headB->next;\n    }\n    return nullptr;\n}\n```\n\n然后是另一种方法，观察下图：\n\n```python\nA:          a1 → a2\n                   ↘\n                     c1 → c2 → c3\n                   ↗\nB:     b1 → b2 → b3\n```\n\n如果我们可以不断的把c3,c2,c1去掉，到最后，我们就会找到交点,这个方法只需要`O(1)`的空间复杂度以及`O(n*k)`的时间复杂度，k是两个链表共同拥有的节点。\n\n```c++\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    //if (headA == nullptr || headB == nullptr) return nullptr;\n    ListNode *end = nullptr;\n    while(1) {\n        if (headA == end || headB == end) return end;\n        ListNode *pa = headA;\n        ListNode *pb = headB;\n        while(pa->next != end) pa = pa->next;\n        while(pb->next != end) pb = pb->next;\n        if (pa != pb) return end;\n        else end = pa;\n    }\n}\n```\n\n然后是在`dicuss`中看到的：\n\n```c++\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    ListNode *cur1 = headA, *cur2 = headB;\n    while(cur1 != cur2){\n        cur1 = cur1?cur1->next:headB;\n        cur2 = cur2?cur2->next:headA;\n    }\n    return cur1;\n}\n```\n\n第一眼看，没看懂，后来仔细看看才发现，`cur1`原本是`headA`开始的，但是在循环里面却被换成了`headB`,`cur2`同理。\n\n所以他们其实会走同样多的距离并到达交点,如果没有交点，就同时到达`nullptr`。\n","source":"_posts/Intersection-of-Two-Linked-Lists.md","raw":"---\ntitle: Intersection of Two Linked Lists\ndate: 2017-11-02T20:29:24.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Linked-List\n---\n\n第38天。\n\n今天课贼多，突然发现贼多作业没写完。。。\n\n今天的题目是[Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/description/):\n> Write a program to find the node at which the intersection of two singly linked lists begins.\n>\n>\n> For example, the following two linked lists:\n\n```python\nA:          a1 → a2\n                   ↘\n                     c1 → c2 → c3\n                   ↗\nB:     b1 → b2 → b3\n```\n\n> begin to intersect at node c1.\n>\n>\n> Notes:\n>\n> If the two linked lists have no intersection at all, return null.\n> The linked lists must retain their original structure after the function returns.\n> You may assume there are no cycles anywhere in the entire linked structure.\n> Your code should preferably run in O(n) time and use only O(1) memory.\n\n最简单的方法就是先遍历一遍第一个链表所有的节点，然后记录下来，然后在遍历第二个链表节点的使用进行 查找即可，虽然很简单，但是时间复杂度很高和空间复杂度都挺高的：\n\n```c++\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    vector<ListNode *> vec;\n    while(headA) {\n        vec.push_back(headA);\n        headA = headA->next;\n    }\n    while(headB) {\n        if (find(vec.begin(),vec.end(),headB) != vec.end()) return headB;\n        headB = headB->next;\n    }\n    return nullptr;\n}\n```\n\n然后是另一种方法，观察下图：\n\n```python\nA:          a1 → a2\n                   ↘\n                     c1 → c2 → c3\n                   ↗\nB:     b1 → b2 → b3\n```\n\n如果我们可以不断的把c3,c2,c1去掉，到最后，我们就会找到交点,这个方法只需要`O(1)`的空间复杂度以及`O(n*k)`的时间复杂度，k是两个链表共同拥有的节点。\n\n```c++\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    //if (headA == nullptr || headB == nullptr) return nullptr;\n    ListNode *end = nullptr;\n    while(1) {\n        if (headA == end || headB == end) return end;\n        ListNode *pa = headA;\n        ListNode *pb = headB;\n        while(pa->next != end) pa = pa->next;\n        while(pb->next != end) pb = pb->next;\n        if (pa != pb) return end;\n        else end = pa;\n    }\n}\n```\n\n然后是在`dicuss`中看到的：\n\n```c++\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    ListNode *cur1 = headA, *cur2 = headB;\n    while(cur1 != cur2){\n        cur1 = cur1?cur1->next:headB;\n        cur2 = cur2?cur2->next:headA;\n    }\n    return cur1;\n}\n```\n\n第一眼看，没看懂，后来仔细看看才发现，`cur1`原本是`headA`开始的，但是在循环里面却被换成了`headB`,`cur2`同理。\n\n所以他们其实会走同样多的距离并到达交点,如果没有交点，就同时到达`nullptr`。\n","slug":"Intersection-of-Two-Linked-Lists","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o40065qmcm3smf1hve","content":"<p>第38天。</p>\n<p>今天课贼多，突然发现贼多作业没写完。。。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/intersection-of-two-linked-lists/description/\">Intersection of Two Linked Lists</a>:</p>\n<blockquote>\n<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n<p>For example, the following two linked lists:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A:          a1 → a2</span><br><span class=\"line\">                   ↘</span><br><span class=\"line\">                     c1 → c2 → c3</span><br><span class=\"line\">                   ↗</span><br><span class=\"line\">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>begin to intersect at node c1.</p>\n<p>Notes:</p>\n<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>\n</blockquote>\n<p>最简单的方法就是先遍历一遍第一个链表所有的节点，然后记录下来，然后在遍历第二个链表节点的使用进行 查找即可，虽然很简单，但是时间复杂度很高和空间复杂度都挺高的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;ListNode *&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(headA) &#123;</span><br><span class=\"line\">        vec.push_back(headA);</span><br><span class=\"line\">        headA = headA-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(headB) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (find(vec.begin(),vec.end(),headB) != vec.end()) <span class=\"keyword\">return</span> headB;</span><br><span class=\"line\">        headB = headB-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是另一种方法，观察下图：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A:          a1 → a2</span><br><span class=\"line\">                   ↘</span><br><span class=\"line\">                     c1 → c2 → c3</span><br><span class=\"line\">                   ↗</span><br><span class=\"line\">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>\n\n<p>如果我们可以不断的把c3,c2,c1去掉，到最后，我们就会找到交点,这个方法只需要<code>O(1)</code>的空间复杂度以及<code>O(n*k)</code>的时间复杂度，k是两个链表共同拥有的节点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if (headA == nullptr || headB == nullptr) return nullptr;</span></span><br><span class=\"line\">    ListNode *end = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == end || headB == end) <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">        ListNode *pa = headA;</span><br><span class=\"line\">        ListNode *pb = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pa-&gt;next != end) pa = pa-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pb-&gt;next != end) pb = pb-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pa != pb) <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> end = pa;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">    ListNode *cur1 = headA, *cur2 = headB;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur1 != cur2)&#123;</span><br><span class=\"line\">        cur1 = cur1?cur1-&gt;next:headB;</span><br><span class=\"line\">        cur2 = cur2?cur2-&gt;next:headA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一眼看，没看懂，后来仔细看看才发现，<code>cur1</code>原本是<code>headA</code>开始的，但是在循环里面却被换成了<code>headB</code>,<code>cur2</code>同理。</p>\n<p>所以他们其实会走同样多的距离并到达交点,如果没有交点，就同时到达<code>nullptr</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第38天。</p>\n<p>今天课贼多，突然发现贼多作业没写完。。。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/intersection-of-two-linked-lists/description/\">Intersection of Two Linked Lists</a>:</p>\n<blockquote>\n<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n<p>For example, the following two linked lists:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A:          a1 → a2</span><br><span class=\"line\">                   ↘</span><br><span class=\"line\">                     c1 → c2 → c3</span><br><span class=\"line\">                   ↗</span><br><span class=\"line\">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>begin to intersect at node c1.</p>\n<p>Notes:</p>\n<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>\n</blockquote>\n<p>最简单的方法就是先遍历一遍第一个链表所有的节点，然后记录下来，然后在遍历第二个链表节点的使用进行 查找即可，虽然很简单，但是时间复杂度很高和空间复杂度都挺高的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;ListNode *&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(headA) &#123;</span><br><span class=\"line\">        vec.push_back(headA);</span><br><span class=\"line\">        headA = headA-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(headB) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (find(vec.begin(),vec.end(),headB) != vec.end()) <span class=\"keyword\">return</span> headB;</span><br><span class=\"line\">        headB = headB-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是另一种方法，观察下图：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A:          a1 → a2</span><br><span class=\"line\">                   ↘</span><br><span class=\"line\">                     c1 → c2 → c3</span><br><span class=\"line\">                   ↗</span><br><span class=\"line\">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>\n\n<p>如果我们可以不断的把c3,c2,c1去掉，到最后，我们就会找到交点,这个方法只需要<code>O(1)</code>的空间复杂度以及<code>O(n*k)</code>的时间复杂度，k是两个链表共同拥有的节点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if (headA == nullptr || headB == nullptr) return nullptr;</span></span><br><span class=\"line\">    ListNode *end = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == end || headB == end) <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">        ListNode *pa = headA;</span><br><span class=\"line\">        ListNode *pb = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pa-&gt;next != end) pa = pa-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pb-&gt;next != end) pb = pb-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pa != pb) <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> end = pa;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">    ListNode *cur1 = headA, *cur2 = headB;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur1 != cur2)&#123;</span><br><span class=\"line\">        cur1 = cur1?cur1-&gt;next:headB;</span><br><span class=\"line\">        cur2 = cur2?cur2-&gt;next:headA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一眼看，没看懂，后来仔细看看才发现，<code>cur1</code>原本是<code>headA</code>开始的，但是在循环里面却被换成了<code>headB</code>,<code>cur2</code>同理。</p>\n<p>所以他们其实会走同样多的距离并到达交点,如果没有交点，就同时到达<code>nullptr</code>。</p>\n"},{"title":"Interval List Intersections","date":"2019-12-22T02:31:30.000Z","_content":"\n> 第46天。\n\n今天的题目是[Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/):\n\n挺简单的题目，用两个指针控制就好了：\n\n```c++\nvector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {\n    vector<vector<int>> res;\n    int i = 0, j = 0;\n    while(i < A.size() && j < B.size()) {\n        // check A[i] and B[j]\n        int left = max(A[i][0], B[j][0]), right = min(A[i][1], B[j][1]);\n        if (left <= right) res.push_back({left, right});\n        // update i and j\n        if (A[i][1] > B[j][1]) j++;\n        else if (A[i][1] < B[j][1]) i++;\n        else {\n            i++; j++;\n        }\n    }\n    \n    return res;\n}\n```\n","source":"_posts/Interval-List-Intersections.md","raw":"---\ntitle: Interval List Intersections\ndate: 2019-12-22T10:31:30.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第46天。\n\n今天的题目是[Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/):\n\n挺简单的题目，用两个指针控制就好了：\n\n```c++\nvector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {\n    vector<vector<int>> res;\n    int i = 0, j = 0;\n    while(i < A.size() && j < B.size()) {\n        // check A[i] and B[j]\n        int left = max(A[i][0], B[j][0]), right = min(A[i][1], B[j][1]);\n        if (left <= right) res.push_back({left, right});\n        // update i and j\n        if (A[i][1] > B[j][1]) j++;\n        else if (A[i][1] < B[j][1]) i++;\n        else {\n            i++; j++;\n        }\n    }\n    \n    return res;\n}\n```\n","slug":"Interval-List-Intersections","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o50068qmcm7sp62cv6","content":"<blockquote>\n<p>第46天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/interval-list-intersections/\">Interval List Intersections</a>:</p>\n<p>挺简单的题目，用两个指针控制就好了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; intervalIntersection(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; A.size() &amp;&amp; j &lt; B.size()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// check A[i] and B[j]</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = max(A[i][<span class=\"number\">0</span>], B[j][<span class=\"number\">0</span>]), right = min(A[i][<span class=\"number\">1</span>], B[j][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt;= right) res.push_back(&#123;left, right&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// update i and j</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[i][<span class=\"number\">1</span>] &gt; B[j][<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (A[i][<span class=\"number\">1</span>] &lt; B[j][<span class=\"number\">1</span>]) i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            i++; j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第46天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/interval-list-intersections/\">Interval List Intersections</a>:</p>\n<p>挺简单的题目，用两个指针控制就好了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; intervalIntersection(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; A.size() &amp;&amp; j &lt; B.size()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// check A[i] and B[j]</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = max(A[i][<span class=\"number\">0</span>], B[j][<span class=\"number\">0</span>]), right = min(A[i][<span class=\"number\">1</span>], B[j][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt;= right) res.push_back(&#123;left, right&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// update i and j</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[i][<span class=\"number\">1</span>] &gt; B[j][<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (A[i][<span class=\"number\">1</span>] &lt; B[j][<span class=\"number\">1</span>]) i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            i++; j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Invert Binary Tree","date":"2017-11-05T01:18:33.000Z","_content":"\n第41天。\n\n今天的题目是[Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/discuss/):\n\n>Invert a binary tree.\n\n```python\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n```\n\n> to\n\n```python\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n```\n\n> Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.\n\nemmmm，挺出名的一道题目。\n\n其实挺简单：\n\n```c++\nTreeNode* invertTre1e(TreeNode* root) {\n    if (root == nullptr) return root;\n    TreeNode *left = invertTree(root->right);\n    TreeNode *right = invertTree(root->left);\n    root->left = left;\n    root->right = right;\n    return root;\n}\n```\n\n然后是迭代的方法:\n\n```c++\nTreeNode* invertTree(TreeNode *root) {\n    stack<TreeNode *> st;\n    st.push(root);\n    TreeNode *ret =root;\n    while(!st.empty()) {\n        root = st.top();\n        st.pop();\n        if (root) {\n            st.push(root->left);\n            st.push(root->right);\n            TreeNode *t = root->left;\n            root->left = root->right;\n            root->right = t;\n        }\n    }\n    return ret;\n}\n```\n","source":"_posts/Invert-Binary-Tree.md","raw":"---\ntitle: Invert Binary Tree\ndate: 2017-11-05T09:18:33.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第41天。\n\n今天的题目是[Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/discuss/):\n\n>Invert a binary tree.\n\n```python\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n```\n\n> to\n\n```python\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n```\n\n> Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.\n\nemmmm，挺出名的一道题目。\n\n其实挺简单：\n\n```c++\nTreeNode* invertTre1e(TreeNode* root) {\n    if (root == nullptr) return root;\n    TreeNode *left = invertTree(root->right);\n    TreeNode *right = invertTree(root->left);\n    root->left = left;\n    root->right = right;\n    return root;\n}\n```\n\n然后是迭代的方法:\n\n```c++\nTreeNode* invertTree(TreeNode *root) {\n    stack<TreeNode *> st;\n    st.push(root);\n    TreeNode *ret =root;\n    while(!st.empty()) {\n        root = st.top();\n        st.pop();\n        if (root) {\n            st.push(root->left);\n            st.push(root->right);\n            TreeNode *t = root->left;\n            root->left = root->right;\n            root->right = t;\n        }\n    }\n    return ret;\n}\n```\n","slug":"Invert-Binary-Tree","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o5006cqmcm9pd094td","content":"<p>第41天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/invert-binary-tree/discuss/\">Invert Binary Tree</a>:</p>\n<blockquote>\n<p>Invert a binary tree.</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">4</span></span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  <span class=\"number\">2</span>     <span class=\"number\">7</span></span><br><span class=\"line\"> / \\   / \\</span><br><span class=\"line\"><span class=\"number\">1</span>   <span class=\"number\">3</span> <span class=\"number\">6</span>   <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>to</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">4</span></span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  <span class=\"number\">7</span>     <span class=\"number\">2</span></span><br><span class=\"line\"> / \\   / \\</span><br><span class=\"line\"><span class=\"number\">9</span>   <span class=\"number\">6</span> <span class=\"number\">3</span>   <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>\n</blockquote>\n<p>emmmm，挺出名的一道题目。</p>\n<p>其实挺简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">invertTre1e</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    TreeNode *left = invertTree(root-&gt;right);</span><br><span class=\"line\">    TreeNode *right = invertTree(root-&gt;left);</span><br><span class=\"line\">    root-&gt;left = left;</span><br><span class=\"line\">    root-&gt;right = right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是迭代的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    st.push(root);</span><br><span class=\"line\">    TreeNode *ret =root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">        root = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">            st.push(root-&gt;left);</span><br><span class=\"line\">            st.push(root-&gt;right);</span><br><span class=\"line\">            TreeNode *t = root-&gt;left;</span><br><span class=\"line\">            root-&gt;left = root-&gt;right;</span><br><span class=\"line\">            root-&gt;right = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第41天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/invert-binary-tree/discuss/\">Invert Binary Tree</a>:</p>\n<blockquote>\n<p>Invert a binary tree.</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">4</span></span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  <span class=\"number\">2</span>     <span class=\"number\">7</span></span><br><span class=\"line\"> / \\   / \\</span><br><span class=\"line\"><span class=\"number\">1</span>   <span class=\"number\">3</span> <span class=\"number\">6</span>   <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>to</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">4</span></span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  <span class=\"number\">7</span>     <span class=\"number\">2</span></span><br><span class=\"line\"> / \\   / \\</span><br><span class=\"line\"><span class=\"number\">9</span>   <span class=\"number\">6</span> <span class=\"number\">3</span>   <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>\n</blockquote>\n<p>emmmm，挺出名的一道题目。</p>\n<p>其实挺简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">invertTre1e</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    TreeNode *left = invertTree(root-&gt;right);</span><br><span class=\"line\">    TreeNode *right = invertTree(root-&gt;left);</span><br><span class=\"line\">    root-&gt;left = left;</span><br><span class=\"line\">    root-&gt;right = right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是迭代的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    st.push(root);</span><br><span class=\"line\">    TreeNode *ret =root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">        root = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">            st.push(root-&gt;left);</span><br><span class=\"line\">            st.push(root-&gt;right);</span><br><span class=\"line\">            TreeNode *t = root-&gt;left;</span><br><span class=\"line\">            root-&gt;left = root-&gt;right;</span><br><span class=\"line\">            root-&gt;right = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Is Graph Bipartite?","date":"2019-11-25T02:20:49.000Z","_content":"\n> 第21天。\n\n今天的题目是[  Is Graph Bipartite? ]( https://leetcode.com/problems/is-graph-bipartite/ )：\n\n---\n\nGiven an undirected `graph`, return `true` if and only if it is bipartite.\n\nRecall that a graph is *bipartite* if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.\n\nThe graph is given in the following form: `graph[i]` is a list of indexes `j` for which the edge between nodes `i` and `j` exists. Each node is an integer between `0` and `graph.length - 1`. There are no self edges or parallel edges: `graph[i]` does not contain `i`, and it doesn't contain any element twice.\n\n```\nExample 1:\nInput: [[1,3], [0,2], [1,3], [0,2]]\nOutput: true\nExplanation: \nThe graph looks like this:\n0----1\n|    |\n|    |\n3----2\nWe can divide the vertices into two groups: {0, 2} and {1, 3}.\nExample 2:\nInput: [[1,2,3], [0,2], [0,1,3], [0,2]]\nOutput: false\nExplanation: \nThe graph looks like this:\n0----1\n| \\  |\n|  \\ |\n3----2\nWe cannot find a way to divide the set of nodes into two independent subsets.\n```\n\n \n\n**Note:**\n\n- `graph` will have length in range `[1, 100]`.\n- `graph[i]` will contain integers in range `[0, graph.length - 1]`.\n- `graph[i]` will not contain `i` or duplicate values.\n- The graph is undirected: if any element `j` is in `graph[i]`, then `i` will be in `graph[j]`.\n\n---\n\n这是一道关于图的问题，题目的意思很简单，就是要判断一个图是不是一个二部图，所谓的二部图，就是一个图可以把所有节点划分到两个不相交的两个集合，这两个集合内部没有边相连。\n\n我们可以对图进行一次遍历，遍历的时候对节点进行着色，着色的规律是这样的，当从一个节点跳到另一个节点的时候，我们就切换一次颜色（共有三种颜色，其中一种表示没有访问，即白色）。因为遍历完了之后，整个图的节点就被划分成两部分了，接下来我们只需要判断所有节点的邻居是否和它是不同色的即可。代码如下：\n\n```c++\nchar color;\nbool isBipartite(vector<vector<int>>& graph) {\n    int size = graph.size();\n    vector<char> flags(size, 'w');\n    // w g b\n    color = 'b';\n    for(int i = 0;i < size;i++) {\n        if (flags[i] == 'w') {\n            dfs(graph, flags, i);\n        }\n    }\n\n    for(int i = 0;i < size;i++) {\n        for(auto j: graph[i]) {\n            if (flags[i] == flags[j]) return false;\n        }\n    }\n    return true;\n}\n\nvoid dfs(vector<vector<int>> &graph, vector<char> &flags, int index) {\n    flags[index] = color;\n    for(auto j: graph[index]) {\n        if (flags[j] == 'w') {\n            color = ~color;\n            dfs(graph, flags, j);\n            color = ~color;\n        }\n    }\n}\n```\n\n","source":"_posts/Is-Graph-Bipartite.md","raw":"---\ntitle: Is Graph Bipartite?\ndate: 2019-11-25T10:20:49.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第21天。\n\n今天的题目是[  Is Graph Bipartite? ]( https://leetcode.com/problems/is-graph-bipartite/ )：\n\n---\n\nGiven an undirected `graph`, return `true` if and only if it is bipartite.\n\nRecall that a graph is *bipartite* if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.\n\nThe graph is given in the following form: `graph[i]` is a list of indexes `j` for which the edge between nodes `i` and `j` exists. Each node is an integer between `0` and `graph.length - 1`. There are no self edges or parallel edges: `graph[i]` does not contain `i`, and it doesn't contain any element twice.\n\n```\nExample 1:\nInput: [[1,3], [0,2], [1,3], [0,2]]\nOutput: true\nExplanation: \nThe graph looks like this:\n0----1\n|    |\n|    |\n3----2\nWe can divide the vertices into two groups: {0, 2} and {1, 3}.\nExample 2:\nInput: [[1,2,3], [0,2], [0,1,3], [0,2]]\nOutput: false\nExplanation: \nThe graph looks like this:\n0----1\n| \\  |\n|  \\ |\n3----2\nWe cannot find a way to divide the set of nodes into two independent subsets.\n```\n\n \n\n**Note:**\n\n- `graph` will have length in range `[1, 100]`.\n- `graph[i]` will contain integers in range `[0, graph.length - 1]`.\n- `graph[i]` will not contain `i` or duplicate values.\n- The graph is undirected: if any element `j` is in `graph[i]`, then `i` will be in `graph[j]`.\n\n---\n\n这是一道关于图的问题，题目的意思很简单，就是要判断一个图是不是一个二部图，所谓的二部图，就是一个图可以把所有节点划分到两个不相交的两个集合，这两个集合内部没有边相连。\n\n我们可以对图进行一次遍历，遍历的时候对节点进行着色，着色的规律是这样的，当从一个节点跳到另一个节点的时候，我们就切换一次颜色（共有三种颜色，其中一种表示没有访问，即白色）。因为遍历完了之后，整个图的节点就被划分成两部分了，接下来我们只需要判断所有节点的邻居是否和它是不同色的即可。代码如下：\n\n```c++\nchar color;\nbool isBipartite(vector<vector<int>>& graph) {\n    int size = graph.size();\n    vector<char> flags(size, 'w');\n    // w g b\n    color = 'b';\n    for(int i = 0;i < size;i++) {\n        if (flags[i] == 'w') {\n            dfs(graph, flags, i);\n        }\n    }\n\n    for(int i = 0;i < size;i++) {\n        for(auto j: graph[i]) {\n            if (flags[i] == flags[j]) return false;\n        }\n    }\n    return true;\n}\n\nvoid dfs(vector<vector<int>> &graph, vector<char> &flags, int index) {\n    flags[index] = color;\n    for(auto j: graph[index]) {\n        if (flags[j] == 'w') {\n            color = ~color;\n            dfs(graph, flags, j);\n            color = ~color;\n        }\n    }\n}\n```\n\n","slug":"Is-Graph-Bipartite","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o6006fqmcm40fxcu3b","content":"<blockquote>\n<p>第21天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/is-graph-bipartite/\">  Is Graph Bipartite? </a>：</p>\n<hr>\n<p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>\n<p>Recall that a graph is <em>bipartite</em> if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>\n<p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists. Each node is an integer between <code>0</code> and <code>graph.length - 1</code>. There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn’t contain any element twice.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The graph looks like this:</span><br><span class=\"line\">0----1</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |</span><br><span class=\"line\">3----2</span><br><span class=\"line\">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br><span class=\"line\">Example 2:</span><br><span class=\"line\">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The graph looks like this:</span><br><span class=\"line\">0----1</span><br><span class=\"line\">| \\  |</span><br><span class=\"line\">|  \\ |</span><br><span class=\"line\">3----2</span><br><span class=\"line\">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ul>\n<li><code>graph</code> will have length in range <code>[1, 100]</code>.</li>\n<li><code>graph[i]</code> will contain integers in range <code>[0, graph.length - 1]</code>.</li>\n<li><code>graph[i]</code> will not contain <code>i</code> or duplicate values.</li>\n<li>The graph is undirected: if any element <code>j</code> is in <code>graph[i]</code>, then <code>i</code> will be in <code>graph[j]</code>.</li>\n</ul>\n<hr>\n<p>这是一道关于图的问题，题目的意思很简单，就是要判断一个图是不是一个二部图，所谓的二部图，就是一个图可以把所有节点划分到两个不相交的两个集合，这两个集合内部没有边相连。</p>\n<p>我们可以对图进行一次遍历，遍历的时候对节点进行着色，着色的规律是这样的，当从一个节点跳到另一个节点的时候，我们就切换一次颜色（共有三种颜色，其中一种表示没有访问，即白色）。因为遍历完了之后，整个图的节点就被划分成两部分了，接下来我们只需要判断所有节点的邻居是否和它是不同色的即可。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> color;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBipartite</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = graph.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; <span class=\"title\">flags</span><span class=\"params\">(size, <span class=\"string\">&#x27;w&#x27;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// w g b</span></span><br><span class=\"line\">    color = <span class=\"string\">&#x27;b&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flags[i] == <span class=\"string\">&#x27;w&#x27;</span>) &#123;</span><br><span class=\"line\">            dfs(graph, flags, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: graph[i]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flags[i] == flags[j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &amp;flags, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    flags[index] = color;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: graph[index]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flags[j] == <span class=\"string\">&#x27;w&#x27;</span>) &#123;</span><br><span class=\"line\">            color = ~color;</span><br><span class=\"line\">            dfs(graph, flags, j);</span><br><span class=\"line\">            color = ~color;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第21天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/is-graph-bipartite/\">  Is Graph Bipartite? </a>：</p>\n<hr>\n<p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>\n<p>Recall that a graph is <em>bipartite</em> if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>\n<p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists. Each node is an integer between <code>0</code> and <code>graph.length - 1</code>. There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn’t contain any element twice.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The graph looks like this:</span><br><span class=\"line\">0----1</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |</span><br><span class=\"line\">3----2</span><br><span class=\"line\">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br><span class=\"line\">Example 2:</span><br><span class=\"line\">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The graph looks like this:</span><br><span class=\"line\">0----1</span><br><span class=\"line\">| \\  |</span><br><span class=\"line\">|  \\ |</span><br><span class=\"line\">3----2</span><br><span class=\"line\">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ul>\n<li><code>graph</code> will have length in range <code>[1, 100]</code>.</li>\n<li><code>graph[i]</code> will contain integers in range <code>[0, graph.length - 1]</code>.</li>\n<li><code>graph[i]</code> will not contain <code>i</code> or duplicate values.</li>\n<li>The graph is undirected: if any element <code>j</code> is in <code>graph[i]</code>, then <code>i</code> will be in <code>graph[j]</code>.</li>\n</ul>\n<hr>\n<p>这是一道关于图的问题，题目的意思很简单，就是要判断一个图是不是一个二部图，所谓的二部图，就是一个图可以把所有节点划分到两个不相交的两个集合，这两个集合内部没有边相连。</p>\n<p>我们可以对图进行一次遍历，遍历的时候对节点进行着色，着色的规律是这样的，当从一个节点跳到另一个节点的时候，我们就切换一次颜色（共有三种颜色，其中一种表示没有访问，即白色）。因为遍历完了之后，整个图的节点就被划分成两部分了，接下来我们只需要判断所有节点的邻居是否和它是不同色的即可。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> color;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBipartite</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = graph.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; <span class=\"title\">flags</span><span class=\"params\">(size, <span class=\"string\">&#x27;w&#x27;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// w g b</span></span><br><span class=\"line\">    color = <span class=\"string\">&#x27;b&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flags[i] == <span class=\"string\">&#x27;w&#x27;</span>) &#123;</span><br><span class=\"line\">            dfs(graph, flags, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: graph[i]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flags[i] == flags[j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &amp;flags, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    flags[index] = color;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: graph[index]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flags[j] == <span class=\"string\">&#x27;w&#x27;</span>) &#123;</span><br><span class=\"line\">            color = ~color;</span><br><span class=\"line\">            dfs(graph, flags, j);</span><br><span class=\"line\">            color = ~color;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Judge-Route-Cicle","date":"2017-12-19T00:20:43.000Z","_content":"\n第83天。\n\n今天的题目是:[Judge Route Circle](https://leetcode.com/problems/judge-route-circle/description/):\n\n> Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.\n>\n> The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.\n>\n> Example 1:\n> Input: \"UD\"\n> Output: true\n> Example 2:\n> Input: \"LL\"\n> Output: false\n\n\n比较无聊的一道题目,我们只需要维护一组下标来记录所在的位置即可，然后判断移动完后是否回到了最开始的位置即可：\n\n```c++\nbool judgeCircle(string moves) {\n    int x = 0, y = 0;\n    for(auto c:moves) {\n        switch(c){\n            case 'U': y++; break;\n            case 'D': y--; break;\n            case 'L': x--; break;\n            case 'R': x++; break;\n        }\n    }\n    return x == 0 && y == 0;\n}\n```\n","source":"_posts/Judge-Route-Cicle.md","raw":"---\ntitle: Judge-Route-Cicle\ndate: 2017-12-19T08:20:43.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第83天。\n\n今天的题目是:[Judge Route Circle](https://leetcode.com/problems/judge-route-circle/description/):\n\n> Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.\n>\n> The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.\n>\n> Example 1:\n> Input: \"UD\"\n> Output: true\n> Example 2:\n> Input: \"LL\"\n> Output: false\n\n\n比较无聊的一道题目,我们只需要维护一组下标来记录所在的位置即可，然后判断移动完后是否回到了最开始的位置即可：\n\n```c++\nbool judgeCircle(string moves) {\n    int x = 0, y = 0;\n    for(auto c:moves) {\n        switch(c){\n            case 'U': y++; break;\n            case 'D': y--; break;\n            case 'L': x--; break;\n            case 'R': x++; break;\n        }\n    }\n    return x == 0 && y == 0;\n}\n```\n","slug":"Judge-Route-Cicle","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o7006iqmcmby9p2c29","content":"<p>第83天。</p>\n<p>今天的题目是:<a href=\"https://leetcode.com/problems/judge-route-circle/description/\">Judge Route Circle</a>:</p>\n<blockquote>\n<p>Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.</p>\n<p>The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.</p>\n<p>Example 1:<br>Input: “UD”<br>Output: true<br>Example 2:<br>Input: “LL”<br>Output: false</p>\n</blockquote>\n<p>比较无聊的一道题目,我们只需要维护一组下标来记录所在的位置即可，然后判断移动完后是否回到了最开始的位置即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judgeCircle</span><span class=\"params\">(<span class=\"built_in\">string</span> moves)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:moves) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(c)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;U&#x27;</span>: y++; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;D&#x27;</span>: y--; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>: x--; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;R&#x27;</span>: x++; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == <span class=\"number\">0</span> &amp;&amp; y == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第83天。</p>\n<p>今天的题目是:<a href=\"https://leetcode.com/problems/judge-route-circle/description/\">Judge Route Circle</a>:</p>\n<blockquote>\n<p>Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.</p>\n<p>The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.</p>\n<p>Example 1:<br>Input: “UD”<br>Output: true<br>Example 2:<br>Input: “LL”<br>Output: false</p>\n</blockquote>\n<p>比较无聊的一道题目,我们只需要维护一组下标来记录所在的位置即可，然后判断移动完后是否回到了最开始的位置即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judgeCircle</span><span class=\"params\">(<span class=\"built_in\">string</span> moves)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:moves) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(c)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;U&#x27;</span>: y++; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;D&#x27;</span>: y--; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>: x--; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;R&#x27;</span>: x++; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == <span class=\"number\">0</span> &amp;&amp; y == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Jump Game III","date":"2020-01-28T04:35:04.000Z","_content":"\n> 第61天。\n\n今天的题目是[Jump Game III](https://leetcode.com/problems/jump-game-iii/):\n\n用广度优先遍历出来即可，为了防止死循环，所以我们需要一个`visited`数组来记录某个位置的元素是否已经访问过来（即是否压入了队列中）：\n\n```c++\nbool canReach(vector<int>& arr, int start) {\n\tqueue<int> q;\n\tvector<int> visited(arr.size(), false);\n\tq.push(start);\n\tvisited[start] = true;\n\twhile(!q.empty()) {\n\t\tfor(int i = 0, size = q.size(); i < size; i++) {\n\t\t\tstart = q.front(); q.pop();\n\t\t\tif (arr[start] == 0) return true;\n\t\t\tif (start - arr[start] >= 0 && visited[start - arr[start]] == false) {\n\t\t\t\tq.push(start - arr[start]);\n\t\t\t\tvisited[start - arr[start]] = true;\n\t\t\t}    \n\t\t\tif (start + arr[start] < arr.size() && visited[start + arr[start]] == false) { \n\t\t\t\tq.push(start + arr[start]);\n\t\t\t\tvisited[start + arr[start]] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n```\n","source":"_posts/Jump-Game-III.md","raw":"---\ntitle: Jump Game III\ndate: 2020-01-28T12:35:04.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第61天。\n\n今天的题目是[Jump Game III](https://leetcode.com/problems/jump-game-iii/):\n\n用广度优先遍历出来即可，为了防止死循环，所以我们需要一个`visited`数组来记录某个位置的元素是否已经访问过来（即是否压入了队列中）：\n\n```c++\nbool canReach(vector<int>& arr, int start) {\n\tqueue<int> q;\n\tvector<int> visited(arr.size(), false);\n\tq.push(start);\n\tvisited[start] = true;\n\twhile(!q.empty()) {\n\t\tfor(int i = 0, size = q.size(); i < size; i++) {\n\t\t\tstart = q.front(); q.pop();\n\t\t\tif (arr[start] == 0) return true;\n\t\t\tif (start - arr[start] >= 0 && visited[start - arr[start]] == false) {\n\t\t\t\tq.push(start - arr[start]);\n\t\t\t\tvisited[start - arr[start]] = true;\n\t\t\t}    \n\t\t\tif (start + arr[start] < arr.size() && visited[start + arr[start]] == false) { \n\t\t\t\tq.push(start + arr[start]);\n\t\t\t\tvisited[start + arr[start]] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n```\n","slug":"Jump-Game-III","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o7006lqmcmcxul8ddw","content":"<blockquote>\n<p>第61天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/jump-game-iii/\">Jump Game III</a>:</p>\n<p>用广度优先遍历出来即可，为了防止死循环，所以我们需要一个<code>visited</code>数组来记录某个位置的元素是否已经访问过来（即是否压入了队列中）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canReach</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; arr, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(arr.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">\tq.push(start);</span><br><span class=\"line\">\tvisited[start] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = q.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\t\tstart = q.front(); q.pop();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (arr[start] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (start - arr[start] &gt;= <span class=\"number\">0</span> &amp;&amp; visited[start - arr[start]] == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">\t\t\t\tq.push(start - arr[start]);</span><br><span class=\"line\">\t\t\t\tvisited[start - arr[start]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;    </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (start + arr[start] &lt; arr.size() &amp;&amp; visited[start + arr[start]] == <span class=\"literal\">false</span>) &#123; </span><br><span class=\"line\">\t\t\t\tq.push(start + arr[start]);</span><br><span class=\"line\">\t\t\t\tvisited[start + arr[start]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第61天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/jump-game-iii/\">Jump Game III</a>:</p>\n<p>用广度优先遍历出来即可，为了防止死循环，所以我们需要一个<code>visited</code>数组来记录某个位置的元素是否已经访问过来（即是否压入了队列中）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canReach</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; arr, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(arr.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">\tq.push(start);</span><br><span class=\"line\">\tvisited[start] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = q.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\t\tstart = q.front(); q.pop();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (arr[start] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (start - arr[start] &gt;= <span class=\"number\">0</span> &amp;&amp; visited[start - arr[start]] == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">\t\t\t\tq.push(start - arr[start]);</span><br><span class=\"line\">\t\t\t\tvisited[start - arr[start]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;    </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (start + arr[start] &lt; arr.size() &amp;&amp; visited[start + arr[start]] == <span class=\"literal\">false</span>) &#123; </span><br><span class=\"line\">\t\t\t\tq.push(start + arr[start]);</span><br><span class=\"line\">\t\t\t\tvisited[start + arr[start]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Jump-Game","date":"2017-10-16T01:27:29.000Z","_content":"\n第23天\n\n又是周一，心塞，一周过去的真快。\n\n今天的题目是[Jump Game](https://leetcode.com/problems/jump-game/description/).\n\n> Given an array of non-negative integers, you are initially positioned at the first index of the array.\n>\n> Each element in the array represents your maximum jump length at that position.\n>\n> Determine if you are able to reach the last index.\n>\n> For example:\n> A = [2,3,1,1,4], return true.\n>\n> A = [3,2,1,0,4], return false.\n\n这道题，主要先理解到，他存放的是`maximum jump length`,也就是说，你可以跳小于这个值的步数。然后自然而然的就想到用递归去做啊：\n\n* 从后向前考虑，用一个值来记录可以从最后一个位置回去的最小index.\n* 在每一个index中，把当前的index当成是自己的要到达的点，再递归调用自己。\n\n```c++\nbool canJump1(vector<int>& nums) {\n    return canJump1(nums,nums.size() - 1);\n}\nbool canJump1(vector<int> &nums,int last) {\n    if (last == 0) return true;\n    int k = 1;\n    for(int i = last-1;i >= 0;i--,k++) {\n        if (nums[i] >= k && canJump1(nums,i))\n            return true;\n    }\n    return false;\n}\n```\n\n然后，这个方法就超时了，做了很多重复的操作。\n\n恩，再仔细看看题目的话，它其实只要求我们返回能否到达，不要求给出跳的方法，所以我们可以换一种思路来考虑，用一个`last`值来记录当前能到达的最远位置（初始值当然是0啦），然后遍历所有能到的点然后更新当前能到的最远点，如果当前能到的点已经大于`nums.size() - 1`了，那么说明我们可以到达，如果遍历完所有的点之后还没有大于，说明到不了：\n\n```c++\nbool canJump2(vector<int> &nums) {\n    int last = 0;\n    for(int i = 0;i <= last && i < nums.size();i++) {\n        last = max(last,i+nums[i]);\n        if (last >= nums.size()-1) return true;\n    }\n    return false;\n}\n```\n\n这个的时间复杂度是`O(n)`,尝试过优化，但是没能成功。\n\n最后是在`dicuss`中看到的方法，其实和上面的想法是一样的，只不过它是从后往前考虑:\n\n```c++\nbool canJump4(vector<int> &nums) {\n    int last = nums.size() - 1;\n    for(int i=nums.size() - 1;i >= 0;i--) {\n        if (i + nums[i] >= last) {\n            last = i;\n        }\n    }\n    return last <= 0;\n}\n```\n","source":"_posts/Jump-Game.md","raw":"---\ntitle: Jump-Game\ndate: 2017-10-16T09:27:29.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第23天\n\n又是周一，心塞，一周过去的真快。\n\n今天的题目是[Jump Game](https://leetcode.com/problems/jump-game/description/).\n\n> Given an array of non-negative integers, you are initially positioned at the first index of the array.\n>\n> Each element in the array represents your maximum jump length at that position.\n>\n> Determine if you are able to reach the last index.\n>\n> For example:\n> A = [2,3,1,1,4], return true.\n>\n> A = [3,2,1,0,4], return false.\n\n这道题，主要先理解到，他存放的是`maximum jump length`,也就是说，你可以跳小于这个值的步数。然后自然而然的就想到用递归去做啊：\n\n* 从后向前考虑，用一个值来记录可以从最后一个位置回去的最小index.\n* 在每一个index中，把当前的index当成是自己的要到达的点，再递归调用自己。\n\n```c++\nbool canJump1(vector<int>& nums) {\n    return canJump1(nums,nums.size() - 1);\n}\nbool canJump1(vector<int> &nums,int last) {\n    if (last == 0) return true;\n    int k = 1;\n    for(int i = last-1;i >= 0;i--,k++) {\n        if (nums[i] >= k && canJump1(nums,i))\n            return true;\n    }\n    return false;\n}\n```\n\n然后，这个方法就超时了，做了很多重复的操作。\n\n恩，再仔细看看题目的话，它其实只要求我们返回能否到达，不要求给出跳的方法，所以我们可以换一种思路来考虑，用一个`last`值来记录当前能到达的最远位置（初始值当然是0啦），然后遍历所有能到的点然后更新当前能到的最远点，如果当前能到的点已经大于`nums.size() - 1`了，那么说明我们可以到达，如果遍历完所有的点之后还没有大于，说明到不了：\n\n```c++\nbool canJump2(vector<int> &nums) {\n    int last = 0;\n    for(int i = 0;i <= last && i < nums.size();i++) {\n        last = max(last,i+nums[i]);\n        if (last >= nums.size()-1) return true;\n    }\n    return false;\n}\n```\n\n这个的时间复杂度是`O(n)`,尝试过优化，但是没能成功。\n\n最后是在`dicuss`中看到的方法，其实和上面的想法是一样的，只不过它是从后往前考虑:\n\n```c++\nbool canJump4(vector<int> &nums) {\n    int last = nums.size() - 1;\n    for(int i=nums.size() - 1;i >= 0;i--) {\n        if (i + nums[i] >= last) {\n            last = i;\n        }\n    }\n    return last <= 0;\n}\n```\n","slug":"Jump-Game","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o8006oqmcmh2sz0buk","content":"<p>第23天</p>\n<p>又是周一，心塞，一周过去的真快。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/jump-game/description/\">Jump Game</a>.</p>\n<blockquote>\n<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\n<p>Each element in the array represents your maximum jump length at that position.</p>\n<p>Determine if you are able to reach the last index.</p>\n<p>For example:<br>A = [2,3,1,1,4], return true.</p>\n<p>A = [3,2,1,0,4], return false.</p>\n</blockquote>\n<p>这道题，主要先理解到，他存放的是<code>maximum jump length</code>,也就是说，你可以跳小于这个值的步数。然后自然而然的就想到用递归去做啊：</p>\n<ul>\n<li>从后向前考虑，用一个值来记录可以从最后一个位置回去的最小index.</li>\n<li>在每一个index中，把当前的index当成是自己的要到达的点，再递归调用自己。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canJump1(nums,nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = last<span class=\"number\">-1</span>;i &gt;= <span class=\"number\">0</span>;i--,k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &gt;= k &amp;&amp; canJump1(nums,i))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，这个方法就超时了，做了很多重复的操作。</p>\n<p>恩，再仔细看看题目的话，它其实只要求我们返回能否到达，不要求给出跳的方法，所以我们可以换一种思路来考虑，用一个<code>last</code>值来记录当前能到达的最远位置（初始值当然是0啦），然后遍历所有能到的点然后更新当前能到的最远点，如果当前能到的点已经大于<code>nums.size() - 1</code>了，那么说明我们可以到达，如果遍历完所有的点之后还没有大于，说明到不了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump2</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;= last &amp;&amp; i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        last = max(last,i+nums[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last &gt;= nums.size()<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个的时间复杂度是<code>O(n)</code>,尝试过优化，但是没能成功。</p>\n<p>最后是在<code>dicuss</code>中看到的方法，其实和上面的想法是一样的，只不过它是从后往前考虑:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump4</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=nums.size() - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + nums[i] &gt;= last) &#123;</span><br><span class=\"line\">            last = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第23天</p>\n<p>又是周一，心塞，一周过去的真快。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/jump-game/description/\">Jump Game</a>.</p>\n<blockquote>\n<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\n<p>Each element in the array represents your maximum jump length at that position.</p>\n<p>Determine if you are able to reach the last index.</p>\n<p>For example:<br>A = [2,3,1,1,4], return true.</p>\n<p>A = [3,2,1,0,4], return false.</p>\n</blockquote>\n<p>这道题，主要先理解到，他存放的是<code>maximum jump length</code>,也就是说，你可以跳小于这个值的步数。然后自然而然的就想到用递归去做啊：</p>\n<ul>\n<li>从后向前考虑，用一个值来记录可以从最后一个位置回去的最小index.</li>\n<li>在每一个index中，把当前的index当成是自己的要到达的点，再递归调用自己。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canJump1(nums,nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = last<span class=\"number\">-1</span>;i &gt;= <span class=\"number\">0</span>;i--,k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &gt;= k &amp;&amp; canJump1(nums,i))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，这个方法就超时了，做了很多重复的操作。</p>\n<p>恩，再仔细看看题目的话，它其实只要求我们返回能否到达，不要求给出跳的方法，所以我们可以换一种思路来考虑，用一个<code>last</code>值来记录当前能到达的最远位置（初始值当然是0啦），然后遍历所有能到的点然后更新当前能到的最远点，如果当前能到的点已经大于<code>nums.size() - 1</code>了，那么说明我们可以到达，如果遍历完所有的点之后还没有大于，说明到不了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump2</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;= last &amp;&amp; i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        last = max(last,i+nums[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last &gt;= nums.size()<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个的时间复杂度是<code>O(n)</code>,尝试过优化，但是没能成功。</p>\n<p>最后是在<code>dicuss</code>中看到的方法，其实和上面的想法是一样的，只不过它是从后往前考虑:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump4</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=nums.size() - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + nums[i] &gt;= last) &#123;</span><br><span class=\"line\">            last = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"K Closest Points to Origin","date":"2019-11-06T05:24:29.000Z","_content":"\n> 第2天了。\n\n今天的题目是[https://leetcode.com/problems/k-closest-points-to-origin/](K Closest Points to Origin):\n\n---\n\nWe have a list of `points` on the plane. Find the `K` closest points to the origin `(0, 0)`.\n\n(Here, the distance between two points on a plane is the Euclidean distance.)\n\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)\n\n \n\n**Example 1:**\n\n```\nInput: points = [[1,3],[-2,2]], K = 1\nOutput: [[-2,2]]\nExplanation: \nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].\n```\n\n**Example 2:**\n\n```\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\nOutput: [[3,3],[-2,4]]\n(The answer [[-2,4],[3,3]] would also be accepted.)\n```\n\n \n\n**Note:**\n\n1. `1 <= K <= points.length <= 10000`\n2. `-10000 < points[i][0] < 10000`\n3. `-10000 < points[i][1] < 10000`\n\n---\n\n今天的题目比较简单，虽然是一道`Mediem`的题目，但是不知道为什么好像常规做法就AC了。解法就是算每个点到原点的距离先，然后排序，最后取出前K个就好了：\n\n```c++\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\n    vector<vector<int>> res;\n    vector<pair<int, int>> index;\n    for(int i = 0, size = points.size(); i < size; i++) {\n        pair<int,int> p = {i, points[i][0]*points[i][0] + points[i][1]*points[i][1]};\n        index.push_back(p);\n    }\n\n    sort(index.begin(), index.end(), [](const pair<int, int> &pi, const pair<int, int> &pj) {\n        return pi.second < pj.second;\n    });\n\n    for(int i = 0;i < K;i++) {\n        res.push_back(points[index[i].first]);\n    }\n\n    return res;\n}\n```\n\n","source":"_posts/K-Closest-Points-to-Origin.md","raw":"---\ntitle: K Closest Points to Origin\ndate: 2019-11-06T13:24:29.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n> 第2天了。\n\n今天的题目是[https://leetcode.com/problems/k-closest-points-to-origin/](K Closest Points to Origin):\n\n---\n\nWe have a list of `points` on the plane. Find the `K` closest points to the origin `(0, 0)`.\n\n(Here, the distance between two points on a plane is the Euclidean distance.)\n\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)\n\n \n\n**Example 1:**\n\n```\nInput: points = [[1,3],[-2,2]], K = 1\nOutput: [[-2,2]]\nExplanation: \nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].\n```\n\n**Example 2:**\n\n```\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\nOutput: [[3,3],[-2,4]]\n(The answer [[-2,4],[3,3]] would also be accepted.)\n```\n\n \n\n**Note:**\n\n1. `1 <= K <= points.length <= 10000`\n2. `-10000 < points[i][0] < 10000`\n3. `-10000 < points[i][1] < 10000`\n\n---\n\n今天的题目比较简单，虽然是一道`Mediem`的题目，但是不知道为什么好像常规做法就AC了。解法就是算每个点到原点的距离先，然后排序，最后取出前K个就好了：\n\n```c++\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\n    vector<vector<int>> res;\n    vector<pair<int, int>> index;\n    for(int i = 0, size = points.size(); i < size; i++) {\n        pair<int,int> p = {i, points[i][0]*points[i][0] + points[i][1]*points[i][1]};\n        index.push_back(p);\n    }\n\n    sort(index.begin(), index.end(), [](const pair<int, int> &pi, const pair<int, int> &pj) {\n        return pi.second < pj.second;\n    });\n\n    for(int i = 0;i < K;i++) {\n        res.push_back(points[index[i].first]);\n    }\n\n    return res;\n}\n```\n\n","slug":"K-Closest-Points-to-Origin","published":1,"updated":"2021-03-10T13:47:05.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o8006rqmcma9sy46m2","content":"<blockquote>\n<p>第2天了。</p>\n</blockquote>\n<p>今天的题目是[<a href=\"https://leetcode.com/problems/k-closest-points-to-origin/]\">https://leetcode.com/problems/k-closest-points-to-origin/]</a>(K Closest Points to Origin):</p>\n<hr>\n<p>We have a list of <code>points</code> on the plane. Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.</p>\n<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>\n<p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: points &#x3D; [[1,3],[-2,2]], K &#x3D; 1</span><br><span class=\"line\">Output: [[-2,2]]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class=\"line\">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class=\"line\">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class=\"line\">We only want the closest K &#x3D; 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: points &#x3D; [[3,3],[5,-1],[-2,4]], K &#x3D; 2</span><br><span class=\"line\">Output: [[3,3],[-2,4]]</span><br><span class=\"line\">(The answer [[-2,4],[3,3]] would also be accepted.)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>\n<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>\n<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>\n</ol>\n<hr>\n<p>今天的题目比较简单，虽然是一道<code>Mediem</code>的题目，但是不知道为什么好像常规做法就AC了。解法就是算每个点到原点的距离先，然后排序，最后取出前K个就好了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; kClosest(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; points, <span class=\"keyword\">int</span> K) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; index;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = points.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; p = &#123;i, points[i][<span class=\"number\">0</span>]*points[i][<span class=\"number\">0</span>] + points[i][<span class=\"number\">1</span>]*points[i][<span class=\"number\">1</span>]&#125;;</span><br><span class=\"line\">        index.push_back(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort(index.begin(), index.end(), [](<span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &amp;pi, <span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &amp;pj) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pi.second &lt; pj.second;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; K;i++) &#123;</span><br><span class=\"line\">        res.push_back(points[index[i].first]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第2天了。</p>\n</blockquote>\n<p>今天的题目是[<a href=\"https://leetcode.com/problems/k-closest-points-to-origin/]\">https://leetcode.com/problems/k-closest-points-to-origin/]</a>(K Closest Points to Origin):</p>\n<hr>\n<p>We have a list of <code>points</code> on the plane. Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.</p>\n<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>\n<p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: points &#x3D; [[1,3],[-2,2]], K &#x3D; 1</span><br><span class=\"line\">Output: [[-2,2]]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class=\"line\">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class=\"line\">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class=\"line\">We only want the closest K &#x3D; 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: points &#x3D; [[3,3],[5,-1],[-2,4]], K &#x3D; 2</span><br><span class=\"line\">Output: [[3,3],[-2,4]]</span><br><span class=\"line\">(The answer [[-2,4],[3,3]] would also be accepted.)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>\n<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>\n<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>\n</ol>\n<hr>\n<p>今天的题目比较简单，虽然是一道<code>Mediem</code>的题目，但是不知道为什么好像常规做法就AC了。解法就是算每个点到原点的距离先，然后排序，最后取出前K个就好了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; kClosest(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; points, <span class=\"keyword\">int</span> K) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; index;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = points.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; p = &#123;i, points[i][<span class=\"number\">0</span>]*points[i][<span class=\"number\">0</span>] + points[i][<span class=\"number\">1</span>]*points[i][<span class=\"number\">1</span>]&#125;;</span><br><span class=\"line\">        index.push_back(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort(index.begin(), index.end(), [](<span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &amp;pi, <span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &amp;pj) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pi.second &lt; pj.second;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; K;i++) &#123;</span><br><span class=\"line\">        res.push_back(points[index[i].first]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Keys and Rooms","date":"2019-11-15T12:42:32.000Z","_content":"\n> 第11天。\n\n今天的题目是[Keys and Rooms](https://leetcode.com/problems/keys-and-rooms/)：\n\n---\n\nThere are `N` rooms and you start in room `0`. Each room has a distinct number in `0, 1, 2, ..., N-1`, and each room may have some keys to access the next room. \n\nFormally, each room `i` has a list of keys `rooms[i]`, and each key `rooms[i][j]` is an integer in `[0, 1, ..., N-1]` where `N = rooms.length`. A key `rooms[i][j] = v` opens the room with number `v`.\n\nInitially, all the rooms start locked (except for room `0`). \n\nYou can walk back and forth between rooms freely.\n\nReturn `true` if and only if you can enter every room.\n\n\n\n**Example 1:**\n\n```\nInput: [[1],[2],[3],[]]\nOutput: true\nExplanation:  \nWe start in room 0, and pick up key 1.\nWe then go to room 1, and pick up key 2.\nWe then go to room 2, and pick up key 3.\nWe then go to room 3.  Since we were able to go to every room, we return true.\n```\n\n**Example 2:**\n\n```\nInput: [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can't enter the room with number 2.\n```\n\n**Note:**\n\n1. `1 <= rooms.length <= 1000`\n2. `0 <= rooms[i].length <= 1000`\n3. The number of keys in all rooms combined is at most `3000`.\n\n---\n\n很简单的一道题，仔细分析一下题目的话，就会发现这个输入其实构成一张图，`rooms[i]`表示从第`i`个节点出发走向的节点列表。然后这个问题就转变成，从`0`号节点出发，能不能遍历完所有节点的问题了，这个问题直接无脑`dfs`就好了，实现代码如下：\n\n```c++\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\n    vector<bool> visited(rooms.size(), false);\n    dfs(rooms, visited, 0);\n    \n    for(int i = 0;i < visited.size(); ++i) { \n        if (visited[i] == false) {\n            return false;\n        } \n    }\n    return true;\n}\nvoid dfs(vector<vector<int>>& rooms, vector<bool> &visited, int index = 0) {\n    visited[index] = true;\n    for(int i = 0;i < rooms[index].size(); ++i) {\n        if (visited[rooms[index][i]] == false) {\n            dfs(rooms, visited, rooms[index][i]);\n        }\n    }\n}\n```\n","source":"_posts/Keys-and-Rooms.md","raw":"---\ntitle: Keys and Rooms\ndate: 2019-11-15T20:42:32.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第11天。\n\n今天的题目是[Keys and Rooms](https://leetcode.com/problems/keys-and-rooms/)：\n\n---\n\nThere are `N` rooms and you start in room `0`. Each room has a distinct number in `0, 1, 2, ..., N-1`, and each room may have some keys to access the next room. \n\nFormally, each room `i` has a list of keys `rooms[i]`, and each key `rooms[i][j]` is an integer in `[0, 1, ..., N-1]` where `N = rooms.length`. A key `rooms[i][j] = v` opens the room with number `v`.\n\nInitially, all the rooms start locked (except for room `0`). \n\nYou can walk back and forth between rooms freely.\n\nReturn `true` if and only if you can enter every room.\n\n\n\n**Example 1:**\n\n```\nInput: [[1],[2],[3],[]]\nOutput: true\nExplanation:  \nWe start in room 0, and pick up key 1.\nWe then go to room 1, and pick up key 2.\nWe then go to room 2, and pick up key 3.\nWe then go to room 3.  Since we were able to go to every room, we return true.\n```\n\n**Example 2:**\n\n```\nInput: [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can't enter the room with number 2.\n```\n\n**Note:**\n\n1. `1 <= rooms.length <= 1000`\n2. `0 <= rooms[i].length <= 1000`\n3. The number of keys in all rooms combined is at most `3000`.\n\n---\n\n很简单的一道题，仔细分析一下题目的话，就会发现这个输入其实构成一张图，`rooms[i]`表示从第`i`个节点出发走向的节点列表。然后这个问题就转变成，从`0`号节点出发，能不能遍历完所有节点的问题了，这个问题直接无脑`dfs`就好了，实现代码如下：\n\n```c++\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\n    vector<bool> visited(rooms.size(), false);\n    dfs(rooms, visited, 0);\n    \n    for(int i = 0;i < visited.size(); ++i) { \n        if (visited[i] == false) {\n            return false;\n        } \n    }\n    return true;\n}\nvoid dfs(vector<vector<int>>& rooms, vector<bool> &visited, int index = 0) {\n    visited[index] = true;\n    for(int i = 0;i < rooms[index].size(); ++i) {\n        if (visited[rooms[index][i]] == false) {\n            dfs(rooms, visited, rooms[index][i]);\n        }\n    }\n}\n```\n","slug":"Keys-and-Rooms","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69o9006uqmcmg4ubbn4a","content":"<blockquote>\n<p>第11天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/keys-and-rooms/\">Keys and Rooms</a>：</p>\n<hr>\n<p>There are <code>N</code> rooms and you start in room <code>0</code>. Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have some keys to access the next room. </p>\n<p>Formally, each room <code>i</code> has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>. A key <code>rooms[i][j] = v</code> opens the room with number <code>v</code>.</p>\n<p>Initially, all the rooms start locked (except for room <code>0</code>). </p>\n<p>You can walk back and forth between rooms freely.</p>\n<p>Return <code>true</code> if and only if you can enter every room.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [[1],[2],[3],[]]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation:  </span><br><span class=\"line\">We start in room 0, and pick up key 1.</span><br><span class=\"line\">We then go to room 1, and pick up key 2.</span><br><span class=\"line\">We then go to room 2, and pick up key 3.</span><br><span class=\"line\">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: We can&#39;t enter the room with number 2.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= rooms.length &lt;= 1000</code></li>\n<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n<li>The number of keys in all rooms combined is at most <code>3000</code>.</li>\n</ol>\n<hr>\n<p>很简单的一道题，仔细分析一下题目的话，就会发现这个输入其实构成一张图，<code>rooms[i]</code>表示从第<code>i</code>个节点出发走向的节点列表。然后这个问题就转变成，从<code>0</code>号节点出发，能不能遍历完所有节点的问题了，这个问题直接无脑<code>dfs</code>就好了，实现代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canVisitAllRooms</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(rooms.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    dfs(rooms, visited, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; visited.size(); ++i) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; rooms, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &amp;visited, <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>)</span> </span>&#123;</span><br><span class=\"line\">    visited[index] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; rooms[index].size(); ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[rooms[index][i]] == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">            dfs(rooms, visited, rooms[index][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第11天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/keys-and-rooms/\">Keys and Rooms</a>：</p>\n<hr>\n<p>There are <code>N</code> rooms and you start in room <code>0</code>. Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have some keys to access the next room. </p>\n<p>Formally, each room <code>i</code> has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>. A key <code>rooms[i][j] = v</code> opens the room with number <code>v</code>.</p>\n<p>Initially, all the rooms start locked (except for room <code>0</code>). </p>\n<p>You can walk back and forth between rooms freely.</p>\n<p>Return <code>true</code> if and only if you can enter every room.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [[1],[2],[3],[]]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation:  </span><br><span class=\"line\">We start in room 0, and pick up key 1.</span><br><span class=\"line\">We then go to room 1, and pick up key 2.</span><br><span class=\"line\">We then go to room 2, and pick up key 3.</span><br><span class=\"line\">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: We can&#39;t enter the room with number 2.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= rooms.length &lt;= 1000</code></li>\n<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n<li>The number of keys in all rooms combined is at most <code>3000</code>.</li>\n</ol>\n<hr>\n<p>很简单的一道题，仔细分析一下题目的话，就会发现这个输入其实构成一张图，<code>rooms[i]</code>表示从第<code>i</code>个节点出发走向的节点列表。然后这个问题就转变成，从<code>0</code>号节点出发，能不能遍历完所有节点的问题了，这个问题直接无脑<code>dfs</code>就好了，实现代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canVisitAllRooms</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(rooms.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    dfs(rooms, visited, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; visited.size(); ++i) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; rooms, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &amp;visited, <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>)</span> </span>&#123;</span><br><span class=\"line\">    visited[index] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; rooms[index].size(); ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[rooms[index][i]] == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">            dfs(rooms, visited, rooms[index][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Kth Largest Element in an array","date":"2017-11-03T00:28:57.000Z","_content":"\n第39天。\n\n今天的题目是[Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/):\n\n> Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n>\n> For example,\n> Given [3,2,1,5,6,4] and k = 2, return 5.\n>\n> Note:\n> You may assume k is always valid, 1 ≤ k ≤ array's length.\n\n简单的做法就是先对无序的数组进行倒序排序，然后返回`nums[k-1]`即可。\n\n```c++\nint findKthLargest(vector<int>& nums, int k) {\n    sort(nums.begin(),nums.end(),[](int a,int b ){ return a > b; });\n    return nums[k-1];\n}\n```\n\n时间复杂度是`O(nlog(n))`.然后是利用`partition`的方法:\n\n```c++\nint findKthLargest(vector<int>& nums, int k) {\n    return findKthLargest(nums,0,nums.size() - 1,k-1); \n}\nint findKthLargest(vector<int> &nums,int first,int last,int k) {\n    int p = partition(nums,first,last);\n    if (k > p) return findKthLargest(nums,p+1,last,k);\n    else if (k < p) return findKthLargest(nums,first,p-1,k);\n    else return nums[p];\n}\nint partition(vector<int> &nums,int first,int last) {\n    if (first == last) return first;\n    swap(nums[first],nums[(random() % (last-first) + first)]);\n    int k = nums[first];\n    while(first < last) {\n        while(first < last && nums[last] <= k) last--;\n        nums[first] = nums[last];\n        while(first < last && nums[first] >= k) first++;\n        nums[last] = nums[first];\n    }\n    nums[first] = k;\n    return first;\n}\n```\n\n显然和上面快排的方法一样时间复杂度都是`O(nlogn)`.\n\n然后是在`dicuss`中看到的用堆排的方法:\n\n```c++\nint heap_size;\ninline int left(int idx) {\n    return (idx << 1) + 1;\n}\ninline int right(int idx) {\n    return (idx << 1) + 2;\n}\nvoid max_heapify(vector<int>& nums, int idx) {\n    int largest = idx;\n    int l = left(idx), r = right(idx);\n    if (l < heap_size && nums[l] > nums[largest]) largest = l;\n    if (r < heap_size && nums[r] > nums[largest]) largest = r;\n    if (largest != idx) {\n        swap(nums[idx], nums[largest]);\n        max_heapify(nums, largest);\n    }\n}\nvoid build_max_heap(vector<int>& nums) {\n    heap_size = nums.size();\n    for (int i = (heap_size >> 1) - 1; i >= 0; i--)\n        max_heapify(nums, i);\n}\nint findKthLargest(vector<int>& nums, int k) {\n    build_max_heap(nums);\n    for (int i = 0; i < k; i++) {\n        swap(nums[0], nums[heap_size - 1]);\n        heap_size--;\n        max_heapify(nums, 0);\n    }\n    return nums[heap_size];\n}\n```\n\n还有用`STL`中`priority_queue`的：\n\n```c++\nint findKthLargest(vector<int>& nums, int k) {\n    priority_queue<int> pq(nums.begin(), nums.end());\n    for (int i = 0; i < k - 1; i++)\n        pq.pop(); \n    return pq.top();\n}\n```\n","source":"_posts/Kth-Largest-Element-in-an-array.md","raw":"---\ntitle: Kth Largest Element in an array\ndate: 2017-11-03T08:28:57.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第39天。\n\n今天的题目是[Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/):\n\n> Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n>\n> For example,\n> Given [3,2,1,5,6,4] and k = 2, return 5.\n>\n> Note:\n> You may assume k is always valid, 1 ≤ k ≤ array's length.\n\n简单的做法就是先对无序的数组进行倒序排序，然后返回`nums[k-1]`即可。\n\n```c++\nint findKthLargest(vector<int>& nums, int k) {\n    sort(nums.begin(),nums.end(),[](int a,int b ){ return a > b; });\n    return nums[k-1];\n}\n```\n\n时间复杂度是`O(nlog(n))`.然后是利用`partition`的方法:\n\n```c++\nint findKthLargest(vector<int>& nums, int k) {\n    return findKthLargest(nums,0,nums.size() - 1,k-1); \n}\nint findKthLargest(vector<int> &nums,int first,int last,int k) {\n    int p = partition(nums,first,last);\n    if (k > p) return findKthLargest(nums,p+1,last,k);\n    else if (k < p) return findKthLargest(nums,first,p-1,k);\n    else return nums[p];\n}\nint partition(vector<int> &nums,int first,int last) {\n    if (first == last) return first;\n    swap(nums[first],nums[(random() % (last-first) + first)]);\n    int k = nums[first];\n    while(first < last) {\n        while(first < last && nums[last] <= k) last--;\n        nums[first] = nums[last];\n        while(first < last && nums[first] >= k) first++;\n        nums[last] = nums[first];\n    }\n    nums[first] = k;\n    return first;\n}\n```\n\n显然和上面快排的方法一样时间复杂度都是`O(nlogn)`.\n\n然后是在`dicuss`中看到的用堆排的方法:\n\n```c++\nint heap_size;\ninline int left(int idx) {\n    return (idx << 1) + 1;\n}\ninline int right(int idx) {\n    return (idx << 1) + 2;\n}\nvoid max_heapify(vector<int>& nums, int idx) {\n    int largest = idx;\n    int l = left(idx), r = right(idx);\n    if (l < heap_size && nums[l] > nums[largest]) largest = l;\n    if (r < heap_size && nums[r] > nums[largest]) largest = r;\n    if (largest != idx) {\n        swap(nums[idx], nums[largest]);\n        max_heapify(nums, largest);\n    }\n}\nvoid build_max_heap(vector<int>& nums) {\n    heap_size = nums.size();\n    for (int i = (heap_size >> 1) - 1; i >= 0; i--)\n        max_heapify(nums, i);\n}\nint findKthLargest(vector<int>& nums, int k) {\n    build_max_heap(nums);\n    for (int i = 0; i < k; i++) {\n        swap(nums[0], nums[heap_size - 1]);\n        heap_size--;\n        max_heapify(nums, 0);\n    }\n    return nums[heap_size];\n}\n```\n\n还有用`STL`中`priority_queue`的：\n\n```c++\nint findKthLargest(vector<int>& nums, int k) {\n    priority_queue<int> pq(nums.begin(), nums.end());\n    for (int i = 0; i < k - 1; i++)\n        pq.pop(); \n    return pq.top();\n}\n```\n","slug":"Kth-Largest-Element-in-an-array","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oa006xqmcm57nrgb7s","content":"<p>第39天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/description/\">Kth Largest Element in an Array</a>:</p>\n<blockquote>\n<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>\n<p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p>\n<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>\n</blockquote>\n<p>简单的做法就是先对无序的数组进行倒序排序，然后返回<code>nums[k-1]</code>即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums.begin(),nums.end(),[](<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b )&#123; <span class=\"keyword\">return</span> a &gt; b; &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[k<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度是<code>O(nlog(n))</code>.然后是利用<code>partition</code>的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findKthLargest(nums,<span class=\"number\">0</span>,nums.size() - <span class=\"number\">1</span>,k<span class=\"number\">-1</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = partition(nums,first,last);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &gt; p) <span class=\"keyword\">return</span> findKthLargest(nums,p+<span class=\"number\">1</span>,last,k);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; p) <span class=\"keyword\">return</span> findKthLargest(nums,first,p<span class=\"number\">-1</span>,k);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> nums[p];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first == last) <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    swap(nums[first],nums[(random() % (last-first) + first)]);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = nums[first];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt; last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(first &lt; last &amp;&amp; nums[last] &lt;= k) last--;</span><br><span class=\"line\">        nums[first] = nums[last];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(first &lt; last &amp;&amp; nums[first] &gt;= k) first++;</span><br><span class=\"line\">        nums[last] = nums[first];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums[first] = k;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显然和上面快排的方法一样时间复杂度都是<code>O(nlogn)</code>.</p>\n<p>然后是在<code>dicuss</code>中看到的用堆排的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> heap_size;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">left</span><span class=\"params\">(<span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (idx &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">right</span><span class=\"params\">(<span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (idx &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">max_heapify</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> largest = idx;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = left(idx), r = right(idx);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &lt; heap_size &amp;&amp; nums[l] &gt; nums[largest]) largest = l;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r &lt; heap_size &amp;&amp; nums[r] &gt; nums[largest]) largest = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (largest != idx) &#123;</span><br><span class=\"line\">        swap(nums[idx], nums[largest]);</span><br><span class=\"line\">        max_heapify(nums, largest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_max_heap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    heap_size = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (heap_size &gt;&gt; <span class=\"number\">1</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        max_heapify(nums, i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    build_max_heap(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">        swap(nums[<span class=\"number\">0</span>], nums[heap_size - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        heap_size--;</span><br><span class=\"line\">        max_heapify(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[heap_size];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有用<code>STL</code>中<code>priority_queue</code>的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">priority_queue</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">pq</span><span class=\"params\">(nums.begin(), nums.end())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">        pq.pop(); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> pq.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第39天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/description/\">Kth Largest Element in an Array</a>:</p>\n<blockquote>\n<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>\n<p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p>\n<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>\n</blockquote>\n<p>简单的做法就是先对无序的数组进行倒序排序，然后返回<code>nums[k-1]</code>即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums.begin(),nums.end(),[](<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b )&#123; <span class=\"keyword\">return</span> a &gt; b; &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[k<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度是<code>O(nlog(n))</code>.然后是利用<code>partition</code>的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findKthLargest(nums,<span class=\"number\">0</span>,nums.size() - <span class=\"number\">1</span>,k<span class=\"number\">-1</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = partition(nums,first,last);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &gt; p) <span class=\"keyword\">return</span> findKthLargest(nums,p+<span class=\"number\">1</span>,last,k);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; p) <span class=\"keyword\">return</span> findKthLargest(nums,first,p<span class=\"number\">-1</span>,k);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> nums[p];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first == last) <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    swap(nums[first],nums[(random() % (last-first) + first)]);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = nums[first];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt; last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(first &lt; last &amp;&amp; nums[last] &lt;= k) last--;</span><br><span class=\"line\">        nums[first] = nums[last];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(first &lt; last &amp;&amp; nums[first] &gt;= k) first++;</span><br><span class=\"line\">        nums[last] = nums[first];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums[first] = k;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显然和上面快排的方法一样时间复杂度都是<code>O(nlogn)</code>.</p>\n<p>然后是在<code>dicuss</code>中看到的用堆排的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> heap_size;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">left</span><span class=\"params\">(<span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (idx &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">right</span><span class=\"params\">(<span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (idx &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">max_heapify</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> largest = idx;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = left(idx), r = right(idx);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &lt; heap_size &amp;&amp; nums[l] &gt; nums[largest]) largest = l;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r &lt; heap_size &amp;&amp; nums[r] &gt; nums[largest]) largest = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (largest != idx) &#123;</span><br><span class=\"line\">        swap(nums[idx], nums[largest]);</span><br><span class=\"line\">        max_heapify(nums, largest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_max_heap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    heap_size = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (heap_size &gt;&gt; <span class=\"number\">1</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        max_heapify(nums, i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    build_max_heap(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">        swap(nums[<span class=\"number\">0</span>], nums[heap_size - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        heap_size--;</span><br><span class=\"line\">        max_heapify(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[heap_size];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有用<code>STL</code>中<code>priority_queue</code>的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">priority_queue</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">pq</span><span class=\"params\">(nums.begin(), nums.end())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">        pq.pop(); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> pq.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Kth Smallest Element in a BST","date":"2019-11-21T01:28:38.000Z","_content":"\n> 第17天，又是一道之前没做出来的题目，然而好像并不难啊。\n\n今天的题目是[ Kth Smallest Element in a BST ]( https://leetcode.com/problems/kth-smallest-element-in-a-bst/ ):\n\n---\n\nGiven a binary search tree, write a function `kthSmallest` to find the **k**th smallest element in it.\n\n**Note:**\nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\n\n**Example 1:**\n\n```\nInput: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\nOutput: 1\n```\n\n**Example 2:**\n\n```\nInput: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\nOutput: 3\n```\n\n**Follow up:**\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n\n---\n\n题意很简单就是求BST中第k小的数字，然后BST本身就包含一定的顺序信息，利用BST中序遍历是有序的性质，我们可以很快的把这道题写出来：\n\n```c++\nint res;\nint kthSmallest(TreeNode* root, int k) {\n    res = 0;\n    kthSmallestR(root, k);\n    return res;\n}\nbool kthSmallestR(TreeNode *root, int &k) {\n    // cout << root << endl;\n    if (root == nullptr) return false;\n\n    if (kthSmallestR(root->left, k)) return true;\n    // cout << root->val << endl;\n    if ((--k) == 0) {\n        res = root->val;\n        return true;\n    }\n    return kthSmallestR(root->right, k);\n}\n```\n\n然后我们可以写出非递归版本的：\n\n```c++\nint kthSmallest(TreeNode* root, int k) {\n    stack<TreeNode *> st;\n\n    while(root || !st.empty()) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n        if (st.empty()) break;\n        root = st.top(); st.pop();\n        if (--k == 0) break;\n        root = root->right;\n    }\n\n    if(root) return root->val;\n    else return -1;\n\n}\n```\n\nBTW，这道题的测试有点不稳定，同一个代码会测试出不同的时间。\n","source":"_posts/Kth-Smallest-Element-in-a-BST.md","raw":"---\ntitle: Kth Smallest Element in a BST\ndate: 2019-11-21T09:28:38.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第17天，又是一道之前没做出来的题目，然而好像并不难啊。\n\n今天的题目是[ Kth Smallest Element in a BST ]( https://leetcode.com/problems/kth-smallest-element-in-a-bst/ ):\n\n---\n\nGiven a binary search tree, write a function `kthSmallest` to find the **k**th smallest element in it.\n\n**Note:**\nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\n\n**Example 1:**\n\n```\nInput: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\nOutput: 1\n```\n\n**Example 2:**\n\n```\nInput: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\nOutput: 3\n```\n\n**Follow up:**\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n\n---\n\n题意很简单就是求BST中第k小的数字，然后BST本身就包含一定的顺序信息，利用BST中序遍历是有序的性质，我们可以很快的把这道题写出来：\n\n```c++\nint res;\nint kthSmallest(TreeNode* root, int k) {\n    res = 0;\n    kthSmallestR(root, k);\n    return res;\n}\nbool kthSmallestR(TreeNode *root, int &k) {\n    // cout << root << endl;\n    if (root == nullptr) return false;\n\n    if (kthSmallestR(root->left, k)) return true;\n    // cout << root->val << endl;\n    if ((--k) == 0) {\n        res = root->val;\n        return true;\n    }\n    return kthSmallestR(root->right, k);\n}\n```\n\n然后我们可以写出非递归版本的：\n\n```c++\nint kthSmallest(TreeNode* root, int k) {\n    stack<TreeNode *> st;\n\n    while(root || !st.empty()) {\n        while(root) {\n            st.push(root);\n            root = root->left;\n        }\n        if (st.empty()) break;\n        root = st.top(); st.pop();\n        if (--k == 0) break;\n        root = root->right;\n    }\n\n    if(root) return root->val;\n    else return -1;\n\n}\n```\n\nBTW，这道题的测试有点不稳定，同一个代码会测试出不同的时间。\n","slug":"Kth-Smallest-Element-in-a-BST","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oa0070qmcm2anb54u1","content":"<blockquote>\n<p>第17天，又是一道之前没做出来的题目，然而好像并不难啊。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\"> Kth Smallest Element in a BST </a>:</p>\n<hr>\n<p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>\n<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class=\"line\">   3</span><br><span class=\"line\">  &#x2F; \\</span><br><span class=\"line\"> 1   4</span><br><span class=\"line\">  \\</span><br><span class=\"line\">   2</span><br><span class=\"line\">Output: 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class=\"line\">       5</span><br><span class=\"line\">      &#x2F; \\</span><br><span class=\"line\">     3   6</span><br><span class=\"line\">    &#x2F; \\</span><br><span class=\"line\">   2   4</span><br><span class=\"line\">  &#x2F;</span><br><span class=\"line\"> 1</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>Follow up:</strong><br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>\n<hr>\n<p>题意很简单就是求BST中第k小的数字，然后BST本身就包含一定的顺序信息，利用BST中序遍历是有序的性质，我们可以很快的把这道题写出来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> res;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    kthSmallestR(root, k);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">kthSmallestR</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> &amp;k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; root &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kthSmallestR(root-&gt;left, k)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((--k) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res = root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> kthSmallestR(root-&gt;right, k);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们可以写出非递归版本的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root || !st.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st.empty()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        root = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (--k == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root) <span class=\"keyword\">return</span> root-&gt;val;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BTW，这道题的测试有点不稳定，同一个代码会测试出不同的时间。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第17天，又是一道之前没做出来的题目，然而好像并不难啊。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\"> Kth Smallest Element in a BST </a>:</p>\n<hr>\n<p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>\n<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class=\"line\">   3</span><br><span class=\"line\">  &#x2F; \\</span><br><span class=\"line\"> 1   4</span><br><span class=\"line\">  \\</span><br><span class=\"line\">   2</span><br><span class=\"line\">Output: 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class=\"line\">       5</span><br><span class=\"line\">      &#x2F; \\</span><br><span class=\"line\">     3   6</span><br><span class=\"line\">    &#x2F; \\</span><br><span class=\"line\">   2   4</span><br><span class=\"line\">  &#x2F;</span><br><span class=\"line\"> 1</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>Follow up:</strong><br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>\n<hr>\n<p>题意很简单就是求BST中第k小的数字，然后BST本身就包含一定的顺序信息，利用BST中序遍历是有序的性质，我们可以很快的把这道题写出来：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> res;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    kthSmallestR(root, k);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">kthSmallestR</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> &amp;k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; root &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kthSmallestR(root-&gt;left, k)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((--k) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res = root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> kthSmallestR(root-&gt;right, k);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们可以写出非递归版本的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root || !st.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st.empty()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        root = st.top(); st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (--k == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root) <span class=\"keyword\">return</span> root-&gt;val;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BTW，这道题的测试有点不稳定，同一个代码会测试出不同的时间。</p>\n"},{"title":"Largest Sum of Averages","date":"2019-12-15T03:19:51.000Z","_content":"\n> 第39天。\n\n今天的题目是[Largest Sum of Averages](https://leetcode.com/problems/largest-sum-of-averages/):\n\n一道动态规划的题目，有点想切钢管的问题。\n\n动规方程如下：\n\n$$\ndp[i, j] = \\left\\{\n    \\begin{aligned}\n        \\sum_{z=0}^j A[z] & & i = 1\\\\\n        \\underset{ {i-1 \\leq t \\leq n-1} }{max} \\{ dp[i-1, t] + \\frac {\\sum_{z=t+1}^n A[z]} {n-t+1}  \\} & & others\n    \\end{aligned}\n\\right.\n$$\n\n```c++\ndouble largestSumOfAverages(vector<int>& A, int K) {\n    // vector<vector<double>> dp(K + 1, vector<double>(A.size(), 0));\n    vector<double> dp(A.size(), 0);\n    double sum = 0;\n    int count;\n    for(int j = 0;j < A.size(); j++) {\n        sum += A[j];\n        dp[j] = sum / (j + 1);\n    }\n    for(int i = 1;i < K; i++) {\n        for(int j = A.size() - 1;j >= i; j--) {\n            sum = 0;\n            count = 0;\n            for(int t = j;t >= i; t--) {\n                sum += A[t];\n                count++;\n                dp[j] = max(dp[j], dp[t-1] + sum/count);\n            }\n        }\n    }\n    return dp[A.size()-1];\n}\n```\n","source":"_posts/Largest-Sum-of-Averages.md","raw":"---\ntitle: Largest Sum of Averages\ndate: 2019-12-15T11:19:51.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第39天。\n\n今天的题目是[Largest Sum of Averages](https://leetcode.com/problems/largest-sum-of-averages/):\n\n一道动态规划的题目，有点想切钢管的问题。\n\n动规方程如下：\n\n$$\ndp[i, j] = \\left\\{\n    \\begin{aligned}\n        \\sum_{z=0}^j A[z] & & i = 1\\\\\n        \\underset{ {i-1 \\leq t \\leq n-1} }{max} \\{ dp[i-1, t] + \\frac {\\sum_{z=t+1}^n A[z]} {n-t+1}  \\} & & others\n    \\end{aligned}\n\\right.\n$$\n\n```c++\ndouble largestSumOfAverages(vector<int>& A, int K) {\n    // vector<vector<double>> dp(K + 1, vector<double>(A.size(), 0));\n    vector<double> dp(A.size(), 0);\n    double sum = 0;\n    int count;\n    for(int j = 0;j < A.size(); j++) {\n        sum += A[j];\n        dp[j] = sum / (j + 1);\n    }\n    for(int i = 1;i < K; i++) {\n        for(int j = A.size() - 1;j >= i; j--) {\n            sum = 0;\n            count = 0;\n            for(int t = j;t >= i; t--) {\n                sum += A[t];\n                count++;\n                dp[j] = max(dp[j], dp[t-1] + sum/count);\n            }\n        }\n    }\n    return dp[A.size()-1];\n}\n```\n","slug":"Largest-Sum-of-Averages","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ob0073qmcmeq4b8jk0","content":"<blockquote>\n<p>第39天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/largest-sum-of-averages/\">Largest Sum of Averages</a>:</p>\n<p>一道动态规划的题目，有点想切钢管的问题。</p>\n<p>动规方程如下：</p>\n<p>$$<br>dp[i, j] = \\left{<br>    \\begin{aligned}<br>        \\sum_{z=0}^j A[z] &amp; &amp; i = 1\\<br>        \\underset{ {i-1 \\leq t \\leq n-1} }{max} { dp[i-1, t] + \\frac {\\sum_{z=t+1}^n A[z]} {n-t+1}  } &amp; &amp; others<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">largestSumOfAverages</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// vector&lt;vector&lt;double&gt;&gt; dp(K + 1, vector&lt;double&gt;(A.size(), 0));</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(A.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; A.size(); j++) &#123;</span><br><span class=\"line\">        sum += A[j];</span><br><span class=\"line\">        dp[j] = sum / (j + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; K; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = A.size() - <span class=\"number\">1</span>;j &gt;= i; j--) &#123;</span><br><span class=\"line\">            sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> t = j;t &gt;= i; t--) &#123;</span><br><span class=\"line\">                sum += A[t];</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                dp[j] = max(dp[j], dp[t<span class=\"number\">-1</span>] + sum/count);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[A.size()<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第39天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/largest-sum-of-averages/\">Largest Sum of Averages</a>:</p>\n<p>一道动态规划的题目，有点想切钢管的问题。</p>\n<p>动规方程如下：</p>\n<p>$$<br>dp[i, j] = \\left{<br>    \\begin{aligned}<br>        \\sum_{z=0}^j A[z] &amp; &amp; i = 1\\<br>        \\underset{ {i-1 \\leq t \\leq n-1} }{max} { dp[i-1, t] + \\frac {\\sum_{z=t+1}^n A[z]} {n-t+1}  } &amp; &amp; others<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">largestSumOfAverages</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// vector&lt;vector&lt;double&gt;&gt; dp(K + 1, vector&lt;double&gt;(A.size(), 0));</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(A.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; A.size(); j++) &#123;</span><br><span class=\"line\">        sum += A[j];</span><br><span class=\"line\">        dp[j] = sum / (j + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; K; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = A.size() - <span class=\"number\">1</span>;j &gt;= i; j--) &#123;</span><br><span class=\"line\">            sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> t = j;t &gt;= i; t--) &#123;</span><br><span class=\"line\">                sum += A[t];</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                dp[j] = max(dp[j], dp[t<span class=\"number\">-1</span>] + sum/count);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[A.size()<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"LeetCode Stack Tag 总结","date":"2020-03-23T02:03:40.000Z","_content":"\n> 准备按 Tag 过一遍之前刷过的 LeetCode，总结一些常用的技巧和套路。\n\n## 题目列表\n\n| Name                                                         | No   | Difficulty | Blog Link                                                    | Note                                                         |\n| :----------------------------------------------------------- | :--- | :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/) | 20   | Easy       | https://blog.codeand.fun/2017/09/24/Valid-Parentheses/       | 可以建一个右括号到左括号的`map`来使代码更加简洁              |\n| [Simplify Path](https://leetcode-cn.com/problems/simplify-path/) | 71   | Medium     | https://blog.codeand.fun/2019/03/02/Simplify-Path/           | 用FSM的思想也可以解，可以用`stringstream`和`getline`进行字符串分割 |\n| [Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) | 94   | Medium     | https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/ | 递归、栈、莫里斯遍历                                         |\n| [ Binary Tree Zigzag Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) | 103  | Medium     | https://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/ | 用栈来模拟，可以避免逆序操作                                 |\n| [Binary Tree Preorder Traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) | 144  | Medium     | https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/ | 递归、栈、莫里斯遍历                                         |\n| [Binary Tree Postorder Traversal](https://leetcode-cn.com/problems/binary-tree-postorder-traversal) | 145  | Medium     | https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/ | `function`对象+`lambda`表达式可以减少代码冗余。              |\n| [Evaluate Reverse Polish Notation](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) | 150  | Medium     | https://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/ |                                                              |\n| [Binary Search Tree Iterator](https://leetcode-cn.com/problems/binary-search-tree-iterator/) | 173  | Medium     | https://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/ | 可以用递归、栈和莫里斯遍历来实现中序遍历                     |\n| [Verify Preorder Serialization of a Binary Tree](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/) | 331  | Medium     | https://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/ | ??这道题和栈好像没有关系啊，不用栈去想反而更简单更快         |\n| [Flatten Nested List Iterator](https://leetcode-cn.com/problems/flatten-nested-list-iterator/) | 341  | Medium     | https://blog.codeand.fun/2018/02/14/Flatten-Nested-List-Iterator/ | 似乎很多用递归能解（但是比较复杂）的题目都可以用栈来简化。同时，用`iterator`可以有效减少内存消耗。 |\n| [Decode String](https://leetcode-cn.com/problems/decode-string/) | 394  | Medium     |                                                              |                                                              |\n\n","source":"_posts/LeetCode-Stack-Tag-总结.md","raw":"---\ntitle: LeetCode Stack Tag 总结\ndate: 2020-03-23T10:03:40.000Z\ntags:\n  - LeetCode\n  - Stack\ncategories:\n  - LeetCode\n---\n\n> 准备按 Tag 过一遍之前刷过的 LeetCode，总结一些常用的技巧和套路。\n\n## 题目列表\n\n| Name                                                         | No   | Difficulty | Blog Link                                                    | Note                                                         |\n| :----------------------------------------------------------- | :--- | :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/) | 20   | Easy       | https://blog.codeand.fun/2017/09/24/Valid-Parentheses/       | 可以建一个右括号到左括号的`map`来使代码更加简洁              |\n| [Simplify Path](https://leetcode-cn.com/problems/simplify-path/) | 71   | Medium     | https://blog.codeand.fun/2019/03/02/Simplify-Path/           | 用FSM的思想也可以解，可以用`stringstream`和`getline`进行字符串分割 |\n| [Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) | 94   | Medium     | https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/ | 递归、栈、莫里斯遍历                                         |\n| [ Binary Tree Zigzag Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) | 103  | Medium     | https://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/ | 用栈来模拟，可以避免逆序操作                                 |\n| [Binary Tree Preorder Traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) | 144  | Medium     | https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/ | 递归、栈、莫里斯遍历                                         |\n| [Binary Tree Postorder Traversal](https://leetcode-cn.com/problems/binary-tree-postorder-traversal) | 145  | Medium     | https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/ | `function`对象+`lambda`表达式可以减少代码冗余。              |\n| [Evaluate Reverse Polish Notation](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) | 150  | Medium     | https://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/ |                                                              |\n| [Binary Search Tree Iterator](https://leetcode-cn.com/problems/binary-search-tree-iterator/) | 173  | Medium     | https://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/ | 可以用递归、栈和莫里斯遍历来实现中序遍历                     |\n| [Verify Preorder Serialization of a Binary Tree](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/) | 331  | Medium     | https://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/ | ??这道题和栈好像没有关系啊，不用栈去想反而更简单更快         |\n| [Flatten Nested List Iterator](https://leetcode-cn.com/problems/flatten-nested-list-iterator/) | 341  | Medium     | https://blog.codeand.fun/2018/02/14/Flatten-Nested-List-Iterator/ | 似乎很多用递归能解（但是比较复杂）的题目都可以用栈来简化。同时，用`iterator`可以有效减少内存消耗。 |\n| [Decode String](https://leetcode-cn.com/problems/decode-string/) | 394  | Medium     |                                                              |                                                              |\n\n","slug":"LeetCode-Stack-Tag-总结","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ob0076qmcmao430d0v","content":"<blockquote>\n<p>准备按 Tag 过一遍之前刷过的 LeetCode，总结一些常用的技巧和套路。</p>\n</blockquote>\n<h2 id=\"题目列表\"><a href=\"#题目列表\" class=\"headerlink\" title=\"题目列表\"></a>题目列表</h2><table>\n<thead>\n<tr>\n<th align=\"left\">Name</th>\n<th align=\"left\">No</th>\n<th align=\"left\">Difficulty</th>\n<th align=\"left\">Blog Link</th>\n<th align=\"left\">Note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">Valid Parentheses</a></td>\n<td align=\"left\">20</td>\n<td align=\"left\">Easy</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2017/09/24/Valid-Parentheses/\">https://blog.codeand.fun/2017/09/24/Valid-Parentheses/</a></td>\n<td align=\"left\">可以建一个右括号到左括号的<code>map</code>来使代码更加简洁</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/simplify-path/\">Simplify Path</a></td>\n<td align=\"left\">71</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2019/03/02/Simplify-Path/\">https://blog.codeand.fun/2019/03/02/Simplify-Path/</a></td>\n<td align=\"left\">用FSM的思想也可以解，可以用<code>stringstream</code>和<code>getline</code>进行字符串分割</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">Binary Tree Inorder Traversal</a></td>\n<td align=\"left\">94</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/\">https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</a></td>\n<td align=\"left\">递归、栈、莫里斯遍历</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\"> Binary Tree Zigzag Level Order Traversal</a></td>\n<td align=\"left\">103</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/\">https://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/</a></td>\n<td align=\"left\">用栈来模拟，可以避免逆序操作</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\">Binary Tree Preorder Traversal</a></td>\n<td align=\"left\">144</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/\">https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</a></td>\n<td align=\"left\">递归、栈、莫里斯遍历</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal\">Binary Tree Postorder Traversal</a></td>\n<td align=\"left\">145</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/\">https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</a></td>\n<td align=\"left\"><code>function</code>对象+<code>lambda</code>表达式可以减少代码冗余。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">Evaluate Reverse Polish Notation</a></td>\n<td align=\"left\">150</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/\">https://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/</a></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/\">Binary Search Tree Iterator</a></td>\n<td align=\"left\">173</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/\">https://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/</a></td>\n<td align=\"left\">可以用递归、栈和莫里斯遍历来实现中序遍历</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/\">Verify Preorder Serialization of a Binary Tree</a></td>\n<td align=\"left\">331</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/\">https://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/</a></td>\n<td align=\"left\">??这道题和栈好像没有关系啊，不用栈去想反而更简单更快</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/flatten-nested-list-iterator/\">Flatten Nested List Iterator</a></td>\n<td align=\"left\">341</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2018/02/14/Flatten-Nested-List-Iterator/\">https://blog.codeand.fun/2018/02/14/Flatten-Nested-List-Iterator/</a></td>\n<td align=\"left\">似乎很多用递归能解（但是比较复杂）的题目都可以用栈来简化。同时，用<code>iterator</code>可以有效减少内存消耗。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/decode-string/\">Decode String</a></td>\n<td align=\"left\">394</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>准备按 Tag 过一遍之前刷过的 LeetCode，总结一些常用的技巧和套路。</p>\n</blockquote>\n<h2 id=\"题目列表\"><a href=\"#题目列表\" class=\"headerlink\" title=\"题目列表\"></a>题目列表</h2><table>\n<thead>\n<tr>\n<th align=\"left\">Name</th>\n<th align=\"left\">No</th>\n<th align=\"left\">Difficulty</th>\n<th align=\"left\">Blog Link</th>\n<th align=\"left\">Note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">Valid Parentheses</a></td>\n<td align=\"left\">20</td>\n<td align=\"left\">Easy</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2017/09/24/Valid-Parentheses/\">https://blog.codeand.fun/2017/09/24/Valid-Parentheses/</a></td>\n<td align=\"left\">可以建一个右括号到左括号的<code>map</code>来使代码更加简洁</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/simplify-path/\">Simplify Path</a></td>\n<td align=\"left\">71</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2019/03/02/Simplify-Path/\">https://blog.codeand.fun/2019/03/02/Simplify-Path/</a></td>\n<td align=\"left\">用FSM的思想也可以解，可以用<code>stringstream</code>和<code>getline</code>进行字符串分割</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">Binary Tree Inorder Traversal</a></td>\n<td align=\"left\">94</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/\">https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</a></td>\n<td align=\"left\">递归、栈、莫里斯遍历</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\"> Binary Tree Zigzag Level Order Traversal</a></td>\n<td align=\"left\">103</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/\">https://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/</a></td>\n<td align=\"left\">用栈来模拟，可以避免逆序操作</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\">Binary Tree Preorder Traversal</a></td>\n<td align=\"left\">144</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/\">https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</a></td>\n<td align=\"left\">递归、栈、莫里斯遍历</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal\">Binary Tree Postorder Traversal</a></td>\n<td align=\"left\">145</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/\">https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</a></td>\n<td align=\"left\"><code>function</code>对象+<code>lambda</code>表达式可以减少代码冗余。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">Evaluate Reverse Polish Notation</a></td>\n<td align=\"left\">150</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/\">https://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/</a></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/\">Binary Search Tree Iterator</a></td>\n<td align=\"left\">173</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/\">https://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/</a></td>\n<td align=\"left\">可以用递归、栈和莫里斯遍历来实现中序遍历</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/\">Verify Preorder Serialization of a Binary Tree</a></td>\n<td align=\"left\">331</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/\">https://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/</a></td>\n<td align=\"left\">??这道题和栈好像没有关系啊，不用栈去想反而更简单更快</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/flatten-nested-list-iterator/\">Flatten Nested List Iterator</a></td>\n<td align=\"left\">341</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"><a href=\"https://blog.codeand.fun/2018/02/14/Flatten-Nested-List-Iterator/\">https://blog.codeand.fun/2018/02/14/Flatten-Nested-List-Iterator/</a></td>\n<td align=\"left\">似乎很多用递归能解（但是比较复杂）的题目都可以用栈来简化。同时，用<code>iterator</code>可以有效减少内存消耗。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode-cn.com/problems/decode-string/\">Decode String</a></td>\n<td align=\"left\">394</td>\n<td align=\"left\">Medium</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n"},{"title":"Length-of-Last-Word","date":"2017-12-12T02:49:45.000Z","_content":"\n第76天。\n\n快考试，可能要水一个月的`easy`题了。\n\n今天的题目是[Length of Last Word](https://leetcode.com/problems/length-of-last-word/description/):\n\n> Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.\n>\n> If the last word does not exist, return 0.\n>\n> Note: A word is defined as a character sequence consists of non-space characters only.\n>\n> Example:\n>\n> Input: \"Hello World\"\n> Output: 5\n\n\n一看完题目，我就想到了`python`的`split`:\n\n```python\ndef lengthOfLastWord(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    words = s.split();\n    if len(words) == 0: return 0;\n    return len(words[-1])\n```\n\n然后是用`c++`用`find`去解的：\n\n```c++\nint lengthOfLastWord(string s) {\n    auto beg = s.begin();\n    auto it = beg;\n    auto end = s.end();\n    // fix the bug like that \"hello world \"\n    for(int i = s.size() - 1;i >= 0 && s[i] == ' ';i--)\n        end--;\n\n    while((it = find(beg,end,' ')) != end) {\n        beg = it + 1;\n    }\n    return end - beg;\n}\n```\n\n然后是从后面向前扫描的方法：\n\n```c++\nint lengthOfLastWord(string s) {\n    auto end = s.rbegin();\n    while(end != s.rend() && *end == ' ') end++;\n    auto beg = end;\n    while(beg != s.rend() && *beg != ' ') beg++;\n    return beg - end;\n}\n```\n\n然后是`dicuss`中的解法，和上面的从后向前扫描的方法类似，只不过它第二个循环里面顺带计算了`length`:\n\n```c++\nint lengthOfLastWord(string s) { \n    int len = 0, tail = s.length() - 1;\n    while (tail >= 0 && s[tail] == ' ') tail--;\n    while (tail >= 0 && s[tail] != ' ') {\n        len++;\n        tail--;\n    }\n    return len;\n}\n```\n","source":"_posts/Length-of-Last-Word.md","raw":"---\ntitle: Length-of-Last-Word\ndate: 2017-12-12T10:49:45.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第76天。\n\n快考试，可能要水一个月的`easy`题了。\n\n今天的题目是[Length of Last Word](https://leetcode.com/problems/length-of-last-word/description/):\n\n> Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.\n>\n> If the last word does not exist, return 0.\n>\n> Note: A word is defined as a character sequence consists of non-space characters only.\n>\n> Example:\n>\n> Input: \"Hello World\"\n> Output: 5\n\n\n一看完题目，我就想到了`python`的`split`:\n\n```python\ndef lengthOfLastWord(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    words = s.split();\n    if len(words) == 0: return 0;\n    return len(words[-1])\n```\n\n然后是用`c++`用`find`去解的：\n\n```c++\nint lengthOfLastWord(string s) {\n    auto beg = s.begin();\n    auto it = beg;\n    auto end = s.end();\n    // fix the bug like that \"hello world \"\n    for(int i = s.size() - 1;i >= 0 && s[i] == ' ';i--)\n        end--;\n\n    while((it = find(beg,end,' ')) != end) {\n        beg = it + 1;\n    }\n    return end - beg;\n}\n```\n\n然后是从后面向前扫描的方法：\n\n```c++\nint lengthOfLastWord(string s) {\n    auto end = s.rbegin();\n    while(end != s.rend() && *end == ' ') end++;\n    auto beg = end;\n    while(beg != s.rend() && *beg != ' ') beg++;\n    return beg - end;\n}\n```\n\n然后是`dicuss`中的解法，和上面的从后向前扫描的方法类似，只不过它第二个循环里面顺带计算了`length`:\n\n```c++\nint lengthOfLastWord(string s) { \n    int len = 0, tail = s.length() - 1;\n    while (tail >= 0 && s[tail] == ' ') tail--;\n    while (tail >= 0 && s[tail] != ' ') {\n        len++;\n        tail--;\n    }\n    return len;\n}\n```\n","slug":"Length-of-Last-Word","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oc0079qmcm8drd9nwb","content":"<p>第76天。</p>\n<p>快考试，可能要水一个月的<code>easy</code>题了。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/length-of-last-word/description/\">Length of Last Word</a>:</p>\n<blockquote>\n<p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>\n<p>If the last word does not exist, return 0.</p>\n<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>\n<p>Example:</p>\n<p>Input: “Hello World”<br>Output: 5</p>\n</blockquote>\n<p>一看完题目，我就想到了<code>python</code>的<code>split</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLastWord</span>(<span class=\"params\">self, s</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type s: str</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    words = s.split();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(words) == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(words[-<span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n\n<p>然后是用<code>c++</code>用<code>find</code>去解的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> beg = s.begin();</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = beg;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> end = s.end();</span><br><span class=\"line\">    <span class=\"comment\">// fix the bug like that &quot;hello world &quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.size() - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span> &amp;&amp; s[i] == <span class=\"string\">&#x27; &#x27;</span>;i--)</span><br><span class=\"line\">        end--;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((it = find(beg,end,<span class=\"string\">&#x27; &#x27;</span>)) != end) &#123;</span><br><span class=\"line\">        beg = it + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end - beg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是从后面向前扫描的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> end = s.rbegin();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(end != s.rend() &amp;&amp; *end == <span class=\"string\">&#x27; &#x27;</span>) end++;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> beg = end;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg != s.rend() &amp;&amp; *beg != <span class=\"string\">&#x27; &#x27;</span>) beg++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beg - end;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的解法，和上面的从后向前扫描的方法类似，只不过它第二个循环里面顺带计算了<code>length</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>, tail = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tail &gt;= <span class=\"number\">0</span> &amp;&amp; s[tail] == <span class=\"string\">&#x27; &#x27;</span>) tail--;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tail &gt;= <span class=\"number\">0</span> &amp;&amp; s[tail] != <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">        tail--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第76天。</p>\n<p>快考试，可能要水一个月的<code>easy</code>题了。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/length-of-last-word/description/\">Length of Last Word</a>:</p>\n<blockquote>\n<p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>\n<p>If the last word does not exist, return 0.</p>\n<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>\n<p>Example:</p>\n<p>Input: “Hello World”<br>Output: 5</p>\n</blockquote>\n<p>一看完题目，我就想到了<code>python</code>的<code>split</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLastWord</span>(<span class=\"params\">self, s</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type s: str</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    words = s.split();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(words) == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(words[-<span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n\n<p>然后是用<code>c++</code>用<code>find</code>去解的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> beg = s.begin();</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = beg;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> end = s.end();</span><br><span class=\"line\">    <span class=\"comment\">// fix the bug like that &quot;hello world &quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.size() - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span> &amp;&amp; s[i] == <span class=\"string\">&#x27; &#x27;</span>;i--)</span><br><span class=\"line\">        end--;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((it = find(beg,end,<span class=\"string\">&#x27; &#x27;</span>)) != end) &#123;</span><br><span class=\"line\">        beg = it + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end - beg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是从后面向前扫描的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> end = s.rbegin();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(end != s.rend() &amp;&amp; *end == <span class=\"string\">&#x27; &#x27;</span>) end++;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> beg = end;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg != s.rend() &amp;&amp; *beg != <span class=\"string\">&#x27; &#x27;</span>) beg++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beg - end;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的解法，和上面的从后向前扫描的方法类似，只不过它第二个循环里面顺带计算了<code>length</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>, tail = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tail &gt;= <span class=\"number\">0</span> &amp;&amp; s[tail] == <span class=\"string\">&#x27; &#x27;</span>) tail--;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tail &gt;= <span class=\"number\">0</span> &amp;&amp; s[tail] != <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">        tail--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Letter Combinations of a Phone Number","date":"2017-10-06T08:33:22.000Z","_content":"\n打卡，第13天\n\n昨晚贼晚睡，然后今天就快吃午饭才起来，然后我又躺尸了一个下午。。。\n\n今天刷了一道`Medium`的题目——[ Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)，不过感觉好水，就和学校oj一样水。。。\n\n> Given a digit string, return all possible letter combinations that the number could represent.\n>\n> A mapping of digit to letters (just like on the telephone buttons) is given below.\n> Input:Digit string \"23\"\n> Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n> Note:\n> Although the above answer is in lexicographical order, your answer could be in any order you want.\n\n恩，大概思路就是要求`letterCombinations(digits)`,我们就需要求`letterCombinations(digits.substr(0,n-1)`.\n\n然后把这个思路转换迭代的方式就成了：\n\n```c++\nvector<string> letterCombinations(string digits) {\n    static vector<string> sMap {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    vector<string> ret;\n    if (digits.size() == 0) return ret;\n    ret.push_back(\"\");\n    for(int i = 0;i < digits.size();i++) {\n        vector<string> now;\n        for(auto c:sMap[digits[i] - '0']) {\n            for(auto s:ret)\n                now.push_back(s+c);\n        }\n        ret.swap(now);\n    }\n    return ret;\n}\n```\n\n思路很简单，实现起来也很简单，没什么好提的，而且`dicuss`中的思路也很这个差不多，不过还是总结一下吧：\n\n* c++ 中 `char`转`string`真心麻烦:\n  * 用`stringstream`很优雅，但是也很麻烦，而且只适用于要平凡从尾部插入的情况,不过这个方法结合io可以做很多漂亮的转换\n  * 用`\"\" + c`,之前的时候用的时候好像是可以的，但是刚才在做题的时候是不行的会出现一些奇怪的字符串。\n  * 最后是比较简单，可以常用的方法：`string(1,c)`,可以把`1`换成其他数字以获取有重复字符的字符串。\n\n* 然后是在`dicuss`中看到的`vector`的`swap`方法，有些情况应该还是不错的，可以提高效率，它应该是直接交换底层指针。\n","source":"_posts/Letter-Combinations-of-a-Phone-Number.md","raw":"---\ntitle: Letter Combinations of a Phone Number\ndate: 2017-10-06T16:33:22.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 串\n---\n\n打卡，第13天\n\n昨晚贼晚睡，然后今天就快吃午饭才起来，然后我又躺尸了一个下午。。。\n\n今天刷了一道`Medium`的题目——[ Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)，不过感觉好水，就和学校oj一样水。。。\n\n> Given a digit string, return all possible letter combinations that the number could represent.\n>\n> A mapping of digit to letters (just like on the telephone buttons) is given below.\n> Input:Digit string \"23\"\n> Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n> Note:\n> Although the above answer is in lexicographical order, your answer could be in any order you want.\n\n恩，大概思路就是要求`letterCombinations(digits)`,我们就需要求`letterCombinations(digits.substr(0,n-1)`.\n\n然后把这个思路转换迭代的方式就成了：\n\n```c++\nvector<string> letterCombinations(string digits) {\n    static vector<string> sMap {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    vector<string> ret;\n    if (digits.size() == 0) return ret;\n    ret.push_back(\"\");\n    for(int i = 0;i < digits.size();i++) {\n        vector<string> now;\n        for(auto c:sMap[digits[i] - '0']) {\n            for(auto s:ret)\n                now.push_back(s+c);\n        }\n        ret.swap(now);\n    }\n    return ret;\n}\n```\n\n思路很简单，实现起来也很简单，没什么好提的，而且`dicuss`中的思路也很这个差不多，不过还是总结一下吧：\n\n* c++ 中 `char`转`string`真心麻烦:\n  * 用`stringstream`很优雅，但是也很麻烦，而且只适用于要平凡从尾部插入的情况,不过这个方法结合io可以做很多漂亮的转换\n  * 用`\"\" + c`,之前的时候用的时候好像是可以的，但是刚才在做题的时候是不行的会出现一些奇怪的字符串。\n  * 最后是比较简单，可以常用的方法：`string(1,c)`,可以把`1`换成其他数字以获取有重复字符的字符串。\n\n* 然后是在`dicuss`中看到的`vector`的`swap`方法，有些情况应该还是不错的，可以提高效率，它应该是直接交换底层指针。\n","slug":"Letter-Combinations-of-a-Phone-Number","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oc007cqmcmfyw6bdhs","content":"<p>打卡，第13天</p>\n<p>昨晚贼晚睡，然后今天就快吃午饭才起来，然后我又躺尸了一个下午。。。</p>\n<p>今天刷了一道<code>Medium</code>的题目——<a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/\"> Letter Combinations of a Phone Number</a>，不过感觉好水，就和学校oj一样水。。。</p>\n<blockquote>\n<p>Given a digit string, return all possible letter combinations that the number could represent.</p>\n<p>A mapping of digit to letters (just like on the telephone buttons) is given below.<br>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>\n</blockquote>\n<p>恩，大概思路就是要求<code>letterCombinations(digits)</code>,我们就需要求<code>letterCombinations(digits.substr(0,n-1)</code>.</p>\n<p>然后把这个思路转换迭代的方式就成了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">letterCombinations</span><span class=\"params\">(<span class=\"built_in\">string</span> digits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; sMap &#123;<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;def&quot;</span>,<span class=\"string\">&quot;ghi&quot;</span>,<span class=\"string\">&quot;jkl&quot;</span>,<span class=\"string\">&quot;mno&quot;</span>,<span class=\"string\">&quot;pqrs&quot;</span>,<span class=\"string\">&quot;tuv&quot;</span>,<span class=\"string\">&quot;wxyz&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (digits.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    ret.push_back(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; digits.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; now;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:sMap[digits[i] - <span class=\"string\">&#x27;0&#x27;</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:ret)</span><br><span class=\"line\">                now.push_back(s+c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret.swap(now);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>思路很简单，实现起来也很简单，没什么好提的，而且<code>dicuss</code>中的思路也很这个差不多，不过还是总结一下吧：</p>\n<ul>\n<li><p>c++ 中 <code>char</code>转<code>string</code>真心麻烦:</p>\n<ul>\n<li>用<code>stringstream</code>很优雅，但是也很麻烦，而且只适用于要平凡从尾部插入的情况,不过这个方法结合io可以做很多漂亮的转换</li>\n<li>用<code>&quot;&quot; + c</code>,之前的时候用的时候好像是可以的，但是刚才在做题的时候是不行的会出现一些奇怪的字符串。</li>\n<li>最后是比较简单，可以常用的方法：<code>string(1,c)</code>,可以把<code>1</code>换成其他数字以获取有重复字符的字符串。</li>\n</ul>\n</li>\n<li><p>然后是在<code>dicuss</code>中看到的<code>vector</code>的<code>swap</code>方法，有些情况应该还是不错的，可以提高效率，它应该是直接交换底层指针。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第13天</p>\n<p>昨晚贼晚睡，然后今天就快吃午饭才起来，然后我又躺尸了一个下午。。。</p>\n<p>今天刷了一道<code>Medium</code>的题目——<a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/\"> Letter Combinations of a Phone Number</a>，不过感觉好水，就和学校oj一样水。。。</p>\n<blockquote>\n<p>Given a digit string, return all possible letter combinations that the number could represent.</p>\n<p>A mapping of digit to letters (just like on the telephone buttons) is given below.<br>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>\n</blockquote>\n<p>恩，大概思路就是要求<code>letterCombinations(digits)</code>,我们就需要求<code>letterCombinations(digits.substr(0,n-1)</code>.</p>\n<p>然后把这个思路转换迭代的方式就成了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">letterCombinations</span><span class=\"params\">(<span class=\"built_in\">string</span> digits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; sMap &#123;<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;def&quot;</span>,<span class=\"string\">&quot;ghi&quot;</span>,<span class=\"string\">&quot;jkl&quot;</span>,<span class=\"string\">&quot;mno&quot;</span>,<span class=\"string\">&quot;pqrs&quot;</span>,<span class=\"string\">&quot;tuv&quot;</span>,<span class=\"string\">&quot;wxyz&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (digits.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    ret.push_back(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; digits.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; now;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:sMap[digits[i] - <span class=\"string\">&#x27;0&#x27;</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s:ret)</span><br><span class=\"line\">                now.push_back(s+c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret.swap(now);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>思路很简单，实现起来也很简单，没什么好提的，而且<code>dicuss</code>中的思路也很这个差不多，不过还是总结一下吧：</p>\n<ul>\n<li><p>c++ 中 <code>char</code>转<code>string</code>真心麻烦:</p>\n<ul>\n<li>用<code>stringstream</code>很优雅，但是也很麻烦，而且只适用于要平凡从尾部插入的情况,不过这个方法结合io可以做很多漂亮的转换</li>\n<li>用<code>&quot;&quot; + c</code>,之前的时候用的时候好像是可以的，但是刚才在做题的时候是不行的会出现一些奇怪的字符串。</li>\n<li>最后是比较简单，可以常用的方法：<code>string(1,c)</code>,可以把<code>1</code>换成其他数字以获取有重复字符的字符串。</li>\n</ul>\n</li>\n<li><p>然后是在<code>dicuss</code>中看到的<code>vector</code>的<code>swap</code>方法，有些情况应该还是不错的，可以提高效率，它应该是直接交换底层指针。</p>\n</li>\n</ul>\n"},{"title":"Lexicographical-Number","date":"2017-12-09T02:39:01.000Z","_content":"\n第73天。\n\n今天的题目是[Lexicographical Numbers](https://leetcode.com/problems/lexicographical-numbers/discuss/):\n\n> Given an integer n, return 1 - n in lexicographical order.\n>\n> For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\n>\n> Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.\n\nemmm，`lexicographical`是字典序的意思。\n\n首先，这种有规律的题目一般用递归来写会比较简单（但是可能会超时），我们先找出它的规律，在不到`n`的时候，没加入一个数字i,我们就要看`i*10 ~ i*10 + 9`是否小于`n`,如果小于我们就把它加入，然后在递归的进行判断。\n\n有一点需要注意的就是，它是从`1`开始的，所以我们一开始就要尝试的把`1 ~ 9`加入，而不是`0 ~ 9`：\n\n```c++\nvector<int> lexicalOrder(int n) {\n    vector<int> ret;\n    //lexicalOrder(ret,n,1);\n    for(int i = 1;i < 10 && i <= n;i++) {\n        ret.push_back(i);\n        lexicalOrder(ret,n,i*10);\n    }\n    return ret;\n}\nvoid lexicalOrder(vector<int> &vec,int n,int base) {\n    for(int i = 0;i < 10;i++,base++) {\n        if (base > n){ return; }\n        vec.push_back(base);\n        lexicalOrder(vec,n,10*base);\n    }\n}\n```\n\n然后是在`dicuss`中看到的迭代解法：\n\n```c++\nvector<int> lexicalOrder(int n) {\n    vector<int> res(n);\n    int cur = 1;\n    for (int i = 0; i < n; i++) {\n        res[i] = cur;\n        if (cur * 10 <= n) {\n            cur *= 10;\n        } else {\n            if (cur >= n) \n                cur /= 10;\n            cur += 1;\n            while (cur % 10 == 0)\n                cur /= 10;\n        }\n    }\n    return res;\n}\n```\n","source":"_posts/Lexicographical-Number.md","raw":"---\ntitle: Lexicographical-Number\ndate: 2017-12-09T10:39:01.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第73天。\n\n今天的题目是[Lexicographical Numbers](https://leetcode.com/problems/lexicographical-numbers/discuss/):\n\n> Given an integer n, return 1 - n in lexicographical order.\n>\n> For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\n>\n> Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.\n\nemmm，`lexicographical`是字典序的意思。\n\n首先，这种有规律的题目一般用递归来写会比较简单（但是可能会超时），我们先找出它的规律，在不到`n`的时候，没加入一个数字i,我们就要看`i*10 ~ i*10 + 9`是否小于`n`,如果小于我们就把它加入，然后在递归的进行判断。\n\n有一点需要注意的就是，它是从`1`开始的，所以我们一开始就要尝试的把`1 ~ 9`加入，而不是`0 ~ 9`：\n\n```c++\nvector<int> lexicalOrder(int n) {\n    vector<int> ret;\n    //lexicalOrder(ret,n,1);\n    for(int i = 1;i < 10 && i <= n;i++) {\n        ret.push_back(i);\n        lexicalOrder(ret,n,i*10);\n    }\n    return ret;\n}\nvoid lexicalOrder(vector<int> &vec,int n,int base) {\n    for(int i = 0;i < 10;i++,base++) {\n        if (base > n){ return; }\n        vec.push_back(base);\n        lexicalOrder(vec,n,10*base);\n    }\n}\n```\n\n然后是在`dicuss`中看到的迭代解法：\n\n```c++\nvector<int> lexicalOrder(int n) {\n    vector<int> res(n);\n    int cur = 1;\n    for (int i = 0; i < n; i++) {\n        res[i] = cur;\n        if (cur * 10 <= n) {\n            cur *= 10;\n        } else {\n            if (cur >= n) \n                cur /= 10;\n            cur += 1;\n            while (cur % 10 == 0)\n                cur /= 10;\n        }\n    }\n    return res;\n}\n```\n","slug":"Lexicographical-Number","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69od007fqmcme2mqdjli","content":"<p>第73天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/lexicographical-numbers/discuss/\">Lexicographical Numbers</a>:</p>\n<blockquote>\n<p>Given an integer n, return 1 - n in lexicographical order.</p>\n<p>For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].</p>\n<p>Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.</p>\n</blockquote>\n<p>emmm，<code>lexicographical</code>是字典序的意思。</p>\n<p>首先，这种有规律的题目一般用递归来写会比较简单（但是可能会超时），我们先找出它的规律，在不到<code>n</code>的时候，没加入一个数字i,我们就要看<code>i*10 ~ i*10 + 9</code>是否小于<code>n</code>,如果小于我们就把它加入，然后在递归的进行判断。</p>\n<p>有一点需要注意的就是，它是从<code>1</code>开始的，所以我们一开始就要尝试的把<code>1 ~ 9</code>加入，而不是<code>0 ~ 9</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">lexicalOrder</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"comment\">//lexicalOrder(ret,n,1);</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; <span class=\"number\">10</span> &amp;&amp; i &lt;= n;i++) &#123;</span><br><span class=\"line\">        ret.push_back(i);</span><br><span class=\"line\">        lexicalOrder(ret,n,i*<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lexicalOrder</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;vec,<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> base)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10</span>;i++,base++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (base &gt; n)&#123; <span class=\"keyword\">return</span>; &#125;</span><br><span class=\"line\">        vec.push_back(base);</span><br><span class=\"line\">        lexicalOrder(vec,n,<span class=\"number\">10</span>*base);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的迭代解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">lexicalOrder</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cur = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        res[i] = cur;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur * <span class=\"number\">10</span> &lt;= n) &#123;</span><br><span class=\"line\">            cur *= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur &gt;= n) </span><br><span class=\"line\">                cur /= <span class=\"number\">10</span>;</span><br><span class=\"line\">            cur += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cur % <span class=\"number\">10</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                cur /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第73天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/lexicographical-numbers/discuss/\">Lexicographical Numbers</a>:</p>\n<blockquote>\n<p>Given an integer n, return 1 - n in lexicographical order.</p>\n<p>For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].</p>\n<p>Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.</p>\n</blockquote>\n<p>emmm，<code>lexicographical</code>是字典序的意思。</p>\n<p>首先，这种有规律的题目一般用递归来写会比较简单（但是可能会超时），我们先找出它的规律，在不到<code>n</code>的时候，没加入一个数字i,我们就要看<code>i*10 ~ i*10 + 9</code>是否小于<code>n</code>,如果小于我们就把它加入，然后在递归的进行判断。</p>\n<p>有一点需要注意的就是，它是从<code>1</code>开始的，所以我们一开始就要尝试的把<code>1 ~ 9</code>加入，而不是<code>0 ~ 9</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">lexicalOrder</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"comment\">//lexicalOrder(ret,n,1);</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; <span class=\"number\">10</span> &amp;&amp; i &lt;= n;i++) &#123;</span><br><span class=\"line\">        ret.push_back(i);</span><br><span class=\"line\">        lexicalOrder(ret,n,i*<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lexicalOrder</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;vec,<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> base)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10</span>;i++,base++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (base &gt; n)&#123; <span class=\"keyword\">return</span>; &#125;</span><br><span class=\"line\">        vec.push_back(base);</span><br><span class=\"line\">        lexicalOrder(vec,n,<span class=\"number\">10</span>*base);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的迭代解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">lexicalOrder</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cur = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        res[i] = cur;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur * <span class=\"number\">10</span> &lt;= n) &#123;</span><br><span class=\"line\">            cur *= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur &gt;= n) </span><br><span class=\"line\">                cur /= <span class=\"number\">10</span>;</span><br><span class=\"line\">            cur += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cur % <span class=\"number\">10</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                cur /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Linked List Cycle","date":"2017-10-30T01:18:19.000Z","_content":"\n第35天。\n\n今天的题目是[Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/):\n\n> Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\n>\n> Note: Do not modify the linked list.\n>\n> Follow up:\n> Can you solve it without using extra space?\n\n这道题是判断链表是否有环的升级版。\n\n首先肯定需要`fast`和`slow`指针来先判断是否有环，如果没有，就直接返回`nullptr`即可。\n\n然后就是怎么计算出环的入口了。\n\n先来个暴力的方法:\n\n```c++\nListNode *detectCycle(ListNode *head) {\n    vector<ListNode *> lvec;\n    ListNode *fast = head;\n    ListNode *slow = head;\n    while(fast && fast->next) {\n        fast = fast->next->next;\n        slow = slow->next;\n        //lvec.push_back(slow);\n        if (slow == fast) {\n            lvec.push_back(slow);\n            slow = slow->next;\n            while(slow != fast) {\n                lvec.push_back(slow);\n                slow=slow->next;\n            }\n            for(auto t:lvec) cout << t->val << endl;\n            while(find(lvec.begin(),lvec.end(),head) == lvec.end())\n                head = head->next;\n            return head;\n        }\n    }\n\n    return nullptr;\n}\n```\n\n当然实际的方法不用那么麻烦：\n\n```c++\nListNode *detectCycle(ListNode *head) {\n    vector<ListNode *> lvec;\n    ListNode *fast = head;\n    ListNode *slow = head;\n    while(fast && fast->next) {\n        fast = fast->next->next;\n        slow = slow->next;\n        if (fast == slow) {\n            slow = head;\n            while(slow != fast) {\n                slow = slow->next;\n                fast = fast->next;\n            }\n            return fast;\n        }\n    }\n\n    return nullptr;\n}\n```\n\nemmmm,一直很好奇为什么可以这样判断，就去搜了一下，发现了这个[判断单向链表是否有环及求环入口的算法数学证明](http://windsmoon.com/2017/10/09/%E5%88%A4%E6%96%AD%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E5%8F%8A%E6%B1%82%E7%8E%AF%E5%85%A5%E5%8F%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/#more).\n","source":"_posts/Linked-List-Cycle.md","raw":"---\ntitle: Linked List Cycle\ndate: 2017-10-30T09:18:19.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Linked-List\n---\n\n第35天。\n\n今天的题目是[Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/):\n\n> Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\n>\n> Note: Do not modify the linked list.\n>\n> Follow up:\n> Can you solve it without using extra space?\n\n这道题是判断链表是否有环的升级版。\n\n首先肯定需要`fast`和`slow`指针来先判断是否有环，如果没有，就直接返回`nullptr`即可。\n\n然后就是怎么计算出环的入口了。\n\n先来个暴力的方法:\n\n```c++\nListNode *detectCycle(ListNode *head) {\n    vector<ListNode *> lvec;\n    ListNode *fast = head;\n    ListNode *slow = head;\n    while(fast && fast->next) {\n        fast = fast->next->next;\n        slow = slow->next;\n        //lvec.push_back(slow);\n        if (slow == fast) {\n            lvec.push_back(slow);\n            slow = slow->next;\n            while(slow != fast) {\n                lvec.push_back(slow);\n                slow=slow->next;\n            }\n            for(auto t:lvec) cout << t->val << endl;\n            while(find(lvec.begin(),lvec.end(),head) == lvec.end())\n                head = head->next;\n            return head;\n        }\n    }\n\n    return nullptr;\n}\n```\n\n当然实际的方法不用那么麻烦：\n\n```c++\nListNode *detectCycle(ListNode *head) {\n    vector<ListNode *> lvec;\n    ListNode *fast = head;\n    ListNode *slow = head;\n    while(fast && fast->next) {\n        fast = fast->next->next;\n        slow = slow->next;\n        if (fast == slow) {\n            slow = head;\n            while(slow != fast) {\n                slow = slow->next;\n                fast = fast->next;\n            }\n            return fast;\n        }\n    }\n\n    return nullptr;\n}\n```\n\nemmmm,一直很好奇为什么可以这样判断，就去搜了一下，发现了这个[判断单向链表是否有环及求环入口的算法数学证明](http://windsmoon.com/2017/10/09/%E5%88%A4%E6%96%AD%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E5%8F%8A%E6%B1%82%E7%8E%AF%E5%85%A5%E5%8F%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/#more).\n","slug":"Linked-List-Cycle","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oe007jqmcm07uc3ebu","content":"<p>第35天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/linked-list-cycle-ii/description/\">Linked List Cycle II</a>:</p>\n<blockquote>\n<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>\n<p>Note: Do not modify the linked list.</p>\n<p>Follow up:<br>Can you solve it without using extra space?</p>\n</blockquote>\n<p>这道题是判断链表是否有环的升级版。</p>\n<p>首先肯定需要<code>fast</code>和<code>slow</code>指针来先判断是否有环，如果没有，就直接返回<code>nullptr</code>即可。</p>\n<p>然后就是怎么计算出环的入口了。</p>\n<p>先来个暴力的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;ListNode *&gt; lvec;</span><br><span class=\"line\">    ListNode *fast = head;</span><br><span class=\"line\">    ListNode *slow = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">//lvec.push_back(slow);</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast) &#123;</span><br><span class=\"line\">            lvec.push_back(slow);</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(slow != fast) &#123;</span><br><span class=\"line\">                lvec.push_back(slow);</span><br><span class=\"line\">                slow=slow-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> t:lvec) <span class=\"built_in\">cout</span> &lt;&lt; t-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(find(lvec.begin(),lvec.end(),head) == lvec.end())</span><br><span class=\"line\">                head = head-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然实际的方法不用那么麻烦：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;ListNode *&gt; lvec;</span><br><span class=\"line\">    ListNode *fast = head;</span><br><span class=\"line\">    ListNode *slow = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fast == slow) &#123;</span><br><span class=\"line\">            slow = head;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(slow != fast) &#123;</span><br><span class=\"line\">                slow = slow-&gt;next;</span><br><span class=\"line\">                fast = fast-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>emmmm,一直很好奇为什么可以这样判断，就去搜了一下，发现了这个<a href=\"http://windsmoon.com/2017/10/09/%E5%88%A4%E6%96%AD%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E5%8F%8A%E6%B1%82%E7%8E%AF%E5%85%A5%E5%8F%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/#more\">判断单向链表是否有环及求环入口的算法数学证明</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第35天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/linked-list-cycle-ii/description/\">Linked List Cycle II</a>:</p>\n<blockquote>\n<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>\n<p>Note: Do not modify the linked list.</p>\n<p>Follow up:<br>Can you solve it without using extra space?</p>\n</blockquote>\n<p>这道题是判断链表是否有环的升级版。</p>\n<p>首先肯定需要<code>fast</code>和<code>slow</code>指针来先判断是否有环，如果没有，就直接返回<code>nullptr</code>即可。</p>\n<p>然后就是怎么计算出环的入口了。</p>\n<p>先来个暴力的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;ListNode *&gt; lvec;</span><br><span class=\"line\">    ListNode *fast = head;</span><br><span class=\"line\">    ListNode *slow = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">//lvec.push_back(slow);</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast) &#123;</span><br><span class=\"line\">            lvec.push_back(slow);</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(slow != fast) &#123;</span><br><span class=\"line\">                lvec.push_back(slow);</span><br><span class=\"line\">                slow=slow-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> t:lvec) <span class=\"built_in\">cout</span> &lt;&lt; t-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(find(lvec.begin(),lvec.end(),head) == lvec.end())</span><br><span class=\"line\">                head = head-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然实际的方法不用那么麻烦：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;ListNode *&gt; lvec;</span><br><span class=\"line\">    ListNode *fast = head;</span><br><span class=\"line\">    ListNode *slow = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fast == slow) &#123;</span><br><span class=\"line\">            slow = head;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(slow != fast) &#123;</span><br><span class=\"line\">                slow = slow-&gt;next;</span><br><span class=\"line\">                fast = fast-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>emmmm,一直很好奇为什么可以这样判断，就去搜了一下，发现了这个<a href=\"http://windsmoon.com/2017/10/09/%E5%88%A4%E6%96%AD%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E5%8F%8A%E6%B1%82%E7%8E%AF%E5%85%A5%E5%8F%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/#more\">判断单向链表是否有环及求环入口的算法数学证明</a>.</p>\n"},{"title":"Linked-List-Random-Node","date":"2018-01-21T02:45:53.000Z","_content":"\n第90天。\n\n今天的题目是[Linked List Random Node](https://leetcode.com/problems/linked-list-random-node/description/):\n\n> Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.\n>\n> Follow up:\n> What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?\n>\n> Example:\n>\n> // Init a singly linked list [1,2,3].\n> ListNode head = new ListNode(1);\n> head.next = new ListNode(2);\n> head.next.next = new ListNode(3);\n> Solution solution = new Solution(head);\n>\n> // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\n> solution.getRandom();\n\n写出了一个朴素的解法，两次扫描：\n\n```c++\nSolution(ListNode* p) {\n    len = 0;\n    head = p;\n    while(p) {\n        len++;\n        p = p->next;\n    }\n    cout << len << endl;\n}\n\n/** Returns a random node's value. */\nint getRandom() {\n    int r = rand() % len;\n    cout << r << endl;\n    ListNode *p = head;\n    while(r-- && p) {\n        p = p->next;\n    }\n    return p->val;\n}\nint len;\nListNode *head;\n```\n\n然后是利用栈来做的一个解法，即一直递归调用直到链表结尾，这时我们已经遍历了一遍链表就可以知道其长度了，在这时生成随机数，然后在递归调用返回的时候通过这个随机数来选取节点：\n\n```c++\nint getRandom() {\n    temp_len = 0;\n    getRandom(head);\n    return res;\n}\nbool getRandom(ListNode *p) {\n    if (p == nullptr) {\n        rand_n = rand() % temp_len;\n        return false;\n    }\n    temp_len++;\n    if(getRandom(p->next)) return true;\n    if (rand_n == 0) {\n        res = p->val;\n        return true;\n    }\n    rand_n--;\n    return false;\n}\nint temp_len;\nint rand_n;\nListNode *head;\nint res;\n```\n\n最后是`dicuss`中的水库抽样法：\n\n```c++\nint getRandom() {\n    int res = head->val;\n    ListNode* node = head->next;\n    int i = 2;\n    while(node){\n        int j = rand()%i;\n        if(j==0)\n            res = node->val;\n        i++;\n        node = node->next;\n    }\n    return res;\n}\n```\n\n证明可参考：[http://blog.csdn.net/so_geili/article/details/52937212](http://blog.csdn.net/so_geili/article/details/52937212)\n\n","source":"_posts/Linked-List-Random-Node.md","raw":"---\ntitle: Linked-List-Random-Node\ndate: 2018-01-21T10:45:53.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第90天。\n\n今天的题目是[Linked List Random Node](https://leetcode.com/problems/linked-list-random-node/description/):\n\n> Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.\n>\n> Follow up:\n> What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?\n>\n> Example:\n>\n> // Init a singly linked list [1,2,3].\n> ListNode head = new ListNode(1);\n> head.next = new ListNode(2);\n> head.next.next = new ListNode(3);\n> Solution solution = new Solution(head);\n>\n> // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\n> solution.getRandom();\n\n写出了一个朴素的解法，两次扫描：\n\n```c++\nSolution(ListNode* p) {\n    len = 0;\n    head = p;\n    while(p) {\n        len++;\n        p = p->next;\n    }\n    cout << len << endl;\n}\n\n/** Returns a random node's value. */\nint getRandom() {\n    int r = rand() % len;\n    cout << r << endl;\n    ListNode *p = head;\n    while(r-- && p) {\n        p = p->next;\n    }\n    return p->val;\n}\nint len;\nListNode *head;\n```\n\n然后是利用栈来做的一个解法，即一直递归调用直到链表结尾，这时我们已经遍历了一遍链表就可以知道其长度了，在这时生成随机数，然后在递归调用返回的时候通过这个随机数来选取节点：\n\n```c++\nint getRandom() {\n    temp_len = 0;\n    getRandom(head);\n    return res;\n}\nbool getRandom(ListNode *p) {\n    if (p == nullptr) {\n        rand_n = rand() % temp_len;\n        return false;\n    }\n    temp_len++;\n    if(getRandom(p->next)) return true;\n    if (rand_n == 0) {\n        res = p->val;\n        return true;\n    }\n    rand_n--;\n    return false;\n}\nint temp_len;\nint rand_n;\nListNode *head;\nint res;\n```\n\n最后是`dicuss`中的水库抽样法：\n\n```c++\nint getRandom() {\n    int res = head->val;\n    ListNode* node = head->next;\n    int i = 2;\n    while(node){\n        int j = rand()%i;\n        if(j==0)\n            res = node->val;\n        i++;\n        node = node->next;\n    }\n    return res;\n}\n```\n\n证明可参考：[http://blog.csdn.net/so_geili/article/details/52937212](http://blog.csdn.net/so_geili/article/details/52937212)\n\n","slug":"Linked-List-Random-Node","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oe007mqmcmagd5frlu","content":"<p>第90天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/linked-list-random-node/description/\">Linked List Random Node</a>:</p>\n<blockquote>\n<p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.</p>\n<p>Follow up:<br>What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?</p>\n<p>Example:</p>\n<p>// Init a singly linked list [1,2,3].<br>ListNode head = new ListNode(1);<br>head.next = new ListNode(2);<br>head.next.next = new ListNode(3);<br>Solution solution = new Solution(head);</p>\n<p>// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.<br>solution.getRandom();</p>\n</blockquote>\n<p>写出了一个朴素的解法，两次扫描：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Solution(ListNode* p) &#123;</span><br><span class=\"line\">    len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    head = p;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p) &#123;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; len &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Returns a random node&#x27;s value. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = rand() % len;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; r &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    ListNode *p = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-- &amp;&amp; p) &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p-&gt;val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> len;</span><br><span class=\"line\">ListNode *head;</span><br></pre></td></tr></table></figure>\n\n<p>然后是利用栈来做的一个解法，即一直递归调用直到链表结尾，这时我们已经遍历了一遍链表就可以知道其长度了，在这时生成随机数，然后在递归调用返回的时候通过这个随机数来选取节点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    temp_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    getRandom(head);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">getRandom</span><span class=\"params\">(ListNode *p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        rand_n = rand() % temp_len;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    temp_len++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(getRandom(p-&gt;next)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rand_n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res = p-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rand_n--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> temp_len;</span><br><span class=\"line\"><span class=\"keyword\">int</span> rand_n;</span><br><span class=\"line\">ListNode *head;</span><br><span class=\"line\"><span class=\"keyword\">int</span> res;</span><br></pre></td></tr></table></figure>\n\n<p>最后是<code>dicuss</code>中的水库抽样法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = head-&gt;val;</span><br><span class=\"line\">    ListNode* node = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(node)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = rand()%i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>)</span><br><span class=\"line\">            res = node-&gt;val;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        node = node-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>证明可参考：<a href=\"http://blog.csdn.net/so_geili/article/details/52937212\">http://blog.csdn.net/so_geili/article/details/52937212</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>第90天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/linked-list-random-node/description/\">Linked List Random Node</a>:</p>\n<blockquote>\n<p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.</p>\n<p>Follow up:<br>What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?</p>\n<p>Example:</p>\n<p>// Init a singly linked list [1,2,3].<br>ListNode head = new ListNode(1);<br>head.next = new ListNode(2);<br>head.next.next = new ListNode(3);<br>Solution solution = new Solution(head);</p>\n<p>// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.<br>solution.getRandom();</p>\n</blockquote>\n<p>写出了一个朴素的解法，两次扫描：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Solution(ListNode* p) &#123;</span><br><span class=\"line\">    len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    head = p;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p) &#123;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; len &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Returns a random node&#x27;s value. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = rand() % len;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; r &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    ListNode *p = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-- &amp;&amp; p) &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p-&gt;val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> len;</span><br><span class=\"line\">ListNode *head;</span><br></pre></td></tr></table></figure>\n\n<p>然后是利用栈来做的一个解法，即一直递归调用直到链表结尾，这时我们已经遍历了一遍链表就可以知道其长度了，在这时生成随机数，然后在递归调用返回的时候通过这个随机数来选取节点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    temp_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    getRandom(head);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">getRandom</span><span class=\"params\">(ListNode *p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        rand_n = rand() % temp_len;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    temp_len++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(getRandom(p-&gt;next)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rand_n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res = p-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rand_n--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> temp_len;</span><br><span class=\"line\"><span class=\"keyword\">int</span> rand_n;</span><br><span class=\"line\">ListNode *head;</span><br><span class=\"line\"><span class=\"keyword\">int</span> res;</span><br></pre></td></tr></table></figure>\n\n<p>最后是<code>dicuss</code>中的水库抽样法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = head-&gt;val;</span><br><span class=\"line\">    ListNode* node = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(node)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = rand()%i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>)</span><br><span class=\"line\">            res = node-&gt;val;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        node = node-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>证明可参考：<a href=\"http://blog.csdn.net/so_geili/article/details/52937212\">http://blog.csdn.net/so_geili/article/details/52937212</a></p>\n"},{"title":"Longest Common Subsequence","date":"2019-11-27T14:57:33.000Z","_content":"\n> 第23天。\n\n今天的题目是[ Longest Common Subsequence ]( https://leetcode.com/problems/longest-common-subsequence/ ):\n\n---\n\nGiven two strings `text1` and `text2`, return the length of their longest common subsequence.\n\nA *subsequence* of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). A *common subsequence* of two strings is a subsequence that is common to both strings.\n\n \n\nIf there is no common subsequence, return 0.\n\n \n\n**Example 1:**\n\n```\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n```\n\n**Example 2:**\n\n```\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n```\n\n**Example 3:**\n\n```\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n```\n\n \n\n**Constraints:**\n\n- `1 <= text1.length <= 1000`\n- `1 <= text2.length <= 1000`\n- The input strings consist of lowercase English characters only.\n\n---\n\n这是一道比较经典的动态规划问题吧，它的动规方程为：\n$$\n\\begin{aligned}\nLCS(i,j) = \\left\\{\n\\begin{array}{rcl}\n\n & LCS[i-1, j-1] + 1 & ,{s1[i] = s2[j]} \\\\\n& max(LCS[i, j-1], LCS[i-1, j]) & ,{s1[i] \\neq s2[j]}\n\n\\end{array}\n\\right.\n\\end{aligned}\n$$\n根据动规方程我们可以写出如下代码：\n\n```c++\nint longestCommonSubsequence(string text1, string text2) {\n    vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));\n    for(int i = 1;i < dp.size(); i++) {\n        for(int j = 1;j < dp[0].size(); j++) {\n            if (text1[i-1] == text2[j-1]) {\n                dp[i][j] = dp[i-1][j-1] + 1;\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n    return dp[text1.size()][text2.size()];\n}\n```\n\n这里的空间复杂度可以继续进行优化，因为`LCS[i,j]`只与当前行和上一行有关系，所以可以优化成两个数组来做：\n\n```c++\nint longestCommonSubsequence(string text1, string text2) {\n\n    int n = text1.size() + 1, m = text2.size() + 1;\n    vector<int> dp1(m, 0);\n    vector<int> dp2(m);\n\n    for(int i = 1;i < n; i++) {\n        dp1[0] = 0;\n        for(int j = 1;j < m; j++) {\n            if (text1[i-1] == text2[j-1]) {\n                dp2[j] = dp1[j-1] + 1;\n            } else {\n                dp2[j] = max(dp1[j], dp2[j-1]);\n            }\n        }\n        swap(dp1, dp2);\n    }\n    return dp1[m-1];\n}\n```\n\n再进一步的话，我们可以发现`dp[i][j]`只与 `dp[i-1][j-1]`，`dp[i-1][j]`，`dp[i][j-1]` 相关，如果我们只用一个数组的话，`dp[i][j]`与`dp[i-1][j]`其实存在同一个位置，而`dp[i][j-1]`是在同一行，所以我们只需要维护一个`prev`变量来保存`dp[i-1][j-1]`的值即可：\n\n```c++\nint longestCommonSubsequence(string text1, string text2) {\n    int n = text1.size(), m = text2.size() + 1;\n    vector<int> dp(m, 0);\n    \n    for(int i = 0;i < n; i++) {\n        int prev = 0;\n        for(int j = 1;j < m; j++) {\n            int temp = prev;\n            prev = dp[j];\n            dp[j] = (text1[i] == text2[j-1]) ? (temp + 1) : (max(dp[j], dp[j-1]));\n        }\n    }\n    return dp[m-1];\n}\n```\n\n","source":"_posts/Longest-Common-Subsequence.md","raw":"---\ntitle: Longest Common Subsequence\ndate: 2019-11-27T22:57:33.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第23天。\n\n今天的题目是[ Longest Common Subsequence ]( https://leetcode.com/problems/longest-common-subsequence/ ):\n\n---\n\nGiven two strings `text1` and `text2`, return the length of their longest common subsequence.\n\nA *subsequence* of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). A *common subsequence* of two strings is a subsequence that is common to both strings.\n\n \n\nIf there is no common subsequence, return 0.\n\n \n\n**Example 1:**\n\n```\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n```\n\n**Example 2:**\n\n```\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n```\n\n**Example 3:**\n\n```\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n```\n\n \n\n**Constraints:**\n\n- `1 <= text1.length <= 1000`\n- `1 <= text2.length <= 1000`\n- The input strings consist of lowercase English characters only.\n\n---\n\n这是一道比较经典的动态规划问题吧，它的动规方程为：\n$$\n\\begin{aligned}\nLCS(i,j) = \\left\\{\n\\begin{array}{rcl}\n\n & LCS[i-1, j-1] + 1 & ,{s1[i] = s2[j]} \\\\\n& max(LCS[i, j-1], LCS[i-1, j]) & ,{s1[i] \\neq s2[j]}\n\n\\end{array}\n\\right.\n\\end{aligned}\n$$\n根据动规方程我们可以写出如下代码：\n\n```c++\nint longestCommonSubsequence(string text1, string text2) {\n    vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));\n    for(int i = 1;i < dp.size(); i++) {\n        for(int j = 1;j < dp[0].size(); j++) {\n            if (text1[i-1] == text2[j-1]) {\n                dp[i][j] = dp[i-1][j-1] + 1;\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n    return dp[text1.size()][text2.size()];\n}\n```\n\n这里的空间复杂度可以继续进行优化，因为`LCS[i,j]`只与当前行和上一行有关系，所以可以优化成两个数组来做：\n\n```c++\nint longestCommonSubsequence(string text1, string text2) {\n\n    int n = text1.size() + 1, m = text2.size() + 1;\n    vector<int> dp1(m, 0);\n    vector<int> dp2(m);\n\n    for(int i = 1;i < n; i++) {\n        dp1[0] = 0;\n        for(int j = 1;j < m; j++) {\n            if (text1[i-1] == text2[j-1]) {\n                dp2[j] = dp1[j-1] + 1;\n            } else {\n                dp2[j] = max(dp1[j], dp2[j-1]);\n            }\n        }\n        swap(dp1, dp2);\n    }\n    return dp1[m-1];\n}\n```\n\n再进一步的话，我们可以发现`dp[i][j]`只与 `dp[i-1][j-1]`，`dp[i-1][j]`，`dp[i][j-1]` 相关，如果我们只用一个数组的话，`dp[i][j]`与`dp[i-1][j]`其实存在同一个位置，而`dp[i][j-1]`是在同一行，所以我们只需要维护一个`prev`变量来保存`dp[i-1][j-1]`的值即可：\n\n```c++\nint longestCommonSubsequence(string text1, string text2) {\n    int n = text1.size(), m = text2.size() + 1;\n    vector<int> dp(m, 0);\n    \n    for(int i = 0;i < n; i++) {\n        int prev = 0;\n        for(int j = 1;j < m; j++) {\n            int temp = prev;\n            prev = dp[j];\n            dp[j] = (text1[i] == text2[j-1]) ? (temp + 1) : (max(dp[j], dp[j-1]));\n        }\n    }\n    return dp[m-1];\n}\n```\n\n","slug":"Longest-Common-Subsequence","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69of007pqmcmhb7few0u","content":"<blockquote>\n<p>第23天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-common-subsequence/\"> Longest Common Subsequence </a>:</p>\n<hr>\n<p>Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence.</p>\n<p>A <em>subsequence</em> of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A <em>common subsequence</em> of two strings is a subsequence that is common to both strings.</p>\n<p>If there is no common subsequence, return 0.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class=\"line\">Output: 3  </span><br><span class=\"line\">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class=\"line\">Output: 0</span><br><span class=\"line\">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Constraints:</strong></p>\n<ul>\n<li><code>1 &lt;= text1.length &lt;= 1000</code></li>\n<li><code>1 &lt;= text2.length &lt;= 1000</code></li>\n<li>The input strings consist of lowercase English characters only.</li>\n</ul>\n<hr>\n<p>这是一道比较经典的动态规划问题吧，它的动规方程为：<br>$$<br>\\begin{aligned}<br>LCS(i,j) = \\left{<br>\\begin{array}{rcl}</p>\n<p> &amp; LCS[i-1, j-1] + 1 &amp; ,{s1[i] = s2[j]} \\<br>&amp; max(LCS[i, j-1], LCS[i-1, j]) &amp; ,{s1[i] \\neq s2[j]}</p>\n<p>\\end{array}<br>\\right.<br>\\end{aligned}<br>$$<br>根据动规方程我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(text1.size() + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(text2.size() + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; dp[<span class=\"number\">0</span>].size(); j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (text1[i<span class=\"number\">-1</span>] == text2[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                dp[i][j] = max(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[text1.size()][text2.size()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的空间复杂度可以继续进行优化，因为<code>LCS[i,j]</code>只与当前行和上一行有关系，所以可以优化成两个数组来做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = text1.size() + <span class=\"number\">1</span>, m = text2.size() + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp1</span><span class=\"params\">(m, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp2</span><span class=\"params\">(m)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; n; i++) &#123;</span><br><span class=\"line\">        dp1[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; m; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (text1[i<span class=\"number\">-1</span>] == text2[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                dp2[j] = dp1[j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                dp2[j] = max(dp1[j], dp2[j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(dp1, dp2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp1[m<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再进一步的话，我们可以发现<code>dp[i][j]</code>只与 <code>dp[i-1][j-1]</code>，<code>dp[i-1][j]</code>，<code>dp[i][j-1]</code> 相关，如果我们只用一个数组的话，<code>dp[i][j]</code>与<code>dp[i-1][j]</code>其实存在同一个位置，而<code>dp[i][j-1]</code>是在同一行，所以我们只需要维护一个<code>prev</code>变量来保存<code>dp[i-1][j-1]</code>的值即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = text1.size(), m = text2.size() + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(m, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> prev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; m; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = prev;</span><br><span class=\"line\">            prev = dp[j];</span><br><span class=\"line\">            dp[j] = (text1[i] == text2[j<span class=\"number\">-1</span>]) ? (temp + <span class=\"number\">1</span>) : (max(dp[j], dp[j<span class=\"number\">-1</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第23天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-common-subsequence/\"> Longest Common Subsequence </a>:</p>\n<hr>\n<p>Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence.</p>\n<p>A <em>subsequence</em> of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A <em>common subsequence</em> of two strings is a subsequence that is common to both strings.</p>\n<p>If there is no common subsequence, return 0.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class=\"line\">Output: 3  </span><br><span class=\"line\">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class=\"line\">Output: 0</span><br><span class=\"line\">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Constraints:</strong></p>\n<ul>\n<li><code>1 &lt;= text1.length &lt;= 1000</code></li>\n<li><code>1 &lt;= text2.length &lt;= 1000</code></li>\n<li>The input strings consist of lowercase English characters only.</li>\n</ul>\n<hr>\n<p>这是一道比较经典的动态规划问题吧，它的动规方程为：<br>$$<br>\\begin{aligned}<br>LCS(i,j) = \\left{<br>\\begin{array}{rcl}</p>\n<p> &amp; LCS[i-1, j-1] + 1 &amp; ,{s1[i] = s2[j]} \\<br>&amp; max(LCS[i, j-1], LCS[i-1, j]) &amp; ,{s1[i] \\neq s2[j]}</p>\n<p>\\end{array}<br>\\right.<br>\\end{aligned}<br>$$<br>根据动规方程我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(text1.size() + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(text2.size() + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; dp[<span class=\"number\">0</span>].size(); j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (text1[i<span class=\"number\">-1</span>] == text2[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                dp[i][j] = max(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[text1.size()][text2.size()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的空间复杂度可以继续进行优化，因为<code>LCS[i,j]</code>只与当前行和上一行有关系，所以可以优化成两个数组来做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = text1.size() + <span class=\"number\">1</span>, m = text2.size() + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp1</span><span class=\"params\">(m, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp2</span><span class=\"params\">(m)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; n; i++) &#123;</span><br><span class=\"line\">        dp1[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; m; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (text1[i<span class=\"number\">-1</span>] == text2[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                dp2[j] = dp1[j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                dp2[j] = max(dp1[j], dp2[j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(dp1, dp2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp1[m<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再进一步的话，我们可以发现<code>dp[i][j]</code>只与 <code>dp[i-1][j-1]</code>，<code>dp[i-1][j]</code>，<code>dp[i][j-1]</code> 相关，如果我们只用一个数组的话，<code>dp[i][j]</code>与<code>dp[i-1][j]</code>其实存在同一个位置，而<code>dp[i][j-1]</code>是在同一行，所以我们只需要维护一个<code>prev</code>变量来保存<code>dp[i-1][j-1]</code>的值即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = text1.size(), m = text2.size() + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(m, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> prev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; m; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = prev;</span><br><span class=\"line\">            prev = dp[j];</span><br><span class=\"line\">            dp[j] = (text1[i] == text2[j<span class=\"number\">-1</span>]) ? (temp + <span class=\"number\">1</span>) : (max(dp[j], dp[j<span class=\"number\">-1</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Longest-Continuous-Increasing-Subsqeuence","date":"2017-12-04T05:19:31.000Z","_content":"\n第68天。\n\n今天的题目是[Longest Continuous Increasing Subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/):\n\n> Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarra y).\n>\n> Example 1:\n> Input: [1,3,5,4,7]\n> Output: 3\n> Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.\n> Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. \n> Example 2:\n> Input: [2,2,2,2,2]\n> Output: 1\n> Explanation: The longest continuous increasing subsequence is [2], its length is 1.\n> Note: Length of the array will not exceed 10,000.\n\n题目比较简单，只需要遍历一遍所有元素，然后每次都比较它和它前面一个元素的大小即可：\n\n```c++\nint findLengthOfLCIS(vector<int>& nums) {\n    if (nums.size() == 0) return 0;\n    int ret = 0;\n    int a = 1;\n    for(int i = 0;i + 1 < nums.size();i++)\n        if (nums[i] < nums[i+1]) a++;\n        else {\n            ret = max(a,ret);\n            a = 1;\n        }\n    return max(a,ret);\n}\n```\n","source":"_posts/Longest-Continuous-Increasing-Subsqeuence.md","raw":"---\ntitle: Longest-Continuous-Increasing-Subsqeuence\ndate: 2017-12-04T13:19:31.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第68天。\n\n今天的题目是[Longest Continuous Increasing Subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/):\n\n> Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarra y).\n>\n> Example 1:\n> Input: [1,3,5,4,7]\n> Output: 3\n> Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.\n> Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. \n> Example 2:\n> Input: [2,2,2,2,2]\n> Output: 1\n> Explanation: The longest continuous increasing subsequence is [2], its length is 1.\n> Note: Length of the array will not exceed 10,000.\n\n题目比较简单，只需要遍历一遍所有元素，然后每次都比较它和它前面一个元素的大小即可：\n\n```c++\nint findLengthOfLCIS(vector<int>& nums) {\n    if (nums.size() == 0) return 0;\n    int ret = 0;\n    int a = 1;\n    for(int i = 0;i + 1 < nums.size();i++)\n        if (nums[i] < nums[i+1]) a++;\n        else {\n            ret = max(a,ret);\n            a = 1;\n        }\n    return max(a,ret);\n}\n```\n","slug":"Longest-Continuous-Increasing-Subsqeuence","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69og007sqmcmcnxy9gvd","content":"<p>第68天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/\">Longest Continuous Increasing Subsequence</a>:</p>\n<blockquote>\n<p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarra y).</p>\n<p>Example 1:<br>Input: [1,3,5,4,7]<br>Output: 3<br>Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4.<br>Example 2:<br>Input: [2,2,2,2,2]<br>Output: 1<br>Explanation: The longest continuous increasing subsequence is [2], its length is 1.<br>Note: Length of the array will not exceed 10,000.</p>\n</blockquote>\n<p>题目比较简单，只需要遍历一遍所有元素，然后每次都比较它和它前面一个元素的大小即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i + <span class=\"number\">1</span> &lt; nums.size();i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &lt; nums[i+<span class=\"number\">1</span>]) a++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ret = max(a,ret);</span><br><span class=\"line\">            a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(a,ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第68天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/\">Longest Continuous Increasing Subsequence</a>:</p>\n<blockquote>\n<p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarra y).</p>\n<p>Example 1:<br>Input: [1,3,5,4,7]<br>Output: 3<br>Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4.<br>Example 2:<br>Input: [2,2,2,2,2]<br>Output: 1<br>Explanation: The longest continuous increasing subsequence is [2], its length is 1.<br>Note: Length of the array will not exceed 10,000.</p>\n</blockquote>\n<p>题目比较简单，只需要遍历一遍所有元素，然后每次都比较它和它前面一个元素的大小即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i + <span class=\"number\">1</span> &lt; nums.size();i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &lt; nums[i+<span class=\"number\">1</span>]) a++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ret = max(a,ret);</span><br><span class=\"line\">            a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(a,ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Longest-Harmonious-Subsequence","date":"2017-12-13T03:22:16.000Z","_content":"\n第77天。\n\n今天的题目是[Longest Harmonious Subsequence](https://leetcode.com/problems/longest-harmonious-subsequence/description/):\n\n> We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.\n>\n> Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.\n>\n> Example 1:\n> Input: [1,3,2,2,5,2,3,7]\n> Output: 5\n> Explanation: The longest harmonious subsequence is [3,2,2,2,3].\n> Note: The length of the input array will not exceed 20,000.\n\n好像有是一个用`hash`做的题目：\n\n```c++\nint findLHS(vector<int>& nums) {\n    unordered_map<int,int> m;\n    for(int i = 0;i < nums.size();i++)\n        m[nums[i]]++;\n    int len = 0;\n    for(auto &p:m) {\n        if (m.count(p.first + 1) > 0)\n            len = max(len,p.second + m[p.first + 1]);\n    }\n    return len;\n}\n```\n\n`dicuss`中有用`sort`做的：\n\n```c++\nint findLHS(vector<int>& nums) {\n    sort(nums.begin(),nums.end());\n    int len = 0;\n    for(int i = 1, start = 0, new_start = 0; i<nums.size(); i++)\n    {\n\n        if (nums[i] - nums[start] > 1)\n            start = new_start;\n        if (nums[i] != nums[i-1])\n            new_start = i;\n        if(nums[i] - nums[start] == 1)\n            len = max(len, i-start+1);\n    }\n    return len;\n}\n```\n","source":"_posts/Longest-Harmonious-Subsequence.md","raw":"---\ntitle: Longest-Harmonious-Subsequence\ndate: 2017-12-13T11:22:16.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第77天。\n\n今天的题目是[Longest Harmonious Subsequence](https://leetcode.com/problems/longest-harmonious-subsequence/description/):\n\n> We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.\n>\n> Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.\n>\n> Example 1:\n> Input: [1,3,2,2,5,2,3,7]\n> Output: 5\n> Explanation: The longest harmonious subsequence is [3,2,2,2,3].\n> Note: The length of the input array will not exceed 20,000.\n\n好像有是一个用`hash`做的题目：\n\n```c++\nint findLHS(vector<int>& nums) {\n    unordered_map<int,int> m;\n    for(int i = 0;i < nums.size();i++)\n        m[nums[i]]++;\n    int len = 0;\n    for(auto &p:m) {\n        if (m.count(p.first + 1) > 0)\n            len = max(len,p.second + m[p.first + 1]);\n    }\n    return len;\n}\n```\n\n`dicuss`中有用`sort`做的：\n\n```c++\nint findLHS(vector<int>& nums) {\n    sort(nums.begin(),nums.end());\n    int len = 0;\n    for(int i = 1, start = 0, new_start = 0; i<nums.size(); i++)\n    {\n\n        if (nums[i] - nums[start] > 1)\n            start = new_start;\n        if (nums[i] != nums[i-1])\n            new_start = i;\n        if(nums[i] - nums[start] == 1)\n            len = max(len, i-start+1);\n    }\n    return len;\n}\n```\n","slug":"Longest-Harmonious-Subsequence","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69og007vqmcmfb158c7v","content":"<p>第77天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-harmonious-subsequence/description/\">Longest Harmonious Subsequence</a>:</p>\n<blockquote>\n<p>We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.</p>\n<p>Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.</p>\n<p>Example 1:<br>Input: [1,3,2,2,5,2,3,7]<br>Output: 5<br>Explanation: The longest harmonious subsequence is [3,2,2,2,3].<br>Note: The length of the input array will not exceed 20,000.</p>\n</blockquote>\n<p>好像有是一个用<code>hash</code>做的题目：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLHS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size();i++)</span><br><span class=\"line\">        m[nums[i]]++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;p:m) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m.count(p.first + <span class=\"number\">1</span>) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            len = max(len,p.second + m[p.first + <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中有用<code>sort</code>做的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLHS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums.begin(),nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, start = <span class=\"number\">0</span>, new_start = <span class=\"number\">0</span>; i&lt;nums.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] - nums[start] &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            start = new_start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != nums[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">            new_start = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[i] - nums[start] == <span class=\"number\">1</span>)</span><br><span class=\"line\">            len = max(len, i-start+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第77天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-harmonious-subsequence/description/\">Longest Harmonious Subsequence</a>:</p>\n<blockquote>\n<p>We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.</p>\n<p>Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.</p>\n<p>Example 1:<br>Input: [1,3,2,2,5,2,3,7]<br>Output: 5<br>Explanation: The longest harmonious subsequence is [3,2,2,2,3].<br>Note: The length of the input array will not exceed 20,000.</p>\n</blockquote>\n<p>好像有是一个用<code>hash</code>做的题目：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLHS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size();i++)</span><br><span class=\"line\">        m[nums[i]]++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;p:m) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m.count(p.first + <span class=\"number\">1</span>) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            len = max(len,p.second + m[p.first + <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中有用<code>sort</code>做的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLHS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums.begin(),nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, start = <span class=\"number\">0</span>, new_start = <span class=\"number\">0</span>; i&lt;nums.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] - nums[start] &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            start = new_start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != nums[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">            new_start = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[i] - nums[start] == <span class=\"number\">1</span>)</span><br><span class=\"line\">            len = max(len, i-start+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Longest-Palindrome","date":"2018-01-16T01:28:28.000Z","_content":"\n第85天。\n\n今天的题目是[Longest Palindrome](https://leetcode.com/problems/longest-palindrome/description/):\n\n> Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\n>\n> This is case sensitive, for example \"Aa\" is not considered a palindrome here.\n>\n> Note:\n> Assume the length of given string will not exceed 1,010.\n>\n> Example:\n>\n> Input:\n> \"abccccdd\"\n>\n> Output:\n> 7\n>\n> Explanation:\n> One longest palindrome that can be built is \"dccaccd\", whose length is 7.\n\n这里有一点比较好玩的就是，他问的是能用这里字母组成的最长回文，所以他给的字符串顺序是不重要的，我们可以先用`unordered_map`先统计各个字母的个数，然后利用这些个数来计算即可。\n\n先考虑回文长度是偶数的情况，一个字母要出现在回文中，就必须保证偶数个字母一起出现，这样的话我们就可以这样来计算了：\n\n```c++\nfor(auto &p:wcount) ret += (p.second / 2);\n    ret *= 2;\n```\n\n然后考虑奇数的情况，从它给的示例中我们很容易的发现，奇数的情况就是偶数的情况加一，当然也可能不加一，因为可以字母不够用。所以我们可以写出以下解法：\n\n\n```c++\nint longestPalindrome(string s) {\n    unordered_map<char,int> wcount;\n    for(auto &c:s) wcount[c]++;\n    int ret = 0;\n    for(auto &p:wcount) ret += (p.second / 2);\n    ret *= 2;\n    return (ret < s.size())?ret+1:ret;\n}\n```\n\n还可以更快一点，把除法和乘法去掉：\n\n```c++\nint longestPalindrome(string s) {\n    unordered_map<char,int> wcount;\n    for(auto &c:s) wcount[c]++;\n    int ret = 0;\n    for(auto &p:wcount) ret += ((p.second % 2)?p.second-1:p.second);\n    return (ret < s.size())?ret+1:ret;\n}\n```\n\n`dicuss`有一个解法比较有趣，他是通过数出现奇数次的字母来实现的：\n\n```c++\nint longestPalindrome(string s) {\n    int odds = 0;\n    for (char c='A'; c<='z'; c++)\n        odds += count(s.begin(), s.end(), c) & 1;\n    return s.size() - odds + (odds > 0);\n}\n```\n","source":"_posts/Longest-Palindrome.md","raw":"---\ntitle: Longest-Palindrome\ndate: 2018-01-16T09:28:28.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第85天。\n\n今天的题目是[Longest Palindrome](https://leetcode.com/problems/longest-palindrome/description/):\n\n> Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\n>\n> This is case sensitive, for example \"Aa\" is not considered a palindrome here.\n>\n> Note:\n> Assume the length of given string will not exceed 1,010.\n>\n> Example:\n>\n> Input:\n> \"abccccdd\"\n>\n> Output:\n> 7\n>\n> Explanation:\n> One longest palindrome that can be built is \"dccaccd\", whose length is 7.\n\n这里有一点比较好玩的就是，他问的是能用这里字母组成的最长回文，所以他给的字符串顺序是不重要的，我们可以先用`unordered_map`先统计各个字母的个数，然后利用这些个数来计算即可。\n\n先考虑回文长度是偶数的情况，一个字母要出现在回文中，就必须保证偶数个字母一起出现，这样的话我们就可以这样来计算了：\n\n```c++\nfor(auto &p:wcount) ret += (p.second / 2);\n    ret *= 2;\n```\n\n然后考虑奇数的情况，从它给的示例中我们很容易的发现，奇数的情况就是偶数的情况加一，当然也可能不加一，因为可以字母不够用。所以我们可以写出以下解法：\n\n\n```c++\nint longestPalindrome(string s) {\n    unordered_map<char,int> wcount;\n    for(auto &c:s) wcount[c]++;\n    int ret = 0;\n    for(auto &p:wcount) ret += (p.second / 2);\n    ret *= 2;\n    return (ret < s.size())?ret+1:ret;\n}\n```\n\n还可以更快一点，把除法和乘法去掉：\n\n```c++\nint longestPalindrome(string s) {\n    unordered_map<char,int> wcount;\n    for(auto &c:s) wcount[c]++;\n    int ret = 0;\n    for(auto &p:wcount) ret += ((p.second % 2)?p.second-1:p.second);\n    return (ret < s.size())?ret+1:ret;\n}\n```\n\n`dicuss`有一个解法比较有趣，他是通过数出现奇数次的字母来实现的：\n\n```c++\nint longestPalindrome(string s) {\n    int odds = 0;\n    for (char c='A'; c<='z'; c++)\n        odds += count(s.begin(), s.end(), c) & 1;\n    return s.size() - odds + (odds > 0);\n}\n```\n","slug":"Longest-Palindrome","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oh007yqmcmd9io9wgz","content":"<p>第85天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-palindrome/description/\">Longest Palindrome</a>:</p>\n<blockquote>\n<p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>\n<p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>\n<p>Note:<br>Assume the length of given string will not exceed 1,010.</p>\n<p>Example:</p>\n<p>Input:<br>“abccccdd”</p>\n<p>Output:<br>7</p>\n<p>Explanation:<br>One longest palindrome that can be built is “dccaccd”, whose length is 7.</p>\n</blockquote>\n<p>这里有一点比较好玩的就是，他问的是能用这里字母组成的最长回文，所以他给的字符串顺序是不重要的，我们可以先用<code>unordered_map</code>先统计各个字母的个数，然后利用这些个数来计算即可。</p>\n<p>先考虑回文长度是偶数的情况，一个字母要出现在回文中，就必须保证偶数个字母一起出现，这样的话我们就可以这样来计算了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;p:wcount) ret += (p.second / <span class=\"number\">2</span>);</span><br><span class=\"line\">    ret *= <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>然后考虑奇数的情况，从它给的示例中我们很容易的发现，奇数的情况就是偶数的情况加一，当然也可能不加一，因为可以字母不够用。所以我们可以写出以下解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; wcount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c:s) wcount[c]++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;p:wcount) ret += (p.second / <span class=\"number\">2</span>);</span><br><span class=\"line\">    ret *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ret &lt; s.size())?ret+<span class=\"number\">1</span>:ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以更快一点，把除法和乘法去掉：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; wcount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c:s) wcount[c]++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;p:wcount) ret += ((p.second % <span class=\"number\">2</span>)?p.second<span class=\"number\">-1</span>:p.second);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ret &lt; s.size())?ret+<span class=\"number\">1</span>:ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>有一个解法比较有趣，他是通过数出现奇数次的字母来实现的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> odds = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c=<span class=\"string\">&#x27;A&#x27;</span>; c&lt;=<span class=\"string\">&#x27;z&#x27;</span>; c++)</span><br><span class=\"line\">        odds += count(s.begin(), s.end(), c) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.size() - odds + (odds &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第85天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-palindrome/description/\">Longest Palindrome</a>:</p>\n<blockquote>\n<p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>\n<p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>\n<p>Note:<br>Assume the length of given string will not exceed 1,010.</p>\n<p>Example:</p>\n<p>Input:<br>“abccccdd”</p>\n<p>Output:<br>7</p>\n<p>Explanation:<br>One longest palindrome that can be built is “dccaccd”, whose length is 7.</p>\n</blockquote>\n<p>这里有一点比较好玩的就是，他问的是能用这里字母组成的最长回文，所以他给的字符串顺序是不重要的，我们可以先用<code>unordered_map</code>先统计各个字母的个数，然后利用这些个数来计算即可。</p>\n<p>先考虑回文长度是偶数的情况，一个字母要出现在回文中，就必须保证偶数个字母一起出现，这样的话我们就可以这样来计算了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;p:wcount) ret += (p.second / <span class=\"number\">2</span>);</span><br><span class=\"line\">    ret *= <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>然后考虑奇数的情况，从它给的示例中我们很容易的发现，奇数的情况就是偶数的情况加一，当然也可能不加一，因为可以字母不够用。所以我们可以写出以下解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; wcount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c:s) wcount[c]++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;p:wcount) ret += (p.second / <span class=\"number\">2</span>);</span><br><span class=\"line\">    ret *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ret &lt; s.size())?ret+<span class=\"number\">1</span>:ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以更快一点，把除法和乘法去掉：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; wcount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c:s) wcount[c]++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;p:wcount) ret += ((p.second % <span class=\"number\">2</span>)?p.second<span class=\"number\">-1</span>:p.second);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ret &lt; s.size())?ret+<span class=\"number\">1</span>:ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>有一个解法比较有趣，他是通过数出现奇数次的字母来实现的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> odds = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c=<span class=\"string\">&#x27;A&#x27;</span>; c&lt;=<span class=\"string\">&#x27;z&#x27;</span>; c++)</span><br><span class=\"line\">        odds += count(s.begin(), s.end(), c) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.size() - odds + (odds &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Longest Palindromic Subsequence","date":"2019-12-03T04:12:04.000Z","_content":"\n\n> 第27天。\n\n今天的题目是[Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)：\n\n一道动态规划的问题，我们假定`dp[i, j]`是字符串`S[i:j]`最长回文串的长度。那么我们可以写出如下动规方程：\n\n$$\ndp[i, j] = \\left\\{\n\\begin{aligned}\ndp[i-1, j-1] + 2 & &,s[i] = s[j] \\\\\nmax\\{d[i-1,j], dp[i, j-1]\\} & &,s[i] \\neq s[j] \n\\end{aligned}\n\\right.\n$$\n\n有了动规方程后，这个问题就简单多了：\n\n```c++\nint longestPalindromeSubseq1(string s) {\n    int size = s.size();\n    vector<vector<int>> dp(size, vector<int>(size, 0));\n    for(int i = size - 1;i >= 0; i--) {\n        dp[i][i] = 1;\n        for(int j = i + 1;j < size;j++) {\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i+1][j-1] + 2;\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][size-1];\n}\n```\n\n为了减少空间复杂度，我们可以这样优化：\n\n```c++\nint longestPalindromeSubseq(string s) {\n    int size = s.size();\n    \n    vector<int> dp1(size, 0), dp2(size, 0);\n    for(int i = size - 1;i >= 0; i--) {\n        dp2[i] = 1;\n        dp1[i] = 0;\n        for(int j = i + 1;j < size;j++) {\n            if (s[i] == s[j]) {\n                // dp[i][j] = dp[i+1][j-1] + 2;\n                dp2[j] = dp1[j-1] + 2;\n            } else {\n                // dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n                dp2[j] = max(dp1[j], dp2[j-1]);\n            }\n        }\n        \n        swap(dp1, dp2);\n    }\n    return dp1[size-1];\n}\n```\n","source":"_posts/Longest-Palindromic-Subsequence.md","raw":"---\ntitle: Longest Palindromic Subsequence\ndate: 2019-12-03T12:12:04.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n\n> 第27天。\n\n今天的题目是[Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)：\n\n一道动态规划的问题，我们假定`dp[i, j]`是字符串`S[i:j]`最长回文串的长度。那么我们可以写出如下动规方程：\n\n$$\ndp[i, j] = \\left\\{\n\\begin{aligned}\ndp[i-1, j-1] + 2 & &,s[i] = s[j] \\\\\nmax\\{d[i-1,j], dp[i, j-1]\\} & &,s[i] \\neq s[j] \n\\end{aligned}\n\\right.\n$$\n\n有了动规方程后，这个问题就简单多了：\n\n```c++\nint longestPalindromeSubseq1(string s) {\n    int size = s.size();\n    vector<vector<int>> dp(size, vector<int>(size, 0));\n    for(int i = size - 1;i >= 0; i--) {\n        dp[i][i] = 1;\n        for(int j = i + 1;j < size;j++) {\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i+1][j-1] + 2;\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][size-1];\n}\n```\n\n为了减少空间复杂度，我们可以这样优化：\n\n```c++\nint longestPalindromeSubseq(string s) {\n    int size = s.size();\n    \n    vector<int> dp1(size, 0), dp2(size, 0);\n    for(int i = size - 1;i >= 0; i--) {\n        dp2[i] = 1;\n        dp1[i] = 0;\n        for(int j = i + 1;j < size;j++) {\n            if (s[i] == s[j]) {\n                // dp[i][j] = dp[i+1][j-1] + 2;\n                dp2[j] = dp1[j-1] + 2;\n            } else {\n                // dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n                dp2[j] = max(dp1[j], dp2[j-1]);\n            }\n        }\n        \n        swap(dp1, dp2);\n    }\n    return dp1[size-1];\n}\n```\n","slug":"Longest-Palindromic-Subsequence","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oh0081qmcmdpoq97rx","content":"<blockquote>\n<p>第27天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-palindromic-subsequence/\">Longest Palindromic Subsequence</a>：</p>\n<p>一道动态规划的问题，我们假定<code>dp[i, j]</code>是字符串<code>S[i:j]</code>最长回文串的长度。那么我们可以写出如下动规方程：</p>\n<p>$$<br>dp[i, j] = \\left{<br>\\begin{aligned}<br>dp[i-1, j-1] + 2 &amp; &amp;,s[i] = s[j] \\<br>max{d[i-1,j], dp[i, j-1]} &amp; &amp;,s[i] \\neq s[j]<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>有了动规方程后，这个问题就简单多了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindromeSubseq1</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = s.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(size, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;j &lt; size;j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] == s[j]) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i+<span class=\"number\">1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                dp[i][j] = max(dp[i+<span class=\"number\">1</span>][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][size<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了减少空间复杂度，我们可以这样优化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindromeSubseq</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = s.size();</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;int&gt; dp1(size, 0), dp2(size, 0);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        dp2[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp1[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;j &lt; size;j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] == s[j]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// dp[i][j] = dp[i+1][j-1] + 2;</span></span><br><span class=\"line\">                dp2[j] = dp1[j<span class=\"number\">-1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</span></span><br><span class=\"line\">                dp2[j] = max(dp1[j], dp2[j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        swap(dp1, dp2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp1[size<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第27天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-palindromic-subsequence/\">Longest Palindromic Subsequence</a>：</p>\n<p>一道动态规划的问题，我们假定<code>dp[i, j]</code>是字符串<code>S[i:j]</code>最长回文串的长度。那么我们可以写出如下动规方程：</p>\n<p>$$<br>dp[i, j] = \\left{<br>\\begin{aligned}<br>dp[i-1, j-1] + 2 &amp; &amp;,s[i] = s[j] \\<br>max{d[i-1,j], dp[i, j-1]} &amp; &amp;,s[i] \\neq s[j]<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>有了动规方程后，这个问题就简单多了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindromeSubseq1</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = s.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(size, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;j &lt; size;j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] == s[j]) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i+<span class=\"number\">1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                dp[i][j] = max(dp[i+<span class=\"number\">1</span>][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][size<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了减少空间复杂度，我们可以这样优化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindromeSubseq</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = s.size();</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;int&gt; dp1(size, 0), dp2(size, 0);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        dp2[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp1[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;j &lt; size;j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] == s[j]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// dp[i][j] = dp[i+1][j-1] + 2;</span></span><br><span class=\"line\">                dp2[j] = dp1[j<span class=\"number\">-1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</span></span><br><span class=\"line\">                dp2[j] = max(dp1[j], dp2[j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        swap(dp1, dp2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp1[size<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Longest Repeating Character Replacement","date":"2019-03-05T02:20:25.000Z","_content":"\n> 第6天， 下雨了。。。。\n\n今天的题目是[Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)。\n\nemmmm，这道题一开始的解法虽然AC了，但是时间复杂度是`O(n^2)`，但是最佳解法却是`O(n)`，先看下我的解法：\n\n思路比较简单，就是不断以某个字符为起始，以这个字符为目标，计算修改k次后能达到的长度，然而这样会有个问题，例如`ABBB`,如果`k`为1的话，我计算出来是`3`，但真实结果是`4`。\n\n为了解决这个问题，我增加了一次判断，对前`k`个字符进行替换，替换成下一个字符，即以下一个字符为目标，计算修改`k`次后能达到的长度。\n\n具体代码如下：\n\n```c++\nclass Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        int len = s.size();\n        int res = 0;\n        int j, a;\n        for(int i = 0; i < len; i++) {\n            char c = s[i];\n            a = k;\n            for(j = i+1;j < len; j++) {\n                if (c != s[j]) {\n                    if (a == 0) break;\n                    else a--;\n                }\n            }\n            res = max(j-i, res);\n        }\n        \n        for(int i = 0;i < k && i+1 < len; i++) {\n            char c = s[i+1];\n            a = k-i-1;\n            for(j = i + 2;j < len; j++) {\n                if (c != s[j]) {\n                    if (a == 0) break;\n                    else a--;\n                }\n            }\n            res = max(j-i, res);\n        }\n        \n        return res;\n    }\n};\n```\n\n\nOK，现在可以忽略掉上面的解法了，看看`O(n)`的解法是怎样的：\n\n```c++\nclass Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        vector<int> ch(26);\n        int start = 0, end = 0, max_count = 0;\n        int len = s.size();\n        while(end < len) {\n            ch[s[end] - 'A']++;\n            // update max_count\n            max_count = max(max_count, ch[s[end]-'A']);\n            end++;\n            if ( end - start > max_count + k) {\n                ch[s[start] - 'A']--;\n                start++;\n            }\n        }\n        return end - start;\n    }\n};\n```\n\n很精妙的用滑窗解决了这个问题：\n\n首先，它用一个数组记录滑窗内的出现字符的个数，因此每次迭代或操作都向前移动一个字符而已，所以我们可以很容易维护出一个`max_count`，即所有字符出现次数最大的那一个。\n\n然后如果是一个正确的解的话，要满足一个约束`end - start - k > max_count`,如果满足的话，可以增大滑窗去寻找更大的窗口，如果不行，那么我们就向前移动滑窗。\n\n虽然在迭代结束后，我们不能保证当前滑窗就是满足约束的解，但是我们可以保证，最大的窗口大小一定和我们现在的滑窗大小是一样的，故可以得到解。\n","source":"_posts/Longest-Repeating-Character-Replacement.md","raw":"---\ntitle: Longest Repeating Character Replacement\ndate: 2019-03-05T10:20:25.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第6天， 下雨了。。。。\n\n今天的题目是[Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)。\n\nemmmm，这道题一开始的解法虽然AC了，但是时间复杂度是`O(n^2)`，但是最佳解法却是`O(n)`，先看下我的解法：\n\n思路比较简单，就是不断以某个字符为起始，以这个字符为目标，计算修改k次后能达到的长度，然而这样会有个问题，例如`ABBB`,如果`k`为1的话，我计算出来是`3`，但真实结果是`4`。\n\n为了解决这个问题，我增加了一次判断，对前`k`个字符进行替换，替换成下一个字符，即以下一个字符为目标，计算修改`k`次后能达到的长度。\n\n具体代码如下：\n\n```c++\nclass Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        int len = s.size();\n        int res = 0;\n        int j, a;\n        for(int i = 0; i < len; i++) {\n            char c = s[i];\n            a = k;\n            for(j = i+1;j < len; j++) {\n                if (c != s[j]) {\n                    if (a == 0) break;\n                    else a--;\n                }\n            }\n            res = max(j-i, res);\n        }\n        \n        for(int i = 0;i < k && i+1 < len; i++) {\n            char c = s[i+1];\n            a = k-i-1;\n            for(j = i + 2;j < len; j++) {\n                if (c != s[j]) {\n                    if (a == 0) break;\n                    else a--;\n                }\n            }\n            res = max(j-i, res);\n        }\n        \n        return res;\n    }\n};\n```\n\n\nOK，现在可以忽略掉上面的解法了，看看`O(n)`的解法是怎样的：\n\n```c++\nclass Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        vector<int> ch(26);\n        int start = 0, end = 0, max_count = 0;\n        int len = s.size();\n        while(end < len) {\n            ch[s[end] - 'A']++;\n            // update max_count\n            max_count = max(max_count, ch[s[end]-'A']);\n            end++;\n            if ( end - start > max_count + k) {\n                ch[s[start] - 'A']--;\n                start++;\n            }\n        }\n        return end - start;\n    }\n};\n```\n\n很精妙的用滑窗解决了这个问题：\n\n首先，它用一个数组记录滑窗内的出现字符的个数，因此每次迭代或操作都向前移动一个字符而已，所以我们可以很容易维护出一个`max_count`，即所有字符出现次数最大的那一个。\n\n然后如果是一个正确的解的话，要满足一个约束`end - start - k > max_count`,如果满足的话，可以增大滑窗去寻找更大的窗口，如果不行，那么我们就向前移动滑窗。\n\n虽然在迭代结束后，我们不能保证当前滑窗就是满足约束的解，但是我们可以保证，最大的窗口大小一定和我们现在的滑窗大小是一样的，故可以得到解。\n","slug":"Longest-Repeating-Character-Replacement","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oi0084qmcme35ncrn0","content":"<blockquote>\n<p>第6天， 下雨了。。。。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-repeating-character-replacement/\">Longest Repeating Character Replacement</a>。</p>\n<p>emmmm，这道题一开始的解法虽然AC了，但是时间复杂度是<code>O(n^2)</code>，但是最佳解法却是<code>O(n)</code>，先看下我的解法：</p>\n<p>思路比较简单，就是不断以某个字符为起始，以这个字符为目标，计算修改k次后能达到的长度，然而这样会有个问题，例如<code>ABBB</code>,如果<code>k</code>为1的话，我计算出来是<code>3</code>，但真实结果是<code>4</code>。</p>\n<p>为了解决这个问题，我增加了一次判断，对前<code>k</code>个字符进行替换，替换成下一个字符，即以下一个字符为目标，计算修改<code>k</code>次后能达到的长度。</p>\n<p>具体代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j, a;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s[i];</span><br><span class=\"line\">            a = k;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j = i+<span class=\"number\">1</span>;j &lt; len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c != s[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (a == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> a--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = max(j-i, res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; k &amp;&amp; i+<span class=\"number\">1</span> &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            a = k-i<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j = i + <span class=\"number\">2</span>;j &lt; len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c != s[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (a == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> a--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = max(j-i, res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>OK，现在可以忽略掉上面的解法了，看看<code>O(n)</code>的解法是怎样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ch</span><span class=\"params\">(<span class=\"number\">26</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>, end = <span class=\"number\">0</span>, max_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(end &lt; len) &#123;</span><br><span class=\"line\">            ch[s[end] - <span class=\"string\">&#x27;A&#x27;</span>]++;</span><br><span class=\"line\">            <span class=\"comment\">// update max_count</span></span><br><span class=\"line\">            max_count = max(max_count, ch[s[end]-<span class=\"string\">&#x27;A&#x27;</span>]);</span><br><span class=\"line\">            end++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( end - start &gt; max_count + k) &#123;</span><br><span class=\"line\">                ch[s[start] - <span class=\"string\">&#x27;A&#x27;</span>]--;</span><br><span class=\"line\">                start++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> end - start;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>很精妙的用滑窗解决了这个问题：</p>\n<p>首先，它用一个数组记录滑窗内的出现字符的个数，因此每次迭代或操作都向前移动一个字符而已，所以我们可以很容易维护出一个<code>max_count</code>，即所有字符出现次数最大的那一个。</p>\n<p>然后如果是一个正确的解的话，要满足一个约束<code>end - start - k &gt; max_count</code>,如果满足的话，可以增大滑窗去寻找更大的窗口，如果不行，那么我们就向前移动滑窗。</p>\n<p>虽然在迭代结束后，我们不能保证当前滑窗就是满足约束的解，但是我们可以保证，最大的窗口大小一定和我们现在的滑窗大小是一样的，故可以得到解。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第6天， 下雨了。。。。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-repeating-character-replacement/\">Longest Repeating Character Replacement</a>。</p>\n<p>emmmm，这道题一开始的解法虽然AC了，但是时间复杂度是<code>O(n^2)</code>，但是最佳解法却是<code>O(n)</code>，先看下我的解法：</p>\n<p>思路比较简单，就是不断以某个字符为起始，以这个字符为目标，计算修改k次后能达到的长度，然而这样会有个问题，例如<code>ABBB</code>,如果<code>k</code>为1的话，我计算出来是<code>3</code>，但真实结果是<code>4</code>。</p>\n<p>为了解决这个问题，我增加了一次判断，对前<code>k</code>个字符进行替换，替换成下一个字符，即以下一个字符为目标，计算修改<code>k</code>次后能达到的长度。</p>\n<p>具体代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j, a;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s[i];</span><br><span class=\"line\">            a = k;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j = i+<span class=\"number\">1</span>;j &lt; len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c != s[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (a == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> a--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = max(j-i, res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; k &amp;&amp; i+<span class=\"number\">1</span> &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            a = k-i<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j = i + <span class=\"number\">2</span>;j &lt; len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c != s[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (a == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> a--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = max(j-i, res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>OK，现在可以忽略掉上面的解法了，看看<code>O(n)</code>的解法是怎样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ch</span><span class=\"params\">(<span class=\"number\">26</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>, end = <span class=\"number\">0</span>, max_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(end &lt; len) &#123;</span><br><span class=\"line\">            ch[s[end] - <span class=\"string\">&#x27;A&#x27;</span>]++;</span><br><span class=\"line\">            <span class=\"comment\">// update max_count</span></span><br><span class=\"line\">            max_count = max(max_count, ch[s[end]-<span class=\"string\">&#x27;A&#x27;</span>]);</span><br><span class=\"line\">            end++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( end - start &gt; max_count + k) &#123;</span><br><span class=\"line\">                ch[s[start] - <span class=\"string\">&#x27;A&#x27;</span>]--;</span><br><span class=\"line\">                start++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> end - start;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>很精妙的用滑窗解决了这个问题：</p>\n<p>首先，它用一个数组记录滑窗内的出现字符的个数，因此每次迭代或操作都向前移动一个字符而已，所以我们可以很容易维护出一个<code>max_count</code>，即所有字符出现次数最大的那一个。</p>\n<p>然后如果是一个正确的解的话，要满足一个约束<code>end - start - k &gt; max_count</code>,如果满足的话，可以增大滑窗去寻找更大的窗口，如果不行，那么我们就向前移动滑窗。</p>\n<p>虽然在迭代结束后，我们不能保证当前滑窗就是满足约束的解，但是我们可以保证，最大的窗口大小一定和我们现在的滑窗大小是一样的，故可以得到解。</p>\n"},{"title":"Longest String Chain","date":"2019-11-10T03:12:09.000Z","_content":"\n> 第6天。\n\n今天的题目是[Longest String Chain]( https://leetcode.com/problems/longest-string-chain/ )：\n\n---\n\nGiven a list of words, each word consists of English lowercase letters.\n\nLet's say `word1` is a predecessor of `word2` if and only if we can add exactly one letter anywhere in `word1` to make it equal to `word2`. For example, `\"abc\"` is a predecessor of `\"abac\"`.\n\nA *word chain* is a sequence of words `[word_1, word_2, ..., word_k]` with `k >= 1`, where `word_1` is a predecessor of `word_2`, `word_2` is a predecessor of `word_3`, and so on.\n\nReturn the longest possible length of a word chain with words chosen from the given list of `words`.\n\n \n\n**Example 1:**\n\n```\nInput: [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\nOutput: 4\nExplanation: one of the longest word chain is \"a\",\"ba\",\"bda\",\"bdca\".\n```\n\n \n\n**Note:**\n\n1. `1 <= words.length <= 1000`\n2. `1 <= words[i].length <= 16`\n3. `words[i]` only consists of English lowercase letters.\n\n---\n\n看到这道题的时候，一开始以为要先转化成图来做，但是感觉好像有点复杂化这个问题了，尝试手动跑了一下样例，发现存在最优子结构，因此我们可以用动态规划来做。动规方程如下：\n\n$$\ndp[i] = max(\\{dp[j] + 1 | isPredecessor(words[i], words[j]) == true \\});\n$$\n\n简单解释一下这个方程（可能写的不是很规范），$dp[i]$ 表示以第i 个字符串为结尾的最长`String Chain`的长度。我们可以用第 i 个字符串的所有`Predecessor`的 dp 值最大值再加一得到。\n\n同时，为了加速，我们可以先对原始的字符串序列做一次按长度的排序。这样就很容易找到和当前字符串长度相差1的字符串了，这样我们在找所有`Predecessor`的时候不需要遍历所有数组。\n\n有了动规方程，我们写出这个代码就简单多了，只要按着类似的套路即可。\n\n这样我们代码就只剩下如何判读一个字符串是否是另一个字符串的`Predecessor`，其实这个问题也挺简单的，只要两个循环即可。\n\n```c++\nbool isPredecessor(string &s1, string &s2) {\n    // check s2 is s1's predecessor\n\n    if (s1.size() != s2.size() + 1) return false;\n\n    int i = 0;\n    int len = s2.size();\n    for(;i < len  && s1[i] == s2[i]; i++)\n        /* pass */;\n    for(;i < len && s1[i+1] == s2[i]; i++)\n        /* pass */;\n\n    return i == len;\n}\nint longestStrChain(vector<string>& words) {\n\n    // sort by size\n    sort(words.begin(), words.end(), [](const string &s1, const string &s2) {\n        return s1.size() < s2.size();\n    });\n\n    vector<int> dp(words.size(), 1);\n    int beg = 0;\n    int res = 0;\n\n    for(int i = 1;i < dp.size(); i++) {\n        while(words[beg].size() + 1 < words[i].size()) beg++;\n\n        for(int j = beg; j < i; j++) {\n            if (isPredecessor(words[i], words[j])) dp[i] = max(dp[i], dp[j] + 1);\n        }\n\n        res = max(dp[i], res);\n    }\n\n    return res;\n}\n```\n\n","source":"_posts/Longest-String-Chain.md","raw":"---\ntitle: Longest String Chain\ndate: 2019-11-10T11:12:09.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第6天。\n\n今天的题目是[Longest String Chain]( https://leetcode.com/problems/longest-string-chain/ )：\n\n---\n\nGiven a list of words, each word consists of English lowercase letters.\n\nLet's say `word1` is a predecessor of `word2` if and only if we can add exactly one letter anywhere in `word1` to make it equal to `word2`. For example, `\"abc\"` is a predecessor of `\"abac\"`.\n\nA *word chain* is a sequence of words `[word_1, word_2, ..., word_k]` with `k >= 1`, where `word_1` is a predecessor of `word_2`, `word_2` is a predecessor of `word_3`, and so on.\n\nReturn the longest possible length of a word chain with words chosen from the given list of `words`.\n\n \n\n**Example 1:**\n\n```\nInput: [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\nOutput: 4\nExplanation: one of the longest word chain is \"a\",\"ba\",\"bda\",\"bdca\".\n```\n\n \n\n**Note:**\n\n1. `1 <= words.length <= 1000`\n2. `1 <= words[i].length <= 16`\n3. `words[i]` only consists of English lowercase letters.\n\n---\n\n看到这道题的时候，一开始以为要先转化成图来做，但是感觉好像有点复杂化这个问题了，尝试手动跑了一下样例，发现存在最优子结构，因此我们可以用动态规划来做。动规方程如下：\n\n$$\ndp[i] = max(\\{dp[j] + 1 | isPredecessor(words[i], words[j]) == true \\});\n$$\n\n简单解释一下这个方程（可能写的不是很规范），$dp[i]$ 表示以第i 个字符串为结尾的最长`String Chain`的长度。我们可以用第 i 个字符串的所有`Predecessor`的 dp 值最大值再加一得到。\n\n同时，为了加速，我们可以先对原始的字符串序列做一次按长度的排序。这样就很容易找到和当前字符串长度相差1的字符串了，这样我们在找所有`Predecessor`的时候不需要遍历所有数组。\n\n有了动规方程，我们写出这个代码就简单多了，只要按着类似的套路即可。\n\n这样我们代码就只剩下如何判读一个字符串是否是另一个字符串的`Predecessor`，其实这个问题也挺简单的，只要两个循环即可。\n\n```c++\nbool isPredecessor(string &s1, string &s2) {\n    // check s2 is s1's predecessor\n\n    if (s1.size() != s2.size() + 1) return false;\n\n    int i = 0;\n    int len = s2.size();\n    for(;i < len  && s1[i] == s2[i]; i++)\n        /* pass */;\n    for(;i < len && s1[i+1] == s2[i]; i++)\n        /* pass */;\n\n    return i == len;\n}\nint longestStrChain(vector<string>& words) {\n\n    // sort by size\n    sort(words.begin(), words.end(), [](const string &s1, const string &s2) {\n        return s1.size() < s2.size();\n    });\n\n    vector<int> dp(words.size(), 1);\n    int beg = 0;\n    int res = 0;\n\n    for(int i = 1;i < dp.size(); i++) {\n        while(words[beg].size() + 1 < words[i].size()) beg++;\n\n        for(int j = beg; j < i; j++) {\n            if (isPredecessor(words[i], words[j])) dp[i] = max(dp[i], dp[j] + 1);\n        }\n\n        res = max(dp[i], res);\n    }\n\n    return res;\n}\n```\n\n","slug":"Longest-String-Chain","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oj0087qmcm7goe3wbl","content":"<blockquote>\n<p>第6天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-string-chain/\">Longest String Chain</a>：</p>\n<hr>\n<p>Given a list of words, each word consists of English lowercase letters.</p>\n<p>Let’s say <code>word1</code> is a predecessor of <code>word2</code> if and only if we can add exactly one letter anywhere in <code>word1</code> to make it equal to <code>word2</code>. For example, <code>&quot;abc&quot;</code> is a predecessor of <code>&quot;abac&quot;</code>.</p>\n<p>A <em>word chain</em> is a sequence of words <code>[word_1, word_2, ..., word_k]</code> with <code>k &gt;= 1</code>, where <code>word_1</code> is a predecessor of <code>word_2</code>, <code>word_2</code> is a predecessor of <code>word_3</code>, and so on.</p>\n<p>Return the longest possible length of a word chain with words chosen from the given list of <code>words</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: one of the longest word chain is &quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n<li><code>1 &lt;= words[i].length &lt;= 16</code></li>\n<li><code>words[i]</code> only consists of English lowercase letters.</li>\n</ol>\n<hr>\n<p>看到这道题的时候，一开始以为要先转化成图来做，但是感觉好像有点复杂化这个问题了，尝试手动跑了一下样例，发现存在最优子结构，因此我们可以用动态规划来做。动规方程如下：</p>\n<p>$$<br>dp[i] = max({dp[j] + 1 | isPredecessor(words[i], words[j]) == true });<br>$$</p>\n<p>简单解释一下这个方程（可能写的不是很规范），$dp[i]$ 表示以第i 个字符串为结尾的最长<code>String Chain</code>的长度。我们可以用第 i 个字符串的所有<code>Predecessor</code>的 dp 值最大值再加一得到。</p>\n<p>同时，为了加速，我们可以先对原始的字符串序列做一次按长度的排序。这样就很容易找到和当前字符串长度相差1的字符串了，这样我们在找所有<code>Predecessor</code>的时候不需要遍历所有数组。</p>\n<p>有了动规方程，我们写出这个代码就简单多了，只要按着类似的套路即可。</p>\n<p>这样我们代码就只剩下如何判读一个字符串是否是另一个字符串的<code>Predecessor</code>，其实这个问题也挺简单的，只要两个循环即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPredecessor</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s1, <span class=\"built_in\">string</span> &amp;s2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// check s2 is s1&#x27;s predecessor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1.size() != s2.size() + <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = s2.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i &lt; len  &amp;&amp; s1[i] == s2[i]; i++)</span><br><span class=\"line\">        <span class=\"comment\">/* pass */</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i &lt; len &amp;&amp; s1[i+<span class=\"number\">1</span>] == s2[i]; i++)</span><br><span class=\"line\">        <span class=\"comment\">/* pass */</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i == len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestStrChain</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// sort by size</span></span><br><span class=\"line\">    sort(words.begin(), words.end(), [](<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s1, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.size() &lt; s2.size();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(words.size(), <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(words[beg].size() + <span class=\"number\">1</span> &lt; words[i].size()) beg++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = beg; j &lt; i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isPredecessor(words[i], words[j])) dp[i] = max(dp[i], dp[j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        res = max(dp[i], res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第6天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-string-chain/\">Longest String Chain</a>：</p>\n<hr>\n<p>Given a list of words, each word consists of English lowercase letters.</p>\n<p>Let’s say <code>word1</code> is a predecessor of <code>word2</code> if and only if we can add exactly one letter anywhere in <code>word1</code> to make it equal to <code>word2</code>. For example, <code>&quot;abc&quot;</code> is a predecessor of <code>&quot;abac&quot;</code>.</p>\n<p>A <em>word chain</em> is a sequence of words <code>[word_1, word_2, ..., word_k]</code> with <code>k &gt;= 1</code>, where <code>word_1</code> is a predecessor of <code>word_2</code>, <code>word_2</code> is a predecessor of <code>word_3</code>, and so on.</p>\n<p>Return the longest possible length of a word chain with words chosen from the given list of <code>words</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: one of the longest word chain is &quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n<li><code>1 &lt;= words[i].length &lt;= 16</code></li>\n<li><code>words[i]</code> only consists of English lowercase letters.</li>\n</ol>\n<hr>\n<p>看到这道题的时候，一开始以为要先转化成图来做，但是感觉好像有点复杂化这个问题了，尝试手动跑了一下样例，发现存在最优子结构，因此我们可以用动态规划来做。动规方程如下：</p>\n<p>$$<br>dp[i] = max({dp[j] + 1 | isPredecessor(words[i], words[j]) == true });<br>$$</p>\n<p>简单解释一下这个方程（可能写的不是很规范），$dp[i]$ 表示以第i 个字符串为结尾的最长<code>String Chain</code>的长度。我们可以用第 i 个字符串的所有<code>Predecessor</code>的 dp 值最大值再加一得到。</p>\n<p>同时，为了加速，我们可以先对原始的字符串序列做一次按长度的排序。这样就很容易找到和当前字符串长度相差1的字符串了，这样我们在找所有<code>Predecessor</code>的时候不需要遍历所有数组。</p>\n<p>有了动规方程，我们写出这个代码就简单多了，只要按着类似的套路即可。</p>\n<p>这样我们代码就只剩下如何判读一个字符串是否是另一个字符串的<code>Predecessor</code>，其实这个问题也挺简单的，只要两个循环即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPredecessor</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s1, <span class=\"built_in\">string</span> &amp;s2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// check s2 is s1&#x27;s predecessor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1.size() != s2.size() + <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = s2.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i &lt; len  &amp;&amp; s1[i] == s2[i]; i++)</span><br><span class=\"line\">        <span class=\"comment\">/* pass */</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i &lt; len &amp;&amp; s1[i+<span class=\"number\">1</span>] == s2[i]; i++)</span><br><span class=\"line\">        <span class=\"comment\">/* pass */</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i == len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestStrChain</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// sort by size</span></span><br><span class=\"line\">    sort(words.begin(), words.end(), [](<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s1, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.size() &lt; s2.size();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(words.size(), <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(words[beg].size() + <span class=\"number\">1</span> &lt; words[i].size()) beg++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = beg; j &lt; i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isPredecessor(words[i], words[j])) dp[i] = max(dp[i], dp[j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        res = max(dp[i], res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Longest SubString with At Least K Repeating Characters","date":"2017-10-05T05:22:54.000Z","_content":"\n打卡，第12天\n\n今天刷的题目是[Longest Substring with At Least K Repeating Characters](https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/):\n\n> Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\n>\n>Input:\n> s = \"aaabb\", k = 3\n>\n> Output:\n> 3\n>\n> The longest substring is \"aaa\", as 'a' is repeated 3 times.\n>\n>Input:\n> s = \"ababbc\", k = 2\n>\n> Output:\n> 5\n>\n> The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n\n本来是以为像[Longest Substring Without Repeating Characters](https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/)一样用两个下标去遍历，然后动态规划的去做（问题来了？动态规划是什么。。。我竟然还没有去翻，拖延症又犯了），一开始发现我可能需要在遍历前先知道当前字符是否会出现k次啊，恩，那就先用一个`unordered_map`去遍历一遍字符串来记录出现的次数吧：\n\n```c++\nunordered_map<char,int> count;\nfor(auto c:s)\n    ++count[c];\n```\n\n然后就开始思考什么时候`i`应该向前移动了，当`s[j]`出现的次数小于k时,`i`就应该变成`j+1`了，恩，这个时候我就应该计算`s[i,j]`的长度,显然不能直接是`j-i`来算长度啦，因为在以下情况时，它就失灵了：\n\n> Input: s = \"ababacb\" k = 3\n\n如果直接`j-i`的话，就会得出5，但是显然在这个子串中，`b`只出现了两次，所以我们还要回去检查一遍，然后就开始想要怎么计算长度，大概需要一个下标`t`从`i`一直往`j`移动，遍移动遍计算，那么问题来了，我怎么知道什么时候`t`应该往前走，什么时候应该计算，恩，干脆先遍历一遍计算一下出现次数，然后我才能知道什么计算。。。突然发现有点不对，我好像写的代码是重复的，恩，按照这个逻辑一直走下去，好像我会一直递归这个过程，想了想就写成递归的形式吧，看起来好像就莫名其妙的写出了一个用分治法的解法了：\n\n- 先遍历一遍计算整个串中出现的次数\n- 然后开始从头遍历，找出一个`t`使得`count[ s[t] ] < k`\n- 找到了，我们就分别计算`s[i:t]`和s[`t+1:j]`的最大长度即可\n- 没找到，那么说明整个串是符合的，我们直接返回串长度即可\n- 递归结束的条件就是当串长度比k小的时候啦。\n\n```c++\nstring s;   //为了减少递归传递而设置的全局变量\nint t;\n\nint longestSubstring(string ss, int tt) {\n    if (tt <= 1) return ss.size();\n    s = ss;\n    t = tt;\n    unordered_map<char,int> count;\n    for(auto c:s)\n        ++count[c];\n    return longestSubString(0,s.size(),count);\n}\n\nint longestSubString(int beg,int end,unordered_map<char,int> &imap ){\n    if (end - beg < t) return 0;\n    int j;\n    for(j = beg;j < end && imap[s[j]] >= t;j++)\n        /*do nothing*/;\n    if (j == end) return end - beg;\n    unordered_map<char,int> right;\n    for(int k = beg;k < j;k++){\n        --imap[ s[k] ];//重复利用imap，减少空间复杂度\n        ++right[ s[k] ];\n    }\n    return max(longestSubString(beg,j,right),\n                longestSubString(j+1,end,imap));\n}\n```\n\n有一点要注意的就是：如果是使用`map`而不是`unordered_map`的话，时间是会超限的。\n\n然后是在`dicuss`中看到的解法：\n\n下面这个的解法和我的类似，他的会比较简洁，不过应该没我的快，因为他每次都需要递归都是直接传递string的，而且调用`s.substr`其实挺耗费时间的，应该每次都是深拷贝。\n\n```c++\nint longestSubstring(string s, int k) {\n        if(s.size() == 0 || k > s.size())   return 0;\n        if(k == 0)  return s.size();\n        unordered_map<char,int> Map;\n        for(int i = 0; i < s.size(); i++){\n            Map[s[i]]++;\n        }\n        int idx =0;\n        while(idx <s.size() && Map[s[idx]] >= k)    idx++;\n        if(idx == s.size()) return s.size();\n        int left = longestSubstring(s.substr(0 , idx) , k);\n        int right = longestSubstring(s.substr(idx+1) , k);\n        return max(left, right);\n    }\n```\n\n第二个是用迭代的方法做的，比较快点，但是好像最坏情况是会出现`O(n^2)`的时间复杂度：\n\n```c++\nint longestSubstring(string s, int k) {\n   int max_len = 0;\n   for (int first = 0; first+k <= s.size();) {\n       int count[26] = {0};\n       int mask = 0;\n       int max_last = first;\n       for (int last = first; last < s.size(); ++last) {\n           int i = s[last] - 'a';\n           count[i]++;\n           if (count[i]<k) mask |= (1 << i);\n           else   mask &= (~(1 << i));\n           \n           if (mask == 0) {\n               max_len = max(max_len, last-first+1);\n               max_last = last;\n           }\n       }\n       first = max_last + 1;\n   }\n   return max_len;\n}\n```\n","source":"_posts/Longest-SubString-with-At-Least-K-Repeating-Characters.md","raw":"---\ntitle: Longest SubString with At Least K Repeating Characters\ndate: 2017-10-05T13:22:54.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 串\n---\n\n打卡，第12天\n\n今天刷的题目是[Longest Substring with At Least K Repeating Characters](https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/):\n\n> Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\n>\n>Input:\n> s = \"aaabb\", k = 3\n>\n> Output:\n> 3\n>\n> The longest substring is \"aaa\", as 'a' is repeated 3 times.\n>\n>Input:\n> s = \"ababbc\", k = 2\n>\n> Output:\n> 5\n>\n> The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n\n本来是以为像[Longest Substring Without Repeating Characters](https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/)一样用两个下标去遍历，然后动态规划的去做（问题来了？动态规划是什么。。。我竟然还没有去翻，拖延症又犯了），一开始发现我可能需要在遍历前先知道当前字符是否会出现k次啊，恩，那就先用一个`unordered_map`去遍历一遍字符串来记录出现的次数吧：\n\n```c++\nunordered_map<char,int> count;\nfor(auto c:s)\n    ++count[c];\n```\n\n然后就开始思考什么时候`i`应该向前移动了，当`s[j]`出现的次数小于k时,`i`就应该变成`j+1`了，恩，这个时候我就应该计算`s[i,j]`的长度,显然不能直接是`j-i`来算长度啦，因为在以下情况时，它就失灵了：\n\n> Input: s = \"ababacb\" k = 3\n\n如果直接`j-i`的话，就会得出5，但是显然在这个子串中，`b`只出现了两次，所以我们还要回去检查一遍，然后就开始想要怎么计算长度，大概需要一个下标`t`从`i`一直往`j`移动，遍移动遍计算，那么问题来了，我怎么知道什么时候`t`应该往前走，什么时候应该计算，恩，干脆先遍历一遍计算一下出现次数，然后我才能知道什么计算。。。突然发现有点不对，我好像写的代码是重复的，恩，按照这个逻辑一直走下去，好像我会一直递归这个过程，想了想就写成递归的形式吧，看起来好像就莫名其妙的写出了一个用分治法的解法了：\n\n- 先遍历一遍计算整个串中出现的次数\n- 然后开始从头遍历，找出一个`t`使得`count[ s[t] ] < k`\n- 找到了，我们就分别计算`s[i:t]`和s[`t+1:j]`的最大长度即可\n- 没找到，那么说明整个串是符合的，我们直接返回串长度即可\n- 递归结束的条件就是当串长度比k小的时候啦。\n\n```c++\nstring s;   //为了减少递归传递而设置的全局变量\nint t;\n\nint longestSubstring(string ss, int tt) {\n    if (tt <= 1) return ss.size();\n    s = ss;\n    t = tt;\n    unordered_map<char,int> count;\n    for(auto c:s)\n        ++count[c];\n    return longestSubString(0,s.size(),count);\n}\n\nint longestSubString(int beg,int end,unordered_map<char,int> &imap ){\n    if (end - beg < t) return 0;\n    int j;\n    for(j = beg;j < end && imap[s[j]] >= t;j++)\n        /*do nothing*/;\n    if (j == end) return end - beg;\n    unordered_map<char,int> right;\n    for(int k = beg;k < j;k++){\n        --imap[ s[k] ];//重复利用imap，减少空间复杂度\n        ++right[ s[k] ];\n    }\n    return max(longestSubString(beg,j,right),\n                longestSubString(j+1,end,imap));\n}\n```\n\n有一点要注意的就是：如果是使用`map`而不是`unordered_map`的话，时间是会超限的。\n\n然后是在`dicuss`中看到的解法：\n\n下面这个的解法和我的类似，他的会比较简洁，不过应该没我的快，因为他每次都需要递归都是直接传递string的，而且调用`s.substr`其实挺耗费时间的，应该每次都是深拷贝。\n\n```c++\nint longestSubstring(string s, int k) {\n        if(s.size() == 0 || k > s.size())   return 0;\n        if(k == 0)  return s.size();\n        unordered_map<char,int> Map;\n        for(int i = 0; i < s.size(); i++){\n            Map[s[i]]++;\n        }\n        int idx =0;\n        while(idx <s.size() && Map[s[idx]] >= k)    idx++;\n        if(idx == s.size()) return s.size();\n        int left = longestSubstring(s.substr(0 , idx) , k);\n        int right = longestSubstring(s.substr(idx+1) , k);\n        return max(left, right);\n    }\n```\n\n第二个是用迭代的方法做的，比较快点，但是好像最坏情况是会出现`O(n^2)`的时间复杂度：\n\n```c++\nint longestSubstring(string s, int k) {\n   int max_len = 0;\n   for (int first = 0; first+k <= s.size();) {\n       int count[26] = {0};\n       int mask = 0;\n       int max_last = first;\n       for (int last = first; last < s.size(); ++last) {\n           int i = s[last] - 'a';\n           count[i]++;\n           if (count[i]<k) mask |= (1 << i);\n           else   mask &= (~(1 << i));\n           \n           if (mask == 0) {\n               max_len = max(max_len, last-first+1);\n               max_last = last;\n           }\n       }\n       first = max_last + 1;\n   }\n   return max_len;\n}\n```\n","slug":"Longest-SubString-with-At-Least-K-Repeating-Characters","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oj008aqmcm7j0bahx6","content":"<p>打卡，第12天</p>\n<p>今天刷的题目是<a href=\"https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/\">Longest Substring with At Least K Repeating Characters</a>:</p>\n<blockquote>\n<p>Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.</p>\n<p>Input:<br>s = “aaabb”, k = 3</p>\n<p>Output:<br>3</p>\n<p>The longest substring is “aaa”, as ‘a’ is repeated 3 times.</p>\n<p>Input:<br>s = “ababbc”, k = 2</p>\n<p>Output:<br>5</p>\n<p>The longest substring is “ababb”, as ‘a’ is repeated 2 times and ‘b’ is repeated 3 times.</p>\n</blockquote>\n<p>本来是以为像<a href=\"https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/\">Longest Substring Without Repeating Characters</a>一样用两个下标去遍历，然后动态规划的去做（问题来了？动态规划是什么。。。我竟然还没有去翻，拖延症又犯了），一开始发现我可能需要在遍历前先知道当前字符是否会出现k次啊，恩，那就先用一个<code>unordered_map</code>去遍历一遍字符串来记录出现的次数吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; count;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:s)</span><br><span class=\"line\">    ++count[c];</span><br></pre></td></tr></table></figure>\n\n<p>然后就开始思考什么时候<code>i</code>应该向前移动了，当<code>s[j]</code>出现的次数小于k时,<code>i</code>就应该变成<code>j+1</code>了，恩，这个时候我就应该计算<code>s[i,j]</code>的长度,显然不能直接是<code>j-i</code>来算长度啦，因为在以下情况时，它就失灵了：</p>\n<blockquote>\n<p>Input: s = “ababacb” k = 3</p>\n</blockquote>\n<p>如果直接<code>j-i</code>的话，就会得出5，但是显然在这个子串中，<code>b</code>只出现了两次，所以我们还要回去检查一遍，然后就开始想要怎么计算长度，大概需要一个下标<code>t</code>从<code>i</code>一直往<code>j</code>移动，遍移动遍计算，那么问题来了，我怎么知道什么时候<code>t</code>应该往前走，什么时候应该计算，恩，干脆先遍历一遍计算一下出现次数，然后我才能知道什么计算。。。突然发现有点不对，我好像写的代码是重复的，恩，按照这个逻辑一直走下去，好像我会一直递归这个过程，想了想就写成递归的形式吧，看起来好像就莫名其妙的写出了一个用分治法的解法了：</p>\n<ul>\n<li>先遍历一遍计算整个串中出现的次数</li>\n<li>然后开始从头遍历，找出一个<code>t</code>使得<code>count[ s[t] ] &lt; k</code></li>\n<li>找到了，我们就分别计算<code>s[i:t]</code>和s[<code>t+1:j]</code>的最大长度即可</li>\n<li>没找到，那么说明整个串是符合的，我们直接返回串长度即可</li>\n<li>递归结束的条件就是当串长度比k小的时候啦。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> s;   <span class=\"comment\">//为了减少递归传递而设置的全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> ss, <span class=\"keyword\">int</span> tt)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tt &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ss.size();</span><br><span class=\"line\">    s = ss;</span><br><span class=\"line\">    t = tt;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:s)</span><br><span class=\"line\">        ++count[c];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> longestSubString(<span class=\"number\">0</span>,s.size(),count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestSubString</span><span class=\"params\">(<span class=\"keyword\">int</span> beg,<span class=\"keyword\">int</span> end,<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; &amp;imap )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end - beg &lt; t) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = beg;j &lt; end &amp;&amp; imap[s[j]] &gt;= t;j++)</span><br><span class=\"line\">        <span class=\"comment\">/*do nothing*/</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == end) <span class=\"keyword\">return</span> end - beg;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; right;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = beg;k &lt; j;k++)&#123;</span><br><span class=\"line\">        --imap[ s[k] ];<span class=\"comment\">//重复利用imap，减少空间复杂度</span></span><br><span class=\"line\">        ++right[ s[k] ];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(longestSubString(beg,j,right),</span><br><span class=\"line\">                longestSubString(j+<span class=\"number\">1</span>,end,imap));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有一点要注意的就是：如果是使用<code>map</code>而不是<code>unordered_map</code>的话，时间是会超限的。</p>\n<p>然后是在<code>dicuss</code>中看到的解法：</p>\n<p>下面这个的解法和我的类似，他的会比较简洁，不过应该没我的快，因为他每次都需要递归都是直接传递string的，而且调用<code>s.substr</code>其实挺耗费时间的，应该每次都是深拷贝。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.size() == <span class=\"number\">0</span> || k &gt; s.size())   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == <span class=\"number\">0</span>)  <span class=\"keyword\">return</span> s.size();</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; Map;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class=\"line\">            Map[s[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> idx =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(idx &lt;s.size() &amp;&amp; Map[s[idx]] &gt;= k)    idx++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx == s.size()) <span class=\"keyword\">return</span> s.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = longestSubstring(s.substr(<span class=\"number\">0</span> , idx) , k);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = longestSubstring(s.substr(idx+<span class=\"number\">1</span>) , k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left, right);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二个是用迭代的方法做的，比较快点，但是好像最坏情况是会出现<code>O(n^2)</code>的时间复杂度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> max_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> first = <span class=\"number\">0</span>; first+k &lt;= s.size();) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> count[<span class=\"number\">26</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> mask = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> max_last = first;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> last = first; last &lt; s.size(); ++last) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> i = s[last] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">           count[i]++;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (count[i]&lt;k) mask |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">           <span class=\"keyword\">else</span>   mask &amp;= (~(<span class=\"number\">1</span> &lt;&lt; i));</span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"keyword\">if</span> (mask == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               max_len = max(max_len, last-first+<span class=\"number\">1</span>);</span><br><span class=\"line\">               max_last = last;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       first = max_last + <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> max_len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第12天</p>\n<p>今天刷的题目是<a href=\"https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/\">Longest Substring with At Least K Repeating Characters</a>:</p>\n<blockquote>\n<p>Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.</p>\n<p>Input:<br>s = “aaabb”, k = 3</p>\n<p>Output:<br>3</p>\n<p>The longest substring is “aaa”, as ‘a’ is repeated 3 times.</p>\n<p>Input:<br>s = “ababbc”, k = 2</p>\n<p>Output:<br>5</p>\n<p>The longest substring is “ababb”, as ‘a’ is repeated 2 times and ‘b’ is repeated 3 times.</p>\n</blockquote>\n<p>本来是以为像<a href=\"https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/\">Longest Substring Without Repeating Characters</a>一样用两个下标去遍历，然后动态规划的去做（问题来了？动态规划是什么。。。我竟然还没有去翻，拖延症又犯了），一开始发现我可能需要在遍历前先知道当前字符是否会出现k次啊，恩，那就先用一个<code>unordered_map</code>去遍历一遍字符串来记录出现的次数吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; count;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:s)</span><br><span class=\"line\">    ++count[c];</span><br></pre></td></tr></table></figure>\n\n<p>然后就开始思考什么时候<code>i</code>应该向前移动了，当<code>s[j]</code>出现的次数小于k时,<code>i</code>就应该变成<code>j+1</code>了，恩，这个时候我就应该计算<code>s[i,j]</code>的长度,显然不能直接是<code>j-i</code>来算长度啦，因为在以下情况时，它就失灵了：</p>\n<blockquote>\n<p>Input: s = “ababacb” k = 3</p>\n</blockquote>\n<p>如果直接<code>j-i</code>的话，就会得出5，但是显然在这个子串中，<code>b</code>只出现了两次，所以我们还要回去检查一遍，然后就开始想要怎么计算长度，大概需要一个下标<code>t</code>从<code>i</code>一直往<code>j</code>移动，遍移动遍计算，那么问题来了，我怎么知道什么时候<code>t</code>应该往前走，什么时候应该计算，恩，干脆先遍历一遍计算一下出现次数，然后我才能知道什么计算。。。突然发现有点不对，我好像写的代码是重复的，恩，按照这个逻辑一直走下去，好像我会一直递归这个过程，想了想就写成递归的形式吧，看起来好像就莫名其妙的写出了一个用分治法的解法了：</p>\n<ul>\n<li>先遍历一遍计算整个串中出现的次数</li>\n<li>然后开始从头遍历，找出一个<code>t</code>使得<code>count[ s[t] ] &lt; k</code></li>\n<li>找到了，我们就分别计算<code>s[i:t]</code>和s[<code>t+1:j]</code>的最大长度即可</li>\n<li>没找到，那么说明整个串是符合的，我们直接返回串长度即可</li>\n<li>递归结束的条件就是当串长度比k小的时候啦。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> s;   <span class=\"comment\">//为了减少递归传递而设置的全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> ss, <span class=\"keyword\">int</span> tt)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tt &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ss.size();</span><br><span class=\"line\">    s = ss;</span><br><span class=\"line\">    t = tt;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:s)</span><br><span class=\"line\">        ++count[c];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> longestSubString(<span class=\"number\">0</span>,s.size(),count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestSubString</span><span class=\"params\">(<span class=\"keyword\">int</span> beg,<span class=\"keyword\">int</span> end,<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; &amp;imap )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end - beg &lt; t) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = beg;j &lt; end &amp;&amp; imap[s[j]] &gt;= t;j++)</span><br><span class=\"line\">        <span class=\"comment\">/*do nothing*/</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == end) <span class=\"keyword\">return</span> end - beg;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; right;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = beg;k &lt; j;k++)&#123;</span><br><span class=\"line\">        --imap[ s[k] ];<span class=\"comment\">//重复利用imap，减少空间复杂度</span></span><br><span class=\"line\">        ++right[ s[k] ];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(longestSubString(beg,j,right),</span><br><span class=\"line\">                longestSubString(j+<span class=\"number\">1</span>,end,imap));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有一点要注意的就是：如果是使用<code>map</code>而不是<code>unordered_map</code>的话，时间是会超限的。</p>\n<p>然后是在<code>dicuss</code>中看到的解法：</p>\n<p>下面这个的解法和我的类似，他的会比较简洁，不过应该没我的快，因为他每次都需要递归都是直接传递string的，而且调用<code>s.substr</code>其实挺耗费时间的，应该每次都是深拷贝。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.size() == <span class=\"number\">0</span> || k &gt; s.size())   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == <span class=\"number\">0</span>)  <span class=\"keyword\">return</span> s.size();</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; Map;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class=\"line\">            Map[s[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> idx =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(idx &lt;s.size() &amp;&amp; Map[s[idx]] &gt;= k)    idx++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx == s.size()) <span class=\"keyword\">return</span> s.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = longestSubstring(s.substr(<span class=\"number\">0</span> , idx) , k);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = longestSubstring(s.substr(idx+<span class=\"number\">1</span>) , k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left, right);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二个是用迭代的方法做的，比较快点，但是好像最坏情况是会出现<code>O(n^2)</code>的时间复杂度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> max_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> first = <span class=\"number\">0</span>; first+k &lt;= s.size();) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> count[<span class=\"number\">26</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> mask = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> max_last = first;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> last = first; last &lt; s.size(); ++last) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> i = s[last] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">           count[i]++;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (count[i]&lt;k) mask |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">           <span class=\"keyword\">else</span>   mask &amp;= (~(<span class=\"number\">1</span> &lt;&lt; i));</span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"keyword\">if</span> (mask == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               max_len = max(max_len, last-first+<span class=\"number\">1</span>);</span><br><span class=\"line\">               max_last = last;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       first = max_last + <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> max_len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Longest Word in Dictionary through Deleting","date":"2019-12-07T01:10:19.000Z","_content":"\n> 第31天。\n\n今天的题目是[Longest Word in Dictionary through Deleting](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/):\n\n很常规的题目。\n\n因为题目要求返回的是最长的字符串，同时如果有多个解的话，就返回字典序最小的那个，所以我们先按要求进行一次排序。然后在 check 一下是否符合即可。代码如下：\n\n```c++\nbool check(const string &s, const string &t) {\n    int index = 0, i;\n    \n    for(i = 0; i < t.size(); ++i) {\n        while(index < s.size() && s[index] != t[i]) index++;\n        if (index == s.size()) break;\n        else index++;\n    }\n    \n    return i == t.size();\n}\nstring findLongestWord(string s, vector<string>& d) {\n    sort(d.begin(), d.end(),[](const string &s1, const string &s2) {\n        if (s1.size() != s2.size()) return s1.size() > s2.size();\n        else return s1 < s2;\n    });\n    \n    for(int i = 0;i < d.size(); i++) {\n        if (check(s, d[i])) return d[i];\n    }\n    return \"\";\n}\n```\n","source":"_posts/Longest-Word-in-Dictionary-through-Deleting.md","raw":"---\ntitle: Longest Word in Dictionary through Deleting\ndate: 2019-12-07T09:10:19.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第31天。\n\n今天的题目是[Longest Word in Dictionary through Deleting](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/):\n\n很常规的题目。\n\n因为题目要求返回的是最长的字符串，同时如果有多个解的话，就返回字典序最小的那个，所以我们先按要求进行一次排序。然后在 check 一下是否符合即可。代码如下：\n\n```c++\nbool check(const string &s, const string &t) {\n    int index = 0, i;\n    \n    for(i = 0; i < t.size(); ++i) {\n        while(index < s.size() && s[index] != t[i]) index++;\n        if (index == s.size()) break;\n        else index++;\n    }\n    \n    return i == t.size();\n}\nstring findLongestWord(string s, vector<string>& d) {\n    sort(d.begin(), d.end(),[](const string &s1, const string &s2) {\n        if (s1.size() != s2.size()) return s1.size() > s2.size();\n        else return s1 < s2;\n    });\n    \n    for(int i = 0;i < d.size(); i++) {\n        if (check(s, d[i])) return d[i];\n    }\n    return \"\";\n}\n```\n","slug":"Longest-Word-in-Dictionary-through-Deleting","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ok008dqmcmb0ns7058","content":"<blockquote>\n<p>第31天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/\">Longest Word in Dictionary through Deleting</a>:</p>\n<p>很常规的题目。</p>\n<p>因为题目要求返回的是最长的字符串，同时如果有多个解的话，就返回字典序最小的那个，所以我们先按要求进行一次排序。然后在 check 一下是否符合即可。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>, i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; t.size(); ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index &lt; s.size() &amp;&amp; s[index] != t[i]) index++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == s.size()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> i == t.size();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">findLongestWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class=\"line\">    sort(d.begin(), d.end(),[](<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s1, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.size() != s2.size()) <span class=\"keyword\">return</span> s1.size() &gt; s2.size();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> s1 &lt; s2;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; d.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (check(s, d[i])) <span class=\"keyword\">return</span> d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第31天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/\">Longest Word in Dictionary through Deleting</a>:</p>\n<p>很常规的题目。</p>\n<p>因为题目要求返回的是最长的字符串，同时如果有多个解的话，就返回字典序最小的那个，所以我们先按要求进行一次排序。然后在 check 一下是否符合即可。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>, i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; t.size(); ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index &lt; s.size() &amp;&amp; s[index] != t[i]) index++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == s.size()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> i == t.size();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">findLongestWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class=\"line\">    sort(d.begin(), d.end(),[](<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s1, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.size() != s2.size()) <span class=\"keyword\">return</span> s1.size() &gt; s2.size();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> s1 &lt; s2;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; d.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (check(s, d[i])) <span class=\"keyword\">return</span> d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Longest Common Prefix","date":"2017-09-25T01:59:00.000Z","_content":"\n\n恩，今天早上1,2节没课，闲来无事就先把今天的题刷了（你的算法分析实验呢？）今天的题目是[Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/description/),恩，比那个什么最长公共子串简单多了，很容易就可以找到思路（虽然写出来的代码很难看）\n\n大概的解题思路是：\n\n- 先找出最短的字符串，假定他就是我们要的答案\n- 遍历所有字符串，看他们是否有这个字符串\n\t- 如果有就直接返回\n\t- 如果没有就把子串长度减小，再进行重复操作\n\n思路很简单，但我写的很渣（直接过，我也是很懵，我还想再敲多一下的）\n\n先上我的代码吧：\n\n\n```c++\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty()) return \"\";\n    else if (strs.size() == 1) return strs[0];\n    string ret =  strs[0];\n    for(auto &s:strs) {\n        if (ret.size() > s.size())\n            ret = s;\n    }\n    while(ret.size() > 0) {\n        bool is = true;\n        for(auto &s:strs){\n            if (s.substr(0,ret.size()) != ret) {\n                is = false;\n                break;\n            }\n        }\n        if (!is) ret = ret.substr(0,ret.size() - 1);\n        else return ret;\n    }\n    return \"\";\n    \n}\n``` \n\n恩，我是没想到它会直接过的，思路相当简单，当然思路简单一般效率就不会很高。\n\n我的思路一开始是假定最短的串是我们要的结果，而在`dicuss`中别人的写法是另一种思路：\n\n```c++\nstring longestCommonPrefix(vector<string>& strs) {\n   string prefix = \"\";\n    for(int idx=0; strs.size()>0; prefix+=strs[0][idx], idx++)\n        for(int i=0; i<strs.size(); i++)\n            if(idx >= strs[i].size() ||(i > 0 && strs[i][idx] != strs[i-1][idx]))\n                return prefix;\n    return prefix;\n}\n```\n\n比我的代码简洁很多，他是先假定最长前缀是空，然后在用动态规划的思路去做的（恩，要好好研究一下动态规划），而且他这种写法就不需要判断传入的`vector`是不是空了。\n","source":"_posts/LongestCommonPrefix.md","raw":"---\ntitle: Longest Common Prefix\ndate: 2017-09-25T09:59:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 串\n---\n\n\n恩，今天早上1,2节没课，闲来无事就先把今天的题刷了（你的算法分析实验呢？）今天的题目是[Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/description/),恩，比那个什么最长公共子串简单多了，很容易就可以找到思路（虽然写出来的代码很难看）\n\n大概的解题思路是：\n\n- 先找出最短的字符串，假定他就是我们要的答案\n- 遍历所有字符串，看他们是否有这个字符串\n\t- 如果有就直接返回\n\t- 如果没有就把子串长度减小，再进行重复操作\n\n思路很简单，但我写的很渣（直接过，我也是很懵，我还想再敲多一下的）\n\n先上我的代码吧：\n\n\n```c++\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty()) return \"\";\n    else if (strs.size() == 1) return strs[0];\n    string ret =  strs[0];\n    for(auto &s:strs) {\n        if (ret.size() > s.size())\n            ret = s;\n    }\n    while(ret.size() > 0) {\n        bool is = true;\n        for(auto &s:strs){\n            if (s.substr(0,ret.size()) != ret) {\n                is = false;\n                break;\n            }\n        }\n        if (!is) ret = ret.substr(0,ret.size() - 1);\n        else return ret;\n    }\n    return \"\";\n    \n}\n``` \n\n恩，我是没想到它会直接过的，思路相当简单，当然思路简单一般效率就不会很高。\n\n我的思路一开始是假定最短的串是我们要的结果，而在`dicuss`中别人的写法是另一种思路：\n\n```c++\nstring longestCommonPrefix(vector<string>& strs) {\n   string prefix = \"\";\n    for(int idx=0; strs.size()>0; prefix+=strs[0][idx], idx++)\n        for(int i=0; i<strs.size(); i++)\n            if(idx >= strs[i].size() ||(i > 0 && strs[i][idx] != strs[i-1][idx]))\n                return prefix;\n    return prefix;\n}\n```\n\n比我的代码简洁很多，他是先假定最长前缀是空，然后在用动态规划的思路去做的（恩，要好好研究一下动态规划），而且他这种写法就不需要判断传入的`vector`是不是空了。\n","slug":"LongestCommonPrefix","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ol008gqmcm2rts6hdm","content":"<p>恩，今天早上1,2节没课，闲来无事就先把今天的题刷了（你的算法分析实验呢？）今天的题目是<a href=\"https://leetcode.com/problems/longest-common-prefix/description/\">Longest Common Prefix</a>,恩，比那个什么最长公共子串简单多了，很容易就可以找到思路（虽然写出来的代码很难看）</p>\n<p>大概的解题思路是：</p>\n<ul>\n<li>先找出最短的字符串，假定他就是我们要的答案</li>\n<li>遍历所有字符串，看他们是否有这个字符串<ul>\n<li>如果有就直接返回</li>\n<li>如果没有就把子串长度减小，再进行重复操作</li>\n</ul>\n</li>\n</ul>\n<p>思路很简单，但我写的很渣（直接过，我也是很懵，我还想再敲多一下的）</p>\n<p>先上我的代码吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (strs.empty()) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strs.size() == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">string</span> ret =  strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s:strs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret.size() &gt; s.size())</span><br><span class=\"line\">            ret = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ret.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> is = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s:strs)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.substr(<span class=\"number\">0</span>,ret.size()) != ret) &#123;</span><br><span class=\"line\">                is = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!is) ret = ret.substr(<span class=\"number\">0</span>,ret.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，我是没想到它会直接过的，思路相当简单，当然思路简单一般效率就不会很高。</p>\n<p>我的思路一开始是假定最短的串是我们要的结果，而在<code>dicuss</code>中别人的写法是另一种思路：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">string</span> prefix = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> idx=<span class=\"number\">0</span>; strs.size()&gt;<span class=\"number\">0</span>; prefix+=strs[<span class=\"number\">0</span>][idx], idx++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;strs.size(); i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(idx &gt;= strs[i].size() ||(i &gt; <span class=\"number\">0</span> &amp;&amp; strs[i][idx] != strs[i<span class=\"number\">-1</span>][idx]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> prefix;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prefix;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比我的代码简洁很多，他是先假定最长前缀是空，然后在用动态规划的思路去做的（恩，要好好研究一下动态规划），而且他这种写法就不需要判断传入的<code>vector</code>是不是空了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>恩，今天早上1,2节没课，闲来无事就先把今天的题刷了（你的算法分析实验呢？）今天的题目是<a href=\"https://leetcode.com/problems/longest-common-prefix/description/\">Longest Common Prefix</a>,恩，比那个什么最长公共子串简单多了，很容易就可以找到思路（虽然写出来的代码很难看）</p>\n<p>大概的解题思路是：</p>\n<ul>\n<li>先找出最短的字符串，假定他就是我们要的答案</li>\n<li>遍历所有字符串，看他们是否有这个字符串<ul>\n<li>如果有就直接返回</li>\n<li>如果没有就把子串长度减小，再进行重复操作</li>\n</ul>\n</li>\n</ul>\n<p>思路很简单，但我写的很渣（直接过，我也是很懵，我还想再敲多一下的）</p>\n<p>先上我的代码吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (strs.empty()) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strs.size() == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">string</span> ret =  strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s:strs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret.size() &gt; s.size())</span><br><span class=\"line\">            ret = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ret.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> is = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s:strs)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.substr(<span class=\"number\">0</span>,ret.size()) != ret) &#123;</span><br><span class=\"line\">                is = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!is) ret = ret.substr(<span class=\"number\">0</span>,ret.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，我是没想到它会直接过的，思路相当简单，当然思路简单一般效率就不会很高。</p>\n<p>我的思路一开始是假定最短的串是我们要的结果，而在<code>dicuss</code>中别人的写法是另一种思路：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">string</span> prefix = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> idx=<span class=\"number\">0</span>; strs.size()&gt;<span class=\"number\">0</span>; prefix+=strs[<span class=\"number\">0</span>][idx], idx++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;strs.size(); i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(idx &gt;= strs[i].size() ||(i &gt; <span class=\"number\">0</span> &amp;&amp; strs[i][idx] != strs[i<span class=\"number\">-1</span>][idx]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> prefix;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prefix;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比我的代码简洁很多，他是先假定最长前缀是空，然后在用动态规划的思路去做的（恩，要好好研究一下动态规划），而且他这种写法就不需要判断传入的<code>vector</code>是不是空了。</p>\n"},{"title":"LongestPalindromicSubString","date":"2017-10-03T03:14:39.000Z","_content":"\n打卡，第10天\n\n今天刷的题是[Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/),开始想着用动态规划做，但是我好像连动态规划是什么我都不知道。。。\n\n题目:\n\n> Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n>\n> Example:\n>\n> Input: \"babad\"\n>\n> Output: \"bab\"\n>\n> Note: \"aba\" is also a valid answer.\n> Example:\n>\n> Input: \"cbbd\"\n>\n> Output: \"bb\"\n\n所以一如既往的想到了分治法:\n\n```c++\nbool isPalindrome(string &s,int first,int last){\n    while(first < last && s[first] == s[last]){\n        first++;\n        last--;\n    }\n    if (first >= last) return true;\n    else return false;\n}\nstring longestPalindrome(string s) {\n    int retF,retL;\n    int l = longestPalindrome(s,0,s.size() -1 ,retF);\n    return s.substr(retF,l);\n}\n\nint longestPalindrome(string &s,int first,int last,int &retF){\n    if (first < last){\n        int lF,rF,mF;\n        int mid = (first + last)/2;   //分\n        //治\n        int l = longestPalindrome(s,first,mid,lF);\n        int r = longestPalindrome(s,mid + 1,last,rF);\n        int ret = max(l,r);\n        //合，已知\n        int midMax = ret;\n        for(int i = first;i <=mid ;i++)\n            for(int j = mid + 1;j <= last;j++){\n                if (j-i +1 > midMax && isPalindrome(s,i,j)){\n                    midMax = j-i+1;\n                    mF = i;\n                }\n            }\n        if (midMax > ret){\n            retF = mF;\n            return midMax;\n        } else if (ret == l){\n            retF = lF;\n        } else{\n            retF = rF;\n        }\n        return ret;\n    } else if (first == last ) {\n        retF = first;\n        return 1;\n    } else {\n        retF = first;\n        return 0;\n    }\n}\n```\n\n大概的思路是：\n\n- 先用分治法将问题规模不断减半，那么现在只需要考虑如何“合”了\n- 这里\"合\"的时间复杂度是O(n^2)，没能找出更快的，嗯，不对，好像是O(n^3)....\n- whatever，这里的合就是用穷举法去做的，不过不知道为什么还是过了测试\n\n然后是`dicuss`中的解法：\n\n```c++\nstring longestPalindrome(string s) {\n    if (s.empty()) return \"\";\n    if (s.size() == 1) return s;\n    int min_start = 0, max_len = 1;\n    for (int i = 0; i < s.size();) {\n      if (s.size() - i <= max_len / 2) break;\n      int j = i, k = i;\n      while (k < s.size()-1 && s[k+1] == s[k]) ++k; // Skip duplicate characters.\n      i = k+1;\n      while (k < s.size()-1 && j > 0 && s[k + 1] == s[j - 1]) { ++k; --j; } // Expand.\n      int new_len = k - j + 1;\n      if (new_len > max_len) { min_start = j; max_len = new_len; }\n    }\n    return s.substr(min_start, max_len);\n}\n```\n\nemmm,这里好像也是用点穷举的感觉。\n","source":"_posts/LongestPalindromicSubString.md","raw":"---\ntitle: LongestPalindromicSubString\ndate: 2017-10-03T11:14:39.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 串\n  - 分治法\n---\n\n打卡，第10天\n\n今天刷的题是[Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/),开始想着用动态规划做，但是我好像连动态规划是什么我都不知道。。。\n\n题目:\n\n> Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n>\n> Example:\n>\n> Input: \"babad\"\n>\n> Output: \"bab\"\n>\n> Note: \"aba\" is also a valid answer.\n> Example:\n>\n> Input: \"cbbd\"\n>\n> Output: \"bb\"\n\n所以一如既往的想到了分治法:\n\n```c++\nbool isPalindrome(string &s,int first,int last){\n    while(first < last && s[first] == s[last]){\n        first++;\n        last--;\n    }\n    if (first >= last) return true;\n    else return false;\n}\nstring longestPalindrome(string s) {\n    int retF,retL;\n    int l = longestPalindrome(s,0,s.size() -1 ,retF);\n    return s.substr(retF,l);\n}\n\nint longestPalindrome(string &s,int first,int last,int &retF){\n    if (first < last){\n        int lF,rF,mF;\n        int mid = (first + last)/2;   //分\n        //治\n        int l = longestPalindrome(s,first,mid,lF);\n        int r = longestPalindrome(s,mid + 1,last,rF);\n        int ret = max(l,r);\n        //合，已知\n        int midMax = ret;\n        for(int i = first;i <=mid ;i++)\n            for(int j = mid + 1;j <= last;j++){\n                if (j-i +1 > midMax && isPalindrome(s,i,j)){\n                    midMax = j-i+1;\n                    mF = i;\n                }\n            }\n        if (midMax > ret){\n            retF = mF;\n            return midMax;\n        } else if (ret == l){\n            retF = lF;\n        } else{\n            retF = rF;\n        }\n        return ret;\n    } else if (first == last ) {\n        retF = first;\n        return 1;\n    } else {\n        retF = first;\n        return 0;\n    }\n}\n```\n\n大概的思路是：\n\n- 先用分治法将问题规模不断减半，那么现在只需要考虑如何“合”了\n- 这里\"合\"的时间复杂度是O(n^2)，没能找出更快的，嗯，不对，好像是O(n^3)....\n- whatever，这里的合就是用穷举法去做的，不过不知道为什么还是过了测试\n\n然后是`dicuss`中的解法：\n\n```c++\nstring longestPalindrome(string s) {\n    if (s.empty()) return \"\";\n    if (s.size() == 1) return s;\n    int min_start = 0, max_len = 1;\n    for (int i = 0; i < s.size();) {\n      if (s.size() - i <= max_len / 2) break;\n      int j = i, k = i;\n      while (k < s.size()-1 && s[k+1] == s[k]) ++k; // Skip duplicate characters.\n      i = k+1;\n      while (k < s.size()-1 && j > 0 && s[k + 1] == s[j - 1]) { ++k; --j; } // Expand.\n      int new_len = k - j + 1;\n      if (new_len > max_len) { min_start = j; max_len = new_len; }\n    }\n    return s.substr(min_start, max_len);\n}\n```\n\nemmm,这里好像也是用点穷举的感觉。\n","slug":"LongestPalindromicSubString","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ol008jqmcm35aqdcrs","content":"<p>打卡，第10天</p>\n<p>今天刷的题是<a href=\"https://leetcode.com/problems/longest-palindromic-substring/description/\">Longest Palindromic Substring</a>,开始想着用动态规划做，但是我好像连动态规划是什么我都不知道。。。</p>\n<p>题目:</p>\n<blockquote>\n<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>\n<p>Example:</p>\n<p>Input: “babad”</p>\n<p>Output: “bab”</p>\n<p>Note: “aba” is also a valid answer.<br>Example:</p>\n<p>Input: “cbbd”</p>\n<p>Output: “bb”</p>\n</blockquote>\n<p>所以一如既往的想到了分治法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt; last &amp;&amp; s[first] == s[last])&#123;</span><br><span class=\"line\">        first++;</span><br><span class=\"line\">        last--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &gt;= last) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> retF,retL;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = longestPalindrome(s,<span class=\"number\">0</span>,s.size() <span class=\"number\">-1</span> ,retF);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.substr(retF,l);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> &amp;retF)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &lt; last)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lF,rF,mF;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (first + last)/<span class=\"number\">2</span>;   <span class=\"comment\">//分</span></span><br><span class=\"line\">        <span class=\"comment\">//治</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = longestPalindrome(s,first,mid,lF);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = longestPalindrome(s,mid + <span class=\"number\">1</span>,last,rF);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = max(l,r);</span><br><span class=\"line\">        <span class=\"comment\">//合，已知</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> midMax = ret;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = first;i &lt;=mid ;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = mid + <span class=\"number\">1</span>;j &lt;= last;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j-i +<span class=\"number\">1</span> &gt; midMax &amp;&amp; isPalindrome(s,i,j))&#123;</span><br><span class=\"line\">                    midMax = j-i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    mF = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (midMax &gt; ret)&#123;</span><br><span class=\"line\">            retF = mF;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> midMax;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret == l)&#123;</span><br><span class=\"line\">            retF = lF;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            retF = rF;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (first == last ) &#123;</span><br><span class=\"line\">        retF = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        retF = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大概的思路是：</p>\n<ul>\n<li>先用分治法将问题规模不断减半，那么现在只需要考虑如何“合”了</li>\n<li>这里”合”的时间复杂度是O(n^2)，没能找出更快的，嗯，不对，好像是O(n^3)….</li>\n<li>whatever，这里的合就是用穷举法去做的，不过不知道为什么还是过了测试</li>\n</ul>\n<p>然后是<code>dicuss</code>中的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s.empty()) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s.size() == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_start = <span class=\"number\">0</span>, max_len = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size();) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (s.size() - i &lt;= max_len / <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> j = i, k = i;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (k &lt; s.size()<span class=\"number\">-1</span> &amp;&amp; s[k+<span class=\"number\">1</span>] == s[k]) ++k; <span class=\"comment\">// Skip duplicate characters.</span></span><br><span class=\"line\">      i = k+<span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (k &lt; s.size()<span class=\"number\">-1</span> &amp;&amp; j &gt; <span class=\"number\">0</span> &amp;&amp; s[k + <span class=\"number\">1</span>] == s[j - <span class=\"number\">1</span>]) &#123; ++k; --j; &#125; <span class=\"comment\">// Expand.</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> new_len = k - j + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_len &gt; max_len) &#123; min_start = j; max_len = new_len; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.substr(min_start, max_len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>emmm,这里好像也是用点穷举的感觉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第10天</p>\n<p>今天刷的题是<a href=\"https://leetcode.com/problems/longest-palindromic-substring/description/\">Longest Palindromic Substring</a>,开始想着用动态规划做，但是我好像连动态规划是什么我都不知道。。。</p>\n<p>题目:</p>\n<blockquote>\n<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>\n<p>Example:</p>\n<p>Input: “babad”</p>\n<p>Output: “bab”</p>\n<p>Note: “aba” is also a valid answer.<br>Example:</p>\n<p>Input: “cbbd”</p>\n<p>Output: “bb”</p>\n</blockquote>\n<p>所以一如既往的想到了分治法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt; last &amp;&amp; s[first] == s[last])&#123;</span><br><span class=\"line\">        first++;</span><br><span class=\"line\">        last--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &gt;= last) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> retF,retL;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = longestPalindrome(s,<span class=\"number\">0</span>,s.size() <span class=\"number\">-1</span> ,retF);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.substr(retF,l);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> &amp;retF)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &lt; last)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lF,rF,mF;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (first + last)/<span class=\"number\">2</span>;   <span class=\"comment\">//分</span></span><br><span class=\"line\">        <span class=\"comment\">//治</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = longestPalindrome(s,first,mid,lF);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = longestPalindrome(s,mid + <span class=\"number\">1</span>,last,rF);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = max(l,r);</span><br><span class=\"line\">        <span class=\"comment\">//合，已知</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> midMax = ret;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = first;i &lt;=mid ;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = mid + <span class=\"number\">1</span>;j &lt;= last;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j-i +<span class=\"number\">1</span> &gt; midMax &amp;&amp; isPalindrome(s,i,j))&#123;</span><br><span class=\"line\">                    midMax = j-i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    mF = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (midMax &gt; ret)&#123;</span><br><span class=\"line\">            retF = mF;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> midMax;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret == l)&#123;</span><br><span class=\"line\">            retF = lF;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            retF = rF;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (first == last ) &#123;</span><br><span class=\"line\">        retF = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        retF = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大概的思路是：</p>\n<ul>\n<li>先用分治法将问题规模不断减半，那么现在只需要考虑如何“合”了</li>\n<li>这里”合”的时间复杂度是O(n^2)，没能找出更快的，嗯，不对，好像是O(n^3)….</li>\n<li>whatever，这里的合就是用穷举法去做的，不过不知道为什么还是过了测试</li>\n</ul>\n<p>然后是<code>dicuss</code>中的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s.empty()) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s.size() == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_start = <span class=\"number\">0</span>, max_len = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size();) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (s.size() - i &lt;= max_len / <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> j = i, k = i;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (k &lt; s.size()<span class=\"number\">-1</span> &amp;&amp; s[k+<span class=\"number\">1</span>] == s[k]) ++k; <span class=\"comment\">// Skip duplicate characters.</span></span><br><span class=\"line\">      i = k+<span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (k &lt; s.size()<span class=\"number\">-1</span> &amp;&amp; j &gt; <span class=\"number\">0</span> &amp;&amp; s[k + <span class=\"number\">1</span>] == s[j - <span class=\"number\">1</span>]) &#123; ++k; --j; &#125; <span class=\"comment\">// Expand.</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> new_len = k - j + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_len &gt; max_len) &#123; min_start = j; max_len = new_len; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.substr(min_start, max_len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>emmm,这里好像也是用点穷举的感觉。</p>\n"},{"title":"Longest Substring Without Repeating Characters","date":"2017-10-01T05:20:00.000Z","_content":"\n#  Longest Substring Without Repeating Characters\n\n打卡，第8天\n\n今天国庆，然而不会家，找了一道之前不敢做的题目做了——[Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/),开始又是想着用分治法去完成（因为算法课在讲分治法），然而并没有做出来，又是同一个原因，在治的时候复杂度降不下来。\n\n题目描述：\n\n> Given a string, find the length of the longest substring without repeating characters.\n>\n> Examples:\n>\n> Given \"abcabcbb\", the answer is \"abc\", which the length is 3.\n>\n> Given \"bbbbb\", the answer is \"b\", with the length of 1.\n>\n> Given \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n先放code吧：\n\n```c++\nint lengthOfLongestSubstring(string s) {\n    int i = 0,j = 0;\n    int ret = 0;\n    map<char,bool> cbmap;\n    while( j < s.size() ){\n        while(j < s.size() && cbmap[s[j]] == false)\n            cbmap[ s[j++] ] = true;\n        ret = max(j-i,ret);\n        while(i < j && cbmap[s[j]] != false)\n            cbmap[ s[i++] ] = false;\n        cbmap[ s[j++] ] = true;\n    }\n    return ret;\n}\n```\n\n大概的思路是：\n\n- 用两个下标来标识`Substring`的位置，`s[i,j)`就是我们当前的`Substring`.\n- 用j去遍历整个串，如果当前子串中没有`s[j]`，`j`就继续往下遍历，如果有，这时就可以计算一下当前子串的长度和之前的最长子串长度进行对比。\n- 在`j`停止遍历后，我们就让`i`向前移动，直到，当前子串不包含`s[j]`,这样我们就可以把`s[j]`加入当前子串，并继续进行遍历。\n\n写着写着突然发现，有个地方可以改：\n\n```c++\nint lengthOfLongestSubstring(string s) {\n    int ret = 0;\n    map<char,bool> cbmap;\n    for(int i = 0,j = 0; j < s.size();j++ ){\n        while(j < s.size() && cbmap[s[j]] == false)\n            cbmap[ s[j++] ] = true;\n        ret = max(j-i,ret);\n        while(i < j && s[i++] != s[j])\n            cbmap[ s[i - 1] ] = false;\n    }\n    return ret;\n}\n```\n\n思路还是一样的，只不过写的更加精炼了罢了。\n\n然后看看`dicuss`中别人写的：\n\n```c++\nint lengthOfLongestSubstring(string s) {\n    // for ASCII char sequence, use this as a hashmap\n    vector<int> charIndex(256, -1);\n    int longest = 0, m = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        m = max(charIndex[s[i]] + 1, m);    // automatically takes care of -1 case\n        charIndex[s[i]] = i;\n        longest = max(longest, i - m + 1);\n    }\n\n    return longest;\n}\n\n```\n\n他这里用的是`vector<int>`去记录最大的下标，而我是用的是`map`去记录当前子串中是否有这个字符，用他这种方法可以把`i`向前移的循环给去掉。\n","source":"_posts/LongestSubstringWithoutRepeatingCharacters.md","raw":"---\ntitle: Longest Substring Without Repeating Characters\ndate: 2017-10-01T13:20:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 串\n---\n\n#  Longest Substring Without Repeating Characters\n\n打卡，第8天\n\n今天国庆，然而不会家，找了一道之前不敢做的题目做了——[Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/),开始又是想着用分治法去完成（因为算法课在讲分治法），然而并没有做出来，又是同一个原因，在治的时候复杂度降不下来。\n\n题目描述：\n\n> Given a string, find the length of the longest substring without repeating characters.\n>\n> Examples:\n>\n> Given \"abcabcbb\", the answer is \"abc\", which the length is 3.\n>\n> Given \"bbbbb\", the answer is \"b\", with the length of 1.\n>\n> Given \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n先放code吧：\n\n```c++\nint lengthOfLongestSubstring(string s) {\n    int i = 0,j = 0;\n    int ret = 0;\n    map<char,bool> cbmap;\n    while( j < s.size() ){\n        while(j < s.size() && cbmap[s[j]] == false)\n            cbmap[ s[j++] ] = true;\n        ret = max(j-i,ret);\n        while(i < j && cbmap[s[j]] != false)\n            cbmap[ s[i++] ] = false;\n        cbmap[ s[j++] ] = true;\n    }\n    return ret;\n}\n```\n\n大概的思路是：\n\n- 用两个下标来标识`Substring`的位置，`s[i,j)`就是我们当前的`Substring`.\n- 用j去遍历整个串，如果当前子串中没有`s[j]`，`j`就继续往下遍历，如果有，这时就可以计算一下当前子串的长度和之前的最长子串长度进行对比。\n- 在`j`停止遍历后，我们就让`i`向前移动，直到，当前子串不包含`s[j]`,这样我们就可以把`s[j]`加入当前子串，并继续进行遍历。\n\n写着写着突然发现，有个地方可以改：\n\n```c++\nint lengthOfLongestSubstring(string s) {\n    int ret = 0;\n    map<char,bool> cbmap;\n    for(int i = 0,j = 0; j < s.size();j++ ){\n        while(j < s.size() && cbmap[s[j]] == false)\n            cbmap[ s[j++] ] = true;\n        ret = max(j-i,ret);\n        while(i < j && s[i++] != s[j])\n            cbmap[ s[i - 1] ] = false;\n    }\n    return ret;\n}\n```\n\n思路还是一样的，只不过写的更加精炼了罢了。\n\n然后看看`dicuss`中别人写的：\n\n```c++\nint lengthOfLongestSubstring(string s) {\n    // for ASCII char sequence, use this as a hashmap\n    vector<int> charIndex(256, -1);\n    int longest = 0, m = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        m = max(charIndex[s[i]] + 1, m);    // automatically takes care of -1 case\n        charIndex[s[i]] = i;\n        longest = max(longest, i - m + 1);\n    }\n\n    return longest;\n}\n\n```\n\n他这里用的是`vector<int>`去记录最大的下标，而我是用的是`map`去记录当前子串中是否有这个字符，用他这种方法可以把`i`向前移的循环给去掉。\n","slug":"LongestSubstringWithoutRepeatingCharacters","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69om008mqmcm81ua313r","content":"<h1 id=\"Longest-Substring-Without-Repeating-Characters\"><a href=\"#Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"Longest Substring Without Repeating Characters\"></a>Longest Substring Without Repeating Characters</h1><p>打卡，第8天</p>\n<p>今天国庆，然而不会家，找了一道之前不敢做的题目做了——<a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\">Longest Substring Without Repeating Characters</a>,开始又是想着用分治法去完成（因为算法课在讲分治法），然而并没有做出来，又是同一个原因，在治的时候复杂度降不下来。</p>\n<p>题目描述：</p>\n<blockquote>\n<p>Given a string, find the length of the longest substring without repeating characters.</p>\n<p>Examples:</p>\n<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>\n<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>\n<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>\n</blockquote>\n<p>先放code吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">bool</span>&gt; cbmap;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( j &lt; s.size() )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &lt; s.size() &amp;&amp; cbmap[s[j]] == <span class=\"literal\">false</span>)</span><br><span class=\"line\">            cbmap[ s[j++] ] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        ret = max(j-i,ret);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; cbmap[s[j]] != <span class=\"literal\">false</span>)</span><br><span class=\"line\">            cbmap[ s[i++] ] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        cbmap[ s[j++] ] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大概的思路是：</p>\n<ul>\n<li>用两个下标来标识<code>Substring</code>的位置，<code>s[i,j)</code>就是我们当前的<code>Substring</code>.</li>\n<li>用j去遍历整个串，如果当前子串中没有<code>s[j]</code>，<code>j</code>就继续往下遍历，如果有，这时就可以计算一下当前子串的长度和之前的最长子串长度进行对比。</li>\n<li>在<code>j</code>停止遍历后，我们就让<code>i</code>向前移动，直到，当前子串不包含<code>s[j]</code>,这样我们就可以把<code>s[j]</code>加入当前子串，并继续进行遍历。</li>\n</ul>\n<p>写着写着突然发现，有个地方可以改：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">bool</span>&gt; cbmap;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>; j &lt; s.size();j++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &lt; s.size() &amp;&amp; cbmap[s[j]] == <span class=\"literal\">false</span>)</span><br><span class=\"line\">            cbmap[ s[j++] ] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        ret = max(j-i,ret);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; s[i++] != s[j])</span><br><span class=\"line\">            cbmap[ s[i - <span class=\"number\">1</span>] ] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>思路还是一样的，只不过写的更加精炼了罢了。</p>\n<p>然后看看<code>dicuss</code>中别人写的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// for ASCII char sequence, use this as a hashmap</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">charIndex</span><span class=\"params\">(<span class=\"number\">256</span>, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> longest = <span class=\"number\">0</span>, m = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">        m = max(charIndex[s[i]] + <span class=\"number\">1</span>, m);    <span class=\"comment\">// automatically takes care of -1 case</span></span><br><span class=\"line\">        charIndex[s[i]] = i;</span><br><span class=\"line\">        longest = max(longest, i - m + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> longest;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>他这里用的是<code>vector&lt;int&gt;</code>去记录最大的下标，而我是用的是<code>map</code>去记录当前子串中是否有这个字符，用他这种方法可以把<code>i</code>向前移的循环给去掉。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Longest-Substring-Without-Repeating-Characters\"><a href=\"#Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"Longest Substring Without Repeating Characters\"></a>Longest Substring Without Repeating Characters</h1><p>打卡，第8天</p>\n<p>今天国庆，然而不会家，找了一道之前不敢做的题目做了——<a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\">Longest Substring Without Repeating Characters</a>,开始又是想着用分治法去完成（因为算法课在讲分治法），然而并没有做出来，又是同一个原因，在治的时候复杂度降不下来。</p>\n<p>题目描述：</p>\n<blockquote>\n<p>Given a string, find the length of the longest substring without repeating characters.</p>\n<p>Examples:</p>\n<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>\n<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>\n<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>\n</blockquote>\n<p>先放code吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">bool</span>&gt; cbmap;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( j &lt; s.size() )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &lt; s.size() &amp;&amp; cbmap[s[j]] == <span class=\"literal\">false</span>)</span><br><span class=\"line\">            cbmap[ s[j++] ] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        ret = max(j-i,ret);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; cbmap[s[j]] != <span class=\"literal\">false</span>)</span><br><span class=\"line\">            cbmap[ s[i++] ] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        cbmap[ s[j++] ] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大概的思路是：</p>\n<ul>\n<li>用两个下标来标识<code>Substring</code>的位置，<code>s[i,j)</code>就是我们当前的<code>Substring</code>.</li>\n<li>用j去遍历整个串，如果当前子串中没有<code>s[j]</code>，<code>j</code>就继续往下遍历，如果有，这时就可以计算一下当前子串的长度和之前的最长子串长度进行对比。</li>\n<li>在<code>j</code>停止遍历后，我们就让<code>i</code>向前移动，直到，当前子串不包含<code>s[j]</code>,这样我们就可以把<code>s[j]</code>加入当前子串，并继续进行遍历。</li>\n</ul>\n<p>写着写着突然发现，有个地方可以改：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">bool</span>&gt; cbmap;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>; j &lt; s.size();j++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &lt; s.size() &amp;&amp; cbmap[s[j]] == <span class=\"literal\">false</span>)</span><br><span class=\"line\">            cbmap[ s[j++] ] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        ret = max(j-i,ret);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; s[i++] != s[j])</span><br><span class=\"line\">            cbmap[ s[i - <span class=\"number\">1</span>] ] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>思路还是一样的，只不过写的更加精炼了罢了。</p>\n<p>然后看看<code>dicuss</code>中别人写的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// for ASCII char sequence, use this as a hashmap</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">charIndex</span><span class=\"params\">(<span class=\"number\">256</span>, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> longest = <span class=\"number\">0</span>, m = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">        m = max(charIndex[s[i]] + <span class=\"number\">1</span>, m);    <span class=\"comment\">// automatically takes care of -1 case</span></span><br><span class=\"line\">        charIndex[s[i]] = i;</span><br><span class=\"line\">        longest = max(longest, i - m + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> longest;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>他这里用的是<code>vector&lt;int&gt;</code>去记录最大的下标，而我是用的是<code>map</code>去记录当前子串中是否有这个字符，用他这种方法可以把<code>i</code>向前移的循环给去掉。</p>\n"},{"title":"Lowest Common Ancestor of a Binary Tree","date":"2017-11-07T02:22:40.000Z","_content":"\n第42天。\n\n今天的题目是[Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/):\n\n> Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n>\n> According to [the definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”\n\n```python\n        _______3______\n       /              \\\n    ___5__          ___1__\n   /      \\        /      \\\n   6      _2       0       8\n         /  \\\n         7   4\n```\n\n> For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n额，怎么说呢。好久没有在上课前就AC掉了呢。\n\n恩，题目的意思是，找最近的公共祖先。\n\n考虑根节点，如果不考虑特殊的情况（比如说只用一个节点或干脆就没有节点），那么如果我们对其左子树和右子树递归的调用`lowestCommonAncestor`，那么其返回值就有以下几种情况:\n\n* `left`和`right`都非空，那么说明`root`节点就是`lowestCommonAncestor`，那我们就返回`root`\n* 只有`left`非空，那么说明`lowestCommonAncestor`在左子树中,那么我们就返回`left`\n* 只有`right`非空，与上面类似，我们就直接返回`right`\n* 两个都是空，说明`p`和`q`都不在这棵子树中，那其`lowestCommonAncestor`就是`nullptr`.\n\n然后我们再考虑一下特殊情况：\n\n* `root`是`nullptr`,那么就说明到了最底部了，直接返回`nullptr`即可\n* `root`和`p`或`q`相等,说明我们找到了其一个祖先，则返回`p`或`q`.\n\n然后将上面的思路写出来就是:\n\n```c++\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (root == nullptr || root == p || root == q) return root;\n\n    TreeNode *left = lowestCommonAncestor(root->left,p,q);\n    TreeNode *right = lowestCommonAncestor(root->right,p,q);\n\n    if (left && right) return root;\n    else if (left) return left;\n    else if (right) return right;\n    else return nullptr;\n\n}\n```\n\n其实上面有一个问题没考虑到，要是只有`p`在这棵子树中，而`q`不在，那怎么办。\n\nemmmm，但是上面的解法是过了测试的。\n\n如果要考虑这个问题的话，上面就有一些假设就是错的了，因为在`lowestCommonAncestor`在某些情况返回非空只是说明，这棵子树中有一个节点是与`p`和`q`相同的。\n","source":"_posts/Lowest-Common-Ancestor-of-a-Binary-Tree.md","raw":"---\ntitle: Lowest Common Ancestor of a Binary Tree\ndate: 2017-11-07T10:22:40.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第42天。\n\n今天的题目是[Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/):\n\n> Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n>\n> According to [the definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”\n\n```python\n        _______3______\n       /              \\\n    ___5__          ___1__\n   /      \\        /      \\\n   6      _2       0       8\n         /  \\\n         7   4\n```\n\n> For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n额，怎么说呢。好久没有在上课前就AC掉了呢。\n\n恩，题目的意思是，找最近的公共祖先。\n\n考虑根节点，如果不考虑特殊的情况（比如说只用一个节点或干脆就没有节点），那么如果我们对其左子树和右子树递归的调用`lowestCommonAncestor`，那么其返回值就有以下几种情况:\n\n* `left`和`right`都非空，那么说明`root`节点就是`lowestCommonAncestor`，那我们就返回`root`\n* 只有`left`非空，那么说明`lowestCommonAncestor`在左子树中,那么我们就返回`left`\n* 只有`right`非空，与上面类似，我们就直接返回`right`\n* 两个都是空，说明`p`和`q`都不在这棵子树中，那其`lowestCommonAncestor`就是`nullptr`.\n\n然后我们再考虑一下特殊情况：\n\n* `root`是`nullptr`,那么就说明到了最底部了，直接返回`nullptr`即可\n* `root`和`p`或`q`相等,说明我们找到了其一个祖先，则返回`p`或`q`.\n\n然后将上面的思路写出来就是:\n\n```c++\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (root == nullptr || root == p || root == q) return root;\n\n    TreeNode *left = lowestCommonAncestor(root->left,p,q);\n    TreeNode *right = lowestCommonAncestor(root->right,p,q);\n\n    if (left && right) return root;\n    else if (left) return left;\n    else if (right) return right;\n    else return nullptr;\n\n}\n```\n\n其实上面有一个问题没考虑到，要是只有`p`在这棵子树中，而`q`不在，那怎么办。\n\nemmmm，但是上面的解法是过了测试的。\n\n如果要考虑这个问题的话，上面就有一些假设就是错的了，因为在`lowestCommonAncestor`在某些情况返回非空只是说明，这棵子树中有一个节点是与`p`和`q`相同的。\n","slug":"Lowest-Common-Ancestor-of-a-Binary-Tree","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69on008qqmcm554qhxia","content":"<p>第42天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/\">Lowest Common Ancestor of a Binary Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\n<p>According to <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\">the definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     _______3______</span><br><span class=\"line\">    /              \\</span><br><span class=\"line\"> ___5__          ___1__</span><br><span class=\"line\">/      \\        /      \\</span><br><span class=\"line\"><span class=\"number\">6</span>      _2       <span class=\"number\">0</span>       <span class=\"number\">8</span></span><br><span class=\"line\">      /  \\</span><br><span class=\"line\">      <span class=\"number\">7</span>   <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>\n</blockquote>\n<p>额，怎么说呢。好久没有在上课前就AC掉了呢。</p>\n<p>恩，题目的意思是，找最近的公共祖先。</p>\n<p>考虑根节点，如果不考虑特殊的情况（比如说只用一个节点或干脆就没有节点），那么如果我们对其左子树和右子树递归的调用<code>lowestCommonAncestor</code>，那么其返回值就有以下几种情况:</p>\n<ul>\n<li><code>left</code>和<code>right</code>都非空，那么说明<code>root</code>节点就是<code>lowestCommonAncestor</code>，那我们就返回<code>root</code></li>\n<li>只有<code>left</code>非空，那么说明<code>lowestCommonAncestor</code>在左子树中,那么我们就返回<code>left</code></li>\n<li>只有<code>right</code>非空，与上面类似，我们就直接返回<code>right</code></li>\n<li>两个都是空，说明<code>p</code>和<code>q</code>都不在这棵子树中，那其<code>lowestCommonAncestor</code>就是<code>nullptr</code>.</li>\n</ul>\n<p>然后我们再考虑一下特殊情况：</p>\n<ul>\n<li><code>root</code>是<code>nullptr</code>,那么就说明到了最底部了，直接返回<code>nullptr</code>即可</li>\n<li><code>root</code>和<code>p</code>或<code>q</code>相等,说明我们找到了其一个祖先，则返回<code>p</code>或<code>q</code>.</li>\n</ul>\n<p>然后将上面的思路写出来就是:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span> || root == p || root == q) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode *left = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class=\"line\">    TreeNode *right = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &amp;&amp; right) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right) <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实上面有一个问题没考虑到，要是只有<code>p</code>在这棵子树中，而<code>q</code>不在，那怎么办。</p>\n<p>emmmm，但是上面的解法是过了测试的。</p>\n<p>如果要考虑这个问题的话，上面就有一些假设就是错的了，因为在<code>lowestCommonAncestor</code>在某些情况返回非空只是说明，这棵子树中有一个节点是与<code>p</code>和<code>q</code>相同的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第42天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/\">Lowest Common Ancestor of a Binary Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\n<p>According to <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\">the definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     _______3______</span><br><span class=\"line\">    /              \\</span><br><span class=\"line\"> ___5__          ___1__</span><br><span class=\"line\">/      \\        /      \\</span><br><span class=\"line\"><span class=\"number\">6</span>      _2       <span class=\"number\">0</span>       <span class=\"number\">8</span></span><br><span class=\"line\">      /  \\</span><br><span class=\"line\">      <span class=\"number\">7</span>   <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>\n</blockquote>\n<p>额，怎么说呢。好久没有在上课前就AC掉了呢。</p>\n<p>恩，题目的意思是，找最近的公共祖先。</p>\n<p>考虑根节点，如果不考虑特殊的情况（比如说只用一个节点或干脆就没有节点），那么如果我们对其左子树和右子树递归的调用<code>lowestCommonAncestor</code>，那么其返回值就有以下几种情况:</p>\n<ul>\n<li><code>left</code>和<code>right</code>都非空，那么说明<code>root</code>节点就是<code>lowestCommonAncestor</code>，那我们就返回<code>root</code></li>\n<li>只有<code>left</code>非空，那么说明<code>lowestCommonAncestor</code>在左子树中,那么我们就返回<code>left</code></li>\n<li>只有<code>right</code>非空，与上面类似，我们就直接返回<code>right</code></li>\n<li>两个都是空，说明<code>p</code>和<code>q</code>都不在这棵子树中，那其<code>lowestCommonAncestor</code>就是<code>nullptr</code>.</li>\n</ul>\n<p>然后我们再考虑一下特殊情况：</p>\n<ul>\n<li><code>root</code>是<code>nullptr</code>,那么就说明到了最底部了，直接返回<code>nullptr</code>即可</li>\n<li><code>root</code>和<code>p</code>或<code>q</code>相等,说明我们找到了其一个祖先，则返回<code>p</code>或<code>q</code>.</li>\n</ul>\n<p>然后将上面的思路写出来就是:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span> || root == p || root == q) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode *left = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class=\"line\">    TreeNode *right = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &amp;&amp; right) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right) <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实上面有一个问题没考虑到，要是只有<code>p</code>在这棵子树中，而<code>q</code>不在，那怎么办。</p>\n<p>emmmm，但是上面的解法是过了测试的。</p>\n<p>如果要考虑这个问题的话，上面就有一些假设就是错的了，因为在<code>lowestCommonAncestor</code>在某些情况返回非空只是说明，这棵子树中有一个节点是与<code>p</code>和<code>q</code>相同的。</p>\n"},{"title":"Majority Element","date":"2017-11-10T00:33:00.000Z","_content":"\n第45天。\n\n今天的题目是[Majority Element](https://leetcode.com/problems/majority-element/discuss/):\n\n> Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n>\n> You may assume that the array is non-empty and the majority element always exist in the array.\n\n最简单的想法就是，遍历一遍序列，记录出现的次数，然后在遍历一遍刚才记录的次数，如果大于`k`就直接返回，这种时候一般会用到`hash table`，在`c++`中就是`unordered_map`:\n\n```c++\nint majorityElement(vector<int>& nums) {\n    int size = nums.size();\n    int k = size/2;\n    unordered_map<int,int> map;\n    for(auto i:nums) map[i]++;\n    for(auto p:map) if (p.second > k) return p.first;\n}\n```\n\n这种方法的时间复杂度是`O(n)`,空间复杂度也是`O(n)`.\n\n虽然很简单，但是这道题目在`dicuss`中也有很多有趣的解法:\n\n* 因为`Majority Element`在序列中存在`n/2`个，所以假如这个序列时有序的话，他一定会出现在中间:\n\n```c++\nint majorityElement(vector<int>& nums) {\n    nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());\n    return nums[nums.size() / 2];\n}\n```\n\n很`nice`的学到了一个新的函数。\n\n* 同样是因为出现了`k/2`次，所以我们如果随机选取一个元素的话，有一半的概率可以直接选到`Majority Element`:\n\n```c++\nint majorityElement(vector<int>& nums) {\n    int n = nums.size();\n    srand(unsigned(time(NULL)));\n    while (true) {\n        int idx = rand() % n;\n        int candidate = nums[idx];\n        int counts = 0;\n        for (int i = 0; i < n; i++)\n            if (nums[i] == candidate)\n                counts++;\n        if (counts > n / 2) return candidate;\n    }\n}\n```\n\n* `Moore Voting Algorithm`，这个方法的正确性我也不是很确定:\n\n```c++\nint majorityElement(vector<int>& nums) {\n    int major, counts = 0, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (!counts) {\n            major = nums[i];\n            counts = 1;\n        }\n        else counts += (nums[i] == major) ? 1 : -1;\n    }\n    return major;\n}\n```\n","source":"_posts/Majority-Element.md","raw":"---\ntitle: Majority Element\ndate: 2017-11-10T08:33:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第45天。\n\n今天的题目是[Majority Element](https://leetcode.com/problems/majority-element/discuss/):\n\n> Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n>\n> You may assume that the array is non-empty and the majority element always exist in the array.\n\n最简单的想法就是，遍历一遍序列，记录出现的次数，然后在遍历一遍刚才记录的次数，如果大于`k`就直接返回，这种时候一般会用到`hash table`，在`c++`中就是`unordered_map`:\n\n```c++\nint majorityElement(vector<int>& nums) {\n    int size = nums.size();\n    int k = size/2;\n    unordered_map<int,int> map;\n    for(auto i:nums) map[i]++;\n    for(auto p:map) if (p.second > k) return p.first;\n}\n```\n\n这种方法的时间复杂度是`O(n)`,空间复杂度也是`O(n)`.\n\n虽然很简单，但是这道题目在`dicuss`中也有很多有趣的解法:\n\n* 因为`Majority Element`在序列中存在`n/2`个，所以假如这个序列时有序的话，他一定会出现在中间:\n\n```c++\nint majorityElement(vector<int>& nums) {\n    nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());\n    return nums[nums.size() / 2];\n}\n```\n\n很`nice`的学到了一个新的函数。\n\n* 同样是因为出现了`k/2`次，所以我们如果随机选取一个元素的话，有一半的概率可以直接选到`Majority Element`:\n\n```c++\nint majorityElement(vector<int>& nums) {\n    int n = nums.size();\n    srand(unsigned(time(NULL)));\n    while (true) {\n        int idx = rand() % n;\n        int candidate = nums[idx];\n        int counts = 0;\n        for (int i = 0; i < n; i++)\n            if (nums[i] == candidate)\n                counts++;\n        if (counts > n / 2) return candidate;\n    }\n}\n```\n\n* `Moore Voting Algorithm`，这个方法的正确性我也不是很确定:\n\n```c++\nint majorityElement(vector<int>& nums) {\n    int major, counts = 0, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (!counts) {\n            major = nums[i];\n            counts = 1;\n        }\n        else counts += (nums[i] == major) ? 1 : -1;\n    }\n    return major;\n}\n```\n","slug":"Majority-Element","published":1,"updated":"2021-03-10T13:47:05.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oo008tqmcmeb761vs9","content":"<p>第45天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/majority-element/discuss/\">Majority Element</a>:</p>\n<blockquote>\n<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n</blockquote>\n<p>最简单的想法就是，遍历一遍序列，记录出现的次数，然后在遍历一遍刚才记录的次数，如果大于<code>k</code>就直接返回，这种时候一般会用到<code>hash table</code>，在<code>c++</code>中就是<code>unordered_map</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = size/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; <span class=\"built_in\">map</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) <span class=\"built_in\">map</span>[i]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p:<span class=\"built_in\">map</span>) <span class=\"keyword\">if</span> (p.second &gt; k) <span class=\"keyword\">return</span> p.first;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法的时间复杂度是<code>O(n)</code>,空间复杂度也是<code>O(n)</code>.</p>\n<p>虽然很简单，但是这道题目在<code>dicuss</code>中也有很多有趣的解法:</p>\n<ul>\n<li>因为<code>Majority Element</code>在序列中存在<code>n/2</code>个，所以假如这个序列时有序的话，他一定会出现在中间:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    nth_element(nums.begin(), nums.begin() + nums.size() / <span class=\"number\">2</span>, nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[nums.size() / <span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很<code>nice</code>的学到了一个新的函数。</p>\n<ul>\n<li>同样是因为出现了<code>k/2</code>次，所以我们如果随机选取一个元素的话，有一半的概率可以直接选到<code>Majority Element</code>:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    srand(<span class=\"keyword\">unsigned</span>(time(<span class=\"literal\">NULL</span>)));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> idx = rand() % n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> candidate = nums[idx];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> counts = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == candidate)</span><br><span class=\"line\">                counts++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (counts &gt; n / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Moore Voting Algorithm</code>，这个方法的正确性我也不是很确定:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> major, counts = <span class=\"number\">0</span>, n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!counts) &#123;</span><br><span class=\"line\">            major = nums[i];</span><br><span class=\"line\">            counts = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> counts += (nums[i] == major) ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第45天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/majority-element/discuss/\">Majority Element</a>:</p>\n<blockquote>\n<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n</blockquote>\n<p>最简单的想法就是，遍历一遍序列，记录出现的次数，然后在遍历一遍刚才记录的次数，如果大于<code>k</code>就直接返回，这种时候一般会用到<code>hash table</code>，在<code>c++</code>中就是<code>unordered_map</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = size/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; <span class=\"built_in\">map</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) <span class=\"built_in\">map</span>[i]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p:<span class=\"built_in\">map</span>) <span class=\"keyword\">if</span> (p.second &gt; k) <span class=\"keyword\">return</span> p.first;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法的时间复杂度是<code>O(n)</code>,空间复杂度也是<code>O(n)</code>.</p>\n<p>虽然很简单，但是这道题目在<code>dicuss</code>中也有很多有趣的解法:</p>\n<ul>\n<li>因为<code>Majority Element</code>在序列中存在<code>n/2</code>个，所以假如这个序列时有序的话，他一定会出现在中间:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    nth_element(nums.begin(), nums.begin() + nums.size() / <span class=\"number\">2</span>, nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[nums.size() / <span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很<code>nice</code>的学到了一个新的函数。</p>\n<ul>\n<li>同样是因为出现了<code>k/2</code>次，所以我们如果随机选取一个元素的话，有一半的概率可以直接选到<code>Majority Element</code>:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">    srand(<span class=\"keyword\">unsigned</span>(time(<span class=\"literal\">NULL</span>)));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> idx = rand() % n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> candidate = nums[idx];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> counts = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == candidate)</span><br><span class=\"line\">                counts++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (counts &gt; n / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Moore Voting Algorithm</code>，这个方法的正确性我也不是很确定:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> major, counts = <span class=\"number\">0</span>, n = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!counts) &#123;</span><br><span class=\"line\">            major = nums[i];</span><br><span class=\"line\">            counts = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> counts += (nums[i] == major) ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Matchsticks to Square","date":"2019-03-08T03:10:39.000Z","_content":"\n> 第9天，恩，忘记洗衣服了，写完就去洗。\n\n今天的题目是[Matchsticks to Square](https://leetcode.com/problems/matchsticks-to-square/)。\n\n没想到是一道暴搜的题。。。\n\n既然是暴搜，那思路就比较简单了：\n\n我们先计算出数组和，然后除以4就是每条边的长度了，然后用暴力搜索的方式看是否能连续四次移除长度之和为边长的火柴。\n\n暴搜时可以用一些小技巧，比如先排序来保证先用掉比较长的火柴，这样一旦发现，剩下的火柴比需要的长度还长就可以直接判定失败了，减少搜索次数。\n\n而且标记是否使用掉该火柴的`used`数组也可以省略掉，因为火柴长度一定大于0， 可以用其相反数来表示已经用掉了\n\n```c++\nclass Solution {\npublic:\n    bool makesquare(vector<int>& nums) {\n        int len = nums.size();\n        if (len == 0) return false;\n        sort(nums.rbegin(), nums.rend());\n        \n        int sum = 0;\n        for(auto &i: nums) sum+=i;\n        \n        if (sum % 4) return false;\n        \n        for(int i = 0;i < 4; i++) {\n            if (dfs(nums, sum/4) == false) return false;\n        }\n        return true;\n    }\n    bool dfs(vector<int> &nums, int len) {\n        if (len == 0) return true;\n        else if (len < 0) return false;\n        \n        for(int i = 0;i < nums.size(); i++) {\n            if (len < nums[i]) return false;\n            if (nums[i] <= 0) continue;\n            nums[i] = -nums[i];\n            if (dfs(nums, len + nums[i])) return true; \n            nums[i] = -nums[i];\n        }\n        return false;\n    }\n};\n```\n","source":"_posts/Matchsticks-to-Square.md","raw":"---\ntitle: Matchsticks to Square\ndate: 2019-03-08T11:10:39.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第9天，恩，忘记洗衣服了，写完就去洗。\n\n今天的题目是[Matchsticks to Square](https://leetcode.com/problems/matchsticks-to-square/)。\n\n没想到是一道暴搜的题。。。\n\n既然是暴搜，那思路就比较简单了：\n\n我们先计算出数组和，然后除以4就是每条边的长度了，然后用暴力搜索的方式看是否能连续四次移除长度之和为边长的火柴。\n\n暴搜时可以用一些小技巧，比如先排序来保证先用掉比较长的火柴，这样一旦发现，剩下的火柴比需要的长度还长就可以直接判定失败了，减少搜索次数。\n\n而且标记是否使用掉该火柴的`used`数组也可以省略掉，因为火柴长度一定大于0， 可以用其相反数来表示已经用掉了\n\n```c++\nclass Solution {\npublic:\n    bool makesquare(vector<int>& nums) {\n        int len = nums.size();\n        if (len == 0) return false;\n        sort(nums.rbegin(), nums.rend());\n        \n        int sum = 0;\n        for(auto &i: nums) sum+=i;\n        \n        if (sum % 4) return false;\n        \n        for(int i = 0;i < 4; i++) {\n            if (dfs(nums, sum/4) == false) return false;\n        }\n        return true;\n    }\n    bool dfs(vector<int> &nums, int len) {\n        if (len == 0) return true;\n        else if (len < 0) return false;\n        \n        for(int i = 0;i < nums.size(); i++) {\n            if (len < nums[i]) return false;\n            if (nums[i] <= 0) continue;\n            nums[i] = -nums[i];\n            if (dfs(nums, len + nums[i])) return true; \n            nums[i] = -nums[i];\n        }\n        return false;\n    }\n};\n```\n","slug":"Matchsticks-to-Square","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oo008wqmcm1tdq0yn4","content":"<blockquote>\n<p>第9天，恩，忘记洗衣服了，写完就去洗。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/matchsticks-to-square/\">Matchsticks to Square</a>。</p>\n<p>没想到是一道暴搜的题。。。</p>\n<p>既然是暴搜，那思路就比较简单了：</p>\n<p>我们先计算出数组和，然后除以4就是每条边的长度了，然后用暴力搜索的方式看是否能连续四次移除长度之和为边长的火柴。</p>\n<p>暴搜时可以用一些小技巧，比如先排序来保证先用掉比较长的火柴，这样一旦发现，剩下的火柴比需要的长度还长就可以直接判定失败了，减少搜索次数。</p>\n<p>而且标记是否使用掉该火柴的<code>used</code>数组也可以省略掉，因为火柴长度一定大于0， 可以用其相反数来表示已经用掉了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">makesquare</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        sort(nums.rbegin(), nums.rend());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;i: nums) sum+=i;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum % <span class=\"number\">4</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dfs(nums, sum/<span class=\"number\">4</span>) == <span class=\"literal\">false</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (len &lt; nums[i]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            nums[i] = -nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dfs(nums, len + nums[i])) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">            nums[i] = -nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第9天，恩，忘记洗衣服了，写完就去洗。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/matchsticks-to-square/\">Matchsticks to Square</a>。</p>\n<p>没想到是一道暴搜的题。。。</p>\n<p>既然是暴搜，那思路就比较简单了：</p>\n<p>我们先计算出数组和，然后除以4就是每条边的长度了，然后用暴力搜索的方式看是否能连续四次移除长度之和为边长的火柴。</p>\n<p>暴搜时可以用一些小技巧，比如先排序来保证先用掉比较长的火柴，这样一旦发现，剩下的火柴比需要的长度还长就可以直接判定失败了，减少搜索次数。</p>\n<p>而且标记是否使用掉该火柴的<code>used</code>数组也可以省略掉，因为火柴长度一定大于0， 可以用其相反数来表示已经用掉了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">makesquare</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        sort(nums.rbegin(), nums.rend());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;i: nums) sum+=i;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum % <span class=\"number\">4</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dfs(nums, sum/<span class=\"number\">4</span>) == <span class=\"literal\">false</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (len &lt; nums[i]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            nums[i] = -nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dfs(nums, len + nums[i])) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">            nums[i] = -nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Maximal-Square","date":"2017-11-16T11:48:47.000Z","_content":"\n第50天。\n\n恍恍惚惚，就50天了。\n\n今天的题目是[Maximal Square](https://leetcode.com/problems/maximal-square/description/):\n\n> Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n>\n> For example, given the following matrix:\n>\n\n```python\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n```\n\n> Return 4.\n\n让人很意外，这是一道动态规划的题目。\n\n先说说我的非动态规划的解法：\n\n大概的想法是，做一次遍历，每次遇到`1`,就向下拓展，如果扩展，扩展的方法是就是只需要看当前正方形的外围是否都是`1`，如果都是`1`,那么我们就可以继续向下扩展，这样就可以遍历出一个正方形，然后我们在对`matrix`进行遍历的时候还可以通过当前的最大面积来提早结束遍历：\n\n```python\ndef expend(self,matrix,i,j,ret):\n    \"\"\"\n    :type matrix: List[List[str]]\n    :type i: int\n    :type j: int\n    :type ret: int\n    :rtype ret\n    \"\"\"\n    if i >= len(matrix) or j >= len(matrix[0]):\n        return ret\n    for k in range(ret+1):\n        if matrix[i][j - k] == '0' or matrix[i-k][j] == '0':\n            return ret\n    return self.expend(matrix,i+1,j+1,ret+1)\n\ndef maximalSquare1(self, matrix):\n    \"\"\"\n    :type matrix: List[List[str]]\n    :rtype: int\n    \"\"\"\n    ret,i = 0,0\n    while i + ret < len(matrix):\n        j = 0\n        while j + ret < len(matrix[0]):\n            if matrix[i][j] == '1':\n                ret = max(ret,self.expend(matrix,i+1,j+1,1))\n            j += 1\n        i += 1\n    return ret*ret\n```\n\n挺暴力的方法，不知道是不是因为可以提前结束，所以这个方法也直接AC了。\n\n然后是`DP`的解法。\n\n在解决这个问题之前，我们先考虑如果求出以`matrix[i][j]`为右下角的正方形最大面积。\n\n如果`matrix[i][j] = '0'`,那么显然`size[i][j] = 0`\n如果`matrix[i][j] = '1'`,那么我们需要考虑其向上，向左，向左上的最大面积。\n\n假设`size[i-1][j-1] = 2`,则我们至少可以知道：\n\n```python\n[\n    [1,1,*]\n    [1,1,*]\n    [*,*,-]\n]\n```\n\n如果`size[i][j-1] = 2`,我们至少知道：\n\n```python\n[\n    [*,*,*]\n    [1,1,*]\n    [1,1,-]\n]\n```\n\n如果`size[i-1][j] = 2`,我们至少知道：\n\n```python\n[\n    [*,1,1]\n    [*,1,1]\n    [*,*,-]\n]\n```\n\n从上面可以看出来，只有当`size[i-1][j-1] == 2 and size[i][j-1] == 2 and size[i-1][j-1] == 2`时，`size[i][j] == 3`,\n\n则我们可以得出以下递推式：\n\n`size[i][j] = min(size[i-1][j-1],size[i][j-1],size[i-1][j])+1 if matrix[i][j] == '1'`\n`size[i][j] = 0 if matrix[i][j] == '0'`\n\n然后我们还需要考虑一下边界条件，因为当`i=0`或`j=0`时，上面的递推式是没有考虑到的，我们再加上：\n\n`size[i][j] = (matrix[i][j] == '1') where i == 0 or j == 0`\n\n然后我们就可以写出以下解法：\n\n```python\ndef maximalSquare(self,matrix):\n    if len(matrix) == 0:\n        return 0\n    dp1 = []\n    ret = 0\n    for i in range(len(matrix[0])):\n        t = int(matrix[0][i] == '1')\n        dp1.append(t)\n        ret = max(ret,t)\n    for i in range(1,len(matrix)):\n        dp2 = [ 0 for i in range(len(matrix[0])) ]\n        dp2[0] = int(matrix[i][0] == '1')\n        ret = max(dp2[0],ret)\n        for j in range(1,len(matrix[0])):\n            if matrix[i][j] == '1':\n                dp2[j] = min(min(dp1[j-1],dp1[j]),dp2[j-1]) + 1\n            ret = max(ret,dp2[j])\n        dp1 = dp2\n    return ret*ret\n```\n","source":"_posts/Maximal-Square.md","raw":"---\ntitle: Maximal-Square\ndate: 2017-11-16T19:48:47.000Z\ncategories:\n  - LeetCode\ntags:\n  - DP\n---\n\n第50天。\n\n恍恍惚惚，就50天了。\n\n今天的题目是[Maximal Square](https://leetcode.com/problems/maximal-square/description/):\n\n> Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n>\n> For example, given the following matrix:\n>\n\n```python\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n```\n\n> Return 4.\n\n让人很意外，这是一道动态规划的题目。\n\n先说说我的非动态规划的解法：\n\n大概的想法是，做一次遍历，每次遇到`1`,就向下拓展，如果扩展，扩展的方法是就是只需要看当前正方形的外围是否都是`1`，如果都是`1`,那么我们就可以继续向下扩展，这样就可以遍历出一个正方形，然后我们在对`matrix`进行遍历的时候还可以通过当前的最大面积来提早结束遍历：\n\n```python\ndef expend(self,matrix,i,j,ret):\n    \"\"\"\n    :type matrix: List[List[str]]\n    :type i: int\n    :type j: int\n    :type ret: int\n    :rtype ret\n    \"\"\"\n    if i >= len(matrix) or j >= len(matrix[0]):\n        return ret\n    for k in range(ret+1):\n        if matrix[i][j - k] == '0' or matrix[i-k][j] == '0':\n            return ret\n    return self.expend(matrix,i+1,j+1,ret+1)\n\ndef maximalSquare1(self, matrix):\n    \"\"\"\n    :type matrix: List[List[str]]\n    :rtype: int\n    \"\"\"\n    ret,i = 0,0\n    while i + ret < len(matrix):\n        j = 0\n        while j + ret < len(matrix[0]):\n            if matrix[i][j] == '1':\n                ret = max(ret,self.expend(matrix,i+1,j+1,1))\n            j += 1\n        i += 1\n    return ret*ret\n```\n\n挺暴力的方法，不知道是不是因为可以提前结束，所以这个方法也直接AC了。\n\n然后是`DP`的解法。\n\n在解决这个问题之前，我们先考虑如果求出以`matrix[i][j]`为右下角的正方形最大面积。\n\n如果`matrix[i][j] = '0'`,那么显然`size[i][j] = 0`\n如果`matrix[i][j] = '1'`,那么我们需要考虑其向上，向左，向左上的最大面积。\n\n假设`size[i-1][j-1] = 2`,则我们至少可以知道：\n\n```python\n[\n    [1,1,*]\n    [1,1,*]\n    [*,*,-]\n]\n```\n\n如果`size[i][j-1] = 2`,我们至少知道：\n\n```python\n[\n    [*,*,*]\n    [1,1,*]\n    [1,1,-]\n]\n```\n\n如果`size[i-1][j] = 2`,我们至少知道：\n\n```python\n[\n    [*,1,1]\n    [*,1,1]\n    [*,*,-]\n]\n```\n\n从上面可以看出来，只有当`size[i-1][j-1] == 2 and size[i][j-1] == 2 and size[i-1][j-1] == 2`时，`size[i][j] == 3`,\n\n则我们可以得出以下递推式：\n\n`size[i][j] = min(size[i-1][j-1],size[i][j-1],size[i-1][j])+1 if matrix[i][j] == '1'`\n`size[i][j] = 0 if matrix[i][j] == '0'`\n\n然后我们还需要考虑一下边界条件，因为当`i=0`或`j=0`时，上面的递推式是没有考虑到的，我们再加上：\n\n`size[i][j] = (matrix[i][j] == '1') where i == 0 or j == 0`\n\n然后我们就可以写出以下解法：\n\n```python\ndef maximalSquare(self,matrix):\n    if len(matrix) == 0:\n        return 0\n    dp1 = []\n    ret = 0\n    for i in range(len(matrix[0])):\n        t = int(matrix[0][i] == '1')\n        dp1.append(t)\n        ret = max(ret,t)\n    for i in range(1,len(matrix)):\n        dp2 = [ 0 for i in range(len(matrix[0])) ]\n        dp2[0] = int(matrix[i][0] == '1')\n        ret = max(dp2[0],ret)\n        for j in range(1,len(matrix[0])):\n            if matrix[i][j] == '1':\n                dp2[j] = min(min(dp1[j-1],dp1[j]),dp2[j-1]) + 1\n            ret = max(ret,dp2[j])\n        dp1 = dp2\n    return ret*ret\n```\n","slug":"Maximal-Square","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69op008zqmcm66kuc49x","content":"<p>第50天。</p>\n<p>恍恍惚惚，就50天了。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximal-square/description/\">Maximal Square</a>:</p>\n<blockquote>\n<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>\n<p>For example, given the following matrix:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Return 4.</p>\n</blockquote>\n<p>让人很意外，这是一道动态规划的题目。</p>\n<p>先说说我的非动态规划的解法：</p>\n<p>大概的想法是，做一次遍历，每次遇到<code>1</code>,就向下拓展，如果扩展，扩展的方法是就是只需要看当前正方形的外围是否都是<code>1</code>，如果都是<code>1</code>,那么我们就可以继续向下扩展，这样就可以遍历出一个正方形，然后我们在对<code>matrix</code>进行遍历的时候还可以通过当前的最大面积来提早结束遍历：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">expend</span>(<span class=\"params\">self,matrix,i,j,ret</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type matrix: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">    :type i: int</span></span><br><span class=\"line\"><span class=\"string\">    :type j: int</span></span><br><span class=\"line\"><span class=\"string\">    :type ret: int</span></span><br><span class=\"line\"><span class=\"string\">    :rtype ret</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &gt;= <span class=\"built_in\">len</span>(matrix) <span class=\"keyword\">or</span> j &gt;= <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(ret+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> matrix[i][j - k] == <span class=\"string\">&#x27;0&#x27;</span> <span class=\"keyword\">or</span> matrix[i-k][j] == <span class=\"string\">&#x27;0&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.expend(matrix,i+<span class=\"number\">1</span>,j+<span class=\"number\">1</span>,ret+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalSquare1</span>(<span class=\"params\">self, matrix</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type matrix: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    ret,i = <span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i + ret &lt; <span class=\"built_in\">len</span>(matrix):</span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j + ret &lt; <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>:</span><br><span class=\"line\">                ret = <span class=\"built_in\">max</span>(ret,self.expend(matrix,i+<span class=\"number\">1</span>,j+<span class=\"number\">1</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret*ret</span><br></pre></td></tr></table></figure>\n\n<p>挺暴力的方法，不知道是不是因为可以提前结束，所以这个方法也直接AC了。</p>\n<p>然后是<code>DP</code>的解法。</p>\n<p>在解决这个问题之前，我们先考虑如果求出以<code>matrix[i][j]</code>为右下角的正方形最大面积。</p>\n<p>如果<code>matrix[i][j] = &#39;0&#39;</code>,那么显然<code>size[i][j] = 0</code><br>如果<code>matrix[i][j] = &#39;1&#39;</code>,那么我们需要考虑其向上，向左，向左上的最大面积。</p>\n<p>假设<code>size[i-1][j-1] = 2</code>,则我们至少可以知道：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    [<span class=\"number\">1</span>,<span class=\"number\">1</span>,*]</span><br><span class=\"line\">    [<span class=\"number\">1</span>,<span class=\"number\">1</span>,*]</span><br><span class=\"line\">    [*,*,-]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>size[i][j-1] = 2</code>,我们至少知道：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    [*,*,*]</span><br><span class=\"line\">    [<span class=\"number\">1</span>,<span class=\"number\">1</span>,*]</span><br><span class=\"line\">    [<span class=\"number\">1</span>,<span class=\"number\">1</span>,-]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>size[i-1][j] = 2</code>,我们至少知道：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    [*,<span class=\"number\">1</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    [*,<span class=\"number\">1</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    [*,*,-]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>从上面可以看出来，只有当<code>size[i-1][j-1] == 2 and size[i][j-1] == 2 and size[i-1][j-1] == 2</code>时，<code>size[i][j] == 3</code>,</p>\n<p>则我们可以得出以下递推式：</p>\n<p><code>size[i][j] = min(size[i-1][j-1],size[i][j-1],size[i-1][j])+1 if matrix[i][j] == &#39;1&#39;</code><br><code>size[i][j] = 0 if matrix[i][j] == &#39;0&#39;</code></p>\n<p>然后我们还需要考虑一下边界条件，因为当<code>i=0</code>或<code>j=0</code>时，上面的递推式是没有考虑到的，我们再加上：</p>\n<p><code>size[i][j] = (matrix[i][j] == &#39;1&#39;) where i == 0 or j == 0</code></p>\n<p>然后我们就可以写出以下解法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalSquare</span>(<span class=\"params\">self,matrix</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(matrix) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    dp1 = []</span><br><span class=\"line\">    ret = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])):</span><br><span class=\"line\">        t = <span class=\"built_in\">int</span>(matrix[<span class=\"number\">0</span>][i] == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">        dp1.append(t)</span><br><span class=\"line\">        ret = <span class=\"built_in\">max</span>(ret,t)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"built_in\">len</span>(matrix)):</span><br><span class=\"line\">        dp2 = [ <span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])) ]</span><br><span class=\"line\">        dp2[<span class=\"number\">0</span>] = <span class=\"built_in\">int</span>(matrix[i][<span class=\"number\">0</span>] == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">        ret = <span class=\"built_in\">max</span>(dp2[<span class=\"number\">0</span>],ret)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>:</span><br><span class=\"line\">                dp2[j] = <span class=\"built_in\">min</span>(<span class=\"built_in\">min</span>(dp1[j-<span class=\"number\">1</span>],dp1[j]),dp2[j-<span class=\"number\">1</span>]) + <span class=\"number\">1</span></span><br><span class=\"line\">            ret = <span class=\"built_in\">max</span>(ret,dp2[j])</span><br><span class=\"line\">        dp1 = dp2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret*ret</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第50天。</p>\n<p>恍恍惚惚，就50天了。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximal-square/description/\">Maximal Square</a>:</p>\n<blockquote>\n<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>\n<p>For example, given the following matrix:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Return 4.</p>\n</blockquote>\n<p>让人很意外，这是一道动态规划的题目。</p>\n<p>先说说我的非动态规划的解法：</p>\n<p>大概的想法是，做一次遍历，每次遇到<code>1</code>,就向下拓展，如果扩展，扩展的方法是就是只需要看当前正方形的外围是否都是<code>1</code>，如果都是<code>1</code>,那么我们就可以继续向下扩展，这样就可以遍历出一个正方形，然后我们在对<code>matrix</code>进行遍历的时候还可以通过当前的最大面积来提早结束遍历：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">expend</span>(<span class=\"params\">self,matrix,i,j,ret</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type matrix: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">    :type i: int</span></span><br><span class=\"line\"><span class=\"string\">    :type j: int</span></span><br><span class=\"line\"><span class=\"string\">    :type ret: int</span></span><br><span class=\"line\"><span class=\"string\">    :rtype ret</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &gt;= <span class=\"built_in\">len</span>(matrix) <span class=\"keyword\">or</span> j &gt;= <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(ret+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> matrix[i][j - k] == <span class=\"string\">&#x27;0&#x27;</span> <span class=\"keyword\">or</span> matrix[i-k][j] == <span class=\"string\">&#x27;0&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.expend(matrix,i+<span class=\"number\">1</span>,j+<span class=\"number\">1</span>,ret+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalSquare1</span>(<span class=\"params\">self, matrix</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type matrix: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    ret,i = <span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i + ret &lt; <span class=\"built_in\">len</span>(matrix):</span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j + ret &lt; <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>:</span><br><span class=\"line\">                ret = <span class=\"built_in\">max</span>(ret,self.expend(matrix,i+<span class=\"number\">1</span>,j+<span class=\"number\">1</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret*ret</span><br></pre></td></tr></table></figure>\n\n<p>挺暴力的方法，不知道是不是因为可以提前结束，所以这个方法也直接AC了。</p>\n<p>然后是<code>DP</code>的解法。</p>\n<p>在解决这个问题之前，我们先考虑如果求出以<code>matrix[i][j]</code>为右下角的正方形最大面积。</p>\n<p>如果<code>matrix[i][j] = &#39;0&#39;</code>,那么显然<code>size[i][j] = 0</code><br>如果<code>matrix[i][j] = &#39;1&#39;</code>,那么我们需要考虑其向上，向左，向左上的最大面积。</p>\n<p>假设<code>size[i-1][j-1] = 2</code>,则我们至少可以知道：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    [<span class=\"number\">1</span>,<span class=\"number\">1</span>,*]</span><br><span class=\"line\">    [<span class=\"number\">1</span>,<span class=\"number\">1</span>,*]</span><br><span class=\"line\">    [*,*,-]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>size[i][j-1] = 2</code>,我们至少知道：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    [*,*,*]</span><br><span class=\"line\">    [<span class=\"number\">1</span>,<span class=\"number\">1</span>,*]</span><br><span class=\"line\">    [<span class=\"number\">1</span>,<span class=\"number\">1</span>,-]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>size[i-1][j] = 2</code>,我们至少知道：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    [*,<span class=\"number\">1</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    [*,<span class=\"number\">1</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    [*,*,-]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>从上面可以看出来，只有当<code>size[i-1][j-1] == 2 and size[i][j-1] == 2 and size[i-1][j-1] == 2</code>时，<code>size[i][j] == 3</code>,</p>\n<p>则我们可以得出以下递推式：</p>\n<p><code>size[i][j] = min(size[i-1][j-1],size[i][j-1],size[i-1][j])+1 if matrix[i][j] == &#39;1&#39;</code><br><code>size[i][j] = 0 if matrix[i][j] == &#39;0&#39;</code></p>\n<p>然后我们还需要考虑一下边界条件，因为当<code>i=0</code>或<code>j=0</code>时，上面的递推式是没有考虑到的，我们再加上：</p>\n<p><code>size[i][j] = (matrix[i][j] == &#39;1&#39;) where i == 0 or j == 0</code></p>\n<p>然后我们就可以写出以下解法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalSquare</span>(<span class=\"params\">self,matrix</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(matrix) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    dp1 = []</span><br><span class=\"line\">    ret = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])):</span><br><span class=\"line\">        t = <span class=\"built_in\">int</span>(matrix[<span class=\"number\">0</span>][i] == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">        dp1.append(t)</span><br><span class=\"line\">        ret = <span class=\"built_in\">max</span>(ret,t)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"built_in\">len</span>(matrix)):</span><br><span class=\"line\">        dp2 = [ <span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])) ]</span><br><span class=\"line\">        dp2[<span class=\"number\">0</span>] = <span class=\"built_in\">int</span>(matrix[i][<span class=\"number\">0</span>] == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">        ret = <span class=\"built_in\">max</span>(dp2[<span class=\"number\">0</span>],ret)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>:</span><br><span class=\"line\">                dp2[j] = <span class=\"built_in\">min</span>(<span class=\"built_in\">min</span>(dp1[j-<span class=\"number\">1</span>],dp1[j]),dp2[j-<span class=\"number\">1</span>]) + <span class=\"number\">1</span></span><br><span class=\"line\">            ret = <span class=\"built_in\">max</span>(ret,dp2[j])</span><br><span class=\"line\">        dp1 = dp2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret*ret</span><br></pre></td></tr></table></figure>\n"},{"title":"Maximum Binary Tree","date":"2019-03-21T03:31:43.000Z","_content":"\n> 第15天。\n\n今天的题目是[Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)。\n\n并不难的一道题，而且不同寻常的是用栈去做比用递归去做要方便一点。\n\n我这里的想法是，从左向右一直插入就好了，例如输入是`[3, 2, 1, 6, 0, 5]`\n\n先插入 3 ，然后插入下一个元素时进行讨论：\n\n- 如果比上一次插入的元素要小，我就直接插入到上一次插入节点的右孩子处就好了。\n- 如果比上一次插入的元素要大，我就用栈回溯到上上次插入节点的位置，进行判断，以此类推。\n\t- 如果在栈中找到了，我就将新元素插入到该节点的右孩子处，并把原来的右子树当成是新元素的左子树。\n\t- 如果没在栈中找到，我就把新元素当成新的根节点，并把原来的数当成新元素的左子树。\n\n代码如下：\n\n```c++\nTreeNode* constructMaximumBinaryTree1(vector<int>& nums) {\n\tif (nums.size() == 0) return nullptr;\n\t\n\tstack<TreeNode*> st;\n\t\n\tauto end = nums.end();\n\t\n\tTreeNode *root = new TreeNode(nums[0]);\n\tTreeNode *p = root;\n\t\n\tst.push(root);\n\t\n\tfor(auto it = nums.begin() + 1; it != end; ++it) {\n\t\tint val = *it;\n\t\tTreeNode *t = new TreeNode(val);\n\t\t\n\t\tif (val < p->val) {\n\t\t\tp->right = t;\n\t\t} else {\n\t\t\twhile(!st.empty() && val > st.top()->val) st.pop();\n\t\t\tif (!st.empty()) {\n\t\t\t\tp = st.top();\n\t\t\t\tt->left = p->right;\n\t\t\t\tp->right = t;\n\t\t\t} else {\n\t\t\t\tt->left = root;\n\t\t\t\troot = t;\n\t\t\t}\n\t\t}\n\t\tp = t;\n\t\tst.push(p);\n\t}\n\t\n\treturn root;\n}\n```\n","source":"_posts/Maximum-Binary-Tree.md","raw":"---\ntitle: Maximum Binary Tree\ndate: 2019-03-21T11:31:43.000Z\ntags:\n  - LeetCode\n  - Tree\ncategories:\n  - LeetCode\n---\n\n> 第15天。\n\n今天的题目是[Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)。\n\n并不难的一道题，而且不同寻常的是用栈去做比用递归去做要方便一点。\n\n我这里的想法是，从左向右一直插入就好了，例如输入是`[3, 2, 1, 6, 0, 5]`\n\n先插入 3 ，然后插入下一个元素时进行讨论：\n\n- 如果比上一次插入的元素要小，我就直接插入到上一次插入节点的右孩子处就好了。\n- 如果比上一次插入的元素要大，我就用栈回溯到上上次插入节点的位置，进行判断，以此类推。\n\t- 如果在栈中找到了，我就将新元素插入到该节点的右孩子处，并把原来的右子树当成是新元素的左子树。\n\t- 如果没在栈中找到，我就把新元素当成新的根节点，并把原来的数当成新元素的左子树。\n\n代码如下：\n\n```c++\nTreeNode* constructMaximumBinaryTree1(vector<int>& nums) {\n\tif (nums.size() == 0) return nullptr;\n\t\n\tstack<TreeNode*> st;\n\t\n\tauto end = nums.end();\n\t\n\tTreeNode *root = new TreeNode(nums[0]);\n\tTreeNode *p = root;\n\t\n\tst.push(root);\n\t\n\tfor(auto it = nums.begin() + 1; it != end; ++it) {\n\t\tint val = *it;\n\t\tTreeNode *t = new TreeNode(val);\n\t\t\n\t\tif (val < p->val) {\n\t\t\tp->right = t;\n\t\t} else {\n\t\t\twhile(!st.empty() && val > st.top()->val) st.pop();\n\t\t\tif (!st.empty()) {\n\t\t\t\tp = st.top();\n\t\t\t\tt->left = p->right;\n\t\t\t\tp->right = t;\n\t\t\t} else {\n\t\t\t\tt->left = root;\n\t\t\t\troot = t;\n\t\t\t}\n\t\t}\n\t\tp = t;\n\t\tst.push(p);\n\t}\n\t\n\treturn root;\n}\n```\n","slug":"Maximum-Binary-Tree","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oq0092qmcm6ef02x5k","content":"<blockquote>\n<p>第15天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-binary-tree/\">Maximum Binary Tree</a>。</p>\n<p>并不难的一道题，而且不同寻常的是用栈去做比用递归去做要方便一点。</p>\n<p>我这里的想法是，从左向右一直插入就好了，例如输入是<code>[3, 2, 1, 6, 0, 5]</code></p>\n<p>先插入 3 ，然后插入下一个元素时进行讨论：</p>\n<ul>\n<li>如果比上一次插入的元素要小，我就直接插入到上一次插入节点的右孩子处就好了。</li>\n<li>如果比上一次插入的元素要大，我就用栈回溯到上上次插入节点的位置，进行判断，以此类推。<ul>\n<li>如果在栈中找到了，我就将新元素插入到该节点的右孩子处，并把原来的右子树当成是新元素的左子树。</li>\n<li>如果没在栈中找到，我就把新元素当成新的根节点，并把原来的数当成新元素的左子树。</li>\n</ul>\n</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">constructMaximumBinaryTree1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nums.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;TreeNode*&gt; st;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> end = nums.end();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tTreeNode *root = <span class=\"keyword\">new</span> TreeNode(nums[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\tTreeNode *p = root;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tst.push(root);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = nums.begin() + <span class=\"number\">1</span>; it != end; ++it) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> val = *it;</span><br><span class=\"line\">\t\tTreeNode *t = <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (val &lt; p-&gt;val) &#123;</span><br><span class=\"line\">\t\t\tp-&gt;right = t;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(!st.empty() &amp;&amp; val &gt; st.top()-&gt;val) st.pop();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!st.empty()) &#123;</span><br><span class=\"line\">\t\t\t\tp = st.top();</span><br><span class=\"line\">\t\t\t\tt-&gt;left = p-&gt;right;</span><br><span class=\"line\">\t\t\t\tp-&gt;right = t;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tt-&gt;left = root;</span><br><span class=\"line\">\t\t\t\troot = t;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp = t;</span><br><span class=\"line\">\t\tst.push(p);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第15天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-binary-tree/\">Maximum Binary Tree</a>。</p>\n<p>并不难的一道题，而且不同寻常的是用栈去做比用递归去做要方便一点。</p>\n<p>我这里的想法是，从左向右一直插入就好了，例如输入是<code>[3, 2, 1, 6, 0, 5]</code></p>\n<p>先插入 3 ，然后插入下一个元素时进行讨论：</p>\n<ul>\n<li>如果比上一次插入的元素要小，我就直接插入到上一次插入节点的右孩子处就好了。</li>\n<li>如果比上一次插入的元素要大，我就用栈回溯到上上次插入节点的位置，进行判断，以此类推。<ul>\n<li>如果在栈中找到了，我就将新元素插入到该节点的右孩子处，并把原来的右子树当成是新元素的左子树。</li>\n<li>如果没在栈中找到，我就把新元素当成新的根节点，并把原来的数当成新元素的左子树。</li>\n</ul>\n</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">constructMaximumBinaryTree1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nums.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;TreeNode*&gt; st;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> end = nums.end();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tTreeNode *root = <span class=\"keyword\">new</span> TreeNode(nums[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\tTreeNode *p = root;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tst.push(root);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = nums.begin() + <span class=\"number\">1</span>; it != end; ++it) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> val = *it;</span><br><span class=\"line\">\t\tTreeNode *t = <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (val &lt; p-&gt;val) &#123;</span><br><span class=\"line\">\t\t\tp-&gt;right = t;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(!st.empty() &amp;&amp; val &gt; st.top()-&gt;val) st.pop();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!st.empty()) &#123;</span><br><span class=\"line\">\t\t\t\tp = st.top();</span><br><span class=\"line\">\t\t\t\tt-&gt;left = p-&gt;right;</span><br><span class=\"line\">\t\t\t\tp-&gt;right = t;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tt-&gt;left = root;</span><br><span class=\"line\">\t\t\t\troot = t;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp = t;</span><br><span class=\"line\">\t\tst.push(p);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Maximum Difference Between Node and Ancestor","date":"2020-01-04T13:04:02.000Z","_content":"\n> 第55天\n\n今天的题目是[Maximum Difference Between Node and Ancestor](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/):\n\n我们做一次后序遍历，维护一个子树的最大值和最小值，用当前节点的值与最大最小值求距离，并返回距离的最大值即可。\n\n```c++\nint maxAncestorDiff(TreeNode* root) {\n    if (root == nullptr) return -1;\n    int minVal, maxVal;\n    return maxAncestorDiff(root, minVal, maxVal);\n}\nint maxAncestorDiff1(TreeNode *root, int &minVal, int &maxVal) {\n    if (root == nullptr) return -1;\n    minVal = maxVal = root->val;\n    \n    int d = -1, leftMin, leftMax, rightMin, rightMax;\n    \n    if (root->left) {\n        int r = maxAncestorDiff(root->left, leftMin, leftMax);\n        d = max(r, max(abs(root->val - leftMin), abs(root->val - leftMax)));\n        minVal = min(minVal, leftMin);\n        maxVal = max(maxVal, leftMax);\n    }\n    if (root->right) {\n        int r = maxAncestorDiff(root->right, rightMin, rightMax);\n        d = max(d,max(r, max(abs(root->val - rightMax), abs(root->val - rightMin))));\n        minVal = min(minVal, rightMin);\n        maxVal = max(maxVal, rightMax);\n    }\n    if (!root->left && !root->right) return -1;\n    return d;\n}\n```\n\n这样做可能有点过于复杂了，我们可以把后序遍历转成先序遍历来，同样也需要维护最大值和最小值，不过因为是先序遍历，所以比较简单\n\n```c++\nint maxAncestorDiff(TreeNode* root) {\n    if (root == nullptr) return -1;\n    int minVal, maxVal;\n    minVal = maxVal = root->val;\n    return maxAncestorDiff(root, minVal, maxVal);\n}\n\nint maxAncestorDiff(TreeNode *root, int maxVal, int minVal) {\n    if (root == nullptr) return maxVal - minVal;\n    maxVal = max(maxVal, root->val);\n    minVal = min(minVal, root->val);\n    // cout << maxVal << \" \" << minVal << endl;\n    return max(maxAncestorDiff(root->left, maxVal, minVal),\n                maxAncestorDiff(root->right, maxVal, minVal));\n}\n```\n","source":"_posts/Maximum-Difference-Between-Node-and-Ancestor.md","raw":"---\ntitle: Maximum Difference Between Node and Ancestor\ndate: 2020-01-04T21:04:02.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第55天\n\n今天的题目是[Maximum Difference Between Node and Ancestor](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/):\n\n我们做一次后序遍历，维护一个子树的最大值和最小值，用当前节点的值与最大最小值求距离，并返回距离的最大值即可。\n\n```c++\nint maxAncestorDiff(TreeNode* root) {\n    if (root == nullptr) return -1;\n    int minVal, maxVal;\n    return maxAncestorDiff(root, minVal, maxVal);\n}\nint maxAncestorDiff1(TreeNode *root, int &minVal, int &maxVal) {\n    if (root == nullptr) return -1;\n    minVal = maxVal = root->val;\n    \n    int d = -1, leftMin, leftMax, rightMin, rightMax;\n    \n    if (root->left) {\n        int r = maxAncestorDiff(root->left, leftMin, leftMax);\n        d = max(r, max(abs(root->val - leftMin), abs(root->val - leftMax)));\n        minVal = min(minVal, leftMin);\n        maxVal = max(maxVal, leftMax);\n    }\n    if (root->right) {\n        int r = maxAncestorDiff(root->right, rightMin, rightMax);\n        d = max(d,max(r, max(abs(root->val - rightMax), abs(root->val - rightMin))));\n        minVal = min(minVal, rightMin);\n        maxVal = max(maxVal, rightMax);\n    }\n    if (!root->left && !root->right) return -1;\n    return d;\n}\n```\n\n这样做可能有点过于复杂了，我们可以把后序遍历转成先序遍历来，同样也需要维护最大值和最小值，不过因为是先序遍历，所以比较简单\n\n```c++\nint maxAncestorDiff(TreeNode* root) {\n    if (root == nullptr) return -1;\n    int minVal, maxVal;\n    minVal = maxVal = root->val;\n    return maxAncestorDiff(root, minVal, maxVal);\n}\n\nint maxAncestorDiff(TreeNode *root, int maxVal, int minVal) {\n    if (root == nullptr) return maxVal - minVal;\n    maxVal = max(maxVal, root->val);\n    minVal = min(minVal, root->val);\n    // cout << maxVal << \" \" << minVal << endl;\n    return max(maxAncestorDiff(root->left, maxVal, minVal),\n                maxAncestorDiff(root->right, maxVal, minVal));\n}\n```\n","slug":"Maximum-Difference-Between-Node-and-Ancestor","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oq0095qmcmddta92vq","content":"<blockquote>\n<p>第55天</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/\">Maximum Difference Between Node and Ancestor</a>:</p>\n<p>我们做一次后序遍历，维护一个子树的最大值和最小值，用当前节点的值与最大最小值求距离，并返回距离的最大值即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxAncestorDiff</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minVal, maxVal;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxAncestorDiff(root, minVal, maxVal);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxAncestorDiff1</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> &amp;minVal, <span class=\"keyword\">int</span> &amp;maxVal)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    minVal = maxVal = root-&gt;val;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = <span class=\"number\">-1</span>, leftMin, leftMax, rightMin, rightMax;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = maxAncestorDiff(root-&gt;left, leftMin, leftMax);</span><br><span class=\"line\">        d = max(r, max(<span class=\"built_in\">abs</span>(root-&gt;val - leftMin), <span class=\"built_in\">abs</span>(root-&gt;val - leftMax)));</span><br><span class=\"line\">        minVal = min(minVal, leftMin);</span><br><span class=\"line\">        maxVal = max(maxVal, leftMax);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = maxAncestorDiff(root-&gt;right, rightMin, rightMax);</span><br><span class=\"line\">        d = max(d,max(r, max(<span class=\"built_in\">abs</span>(root-&gt;val - rightMax), <span class=\"built_in\">abs</span>(root-&gt;val - rightMin))));</span><br><span class=\"line\">        minVal = min(minVal, rightMin);</span><br><span class=\"line\">        maxVal = max(maxVal, rightMax);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样做可能有点过于复杂了，我们可以把后序遍历转成先序遍历来，同样也需要维护最大值和最小值，不过因为是先序遍历，所以比较简单</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxAncestorDiff</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minVal, maxVal;</span><br><span class=\"line\">    minVal = maxVal = root-&gt;val;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxAncestorDiff(root, minVal, maxVal);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxAncestorDiff</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> maxVal, <span class=\"keyword\">int</span> minVal)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> maxVal - minVal;</span><br><span class=\"line\">    maxVal = max(maxVal, root-&gt;val);</span><br><span class=\"line\">    minVal = min(minVal, root-&gt;val);</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; maxVal &lt;&lt; &quot; &quot; &lt;&lt; minVal &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(maxAncestorDiff(root-&gt;left, maxVal, minVal),</span><br><span class=\"line\">                maxAncestorDiff(root-&gt;right, maxVal, minVal));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第55天</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/\">Maximum Difference Between Node and Ancestor</a>:</p>\n<p>我们做一次后序遍历，维护一个子树的最大值和最小值，用当前节点的值与最大最小值求距离，并返回距离的最大值即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxAncestorDiff</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minVal, maxVal;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxAncestorDiff(root, minVal, maxVal);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxAncestorDiff1</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> &amp;minVal, <span class=\"keyword\">int</span> &amp;maxVal)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    minVal = maxVal = root-&gt;val;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = <span class=\"number\">-1</span>, leftMin, leftMax, rightMin, rightMax;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = maxAncestorDiff(root-&gt;left, leftMin, leftMax);</span><br><span class=\"line\">        d = max(r, max(<span class=\"built_in\">abs</span>(root-&gt;val - leftMin), <span class=\"built_in\">abs</span>(root-&gt;val - leftMax)));</span><br><span class=\"line\">        minVal = min(minVal, leftMin);</span><br><span class=\"line\">        maxVal = max(maxVal, leftMax);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = maxAncestorDiff(root-&gt;right, rightMin, rightMax);</span><br><span class=\"line\">        d = max(d,max(r, max(<span class=\"built_in\">abs</span>(root-&gt;val - rightMax), <span class=\"built_in\">abs</span>(root-&gt;val - rightMin))));</span><br><span class=\"line\">        minVal = min(minVal, rightMin);</span><br><span class=\"line\">        maxVal = max(maxVal, rightMax);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样做可能有点过于复杂了，我们可以把后序遍历转成先序遍历来，同样也需要维护最大值和最小值，不过因为是先序遍历，所以比较简单</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxAncestorDiff</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minVal, maxVal;</span><br><span class=\"line\">    minVal = maxVal = root-&gt;val;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxAncestorDiff(root, minVal, maxVal);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxAncestorDiff</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> maxVal, <span class=\"keyword\">int</span> minVal)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> maxVal - minVal;</span><br><span class=\"line\">    maxVal = max(maxVal, root-&gt;val);</span><br><span class=\"line\">    minVal = min(minVal, root-&gt;val);</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; maxVal &lt;&lt; &quot; &quot; &lt;&lt; minVal &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(maxAncestorDiff(root-&gt;left, maxVal, minVal),</span><br><span class=\"line\">                maxAncestorDiff(root-&gt;right, maxVal, minVal));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Maximum Length of Repeated Subarray & Edit Distance","date":"2019-12-24T02:41:32.000Z","_content":"\n> 第48天。\n\n今天的题目是[Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/):\n\n一道DP的题目，有点像LCS。\n\n我们假定`dp[i, j]`为以`A[i]`结尾和以`B[j]`结尾的最长重合子数组的长度，则：\n\n$$\ndp[i, j] = \\left\\{\n    \\begin{aligned}\n        0 &, & A[i] \\neq B[i] \\\\\n        dp[i-1, j-1] + 1 &, & A[i] = B[i]\n    \\end{aligned}\n\\right.\n$$\n\n然后我们只需要对`dp`求最大值即可得到最长重复子数组的长度：\n\n```c++\nint findLength(vector<int>& A, vector<int>& B) {\n    int n = A.size();\n    if (n == 0) return 0;\n    \n    vector<int> dp(n+1, 0);\n    int res = 0;\n    for(int i = 1;i <= n; i++) {\n        for(int j = n;j >= 1; j--) {\n            dp[j] = (A[i-1] == B[j-1]) ? (dp[j-1] + 1) : 0;\n            res = max(dp[j], res);\n        }\n    }\n    \n    return res;\n}\n```\n\n来多一道[Edit Distance](https://leetcode.com/problems/edit-distance/):\n\n一道hard的题目，一次直接AC了。也是DP的题目，这道题让人觉得麻烦的是，它支持三种操作：\n\n- 插入\n- 删除\n- 替换\n\n一开始会觉得，插入和删除有点难区分，后来想了想，好像他们的代价是一样的，所以我们可以只用删除，不用插入，所以我们可以来解决这个问题：\n\n`dp[i, j]`为`word1[0..i]`和`word2[0..j]`的编辑距离：\n\n- 如果`word1[i] == word2[j]`的话，`dp[i,j] = dp[i-1, j-1]`，即不需要做任何编辑\n- 如果`word1[i] != word2[j]`的话，我们可以尝试删除或替换两种操作\n    - 删除`word1[i]`\n    - 删除`word2[i]`\n    - 替换`word1[i]`或`word2[i]`\n\n则`dp[i, j] = min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1])`\n\n边界条件就是，当`i==0`时，`dp[i, j] = j`,当`j==0`时，`dp[i, j] = i`。\n\n所以我们可以写出动规方程：\n\n\n$$\ndp[i, j] = \\left\\{\n    \\begin{aligned}\n        i &, & i = 0 \\\\\n        j &, & j = 0 \\\\\n        dp[i-1, j-1] &, & word1[i] = word2[j] \\\\\n        min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1]) &, & A[i] \\neq B[i]\n    \\end{aligned}\n\\right.\n$$\n\n因此，代码如下：\n\n```c++\nint minDistance(string word1, string word2) {\n    int n1 = word1.size(), n2 = word2.size();\n    vector<int> dp(n2 + 1);\n    for(int j = 0;j <= n2; j++) {\n        dp[j] = j;\n    }\n    int prev;\n    for(int i = 1; i <= n1; i++) {\n        prev = dp[0];\n        dp[0] = i;\n        for(int j = 1;j <= n2; j++) {\n            swap(dp[j], prev);\n            if (word1[i-1] != word2[j-1]) {\n                dp[j] = min(min(dp[j-1], dp[j]), prev) + 1;\n            }\n        }\n    }\n    return dp[n2];\n}\n```\n","source":"_posts/Maximum-Length-of-Repeated-Subarray.md","raw":"---\ntitle: Maximum Length of Repeated Subarray & Edit Distance\ndate: 2019-12-24T10:41:32.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第48天。\n\n今天的题目是[Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/):\n\n一道DP的题目，有点像LCS。\n\n我们假定`dp[i, j]`为以`A[i]`结尾和以`B[j]`结尾的最长重合子数组的长度，则：\n\n$$\ndp[i, j] = \\left\\{\n    \\begin{aligned}\n        0 &, & A[i] \\neq B[i] \\\\\n        dp[i-1, j-1] + 1 &, & A[i] = B[i]\n    \\end{aligned}\n\\right.\n$$\n\n然后我们只需要对`dp`求最大值即可得到最长重复子数组的长度：\n\n```c++\nint findLength(vector<int>& A, vector<int>& B) {\n    int n = A.size();\n    if (n == 0) return 0;\n    \n    vector<int> dp(n+1, 0);\n    int res = 0;\n    for(int i = 1;i <= n; i++) {\n        for(int j = n;j >= 1; j--) {\n            dp[j] = (A[i-1] == B[j-1]) ? (dp[j-1] + 1) : 0;\n            res = max(dp[j], res);\n        }\n    }\n    \n    return res;\n}\n```\n\n来多一道[Edit Distance](https://leetcode.com/problems/edit-distance/):\n\n一道hard的题目，一次直接AC了。也是DP的题目，这道题让人觉得麻烦的是，它支持三种操作：\n\n- 插入\n- 删除\n- 替换\n\n一开始会觉得，插入和删除有点难区分，后来想了想，好像他们的代价是一样的，所以我们可以只用删除，不用插入，所以我们可以来解决这个问题：\n\n`dp[i, j]`为`word1[0..i]`和`word2[0..j]`的编辑距离：\n\n- 如果`word1[i] == word2[j]`的话，`dp[i,j] = dp[i-1, j-1]`，即不需要做任何编辑\n- 如果`word1[i] != word2[j]`的话，我们可以尝试删除或替换两种操作\n    - 删除`word1[i]`\n    - 删除`word2[i]`\n    - 替换`word1[i]`或`word2[i]`\n\n则`dp[i, j] = min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1])`\n\n边界条件就是，当`i==0`时，`dp[i, j] = j`,当`j==0`时，`dp[i, j] = i`。\n\n所以我们可以写出动规方程：\n\n\n$$\ndp[i, j] = \\left\\{\n    \\begin{aligned}\n        i &, & i = 0 \\\\\n        j &, & j = 0 \\\\\n        dp[i-1, j-1] &, & word1[i] = word2[j] \\\\\n        min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1]) &, & A[i] \\neq B[i]\n    \\end{aligned}\n\\right.\n$$\n\n因此，代码如下：\n\n```c++\nint minDistance(string word1, string word2) {\n    int n1 = word1.size(), n2 = word2.size();\n    vector<int> dp(n2 + 1);\n    for(int j = 0;j <= n2; j++) {\n        dp[j] = j;\n    }\n    int prev;\n    for(int i = 1; i <= n1; i++) {\n        prev = dp[0];\n        dp[0] = i;\n        for(int j = 1;j <= n2; j++) {\n            swap(dp[j], prev);\n            if (word1[i-1] != word2[j-1]) {\n                dp[j] = min(min(dp[j-1], dp[j]), prev) + 1;\n            }\n        }\n    }\n    return dp[n2];\n}\n```\n","slug":"Maximum-Length-of-Repeated-Subarray","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69or0098qmcmd25me45k","content":"<blockquote>\n<p>第48天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-length-of-repeated-subarray/\">Maximum Length of Repeated Subarray</a>:</p>\n<p>一道DP的题目，有点像LCS。</p>\n<p>我们假定<code>dp[i, j]</code>为以<code>A[i]</code>结尾和以<code>B[j]</code>结尾的最长重合子数组的长度，则：</p>\n<p>$$<br>dp[i, j] = \\left{<br>    \\begin{aligned}<br>        0 &amp;, &amp; A[i] \\neq B[i] \\<br>        dp[i-1, j-1] + 1 &amp;, &amp; A[i] = B[i]<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>然后我们只需要对<code>dp</code>求最大值即可得到最长重复子数组的长度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = A.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = n;j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            dp[j] = (A[i<span class=\"number\">-1</span>] == B[j<span class=\"number\">-1</span>]) ? (dp[j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>) : <span class=\"number\">0</span>;</span><br><span class=\"line\">            res = max(dp[j], res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来多一道<a href=\"https://leetcode.com/problems/edit-distance/\">Edit Distance</a>:</p>\n<p>一道hard的题目，一次直接AC了。也是DP的题目，这道题让人觉得麻烦的是，它支持三种操作：</p>\n<ul>\n<li>插入</li>\n<li>删除</li>\n<li>替换</li>\n</ul>\n<p>一开始会觉得，插入和删除有点难区分，后来想了想，好像他们的代价是一样的，所以我们可以只用删除，不用插入，所以我们可以来解决这个问题：</p>\n<p><code>dp[i, j]</code>为<code>word1[0..i]</code>和<code>word2[0..j]</code>的编辑距离：</p>\n<ul>\n<li>如果<code>word1[i] == word2[j]</code>的话，<code>dp[i,j] = dp[i-1, j-1]</code>，即不需要做任何编辑</li>\n<li>如果<code>word1[i] != word2[j]</code>的话，我们可以尝试删除或替换两种操作<ul>\n<li>删除<code>word1[i]</code></li>\n<li>删除<code>word2[i]</code></li>\n<li>替换<code>word1[i]</code>或<code>word2[i]</code></li>\n</ul>\n</li>\n</ul>\n<p>则<code>dp[i, j] = min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1])</code></p>\n<p>边界条件就是，当<code>i==0</code>时，<code>dp[i, j] = j</code>,当<code>j==0</code>时，<code>dp[i, j] = i</code>。</p>\n<p>所以我们可以写出动规方程：</p>\n<p>$$<br>dp[i, j] = \\left{<br>    \\begin{aligned}<br>        i &amp;, &amp; i = 0 \\<br>        j &amp;, &amp; j = 0 \\<br>        dp[i-1, j-1] &amp;, &amp; word1[i] = word2[j] \\<br>        min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1]) &amp;, &amp; A[i] \\neq B[i]<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>因此，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDistance</span><span class=\"params\">(<span class=\"built_in\">string</span> word1, <span class=\"built_in\">string</span> word2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n1 = word1.size(), n2 = word2.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n2 + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt;= n2; j++) &#123;</span><br><span class=\"line\">        dp[j] = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prev;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n1; i++) &#123;</span><br><span class=\"line\">        prev = dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt;= n2; j++) &#123;</span><br><span class=\"line\">            swap(dp[j], prev);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (word1[i<span class=\"number\">-1</span>] != word2[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                dp[j] = min(min(dp[j<span class=\"number\">-1</span>], dp[j]), prev) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第48天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-length-of-repeated-subarray/\">Maximum Length of Repeated Subarray</a>:</p>\n<p>一道DP的题目，有点像LCS。</p>\n<p>我们假定<code>dp[i, j]</code>为以<code>A[i]</code>结尾和以<code>B[j]</code>结尾的最长重合子数组的长度，则：</p>\n<p>$$<br>dp[i, j] = \\left{<br>    \\begin{aligned}<br>        0 &amp;, &amp; A[i] \\neq B[i] \\<br>        dp[i-1, j-1] + 1 &amp;, &amp; A[i] = B[i]<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>然后我们只需要对<code>dp</code>求最大值即可得到最长重复子数组的长度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = A.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = n;j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            dp[j] = (A[i<span class=\"number\">-1</span>] == B[j<span class=\"number\">-1</span>]) ? (dp[j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>) : <span class=\"number\">0</span>;</span><br><span class=\"line\">            res = max(dp[j], res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来多一道<a href=\"https://leetcode.com/problems/edit-distance/\">Edit Distance</a>:</p>\n<p>一道hard的题目，一次直接AC了。也是DP的题目，这道题让人觉得麻烦的是，它支持三种操作：</p>\n<ul>\n<li>插入</li>\n<li>删除</li>\n<li>替换</li>\n</ul>\n<p>一开始会觉得，插入和删除有点难区分，后来想了想，好像他们的代价是一样的，所以我们可以只用删除，不用插入，所以我们可以来解决这个问题：</p>\n<p><code>dp[i, j]</code>为<code>word1[0..i]</code>和<code>word2[0..j]</code>的编辑距离：</p>\n<ul>\n<li>如果<code>word1[i] == word2[j]</code>的话，<code>dp[i,j] = dp[i-1, j-1]</code>，即不需要做任何编辑</li>\n<li>如果<code>word1[i] != word2[j]</code>的话，我们可以尝试删除或替换两种操作<ul>\n<li>删除<code>word1[i]</code></li>\n<li>删除<code>word2[i]</code></li>\n<li>替换<code>word1[i]</code>或<code>word2[i]</code></li>\n</ul>\n</li>\n</ul>\n<p>则<code>dp[i, j] = min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1])</code></p>\n<p>边界条件就是，当<code>i==0</code>时，<code>dp[i, j] = j</code>,当<code>j==0</code>时，<code>dp[i, j] = i</code>。</p>\n<p>所以我们可以写出动规方程：</p>\n<p>$$<br>dp[i, j] = \\left{<br>    \\begin{aligned}<br>        i &amp;, &amp; i = 0 \\<br>        j &amp;, &amp; j = 0 \\<br>        dp[i-1, j-1] &amp;, &amp; word1[i] = word2[j] \\<br>        min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1]) &amp;, &amp; A[i] \\neq B[i]<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>因此，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDistance</span><span class=\"params\">(<span class=\"built_in\">string</span> word1, <span class=\"built_in\">string</span> word2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n1 = word1.size(), n2 = word2.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n2 + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt;= n2; j++) &#123;</span><br><span class=\"line\">        dp[j] = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prev;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n1; i++) &#123;</span><br><span class=\"line\">        prev = dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt;= n2; j++) &#123;</span><br><span class=\"line\">            swap(dp[j], prev);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (word1[i<span class=\"number\">-1</span>] != word2[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                dp[j] = min(min(dp[j<span class=\"number\">-1</span>], dp[j]), prev) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Maximum Level Sum of a Binary Tree","date":"2019-12-26T15:07:45.000Z","_content":"\n> 第49天。\n\n今天的题目是[Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/):\n\n送分题，直接用层次便利计算每一层的元素之和，然后去最大即可。\n\n```c++\nint maxLevelSum(TreeNode* root) {\n    if (!root) return -1;\n    \n    int max_level = -1, max_sum = INT_MIN;\n    \n    queue<TreeNode *> q;\n    q.push(root);\n    \n    int cur_level = 1, cur_sum;\n    \n    while(!q.empty()) {\n        cur_sum = 0;\n        for(int i = 0, size = q.size(); i < size; i++) {\n            root = q.front(); q.pop();\n            cur_sum += root->val;\n            if (root->left) q.push(root->left);\n            if (root->right) q.push(root->right);\n        }\n        if (cur_sum > max_sum) {\n            max_sum = cur_sum;\n            max_level = cur_level;\n        }\n        cur_level++;\n    }\n    \n    return max_level;\n}\n```\n","source":"_posts/Maximum-Level-Sum-of-a-Binary-Tree.md","raw":"---\ntitle: Maximum Level Sum of a Binary Tree\ndate: 2019-12-26T23:07:45.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第49天。\n\n今天的题目是[Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/):\n\n送分题，直接用层次便利计算每一层的元素之和，然后去最大即可。\n\n```c++\nint maxLevelSum(TreeNode* root) {\n    if (!root) return -1;\n    \n    int max_level = -1, max_sum = INT_MIN;\n    \n    queue<TreeNode *> q;\n    q.push(root);\n    \n    int cur_level = 1, cur_sum;\n    \n    while(!q.empty()) {\n        cur_sum = 0;\n        for(int i = 0, size = q.size(); i < size; i++) {\n            root = q.front(); q.pop();\n            cur_sum += root->val;\n            if (root->left) q.push(root->left);\n            if (root->right) q.push(root->right);\n        }\n        if (cur_sum > max_sum) {\n            max_sum = cur_sum;\n            max_level = cur_level;\n        }\n        cur_level++;\n    }\n    \n    return max_level;\n}\n```\n","slug":"Maximum-Level-Sum-of-a-Binary-Tree","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69or009bqmcm3hlsdm03","content":"<blockquote>\n<p>第49天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/\">Maximum Level Sum of a Binary Tree</a>:</p>\n<p>送分题，直接用层次便利计算每一层的元素之和，然后去最大即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxLevelSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_level = <span class=\"number\">-1</span>, max_sum = INT_MIN;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> cur_level = <span class=\"number\">1</span>, cur_sum;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">        cur_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = q.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">            root = q.front(); q.pop();</span><br><span class=\"line\">            cur_sum += root-&gt;val;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur_sum &gt; max_sum) &#123;</span><br><span class=\"line\">            max_sum = cur_sum;</span><br><span class=\"line\">            max_level = cur_level;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur_level++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_level;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第49天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/\">Maximum Level Sum of a Binary Tree</a>:</p>\n<p>送分题，直接用层次便利计算每一层的元素之和，然后去最大即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxLevelSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_level = <span class=\"number\">-1</span>, max_sum = INT_MIN;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> cur_level = <span class=\"number\">1</span>, cur_sum;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">        cur_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = q.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">            root = q.front(); q.pop();</span><br><span class=\"line\">            cur_sum += root-&gt;val;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur_sum &gt; max_sum) &#123;</span><br><span class=\"line\">            max_sum = cur_sum;</span><br><span class=\"line\">            max_level = cur_level;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur_level++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_level;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Maximum-Swap","date":"2017-12-11T02:00:36.000Z","_content":"\n第75天。\n\n今天的题目是[Maximum Swap](https://leetcode.com/problems/maximum-swap/description/):\n\n> Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.\n>\n> Example 1:\n> Input: 2736\n> Output: 7236\n> Explanation: Swap the number 2 and the number 7.\n> Example 2:\n> Input: 9973\n> Output: 9973\n> Explanation: No swap.\n> Note:\n> The given number is in the range [0, 10^8]\n\n怎么说呢，写一个不优雅的解法还是挺简单的。\n\n先把`num`分解成多个`digit`，然后尝试在找出最大的，如果最大的值和最高位不同，我们就交换，如果相同，我们就找出除去最高位的最大值，直到找不到能交换的，或者交换一次，我们就退出。\n\n然后把`digit`按照对应的次序还原即可：\n\n```c++\nint maximumSwap(int num) {\n    vector<int> t;\n    while(num != 0) {\n        t.push_back(num % 10);\n        num /= 10;\n    }\n\n    int k = t.size() - 1;\n    while(k >= 0) {\n        auto max = max_element(t.begin(),t.begin() + k + 1);\n        if (*max != t[k]) {\n            int a = *max;\n            *max = t[k];\n            t[k] = a;\n            break;\n        }\n        k--;\n    }\n\n    for(auto it = t.rbegin();it != t.rend();it++) {\n        num = 10 * num + *it;\n    }\n    return num;\n}\n```\n\n然后是`dicuss`中的解法,好像想法差不多。\n\n```c++\nint maximumSwap(int num) {\n    string numString = to_string(num);\n    int n = numString.length();\n    vector<int> dpPosition(n, -1);\n\n    int curMaxPos = n - 1;\n    for (int i = n - 1; i >= 0; i--) {\n        if (numString[i] > numString[curMaxPos]) {\n            curMaxPos = i;\n        }\n        dpPosition[i] = curMaxPos;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if(numString[dpPosition[i]] != numString[i]) {\n            swap(numString[i], numString[dpPosition[i]]);\n            break;\n        }\n    }\n\n    return stoi(numString);\n}\n```\n","source":"_posts/Maximum-Swap.md","raw":"---\ntitle: Maximum-Swap\ndate: 2017-12-11T10:00:36.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第75天。\n\n今天的题目是[Maximum Swap](https://leetcode.com/problems/maximum-swap/description/):\n\n> Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.\n>\n> Example 1:\n> Input: 2736\n> Output: 7236\n> Explanation: Swap the number 2 and the number 7.\n> Example 2:\n> Input: 9973\n> Output: 9973\n> Explanation: No swap.\n> Note:\n> The given number is in the range [0, 10^8]\n\n怎么说呢，写一个不优雅的解法还是挺简单的。\n\n先把`num`分解成多个`digit`，然后尝试在找出最大的，如果最大的值和最高位不同，我们就交换，如果相同，我们就找出除去最高位的最大值，直到找不到能交换的，或者交换一次，我们就退出。\n\n然后把`digit`按照对应的次序还原即可：\n\n```c++\nint maximumSwap(int num) {\n    vector<int> t;\n    while(num != 0) {\n        t.push_back(num % 10);\n        num /= 10;\n    }\n\n    int k = t.size() - 1;\n    while(k >= 0) {\n        auto max = max_element(t.begin(),t.begin() + k + 1);\n        if (*max != t[k]) {\n            int a = *max;\n            *max = t[k];\n            t[k] = a;\n            break;\n        }\n        k--;\n    }\n\n    for(auto it = t.rbegin();it != t.rend();it++) {\n        num = 10 * num + *it;\n    }\n    return num;\n}\n```\n\n然后是`dicuss`中的解法,好像想法差不多。\n\n```c++\nint maximumSwap(int num) {\n    string numString = to_string(num);\n    int n = numString.length();\n    vector<int> dpPosition(n, -1);\n\n    int curMaxPos = n - 1;\n    for (int i = n - 1; i >= 0; i--) {\n        if (numString[i] > numString[curMaxPos]) {\n            curMaxPos = i;\n        }\n        dpPosition[i] = curMaxPos;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if(numString[dpPosition[i]] != numString[i]) {\n            swap(numString[i], numString[dpPosition[i]]);\n            break;\n        }\n    }\n\n    return stoi(numString);\n}\n```\n","slug":"Maximum-Swap","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69os009eqmcm8mnwf5kx","content":"<p>第75天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-swap/description/\">Maximum Swap</a>:</p>\n<blockquote>\n<p>Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.</p>\n<p>Example 1:<br>Input: 2736<br>Output: 7236<br>Explanation: Swap the number 2 and the number 7.<br>Example 2:<br>Input: 9973<br>Output: 9973<br>Explanation: No swap.<br>Note:<br>The given number is in the range [0, 10^8]</p>\n</blockquote>\n<p>怎么说呢，写一个不优雅的解法还是挺简单的。</p>\n<p>先把<code>num</code>分解成多个<code>digit</code>，然后尝试在找出最大的，如果最大的值和最高位不同，我们就交换，如果相同，我们就找出除去最高位的最大值，直到找不到能交换的，或者交换一次，我们就退出。</p>\n<p>然后把<code>digit</code>按照对应的次序还原即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximumSwap</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(num != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        t.push_back(num % <span class=\"number\">10</span>);</span><br><span class=\"line\">        num /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = t.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> max = max_element(t.begin(),t.begin() + k + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*max != t[k]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = *max;</span><br><span class=\"line\">            *max = t[k];</span><br><span class=\"line\">            t[k] = a;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = t.rbegin();it != t.rend();it++) &#123;</span><br><span class=\"line\">        num = <span class=\"number\">10</span> * num + *it;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的解法,好像想法差不多。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximumSwap</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> numString = to_string(num);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = numString.length();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dpPosition</span><span class=\"params\">(n, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> curMaxPos = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numString[i] &gt; numString[curMaxPos]) &#123;</span><br><span class=\"line\">            curMaxPos = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dpPosition[i] = curMaxPos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(numString[dpPosition[i]] != numString[i]) &#123;</span><br><span class=\"line\">            swap(numString[i], numString[dpPosition[i]]);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stoi(numString);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第75天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/maximum-swap/description/\">Maximum Swap</a>:</p>\n<blockquote>\n<p>Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.</p>\n<p>Example 1:<br>Input: 2736<br>Output: 7236<br>Explanation: Swap the number 2 and the number 7.<br>Example 2:<br>Input: 9973<br>Output: 9973<br>Explanation: No swap.<br>Note:<br>The given number is in the range [0, 10^8]</p>\n</blockquote>\n<p>怎么说呢，写一个不优雅的解法还是挺简单的。</p>\n<p>先把<code>num</code>分解成多个<code>digit</code>，然后尝试在找出最大的，如果最大的值和最高位不同，我们就交换，如果相同，我们就找出除去最高位的最大值，直到找不到能交换的，或者交换一次，我们就退出。</p>\n<p>然后把<code>digit</code>按照对应的次序还原即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximumSwap</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(num != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        t.push_back(num % <span class=\"number\">10</span>);</span><br><span class=\"line\">        num /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = t.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> max = max_element(t.begin(),t.begin() + k + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*max != t[k]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = *max;</span><br><span class=\"line\">            *max = t[k];</span><br><span class=\"line\">            t[k] = a;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = t.rbegin();it != t.rend();it++) &#123;</span><br><span class=\"line\">        num = <span class=\"number\">10</span> * num + *it;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的解法,好像想法差不多。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximumSwap</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> numString = to_string(num);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = numString.length();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dpPosition</span><span class=\"params\">(n, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> curMaxPos = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numString[i] &gt; numString[curMaxPos]) &#123;</span><br><span class=\"line\">            curMaxPos = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dpPosition[i] = curMaxPos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(numString[dpPosition[i]] != numString[i]) &#123;</span><br><span class=\"line\">            swap(numString[i], numString[dpPosition[i]]);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stoi(numString);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Maximum Product Subarray","date":"2017-10-02T06:58:46.000Z","_content":"\n打卡，第9天\n\n今天这道题做了好久。。。\n\n> Find the contiguous subarray within an array (containing at least one number) which has the largest product.\n> \n> For example, given the array [2,3,-2,4],\n> the contiguous subarray [2,3] has the largest product = 6.\n\n看到这道题，就让我想起了昨天做得那道[Longest Substring Without Repeating Characters](https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/)。\n\n看起来很像是同一类的题目，想着用同一种方法去做，然后就考虑了好多奇奇怪怪的情况，最后代码写的及其混乱。\n\n```c++\nint maxProduct(vector<int>& nums) {\n    int i = 0,j = 0;\n    int ret = INT_MIN;\n    int now = 0;\n\n    for(j = 0;j < nums.size();j++){\n        if (nums[j] == 0){\n            while(now < 0 && i < j -1)\n                now /= nums[i++];\n            ret = max(ret,now);\n            if (ret < 0) ret = 0;\n            now = 0;\n            i = j+1;\n        } else {\n            now = (now)?now*nums[j]:nums[j];\n            ret = max(ret,now);\n        }\n    }\n\n    while(now < 0 && i < j - 1)\n        now /= nums[i++];\n    ret = max(ret,now);\n    return ret;\n}\n```\n\n这还是做完后进行了一些删减的答案，看起来很复杂，要我现在去解释它都有点困难。\n\n先提提我的思路：\n\n- 和昨天的一样，我用两个下标来标识当前`Subarray`,也就是说，然后让`j`不断向前去遍历。\n\n- 我需要考虑的就是什么时候`i`向前，我的想法是：\n\n    > 当我们遇到一个0时，我们需要把i改成j+1,因为正常情况下`Subarray`中如果有个`0`，那么`Subarray`的乘积就必定是0，为什么说是正常情况呢，因为如果当前最大乘积小于0的话，那么我们遇到一个`0`，要把最大乘积改成`0`.\n\n- 但是如果我们遇到这样的数组`2 -1 4 0`,我们当前的策略的返回值是`2`，但真正应该是4，因此另一个`i`向前的情况是：\n\n    > 遇到一个`0`或遍历完整个数组，我们需要让`i`向前移动，直到让当前乘积变成大于0，或者到达`j`。\n\n最后将这一大段思路变成代码就成了我上面写的了，其实仔细想想，这些思路其实并不复杂，只是有点繁琐，如果心能静点的话，应该可以更快的AC掉这道题。\n\n下面是`dicuss`中的方法：\n\n```c++\nint maxProduct(int A[], int n) {\n    // store the result that is the max we have found so far\n    int r = A[0];\n\n    // imax/imin stores the max/min product of\n    // subarray that ends with the current number A[i]\n    for (int i = 1, imax = r, imin = r; i < n; i++) {\n        // multiplied by a negative makes big number smaller, small number bigger\n        // so we redefine the extremums by swapping them\n        if (A[i] < 0)\n            swap(imax, imin);\n\n        // max/min product for the current number is either the current number itself\n        // or the max/min by the previous number times the current one\n        imax = max(A[i], imax * A[i]);\n        imin = min(A[i], imin * A[i]);\n\n        // the newly computed max value is a candidate for our global result\n        r = max(r, imax);\n    }\n    return r;\n}\n```\n\n把注释去掉话，其实没几句话，说实话，第一次看没看懂，分析一下他的思路：\n\n- 同样是遍历，但是它维护的不是下标，而是在A[0:j]中的子数组的最大值imax和子数组最小值imin.\n\n- 他用的是减治法，大概的想法是，我们知道A[0:n-1]imax和imin，我们如果求出A[0:n]的`imax,imin`。\n\n    - 如果`A[n]>=0`,那么`imax = max(A[n],imax*A[n]);imin = min(A[n],imin*A[n])`\n    - 如果`A[n] < 0`，那么`imin = min(A[n],imax*A[n]);imax = max(A[n],imin*A[n])`\n","source":"_posts/MaximumProductSubarray.md","raw":"---\ntitle: Maximum Product Subarray\ndate: 2017-10-02T14:58:46.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 动态规划\n---\n\n打卡，第9天\n\n今天这道题做了好久。。。\n\n> Find the contiguous subarray within an array (containing at least one number) which has the largest product.\n> \n> For example, given the array [2,3,-2,4],\n> the contiguous subarray [2,3] has the largest product = 6.\n\n看到这道题，就让我想起了昨天做得那道[Longest Substring Without Repeating Characters](https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/)。\n\n看起来很像是同一类的题目，想着用同一种方法去做，然后就考虑了好多奇奇怪怪的情况，最后代码写的及其混乱。\n\n```c++\nint maxProduct(vector<int>& nums) {\n    int i = 0,j = 0;\n    int ret = INT_MIN;\n    int now = 0;\n\n    for(j = 0;j < nums.size();j++){\n        if (nums[j] == 0){\n            while(now < 0 && i < j -1)\n                now /= nums[i++];\n            ret = max(ret,now);\n            if (ret < 0) ret = 0;\n            now = 0;\n            i = j+1;\n        } else {\n            now = (now)?now*nums[j]:nums[j];\n            ret = max(ret,now);\n        }\n    }\n\n    while(now < 0 && i < j - 1)\n        now /= nums[i++];\n    ret = max(ret,now);\n    return ret;\n}\n```\n\n这还是做完后进行了一些删减的答案，看起来很复杂，要我现在去解释它都有点困难。\n\n先提提我的思路：\n\n- 和昨天的一样，我用两个下标来标识当前`Subarray`,也就是说，然后让`j`不断向前去遍历。\n\n- 我需要考虑的就是什么时候`i`向前，我的想法是：\n\n    > 当我们遇到一个0时，我们需要把i改成j+1,因为正常情况下`Subarray`中如果有个`0`，那么`Subarray`的乘积就必定是0，为什么说是正常情况呢，因为如果当前最大乘积小于0的话，那么我们遇到一个`0`，要把最大乘积改成`0`.\n\n- 但是如果我们遇到这样的数组`2 -1 4 0`,我们当前的策略的返回值是`2`，但真正应该是4，因此另一个`i`向前的情况是：\n\n    > 遇到一个`0`或遍历完整个数组，我们需要让`i`向前移动，直到让当前乘积变成大于0，或者到达`j`。\n\n最后将这一大段思路变成代码就成了我上面写的了，其实仔细想想，这些思路其实并不复杂，只是有点繁琐，如果心能静点的话，应该可以更快的AC掉这道题。\n\n下面是`dicuss`中的方法：\n\n```c++\nint maxProduct(int A[], int n) {\n    // store the result that is the max we have found so far\n    int r = A[0];\n\n    // imax/imin stores the max/min product of\n    // subarray that ends with the current number A[i]\n    for (int i = 1, imax = r, imin = r; i < n; i++) {\n        // multiplied by a negative makes big number smaller, small number bigger\n        // so we redefine the extremums by swapping them\n        if (A[i] < 0)\n            swap(imax, imin);\n\n        // max/min product for the current number is either the current number itself\n        // or the max/min by the previous number times the current one\n        imax = max(A[i], imax * A[i]);\n        imin = min(A[i], imin * A[i]);\n\n        // the newly computed max value is a candidate for our global result\n        r = max(r, imax);\n    }\n    return r;\n}\n```\n\n把注释去掉话，其实没几句话，说实话，第一次看没看懂，分析一下他的思路：\n\n- 同样是遍历，但是它维护的不是下标，而是在A[0:j]中的子数组的最大值imax和子数组最小值imin.\n\n- 他用的是减治法，大概的想法是，我们知道A[0:n-1]imax和imin，我们如果求出A[0:n]的`imax,imin`。\n\n    - 如果`A[n]>=0`,那么`imax = max(A[n],imax*A[n]);imin = min(A[n],imin*A[n])`\n    - 如果`A[n] < 0`，那么`imin = min(A[n],imax*A[n]);imax = max(A[n],imin*A[n])`\n","slug":"MaximumProductSubarray","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ot009hqmcm5j15boue","content":"<p>打卡，第9天</p>\n<p>今天这道题做了好久。。。</p>\n<blockquote>\n<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>\n<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p>\n</blockquote>\n<p>看到这道题，就让我想起了昨天做得那道<a href=\"https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/\">Longest Substring Without Repeating Characters</a>。</p>\n<p>看起来很像是同一类的题目，想着用同一种方法去做，然后就考虑了好多奇奇怪怪的情况，最后代码写的及其混乱。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>;j &lt; nums.size();j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[j] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(now &lt; <span class=\"number\">0</span> &amp;&amp; i &lt; j <span class=\"number\">-1</span>)</span><br><span class=\"line\">                now /= nums[i++];</span><br><span class=\"line\">            ret = max(ret,now);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">            now = <span class=\"number\">0</span>;</span><br><span class=\"line\">            i = j+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            now = (now)?now*nums[j]:nums[j];</span><br><span class=\"line\">            ret = max(ret,now);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(now &lt; <span class=\"number\">0</span> &amp;&amp; i &lt; j - <span class=\"number\">1</span>)</span><br><span class=\"line\">        now /= nums[i++];</span><br><span class=\"line\">    ret = max(ret,now);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这还是做完后进行了一些删减的答案，看起来很复杂，要我现在去解释它都有点困难。</p>\n<p>先提提我的思路：</p>\n<ul>\n<li><p>和昨天的一样，我用两个下标来标识当前<code>Subarray</code>,也就是说，然后让<code>j</code>不断向前去遍历。</p>\n</li>\n<li><p>我需要考虑的就是什么时候<code>i</code>向前，我的想法是：</p>\n<blockquote>\n<p>当我们遇到一个0时，我们需要把i改成j+1,因为正常情况下<code>Subarray</code>中如果有个<code>0</code>，那么<code>Subarray</code>的乘积就必定是0，为什么说是正常情况呢，因为如果当前最大乘积小于0的话，那么我们遇到一个<code>0</code>，要把最大乘积改成<code>0</code>.</p>\n</blockquote>\n</li>\n<li><p>但是如果我们遇到这样的数组<code>2 -1 4 0</code>,我们当前的策略的返回值是<code>2</code>，但真正应该是4，因此另一个<code>i</code>向前的情况是：</p>\n<blockquote>\n<p>遇到一个<code>0</code>或遍历完整个数组，我们需要让<code>i</code>向前移动，直到让当前乘积变成大于0，或者到达<code>j</code>。</p>\n</blockquote>\n</li>\n</ul>\n<p>最后将这一大段思路变成代码就成了我上面写的了，其实仔细想想，这些思路其实并不复杂，只是有点繁琐，如果心能静点的话，应该可以更快的AC掉这道题。</p>\n<p>下面是<code>dicuss</code>中的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// store the result that is the max we have found so far</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = A[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// imax/imin stores the max/min product of</span></span><br><span class=\"line\">    <span class=\"comment\">// subarray that ends with the current number A[i]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, imax = r, imin = r; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// multiplied by a negative makes big number smaller, small number bigger</span></span><br><span class=\"line\">        <span class=\"comment\">// so we redefine the extremums by swapping them</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[i] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            swap(imax, imin);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// max/min product for the current number is either the current number itself</span></span><br><span class=\"line\">        <span class=\"comment\">// or the max/min by the previous number times the current one</span></span><br><span class=\"line\">        imax = max(A[i], imax * A[i]);</span><br><span class=\"line\">        imin = min(A[i], imin * A[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// the newly computed max value is a candidate for our global result</span></span><br><span class=\"line\">        r = max(r, imax);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把注释去掉话，其实没几句话，说实话，第一次看没看懂，分析一下他的思路：</p>\n<ul>\n<li><p>同样是遍历，但是它维护的不是下标，而是在A[0:j]中的子数组的最大值imax和子数组最小值imin.</p>\n</li>\n<li><p>他用的是减治法，大概的想法是，我们知道A[0:n-1]imax和imin，我们如果求出A[0:n]的<code>imax,imin</code>。</p>\n<ul>\n<li>如果<code>A[n]&gt;=0</code>,那么<code>imax = max(A[n],imax*A[n]);imin = min(A[n],imin*A[n])</code></li>\n<li>如果<code>A[n] &lt; 0</code>，那么<code>imin = min(A[n],imax*A[n]);imax = max(A[n],imin*A[n])</code></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第9天</p>\n<p>今天这道题做了好久。。。</p>\n<blockquote>\n<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>\n<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p>\n</blockquote>\n<p>看到这道题，就让我想起了昨天做得那道<a href=\"https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/\">Longest Substring Without Repeating Characters</a>。</p>\n<p>看起来很像是同一类的题目，想着用同一种方法去做，然后就考虑了好多奇奇怪怪的情况，最后代码写的及其混乱。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>;j &lt; nums.size();j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[j] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(now &lt; <span class=\"number\">0</span> &amp;&amp; i &lt; j <span class=\"number\">-1</span>)</span><br><span class=\"line\">                now /= nums[i++];</span><br><span class=\"line\">            ret = max(ret,now);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">            now = <span class=\"number\">0</span>;</span><br><span class=\"line\">            i = j+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            now = (now)?now*nums[j]:nums[j];</span><br><span class=\"line\">            ret = max(ret,now);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(now &lt; <span class=\"number\">0</span> &amp;&amp; i &lt; j - <span class=\"number\">1</span>)</span><br><span class=\"line\">        now /= nums[i++];</span><br><span class=\"line\">    ret = max(ret,now);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这还是做完后进行了一些删减的答案，看起来很复杂，要我现在去解释它都有点困难。</p>\n<p>先提提我的思路：</p>\n<ul>\n<li><p>和昨天的一样，我用两个下标来标识当前<code>Subarray</code>,也就是说，然后让<code>j</code>不断向前去遍历。</p>\n</li>\n<li><p>我需要考虑的就是什么时候<code>i</code>向前，我的想法是：</p>\n<blockquote>\n<p>当我们遇到一个0时，我们需要把i改成j+1,因为正常情况下<code>Subarray</code>中如果有个<code>0</code>，那么<code>Subarray</code>的乘积就必定是0，为什么说是正常情况呢，因为如果当前最大乘积小于0的话，那么我们遇到一个<code>0</code>，要把最大乘积改成<code>0</code>.</p>\n</blockquote>\n</li>\n<li><p>但是如果我们遇到这样的数组<code>2 -1 4 0</code>,我们当前的策略的返回值是<code>2</code>，但真正应该是4，因此另一个<code>i</code>向前的情况是：</p>\n<blockquote>\n<p>遇到一个<code>0</code>或遍历完整个数组，我们需要让<code>i</code>向前移动，直到让当前乘积变成大于0，或者到达<code>j</code>。</p>\n</blockquote>\n</li>\n</ul>\n<p>最后将这一大段思路变成代码就成了我上面写的了，其实仔细想想，这些思路其实并不复杂，只是有点繁琐，如果心能静点的话，应该可以更快的AC掉这道题。</p>\n<p>下面是<code>dicuss</code>中的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// store the result that is the max we have found so far</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = A[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// imax/imin stores the max/min product of</span></span><br><span class=\"line\">    <span class=\"comment\">// subarray that ends with the current number A[i]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, imax = r, imin = r; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// multiplied by a negative makes big number smaller, small number bigger</span></span><br><span class=\"line\">        <span class=\"comment\">// so we redefine the extremums by swapping them</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[i] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            swap(imax, imin);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// max/min product for the current number is either the current number itself</span></span><br><span class=\"line\">        <span class=\"comment\">// or the max/min by the previous number times the current one</span></span><br><span class=\"line\">        imax = max(A[i], imax * A[i]);</span><br><span class=\"line\">        imin = min(A[i], imin * A[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// the newly computed max value is a candidate for our global result</span></span><br><span class=\"line\">        r = max(r, imax);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把注释去掉话，其实没几句话，说实话，第一次看没看懂，分析一下他的思路：</p>\n<ul>\n<li><p>同样是遍历，但是它维护的不是下标，而是在A[0:j]中的子数组的最大值imax和子数组最小值imin.</p>\n</li>\n<li><p>他用的是减治法，大概的想法是，我们知道A[0:n-1]imax和imin，我们如果求出A[0:n]的<code>imax,imin</code>。</p>\n<ul>\n<li>如果<code>A[n]&gt;=0</code>,那么<code>imax = max(A[n],imax*A[n]);imin = min(A[n],imin*A[n])</code></li>\n<li>如果<code>A[n] &lt; 0</code>，那么<code>imin = min(A[n],imax*A[n]);imax = max(A[n],imin*A[n])</code></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Maximum Depth of Binary Tree","date":"2017-11-11T00:25:23.000Z","_content":"\n第46天。\n\n今天出游，挑到水题[Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/):\n\n> Given a binary tree, find its maximum depth.\n>\n> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n说是水题，就不讲怎么做了，直接上代码吧:\n\n```c++\nint maxDepth(TreeNode* root) {\n    return maxDepth(root,0);\n}\nint maxDepth(TreeNode *root,int depth) {\n    if (root == nullptr) return depth;\n    return max(maxDepth(root->left,depth+1),maxDepth(root->right,depth+1));\n}\n```\n\n恩，突然发现好像没必要写的那么长:\n\n```c++\nint maxDepth(TreeNode *root) {\n    if (root == nullptr) return 0;\n    return max(maxDepth(root->left),maxDepth(root->right))+1;\n}\n```\n\n恩，送上一个`dicuss`中BFS的解法：\n\n```c++\nint maxDepth(TreeNode *root)\n{\n    if(root == NULL)\n        return 0;\n\n    int res = 0;\n    queue<TreeNode *> q;\n    q.push(root);\n    while(!q.empty())\n    {\n        ++ res;\n        for(int i = 0, n = q.size(); i < n; ++ i)\n        {\n            TreeNode *p = q.front();\n            q.pop();\n\n            if(p -> left != NULL)\n                q.push(p -> left);\n            if(p -> right != NULL)\n                q.push(p -> right);\n        }\n    }\n\n    return res;\n}\n```\n","source":"_posts/Maximun-Depth-of-Binary-Tree.md","raw":"---\ntitle: Maximum Depth of Binary Tree\ndate: 2017-11-11T08:25:23.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第46天。\n\n今天出游，挑到水题[Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/):\n\n> Given a binary tree, find its maximum depth.\n>\n> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n说是水题，就不讲怎么做了，直接上代码吧:\n\n```c++\nint maxDepth(TreeNode* root) {\n    return maxDepth(root,0);\n}\nint maxDepth(TreeNode *root,int depth) {\n    if (root == nullptr) return depth;\n    return max(maxDepth(root->left,depth+1),maxDepth(root->right,depth+1));\n}\n```\n\n恩，突然发现好像没必要写的那么长:\n\n```c++\nint maxDepth(TreeNode *root) {\n    if (root == nullptr) return 0;\n    return max(maxDepth(root->left),maxDepth(root->right))+1;\n}\n```\n\n恩，送上一个`dicuss`中BFS的解法：\n\n```c++\nint maxDepth(TreeNode *root)\n{\n    if(root == NULL)\n        return 0;\n\n    int res = 0;\n    queue<TreeNode *> q;\n    q.push(root);\n    while(!q.empty())\n    {\n        ++ res;\n        for(int i = 0, n = q.size(); i < n; ++ i)\n        {\n            TreeNode *p = q.front();\n            q.pop();\n\n            if(p -> left != NULL)\n                q.push(p -> left);\n            if(p -> right != NULL)\n                q.push(p -> right);\n        }\n    }\n\n    return res;\n}\n```\n","slug":"Maximun-Depth-of-Binary-Tree","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ou009kqmcmg1cud5nm","content":"<p>第46天。</p>\n<p>今天出游，挑到水题<a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/\">Maximum Depth of Binary Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, find its maximum depth.</p>\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n</blockquote>\n<p>说是水题，就不讲怎么做了，直接上代码吧:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxDepth(root,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> depth)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(maxDepth(root-&gt;left,depth+<span class=\"number\">1</span>),maxDepth(root-&gt;right,depth+<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，突然发现好像没必要写的那么长:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，送上一个<code>dicuss</code>中BFS的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++ res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = q.size(); i &lt; n; ++ i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode *p = q.front();</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p -&gt; left != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                q.push(p -&gt; left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p -&gt; right != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                q.push(p -&gt; right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第46天。</p>\n<p>今天出游，挑到水题<a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/\">Maximum Depth of Binary Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, find its maximum depth.</p>\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n</blockquote>\n<p>说是水题，就不讲怎么做了，直接上代码吧:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxDepth(root,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root,<span class=\"keyword\">int</span> depth)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(maxDepth(root-&gt;left,depth+<span class=\"number\">1</span>),maxDepth(root-&gt;right,depth+<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，突然发现好像没必要写的那么长:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，送上一个<code>dicuss</code>中BFS的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++ res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = q.size(); i &lt; n; ++ i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode *p = q.front();</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p -&gt; left != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                q.push(p -&gt; left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p -&gt; right != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                q.push(p -&gt; right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Median Of Two Sorted Arrays","date":"2017-10-14T04:47:24.000Z","_content":"\n第21天，尝试了一下`hard`，结果是完全没做出来。。。从早上8点多到11点半，一直没能AC，最后只好看`dicuss`中的解法了，然后理解还理解了很久。。。看了现在的我还不适合做`hard`级别的。\n\n> There are two sorted arrays nums1 and nums2 of size m and n respectively.\n>\n> Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n> Example 1:\n> nums1 = [1, 3]\n> nums2 = [2]\n>\n> The median is 2.0\n> Example 2:\n> nums1 = [1, 2]\n> nums2 = [3, 4]\n>\n> The median is (2 + 3)/2 = 2.5\n\n因为没做出来，所以只能写写别人的思路了。\n\n我们现在要找的是中位数，那么就有两种情况：\n\n* 整体长度是奇数，那么中位数是序列中的数\n* 整体长度是偶数，那么中位数是序列中两个数的平均值。\n\n先考虑奇数的情况，因为是序列中的数，所以我们现在要求的就是在两个序列中第`（size)/2 + 1`大的数。\n\n现在问题转换成在两个序列中求第k个数：\n\n不断的将`k`减半，并把小的数从序列中排出，每次都能排出掉`k/2`.\n\n```c++\ndouble getKth(vector<int> &nums1,int beg1,int size1,vector<int> &nums2,int beg2,int size2,int k) {\n        //cout << beg1<<\" \" <<size1<<\"\\t\"<<beg2<<\" \"<<size2<<\"\\t\"<<k<<endl;\n        if (size1 > size2) {\n                return getKth(nums2,beg2,size2,nums1,beg1,size1,k);\n        }\n\n        if (size1 == 0) { return nums2[beg2 + k-1];}\n        if (k == 1) return min(nums1[beg1],nums2[beg2]);\n\n        int i = min(size1,k/2);\n        int j = min(size2,k/2);\n\n        if (nums1[beg1 + i-1] > nums2[beg2 + j-1]) {\n            return getKth(nums1,beg1,size1,nums2,beg2+j,size2-j,k-j);\n        } else\n            return getKth(nums1,beg1+i,size1-i,nums2,beg2,size2,k-i);\n    }\n```\n\n考虑偶数的情况，我们只要找出第`(size)/2 + 1`和`(size)/2`的大的数的平均值即可。\n\n将两者统一一下：\n\n```c++\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    int l = (nums1.size() + nums2.size() + 1) >> 1;\n    int r = (nums1.size() + nums2.size() + 2) >> 1;\n    //cout << \"#\" << l << r << endl;\n    double dl = getKth(nums1,0,nums1.size(),nums2,0,nums2.size(),l); \n    double dr = getKth(nums1,0,nums1.size(),nums2,0,nums2.size(),r);\n    //cout << dl <<dr << endl;\n    return (dr+dl)/2;\n}\n```\n\n恩，等下次感觉有能力做了，在来尝试一次！！！\n","source":"_posts/MedianOfTwoSortedArrays.md","raw":"---\ntitle: Median Of Two Sorted Arrays\ndate: 2017-10-14T12:47:24.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第21天，尝试了一下`hard`，结果是完全没做出来。。。从早上8点多到11点半，一直没能AC，最后只好看`dicuss`中的解法了，然后理解还理解了很久。。。看了现在的我还不适合做`hard`级别的。\n\n> There are two sorted arrays nums1 and nums2 of size m and n respectively.\n>\n> Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n> Example 1:\n> nums1 = [1, 3]\n> nums2 = [2]\n>\n> The median is 2.0\n> Example 2:\n> nums1 = [1, 2]\n> nums2 = [3, 4]\n>\n> The median is (2 + 3)/2 = 2.5\n\n因为没做出来，所以只能写写别人的思路了。\n\n我们现在要找的是中位数，那么就有两种情况：\n\n* 整体长度是奇数，那么中位数是序列中的数\n* 整体长度是偶数，那么中位数是序列中两个数的平均值。\n\n先考虑奇数的情况，因为是序列中的数，所以我们现在要求的就是在两个序列中第`（size)/2 + 1`大的数。\n\n现在问题转换成在两个序列中求第k个数：\n\n不断的将`k`减半，并把小的数从序列中排出，每次都能排出掉`k/2`.\n\n```c++\ndouble getKth(vector<int> &nums1,int beg1,int size1,vector<int> &nums2,int beg2,int size2,int k) {\n        //cout << beg1<<\" \" <<size1<<\"\\t\"<<beg2<<\" \"<<size2<<\"\\t\"<<k<<endl;\n        if (size1 > size2) {\n                return getKth(nums2,beg2,size2,nums1,beg1,size1,k);\n        }\n\n        if (size1 == 0) { return nums2[beg2 + k-1];}\n        if (k == 1) return min(nums1[beg1],nums2[beg2]);\n\n        int i = min(size1,k/2);\n        int j = min(size2,k/2);\n\n        if (nums1[beg1 + i-1] > nums2[beg2 + j-1]) {\n            return getKth(nums1,beg1,size1,nums2,beg2+j,size2-j,k-j);\n        } else\n            return getKth(nums1,beg1+i,size1-i,nums2,beg2,size2,k-i);\n    }\n```\n\n考虑偶数的情况，我们只要找出第`(size)/2 + 1`和`(size)/2`的大的数的平均值即可。\n\n将两者统一一下：\n\n```c++\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    int l = (nums1.size() + nums2.size() + 1) >> 1;\n    int r = (nums1.size() + nums2.size() + 2) >> 1;\n    //cout << \"#\" << l << r << endl;\n    double dl = getKth(nums1,0,nums1.size(),nums2,0,nums2.size(),l); \n    double dr = getKth(nums1,0,nums1.size(),nums2,0,nums2.size(),r);\n    //cout << dl <<dr << endl;\n    return (dr+dl)/2;\n}\n```\n\n恩，等下次感觉有能力做了，在来尝试一次！！！\n","slug":"MedianOfTwoSortedArrays","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ov009nqmcm1ryydvwz","content":"<p>第21天，尝试了一下<code>hard</code>，结果是完全没做出来。。。从早上8点多到11点半，一直没能AC，最后只好看<code>dicuss</code>中的解法了，然后理解还理解了很久。。。看了现在的我还不适合做<code>hard</code>级别的。</p>\n<blockquote>\n<p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>Example 1:<br>nums1 = [1, 3]<br>nums2 = [2]</p>\n<p>The median is 2.0<br>Example 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]</p>\n<p>The median is (2 + 3)/2 = 2.5</p>\n</blockquote>\n<p>因为没做出来，所以只能写写别人的思路了。</p>\n<p>我们现在要找的是中位数，那么就有两种情况：</p>\n<ul>\n<li>整体长度是奇数，那么中位数是序列中的数</li>\n<li>整体长度是偶数，那么中位数是序列中两个数的平均值。</li>\n</ul>\n<p>先考虑奇数的情况，因为是序列中的数，所以我们现在要求的就是在两个序列中第<code>（size)/2 + 1</code>大的数。</p>\n<p>现在问题转换成在两个序列中求第k个数：</p>\n<p>不断的将<code>k</code>减半，并把小的数从序列中排出，每次都能排出掉<code>k/2</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getKth</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums1,<span class=\"keyword\">int</span> beg1,<span class=\"keyword\">int</span> size1,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums2,<span class=\"keyword\">int</span> beg2,<span class=\"keyword\">int</span> size2,<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; beg1&lt;&lt;&quot; &quot; &lt;&lt;size1&lt;&lt;&quot;\\t&quot;&lt;&lt;beg2&lt;&lt;&quot; &quot;&lt;&lt;size2&lt;&lt;&quot;\\t&quot;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size1 &gt; size2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> getKth(nums2,beg2,size2,nums1,beg1,size1,k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size1 == <span class=\"number\">0</span>) &#123; <span class=\"keyword\">return</span> nums2[beg2 + k<span class=\"number\">-1</span>];&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> min(nums1[beg1],nums2[beg2]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = min(size1,k/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = min(size2,k/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums1[beg1 + i<span class=\"number\">-1</span>] &gt; nums2[beg2 + j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getKth(nums1,beg1,size1,nums2,beg2+j,size2-j,k-j);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> getKth(nums1,beg1+i,size1-i,nums2,beg2,size2,k-i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>考虑偶数的情况，我们只要找出第<code>(size)/2 + 1</code>和<code>(size)/2</code>的大的数的平均值即可。</p>\n<p>将两者统一一下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = (nums1.size() + nums2.size() + <span class=\"number\">1</span>) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = (nums1.size() + nums2.size() + <span class=\"number\">2</span>) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; &quot;#&quot; &lt;&lt; l &lt;&lt; r &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> dl = getKth(nums1,<span class=\"number\">0</span>,nums1.size(),nums2,<span class=\"number\">0</span>,nums2.size(),l); </span><br><span class=\"line\">    <span class=\"keyword\">double</span> dr = getKth(nums1,<span class=\"number\">0</span>,nums1.size(),nums2,<span class=\"number\">0</span>,nums2.size(),r);</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; dl &lt;&lt;dr &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (dr+dl)/<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，等下次感觉有能力做了，在来尝试一次！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第21天，尝试了一下<code>hard</code>，结果是完全没做出来。。。从早上8点多到11点半，一直没能AC，最后只好看<code>dicuss</code>中的解法了，然后理解还理解了很久。。。看了现在的我还不适合做<code>hard</code>级别的。</p>\n<blockquote>\n<p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>Example 1:<br>nums1 = [1, 3]<br>nums2 = [2]</p>\n<p>The median is 2.0<br>Example 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]</p>\n<p>The median is (2 + 3)/2 = 2.5</p>\n</blockquote>\n<p>因为没做出来，所以只能写写别人的思路了。</p>\n<p>我们现在要找的是中位数，那么就有两种情况：</p>\n<ul>\n<li>整体长度是奇数，那么中位数是序列中的数</li>\n<li>整体长度是偶数，那么中位数是序列中两个数的平均值。</li>\n</ul>\n<p>先考虑奇数的情况，因为是序列中的数，所以我们现在要求的就是在两个序列中第<code>（size)/2 + 1</code>大的数。</p>\n<p>现在问题转换成在两个序列中求第k个数：</p>\n<p>不断的将<code>k</code>减半，并把小的数从序列中排出，每次都能排出掉<code>k/2</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getKth</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums1,<span class=\"keyword\">int</span> beg1,<span class=\"keyword\">int</span> size1,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums2,<span class=\"keyword\">int</span> beg2,<span class=\"keyword\">int</span> size2,<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; beg1&lt;&lt;&quot; &quot; &lt;&lt;size1&lt;&lt;&quot;\\t&quot;&lt;&lt;beg2&lt;&lt;&quot; &quot;&lt;&lt;size2&lt;&lt;&quot;\\t&quot;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size1 &gt; size2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> getKth(nums2,beg2,size2,nums1,beg1,size1,k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size1 == <span class=\"number\">0</span>) &#123; <span class=\"keyword\">return</span> nums2[beg2 + k<span class=\"number\">-1</span>];&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> min(nums1[beg1],nums2[beg2]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = min(size1,k/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = min(size2,k/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums1[beg1 + i<span class=\"number\">-1</span>] &gt; nums2[beg2 + j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getKth(nums1,beg1,size1,nums2,beg2+j,size2-j,k-j);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> getKth(nums1,beg1+i,size1-i,nums2,beg2,size2,k-i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>考虑偶数的情况，我们只要找出第<code>(size)/2 + 1</code>和<code>(size)/2</code>的大的数的平均值即可。</p>\n<p>将两者统一一下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = (nums1.size() + nums2.size() + <span class=\"number\">1</span>) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = (nums1.size() + nums2.size() + <span class=\"number\">2</span>) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; &quot;#&quot; &lt;&lt; l &lt;&lt; r &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> dl = getKth(nums1,<span class=\"number\">0</span>,nums1.size(),nums2,<span class=\"number\">0</span>,nums2.size(),l); </span><br><span class=\"line\">    <span class=\"keyword\">double</span> dr = getKth(nums1,<span class=\"number\">0</span>,nums1.size(),nums2,<span class=\"number\">0</span>,nums2.size(),r);</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; dl &lt;&lt;dr &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (dr+dl)/<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，等下次感觉有能力做了，在来尝试一次！！！</p>\n"},{"title":"Merge-Intervals","date":"2017-10-17T03:13:24.000Z","_content":"\n第24天\n\nemmm，又是一道10分钟刷完的题目——[Merge Intervals](https://leetcode.com/problems/merge-intervals/discuss/)\n\n> Given a collection of intervals, merge all overlapping intervals.\n>\n> For example,\n> Given [1,3],[2,6],[8,10],[15,18],\n> return [1,6],[8,10],[15,18].\n\n这个题目要考虑的就是怎么才能避免不断的插入删除。\n\n其实再后来尝试优化的时候，就是陷入这个误区，尝试的写一个`O(n)`的算法出来，但是发现要不断的遍历和插入和删除元素，我们知道这对`vector`来说时比较耗时的。\n\n我们先确定什么时候两个`Intervals`需要`merge`,考虑`i1`,`i2`,只有`i1.end > i2.start`，这时`i1`和`i2`就应该`merge`成`{i1.start,i2.end}`\n\n* 先对`intervals`按`start`排序\n* 将第一个元素放入`ret`，因为这时`start`是最小的，我们现在只需要寻找`end`即可\n* 我们考察第二个元素，如果第二个元素的`start`小于第一个元素的`end`，我们就将修改`end`,并考察第三个元素，如果不成立，说明当前元素的`end`就已经找到了（因为`start < end`）\n\n```c++\nvector<Interval> merge1(vector<Interval>& intervals) {\n    if (intervals.size() <= 1) return intervals;\n\n    sort(intervals.begin(),intervals.end(),[](const Interval &a,const Interval b) -> bool{\n        return a.start < b.start;\n    });\n\n    vector<Interval> ret;\n    ret.push_back(intervals[0]);\n    int last = 0;\n\n    for(int i = 1;i < intervals.size();i++) {\n        if (ret[last].end >= intervals[i].start)\n            ret[last].end = max(intervals[i].end,ret[last].end);\n        else {\n            ret.push_back(intervals[i]);\n            last++;\n        }\n    }\n\n    return ret;\n}\n```\n\n还有在`dicuss`中看到的答案，但是这个需要做两次`sort`，所以效率不会比上面的方法高:\n\n```java\npublic List<Interval> merge(List<Interval> intervals) {\n    // sort start&end\n    int n = intervals.size();\n    int[] starts = new int[n];\n    int[] ends = new int[n];\n    for (int i = 0; i < n; i++) {\n        starts[i] = intervals.get(i).start;\n        ends[i] = intervals.get(i).end;\n    }\n    Arrays.sort(starts);\n    Arrays.sort(ends);\n    // loop through\n    List<Interval> res = new ArrayList<Interval>();\n    for (int i = 0, j = 0; i < n; i++) { // j is start of interval.\n        if (i == n - 1 || starts[i + 1] > ends[i]) {\n            res.add(new Interval(starts[j], ends[i]));\n            j = i + 1;\n        }\n    }\n    return res;\n}\n```\n","source":"_posts/Merge-Intervals.md","raw":"---\ntitle: Merge-Intervals\ndate: 2017-10-17T11:13:24.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第24天\n\nemmm，又是一道10分钟刷完的题目——[Merge Intervals](https://leetcode.com/problems/merge-intervals/discuss/)\n\n> Given a collection of intervals, merge all overlapping intervals.\n>\n> For example,\n> Given [1,3],[2,6],[8,10],[15,18],\n> return [1,6],[8,10],[15,18].\n\n这个题目要考虑的就是怎么才能避免不断的插入删除。\n\n其实再后来尝试优化的时候，就是陷入这个误区，尝试的写一个`O(n)`的算法出来，但是发现要不断的遍历和插入和删除元素，我们知道这对`vector`来说时比较耗时的。\n\n我们先确定什么时候两个`Intervals`需要`merge`,考虑`i1`,`i2`,只有`i1.end > i2.start`，这时`i1`和`i2`就应该`merge`成`{i1.start,i2.end}`\n\n* 先对`intervals`按`start`排序\n* 将第一个元素放入`ret`，因为这时`start`是最小的，我们现在只需要寻找`end`即可\n* 我们考察第二个元素，如果第二个元素的`start`小于第一个元素的`end`，我们就将修改`end`,并考察第三个元素，如果不成立，说明当前元素的`end`就已经找到了（因为`start < end`）\n\n```c++\nvector<Interval> merge1(vector<Interval>& intervals) {\n    if (intervals.size() <= 1) return intervals;\n\n    sort(intervals.begin(),intervals.end(),[](const Interval &a,const Interval b) -> bool{\n        return a.start < b.start;\n    });\n\n    vector<Interval> ret;\n    ret.push_back(intervals[0]);\n    int last = 0;\n\n    for(int i = 1;i < intervals.size();i++) {\n        if (ret[last].end >= intervals[i].start)\n            ret[last].end = max(intervals[i].end,ret[last].end);\n        else {\n            ret.push_back(intervals[i]);\n            last++;\n        }\n    }\n\n    return ret;\n}\n```\n\n还有在`dicuss`中看到的答案，但是这个需要做两次`sort`，所以效率不会比上面的方法高:\n\n```java\npublic List<Interval> merge(List<Interval> intervals) {\n    // sort start&end\n    int n = intervals.size();\n    int[] starts = new int[n];\n    int[] ends = new int[n];\n    for (int i = 0; i < n; i++) {\n        starts[i] = intervals.get(i).start;\n        ends[i] = intervals.get(i).end;\n    }\n    Arrays.sort(starts);\n    Arrays.sort(ends);\n    // loop through\n    List<Interval> res = new ArrayList<Interval>();\n    for (int i = 0, j = 0; i < n; i++) { // j is start of interval.\n        if (i == n - 1 || starts[i + 1] > ends[i]) {\n            res.add(new Interval(starts[j], ends[i]));\n            j = i + 1;\n        }\n    }\n    return res;\n}\n```\n","slug":"Merge-Intervals","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ow009qqmcm6o377xvy","content":"<p>第24天</p>\n<p>emmm，又是一道10分钟刷完的题目——<a href=\"https://leetcode.com/problems/merge-intervals/discuss/\">Merge Intervals</a></p>\n<blockquote>\n<p>Given a collection of intervals, merge all overlapping intervals.</p>\n<p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>\n</blockquote>\n<p>这个题目要考虑的就是怎么才能避免不断的插入删除。</p>\n<p>其实再后来尝试优化的时候，就是陷入这个误区，尝试的写一个<code>O(n)</code>的算法出来，但是发现要不断的遍历和插入和删除元素，我们知道这对<code>vector</code>来说时比较耗时的。</p>\n<p>我们先确定什么时候两个<code>Intervals</code>需要<code>merge</code>,考虑<code>i1</code>,<code>i2</code>,只有<code>i1.end &gt; i2.start</code>，这时<code>i1</code>和<code>i2</code>就应该<code>merge</code>成<code>&#123;i1.start,i2.end&#125;</code></p>\n<ul>\n<li>先对<code>intervals</code>按<code>start</code>排序</li>\n<li>将第一个元素放入<code>ret</code>，因为这时<code>start</code>是最小的，我们现在只需要寻找<code>end</code>即可</li>\n<li>我们考察第二个元素，如果第二个元素的<code>start</code>小于第一个元素的<code>end</code>，我们就将修改<code>end</code>,并考察第三个元素，如果不成立，说明当前元素的<code>end</code>就已经找到了（因为<code>start &lt; end</code>）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;Interval&gt; <span class=\"title\">merge1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (intervals.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort(intervals.begin(),intervals.end(),[](<span class=\"keyword\">const</span> Interval &amp;a,<span class=\"keyword\">const</span> Interval b) -&gt; <span class=\"keyword\">bool</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.start &lt; b.start;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Interval&gt; ret;</span><br><span class=\"line\">    ret.push_back(intervals[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; intervals.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret[last].end &gt;= intervals[i].start)</span><br><span class=\"line\">            ret[last].end = max(intervals[i].end,ret[last].end);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ret.push_back(intervals[i]);</span><br><span class=\"line\">            last++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有在<code>dicuss</code>中看到的答案，但是这个需要做两次<code>sort</code>，所以效率不会比上面的方法高:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Interval&gt; <span class=\"title\">merge</span><span class=\"params\">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// sort start&amp;end</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = intervals.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] starts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ends = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        starts[i] = intervals.get(i).start;</span><br><span class=\"line\">        ends[i] = intervals.get(i).end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Arrays.sort(starts);</span><br><span class=\"line\">    Arrays.sort(ends);</span><br><span class=\"line\">    <span class=\"comment\">// loop through</span></span><br><span class=\"line\">    List&lt;Interval&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Interval&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; n; i++) &#123; <span class=\"comment\">// j is start of interval.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == n - <span class=\"number\">1</span> || starts[i + <span class=\"number\">1</span>] &gt; ends[i]) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> Interval(starts[j], ends[i]));</span><br><span class=\"line\">            j = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第24天</p>\n<p>emmm，又是一道10分钟刷完的题目——<a href=\"https://leetcode.com/problems/merge-intervals/discuss/\">Merge Intervals</a></p>\n<blockquote>\n<p>Given a collection of intervals, merge all overlapping intervals.</p>\n<p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>\n</blockquote>\n<p>这个题目要考虑的就是怎么才能避免不断的插入删除。</p>\n<p>其实再后来尝试优化的时候，就是陷入这个误区，尝试的写一个<code>O(n)</code>的算法出来，但是发现要不断的遍历和插入和删除元素，我们知道这对<code>vector</code>来说时比较耗时的。</p>\n<p>我们先确定什么时候两个<code>Intervals</code>需要<code>merge</code>,考虑<code>i1</code>,<code>i2</code>,只有<code>i1.end &gt; i2.start</code>，这时<code>i1</code>和<code>i2</code>就应该<code>merge</code>成<code>&#123;i1.start,i2.end&#125;</code></p>\n<ul>\n<li>先对<code>intervals</code>按<code>start</code>排序</li>\n<li>将第一个元素放入<code>ret</code>，因为这时<code>start</code>是最小的，我们现在只需要寻找<code>end</code>即可</li>\n<li>我们考察第二个元素，如果第二个元素的<code>start</code>小于第一个元素的<code>end</code>，我们就将修改<code>end</code>,并考察第三个元素，如果不成立，说明当前元素的<code>end</code>就已经找到了（因为<code>start &lt; end</code>）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;Interval&gt; <span class=\"title\">merge1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (intervals.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort(intervals.begin(),intervals.end(),[](<span class=\"keyword\">const</span> Interval &amp;a,<span class=\"keyword\">const</span> Interval b) -&gt; <span class=\"keyword\">bool</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.start &lt; b.start;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Interval&gt; ret;</span><br><span class=\"line\">    ret.push_back(intervals[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; intervals.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret[last].end &gt;= intervals[i].start)</span><br><span class=\"line\">            ret[last].end = max(intervals[i].end,ret[last].end);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ret.push_back(intervals[i]);</span><br><span class=\"line\">            last++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有在<code>dicuss</code>中看到的答案，但是这个需要做两次<code>sort</code>，所以效率不会比上面的方法高:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Interval&gt; <span class=\"title\">merge</span><span class=\"params\">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// sort start&amp;end</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = intervals.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] starts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ends = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        starts[i] = intervals.get(i).start;</span><br><span class=\"line\">        ends[i] = intervals.get(i).end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Arrays.sort(starts);</span><br><span class=\"line\">    Arrays.sort(ends);</span><br><span class=\"line\">    <span class=\"comment\">// loop through</span></span><br><span class=\"line\">    List&lt;Interval&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Interval&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; n; i++) &#123; <span class=\"comment\">// j is start of interval.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == n - <span class=\"number\">1</span> || starts[i + <span class=\"number\">1</span>] &gt; ends[i]) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> Interval(starts[j], ends[i]));</span><br><span class=\"line\">            j = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Merge Two Binary Trees","date":"2017-11-25T03:20:57.000Z","_content":"\n第59天。\n\n今天早上vpn挂了，然后好像学校IP有出现了点问题（貌似被人列入黑名单了）然后就一直出现`One more step`进行验证，最烦的是这个验证需要翻个墙，然后我就用手机开的wifi来写的题。\n\n今天的题目是[Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/description/):\n\n> Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.\n>\n> You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\n>\n> Example 1:\n> Input: \n\n    Tree 1                     Tree 2\n          1                         2\n         / \\                       / \\\n        3   2                     1   3\n       /                           \\   \\\n      5                             4   7\n\n> Output:\n> Merged tree:\n\n          3\n         / \\\n        4   5\n        / \\   \\\n       5   4   7\n\n> Note: The merging process must start from the root nodes of both trees.\n\n挺简单的问题，对于两个`root`,大致可以分为4种情况：\n\n1. t1 = nullptr and t2 == nullptr: 直接返回nullptr\n1. t1 == nullptr and t2 != nullptr:\n    - new 一个新的节点ret\n    - ret->val = t2->val\n    - ret->left = mergeTrees(t1,t2->left)\n    - ret->right = mergeTree(t1,t2->right)\n1. t1 != nullptr and t2 == nullptr: 与上面类似\n1. t1 != nullptr and t2 != nullptr:\n    - new 一个新的节点ret\n    - ret->val = t1->val + t1->val\n    - ret->left = mergeTrees(t1->left,t2->left)\n    - ret->right = mergeTrees(t1->right,t2->right)\n\n```c++\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n    if (!t1 && !t2) return nullptr;\n    TreeNode * ret = new TreeNode(0);\n    ret->val = ((t2)?t2->val:0) + ((t1)?t1->val:0);\n    ret->left = mergeTrees((t1)?t1->left:t1\n                            ,(t2)?t2->left:t2);\n    ret->right = mergeTrees((t1)?t1->right:t1\n                            ,(t2)?t2->right:t2);\n    return ret;\n}\n```\n\n如果可以不管使用t1和t2的空间的话，可以更简单一点：\n\n```c++\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n    if (!t1) return t2;\n    if (!t2) return t1;\n    TreeNode *ret = new TreeNode(t1->val + t2->val);\n    ret->left = mergeTrees(t1->left,t2->left);\n    ret->right = mergeTrees(t1->right,t2->right);\n    return ret;\n}\n```\n","source":"_posts/Merge-Two-Binary-Trees.md","raw":"---\ntitle: Merge Two Binary Trees\ndate: 2017-11-25T11:20:57.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第59天。\n\n今天早上vpn挂了，然后好像学校IP有出现了点问题（貌似被人列入黑名单了）然后就一直出现`One more step`进行验证，最烦的是这个验证需要翻个墙，然后我就用手机开的wifi来写的题。\n\n今天的题目是[Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/description/):\n\n> Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.\n>\n> You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\n>\n> Example 1:\n> Input: \n\n    Tree 1                     Tree 2\n          1                         2\n         / \\                       / \\\n        3   2                     1   3\n       /                           \\   \\\n      5                             4   7\n\n> Output:\n> Merged tree:\n\n          3\n         / \\\n        4   5\n        / \\   \\\n       5   4   7\n\n> Note: The merging process must start from the root nodes of both trees.\n\n挺简单的问题，对于两个`root`,大致可以分为4种情况：\n\n1. t1 = nullptr and t2 == nullptr: 直接返回nullptr\n1. t1 == nullptr and t2 != nullptr:\n    - new 一个新的节点ret\n    - ret->val = t2->val\n    - ret->left = mergeTrees(t1,t2->left)\n    - ret->right = mergeTree(t1,t2->right)\n1. t1 != nullptr and t2 == nullptr: 与上面类似\n1. t1 != nullptr and t2 != nullptr:\n    - new 一个新的节点ret\n    - ret->val = t1->val + t1->val\n    - ret->left = mergeTrees(t1->left,t2->left)\n    - ret->right = mergeTrees(t1->right,t2->right)\n\n```c++\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n    if (!t1 && !t2) return nullptr;\n    TreeNode * ret = new TreeNode(0);\n    ret->val = ((t2)?t2->val:0) + ((t1)?t1->val:0);\n    ret->left = mergeTrees((t1)?t1->left:t1\n                            ,(t2)?t2->left:t2);\n    ret->right = mergeTrees((t1)?t1->right:t1\n                            ,(t2)?t2->right:t2);\n    return ret;\n}\n```\n\n如果可以不管使用t1和t2的空间的话，可以更简单一点：\n\n```c++\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n    if (!t1) return t2;\n    if (!t2) return t1;\n    TreeNode *ret = new TreeNode(t1->val + t2->val);\n    ret->left = mergeTrees(t1->left,t2->left);\n    ret->right = mergeTrees(t1->right,t2->right);\n    return ret;\n}\n```\n","slug":"Merge-Two-Binary-Trees","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ow009tqmcmha2fewk8","content":"<p>第59天。</p>\n<p>今天早上vpn挂了，然后好像学校IP有出现了点问题（貌似被人列入黑名单了）然后就一直出现<code>One more step</code>进行验证，最烦的是这个验证需要翻个墙，然后我就用手机开的wifi来写的题。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/merge-two-binary-trees/description/\">Merge Two Binary Trees</a>:</p>\n<blockquote>\n<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>\n<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>\n<p>Example 1:<br>Input: </p>\n</blockquote>\n<pre><code>Tree 1                     Tree 2\n      1                         2\n     / \\                       / \\\n    3   2                     1   3\n   /                           \\   \\\n  5                             4   7\n</code></pre>\n<blockquote>\n<p>Output:<br>Merged tree:</p>\n</blockquote>\n<pre><code>      3\n     / \\\n    4   5\n    / \\   \\\n   5   4   7\n</code></pre>\n<blockquote>\n<p>Note: The merging process must start from the root nodes of both trees.</p>\n</blockquote>\n<p>挺简单的问题，对于两个<code>root</code>,大致可以分为4种情况：</p>\n<ol>\n<li>t1 = nullptr and t2 == nullptr: 直接返回nullptr</li>\n<li>t1 == nullptr and t2 != nullptr:<ul>\n<li>new 一个新的节点ret</li>\n<li>ret-&gt;val = t2-&gt;val</li>\n<li>ret-&gt;left = mergeTrees(t1,t2-&gt;left)</li>\n<li>ret-&gt;right = mergeTree(t1,t2-&gt;right)</li>\n</ul>\n</li>\n<li>t1 != nullptr and t2 == nullptr: 与上面类似</li>\n<li>t1 != nullptr and t2 != nullptr:<ul>\n<li>new 一个新的节点ret</li>\n<li>ret-&gt;val = t1-&gt;val + t1-&gt;val</li>\n<li>ret-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left)</li>\n<li>ret-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right)</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!t1 &amp;&amp; !t2) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    TreeNode * ret = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    ret-&gt;val = ((t2)?t2-&gt;val:<span class=\"number\">0</span>) + ((t1)?t1-&gt;val:<span class=\"number\">0</span>);</span><br><span class=\"line\">    ret-&gt;left = mergeTrees((t1)?t1-&gt;left:t1</span><br><span class=\"line\">                            ,(t2)?t2-&gt;left:t2);</span><br><span class=\"line\">    ret-&gt;right = mergeTrees((t1)?t1-&gt;right:t1</span><br><span class=\"line\">                            ,(t2)?t2-&gt;right:t2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果可以不管使用t1和t2的空间的话，可以更简单一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!t1) <span class=\"keyword\">return</span> t2;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!t2) <span class=\"keyword\">return</span> t1;</span><br><span class=\"line\">    TreeNode *ret = <span class=\"keyword\">new</span> TreeNode(t1-&gt;val + t2-&gt;val);</span><br><span class=\"line\">    ret-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class=\"line\">    ret-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第59天。</p>\n<p>今天早上vpn挂了，然后好像学校IP有出现了点问题（貌似被人列入黑名单了）然后就一直出现<code>One more step</code>进行验证，最烦的是这个验证需要翻个墙，然后我就用手机开的wifi来写的题。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/merge-two-binary-trees/description/\">Merge Two Binary Trees</a>:</p>\n<blockquote>\n<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>\n<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>\n<p>Example 1:<br>Input: </p>\n</blockquote>\n<pre><code>Tree 1                     Tree 2\n      1                         2\n     / \\                       / \\\n    3   2                     1   3\n   /                           \\   \\\n  5                             4   7\n</code></pre>\n<blockquote>\n<p>Output:<br>Merged tree:</p>\n</blockquote>\n<pre><code>      3\n     / \\\n    4   5\n    / \\   \\\n   5   4   7\n</code></pre>\n<blockquote>\n<p>Note: The merging process must start from the root nodes of both trees.</p>\n</blockquote>\n<p>挺简单的问题，对于两个<code>root</code>,大致可以分为4种情况：</p>\n<ol>\n<li>t1 = nullptr and t2 == nullptr: 直接返回nullptr</li>\n<li>t1 == nullptr and t2 != nullptr:<ul>\n<li>new 一个新的节点ret</li>\n<li>ret-&gt;val = t2-&gt;val</li>\n<li>ret-&gt;left = mergeTrees(t1,t2-&gt;left)</li>\n<li>ret-&gt;right = mergeTree(t1,t2-&gt;right)</li>\n</ul>\n</li>\n<li>t1 != nullptr and t2 == nullptr: 与上面类似</li>\n<li>t1 != nullptr and t2 != nullptr:<ul>\n<li>new 一个新的节点ret</li>\n<li>ret-&gt;val = t1-&gt;val + t1-&gt;val</li>\n<li>ret-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left)</li>\n<li>ret-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right)</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!t1 &amp;&amp; !t2) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    TreeNode * ret = <span class=\"keyword\">new</span> TreeNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    ret-&gt;val = ((t2)?t2-&gt;val:<span class=\"number\">0</span>) + ((t1)?t1-&gt;val:<span class=\"number\">0</span>);</span><br><span class=\"line\">    ret-&gt;left = mergeTrees((t1)?t1-&gt;left:t1</span><br><span class=\"line\">                            ,(t2)?t2-&gt;left:t2);</span><br><span class=\"line\">    ret-&gt;right = mergeTrees((t1)?t1-&gt;right:t1</span><br><span class=\"line\">                            ,(t2)?t2-&gt;right:t2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果可以不管使用t1和t2的空间的话，可以更简单一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!t1) <span class=\"keyword\">return</span> t2;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!t2) <span class=\"keyword\">return</span> t1;</span><br><span class=\"line\">    TreeNode *ret = <span class=\"keyword\">new</span> TreeNode(t1-&gt;val + t2-&gt;val);</span><br><span class=\"line\">    ret-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class=\"line\">    ret-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Merge Two Sorted List","date":"2017-09-28T03:06:00.000Z","_content":"\n打卡，第五天\n\n今天偷个懒，找下自信先，做个`Easy`的题目——[Merge Two Sorted List](https://leetcode.com/problems/merge-two-sorted-lists/description/) （我也没想到是这么简单的题目）\n\n之前在 `LintCode`做个一个链表排序，也写过一篇[blog](https://wuxiaobai24.github.io/2017/09/19/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/)\n解这道题时用的是`MergeSort`去做.所以已经写过一次`Merge Two Sorted List`了，之前的写法是这样的：\n\n```c++\nListNode *mergeList(ListNode *l1,ListNode *l2){\n  if (!l1) return l2;\n  else if (!l2) return l1;\n  ListNode* ret = new ListNode(0);\n  ListNode*p = ret;\n  while(l1 && l2) {\n    if (l1->val > l2->val) {\n      ret->next = l2;\n      ret = ret->next;\n      l2 = l2->next;\n    } else {\n      ret->next = l1;\n      ret = ret->next;\n      l1 = l1->next;\n    }\n  }\n  ret->next = (l1)?l1:l2;\n  ret = p->next;\n  delete p;\n  return ret;\n}\n```\n\n\n这次做一个小改进（可能时间复杂度上没有改进）：\n\n```c++\nListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode* head = new ListNode(0);\n        ListNode* ret = head;\n        while(l1 || l2) {\n            if ((l1 && l2 && l1->val > l2->val )|| !l1) {\n                head->next = l2;\n                head = head->next;\n                l2 = l2->next;\n            }else {\n                head->next = l1;\n                head = head->next;\n                l1 = l1->next;\n            }\n        }\n        head = ret->next;\n        delete ret;\n        return head;\n    }\n```\n\n恩，细细想想，这个思路效率可能跟慢，不过用在对数组的`Merge`的情况还是可以的（起码比较简洁）。\n","source":"_posts/MergeTwoSortedList.md","raw":"---\ntitle: Merge Two Sorted List\ndate: 2017-09-28T11:06:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 链表\n---\n\n打卡，第五天\n\n今天偷个懒，找下自信先，做个`Easy`的题目——[Merge Two Sorted List](https://leetcode.com/problems/merge-two-sorted-lists/description/) （我也没想到是这么简单的题目）\n\n之前在 `LintCode`做个一个链表排序，也写过一篇[blog](https://wuxiaobai24.github.io/2017/09/19/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/)\n解这道题时用的是`MergeSort`去做.所以已经写过一次`Merge Two Sorted List`了，之前的写法是这样的：\n\n```c++\nListNode *mergeList(ListNode *l1,ListNode *l2){\n  if (!l1) return l2;\n  else if (!l2) return l1;\n  ListNode* ret = new ListNode(0);\n  ListNode*p = ret;\n  while(l1 && l2) {\n    if (l1->val > l2->val) {\n      ret->next = l2;\n      ret = ret->next;\n      l2 = l2->next;\n    } else {\n      ret->next = l1;\n      ret = ret->next;\n      l1 = l1->next;\n    }\n  }\n  ret->next = (l1)?l1:l2;\n  ret = p->next;\n  delete p;\n  return ret;\n}\n```\n\n\n这次做一个小改进（可能时间复杂度上没有改进）：\n\n```c++\nListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode* head = new ListNode(0);\n        ListNode* ret = head;\n        while(l1 || l2) {\n            if ((l1 && l2 && l1->val > l2->val )|| !l1) {\n                head->next = l2;\n                head = head->next;\n                l2 = l2->next;\n            }else {\n                head->next = l1;\n                head = head->next;\n                l1 = l1->next;\n            }\n        }\n        head = ret->next;\n        delete ret;\n        return head;\n    }\n```\n\n恩，细细想想，这个思路效率可能跟慢，不过用在对数组的`Merge`的情况还是可以的（起码比较简洁）。\n","slug":"MergeTwoSortedList","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ox009wqmcma3ahddzz","content":"<p>打卡，第五天</p>\n<p>今天偷个懒，找下自信先，做个<code>Easy</code>的题目——<a href=\"https://leetcode.com/problems/merge-two-sorted-lists/description/\">Merge Two Sorted List</a> （我也没想到是这么简单的题目）</p>\n<p>之前在 <code>LintCode</code>做个一个链表排序，也写过一篇<a href=\"https://wuxiaobai24.github.io/2017/09/19/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/\">blog</a><br>解这道题时用的是<code>MergeSort</code>去做.所以已经写过一次<code>Merge Two Sorted List</code>了，之前的写法是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">mergeList</span><span class=\"params\">(ListNode *l1,ListNode *l2)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!l1) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!l2) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">  ListNode* ret = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">  ListNode*p = ret;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class=\"line\">      ret-&gt;next = l2;</span><br><span class=\"line\">      ret = ret-&gt;next;</span><br><span class=\"line\">      l2 = l2-&gt;next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ret-&gt;next = l1;</span><br><span class=\"line\">      ret = ret-&gt;next;</span><br><span class=\"line\">      l1 = l1-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ret-&gt;next = (l1)?l1:l2;</span><br><span class=\"line\">  ret = p-&gt;next;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>这次做一个小改进（可能时间复杂度上没有改进）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* head = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode* ret = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 || l2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((l1 &amp;&amp; l2 &amp;&amp; l1-&gt;val &gt; l2-&gt;val )|| !l1) &#123;</span><br><span class=\"line\">                head-&gt;next = l2;</span><br><span class=\"line\">                head = head-&gt;next;</span><br><span class=\"line\">                l2 = l2-&gt;next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                head-&gt;next = l1;</span><br><span class=\"line\">                head = head-&gt;next;</span><br><span class=\"line\">                l1 = l1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = ret-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> ret;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，细细想想，这个思路效率可能跟慢，不过用在对数组的<code>Merge</code>的情况还是可以的（起码比较简洁）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第五天</p>\n<p>今天偷个懒，找下自信先，做个<code>Easy</code>的题目——<a href=\"https://leetcode.com/problems/merge-two-sorted-lists/description/\">Merge Two Sorted List</a> （我也没想到是这么简单的题目）</p>\n<p>之前在 <code>LintCode</code>做个一个链表排序，也写过一篇<a href=\"https://wuxiaobai24.github.io/2017/09/19/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/\">blog</a><br>解这道题时用的是<code>MergeSort</code>去做.所以已经写过一次<code>Merge Two Sorted List</code>了，之前的写法是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">mergeList</span><span class=\"params\">(ListNode *l1,ListNode *l2)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!l1) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!l2) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">  ListNode* ret = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">  ListNode*p = ret;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class=\"line\">      ret-&gt;next = l2;</span><br><span class=\"line\">      ret = ret-&gt;next;</span><br><span class=\"line\">      l2 = l2-&gt;next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ret-&gt;next = l1;</span><br><span class=\"line\">      ret = ret-&gt;next;</span><br><span class=\"line\">      l1 = l1-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ret-&gt;next = (l1)?l1:l2;</span><br><span class=\"line\">  ret = p-&gt;next;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>这次做一个小改进（可能时间复杂度上没有改进）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* head = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode* ret = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 || l2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((l1 &amp;&amp; l2 &amp;&amp; l1-&gt;val &gt; l2-&gt;val )|| !l1) &#123;</span><br><span class=\"line\">                head-&gt;next = l2;</span><br><span class=\"line\">                head = head-&gt;next;</span><br><span class=\"line\">                l2 = l2-&gt;next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                head-&gt;next = l1;</span><br><span class=\"line\">                head = head-&gt;next;</span><br><span class=\"line\">                l1 = l1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = ret-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> ret;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，细细想想，这个思路效率可能跟慢，不过用在对数组的<code>Merge</code>的情况还是可以的（起码比较简洁）。</p>\n"},{"title":"Min-Cost-Climbing-Stairs","date":"2018-01-18T01:47:16.000Z","_content":"\n第87天。\n\n今天的题目是[Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/description/)：\n\n> On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\n>\n> Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n>\n> Example 1:\n> Input: cost = [10, 15, 20]\n> Output: 15\n> Explanation: Cheapest is start on cost[1], pay that cost and go to the top.\n> Example 2:\n> Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n> Output: 6\n> Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n> Note:\n> cost will have a length in the range [2, 1000].\n> Every cost[i] will be an integer in the range [0, 999].\n\n比较简单的动态规划题，emmm，爬楼梯的升级：\n\n```c++\nint minCostClimbingStairs(vector<int>& cost) {\n    cost.push_back(0);\n    int n = cost.size();\n    vector<int> dp(n+2,0);\n    for(int i = 2;i < n+2;i++) {\n        dp[i] = min(dp[i-1],dp[i-2]) + cost[i-2];\n    }\n    return dp[n+1];\n}\n```\n\n可以做一些简化:\n\n```c++\nint minCostClimbingStairs(vector<int>& cost) {\n    int n = cost.size();\n    vector<int> dp(n,0);\n    dp[0] = cost[0];\n    dp[1] = cost[1];\n    for(int i = 0;i < n;i++) {\n        dp[i] = min(dp[i-1],dp[i-2]) + cost[i];\n    }\n    return min(dp[n-1],dp[n-2]);\n}\n```\n\n甚至，如果cost可以修改的话，我们还可以把`dp`也省下来:\n\n```c++\nint minCostClimbingStairs(vector<int>& cost) {\n    int n = cost.size();\n    vector<int> &dp = cost;\n    for(int i = 0;i < n;i++) {\n        dp[i] = min(dp[i-1],dp[i-2]) + cost[i];\n    }\n    return min(dp[n-1],dp[n-2]);\n}\n```\n","source":"_posts/Min-Cost-Climbing-Stairs.md","raw":"---\ntitle: Min-Cost-Climbing-Stairs\ndate: 2018-01-18T09:47:16.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - DP\n---\n\n第87天。\n\n今天的题目是[Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/description/)：\n\n> On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\n>\n> Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n>\n> Example 1:\n> Input: cost = [10, 15, 20]\n> Output: 15\n> Explanation: Cheapest is start on cost[1], pay that cost and go to the top.\n> Example 2:\n> Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n> Output: 6\n> Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n> Note:\n> cost will have a length in the range [2, 1000].\n> Every cost[i] will be an integer in the range [0, 999].\n\n比较简单的动态规划题，emmm，爬楼梯的升级：\n\n```c++\nint minCostClimbingStairs(vector<int>& cost) {\n    cost.push_back(0);\n    int n = cost.size();\n    vector<int> dp(n+2,0);\n    for(int i = 2;i < n+2;i++) {\n        dp[i] = min(dp[i-1],dp[i-2]) + cost[i-2];\n    }\n    return dp[n+1];\n}\n```\n\n可以做一些简化:\n\n```c++\nint minCostClimbingStairs(vector<int>& cost) {\n    int n = cost.size();\n    vector<int> dp(n,0);\n    dp[0] = cost[0];\n    dp[1] = cost[1];\n    for(int i = 0;i < n;i++) {\n        dp[i] = min(dp[i-1],dp[i-2]) + cost[i];\n    }\n    return min(dp[n-1],dp[n-2]);\n}\n```\n\n甚至，如果cost可以修改的话，我们还可以把`dp`也省下来:\n\n```c++\nint minCostClimbingStairs(vector<int>& cost) {\n    int n = cost.size();\n    vector<int> &dp = cost;\n    for(int i = 0;i < n;i++) {\n        dp[i] = min(dp[i-1],dp[i-2]) + cost[i];\n    }\n    return min(dp[n-1],dp[n-2]);\n}\n```\n","slug":"Min-Cost-Climbing-Stairs","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oy009zqmcm3hhqghul","content":"<p>第87天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/min-cost-climbing-stairs/description/\">Min Cost Climbing Stairs</a>：</p>\n<blockquote>\n<p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p>\n<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>\n<p>Example 1:<br>Input: cost = [10, 15, 20]<br>Output: 15<br>Explanation: Cheapest is start on cost[1], pay that cost and go to the top.<br>Example 2:<br>Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>Output: 6<br>Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].<br>Note:<br>cost will have a length in the range [2, 1000].<br>Every cost[i] will be an integer in the range [0, 999].</p>\n</blockquote>\n<p>比较简单的动态规划题，emmm，爬楼梯的升级：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minCostClimbingStairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">    cost.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cost.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">2</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i &lt; n+<span class=\"number\">2</span>;i++) &#123;</span><br><span class=\"line\">        dp[i] = min(dp[i<span class=\"number\">-1</span>],dp[i<span class=\"number\">-2</span>]) + cost[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以做一些简化:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minCostClimbingStairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cost.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = cost[<span class=\"number\">0</span>];</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = cost[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++) &#123;</span><br><span class=\"line\">        dp[i] = min(dp[i<span class=\"number\">-1</span>],dp[i<span class=\"number\">-2</span>]) + cost[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(dp[n<span class=\"number\">-1</span>],dp[n<span class=\"number\">-2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>甚至，如果cost可以修改的话，我们还可以把<code>dp</code>也省下来:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minCostClimbingStairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cost.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;dp = cost;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++) &#123;</span><br><span class=\"line\">        dp[i] = min(dp[i<span class=\"number\">-1</span>],dp[i<span class=\"number\">-2</span>]) + cost[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(dp[n<span class=\"number\">-1</span>],dp[n<span class=\"number\">-2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第87天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/min-cost-climbing-stairs/description/\">Min Cost Climbing Stairs</a>：</p>\n<blockquote>\n<p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p>\n<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>\n<p>Example 1:<br>Input: cost = [10, 15, 20]<br>Output: 15<br>Explanation: Cheapest is start on cost[1], pay that cost and go to the top.<br>Example 2:<br>Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>Output: 6<br>Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].<br>Note:<br>cost will have a length in the range [2, 1000].<br>Every cost[i] will be an integer in the range [0, 999].</p>\n</blockquote>\n<p>比较简单的动态规划题，emmm，爬楼梯的升级：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minCostClimbingStairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">    cost.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cost.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">2</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i &lt; n+<span class=\"number\">2</span>;i++) &#123;</span><br><span class=\"line\">        dp[i] = min(dp[i<span class=\"number\">-1</span>],dp[i<span class=\"number\">-2</span>]) + cost[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以做一些简化:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minCostClimbingStairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cost.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = cost[<span class=\"number\">0</span>];</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = cost[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++) &#123;</span><br><span class=\"line\">        dp[i] = min(dp[i<span class=\"number\">-1</span>],dp[i<span class=\"number\">-2</span>]) + cost[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(dp[n<span class=\"number\">-1</span>],dp[n<span class=\"number\">-2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>甚至，如果cost可以修改的话，我们还可以把<code>dp</code>也省下来:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minCostClimbingStairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cost.size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;dp = cost;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++) &#123;</span><br><span class=\"line\">        dp[i] = min(dp[i<span class=\"number\">-1</span>],dp[i<span class=\"number\">-2</span>]) + cost[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(dp[n<span class=\"number\">-1</span>],dp[n<span class=\"number\">-2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Minimum ASCII Delete Sum for Two Strings","date":"2019-12-09T09:17:49.000Z","_content":"\n> 第33天。\n\n今天的题目是[Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/):\n\n一道动态规划的问题，而且挺常规的。这道题的动规方程如下：\n\n$$\ndp[i, j] = \\left\\{\n\\begin{aligned}\n    \\sum_{k=0}^{j} s2[k] & ,& i == 0 \\\\\n    \\sum_{k=0}^{i} s1[k] & ,& j == 0 \\\\\n    dp[i-1, j-1] & ,& s1[i] == s2[j] \\\\\n    min\\{dp[i-1][j] + s1[i], dp[i][j-1] + s2[j]  \\} & ,& s1[i] == s2[j] \n\\end{aligned}\n\\right.\n$$\n\n其中`d[i, j]`表示字符串`s1[0, i)`和字符串`s2[0, j)`的最小删除ASCII之和。根据动规方程可以写出如下代码：\n\n```c++\nint minimumDeleteSum(string s1, string s2) {\n\n    vector<int> dp(s2.size() + 1);\n    dp[0] = 0;\n    for(int i = 1;i < dp.size(); i++) {\n        dp[i] = dp[i-1] + s2[i-1];\n    }\n    \n    int prev;\n    for(int i = 0;i < s1.size(); i++) {\n        prev = dp[0];\n        dp[0] += s1[i];\n        for(int j = 1;j <= s2.size(); j++) {\n            if (s1[i] == s2[j-1]) {\n                swap(prev, dp[j]);\n            } else {\n                prev = dp[j];\n                dp[j] = min(dp[j] + s1[i], dp[j-1] + s2[j-1]);\n            }\n        }\n    }\n    \n    return dp[s2.size()];\n}\n```\n","source":"_posts/Minimum-ASCII-Delete-Sum-for-Two-Strings.md","raw":"---\ntitle: Minimum ASCII Delete Sum for Two Strings\ndate: 2019-12-09T17:17:49.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第33天。\n\n今天的题目是[Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/):\n\n一道动态规划的问题，而且挺常规的。这道题的动规方程如下：\n\n$$\ndp[i, j] = \\left\\{\n\\begin{aligned}\n    \\sum_{k=0}^{j} s2[k] & ,& i == 0 \\\\\n    \\sum_{k=0}^{i} s1[k] & ,& j == 0 \\\\\n    dp[i-1, j-1] & ,& s1[i] == s2[j] \\\\\n    min\\{dp[i-1][j] + s1[i], dp[i][j-1] + s2[j]  \\} & ,& s1[i] == s2[j] \n\\end{aligned}\n\\right.\n$$\n\n其中`d[i, j]`表示字符串`s1[0, i)`和字符串`s2[0, j)`的最小删除ASCII之和。根据动规方程可以写出如下代码：\n\n```c++\nint minimumDeleteSum(string s1, string s2) {\n\n    vector<int> dp(s2.size() + 1);\n    dp[0] = 0;\n    for(int i = 1;i < dp.size(); i++) {\n        dp[i] = dp[i-1] + s2[i-1];\n    }\n    \n    int prev;\n    for(int i = 0;i < s1.size(); i++) {\n        prev = dp[0];\n        dp[0] += s1[i];\n        for(int j = 1;j <= s2.size(); j++) {\n            if (s1[i] == s2[j-1]) {\n                swap(prev, dp[j]);\n            } else {\n                prev = dp[j];\n                dp[j] = min(dp[j] + s1[i], dp[j-1] + s2[j-1]);\n            }\n        }\n    }\n    \n    return dp[s2.size()];\n}\n```\n","slug":"Minimum-ASCII-Delete-Sum-for-Two-Strings","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oy00a2qmcm57hs1yda","content":"<blockquote>\n<p>第33天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\">Minimum ASCII Delete Sum for Two Strings</a>:</p>\n<p>一道动态规划的问题，而且挺常规的。这道题的动规方程如下：</p>\n<p>$$<br>dp[i, j] = \\left{<br>\\begin{aligned}<br>    \\sum_{k=0}^{j} s2[k] &amp; ,&amp; i == 0 \\<br>    \\sum_{k=0}^{i} s1[k] &amp; ,&amp; j == 0 \\<br>    dp[i-1, j-1] &amp; ,&amp; s1[i] == s2[j] \\<br>    min{dp[i-1][j] + s1[i], dp[i][j-1] + s2[j]  } &amp; ,&amp; s1[i] == s2[j]<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>其中<code>d[i, j]</code>表示字符串<code>s1[0, i)</code>和字符串<code>s2[0, j)</code>的最小删除ASCII之和。根据动规方程可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minimumDeleteSum</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(s2.size() + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size(); i++) &#123;</span><br><span class=\"line\">        dp[i] = dp[i<span class=\"number\">-1</span>] + s2[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> prev;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s1.size(); i++) &#123;</span><br><span class=\"line\">        prev = dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] += s1[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt;= s2.size(); j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s1[i] == s2[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                swap(prev, dp[j]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                prev = dp[j];</span><br><span class=\"line\">                dp[j] = min(dp[j] + s1[i], dp[j<span class=\"number\">-1</span>] + s2[j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[s2.size()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第33天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\">Minimum ASCII Delete Sum for Two Strings</a>:</p>\n<p>一道动态规划的问题，而且挺常规的。这道题的动规方程如下：</p>\n<p>$$<br>dp[i, j] = \\left{<br>\\begin{aligned}<br>    \\sum_{k=0}^{j} s2[k] &amp; ,&amp; i == 0 \\<br>    \\sum_{k=0}^{i} s1[k] &amp; ,&amp; j == 0 \\<br>    dp[i-1, j-1] &amp; ,&amp; s1[i] == s2[j] \\<br>    min{dp[i-1][j] + s1[i], dp[i][j-1] + s2[j]  } &amp; ,&amp; s1[i] == s2[j]<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>其中<code>d[i, j]</code>表示字符串<code>s1[0, i)</code>和字符串<code>s2[0, j)</code>的最小删除ASCII之和。根据动规方程可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minimumDeleteSum</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(s2.size() + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; dp.size(); i++) &#123;</span><br><span class=\"line\">        dp[i] = dp[i<span class=\"number\">-1</span>] + s2[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> prev;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s1.size(); i++) &#123;</span><br><span class=\"line\">        prev = dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] += s1[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt;= s2.size(); j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s1[i] == s2[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                swap(prev, dp[j]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                prev = dp[j];</span><br><span class=\"line\">                dp[j] = min(dp[j] + s1[i], dp[j<span class=\"number\">-1</span>] + s2[j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[s2.size()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Minimum Falling Path Sum","date":"2019-03-04T00:32:48.000Z","_content":"\n> 第5天，早起刷题的一天。\n\n今天的题目是[Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/)\n\n一道典型的动态规划题，动态规划的题目一般都可以分为多步走，一旦执行完一步，走下一步时可以利用之前几步的结果来快速的选择下一步要怎么走。\n\n关键就是要找出怎么利用之前几步的结果。\n\n如这里的，我们要知道走到最后一行的最短路径，那么如果我们已经知道了走到倒数第二行（即上一行）的最短路径，我们就可以很快的算出走到最后一行的最短路径，即：\n\n`dp[i][j] = min(dp[i-1][j-1], dp[i][j], dp[i][j+1]) + A[i][j]`\n\n然后很顺手的我们可以用两个数组来优化代码的空间复杂度，即把二维数组转成两个一维数组。\n\n因此代码如下:\n\n```c++\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& A) {\n        int h = A.size(), w;\n        if (h == 0) return 0;\n        w = A[0].size();\n        \n        vector<int> dp0 = A[0];\n        vector<int> dp1(w, INT_MAX);\n        \n        for(int i = 1; i < h; i++) {\n            for(int j = 0;j < w; j++) {\n                dp1[j] = INT_MAX;\n                if (j > 0) dp1[j] = min(dp0[j-1], dp1[j]);\n                dp1[j] = min(dp0[j], dp1[j]);\n                if (j + 1 < w) dp1[j] = min(dp0[j+1], dp1[j]);\n                dp1[j] += A[i][j];\n                \n            }\n            swap(dp1, dp0);\n        }\n        \n        int res = INT_MAX;\n        for(auto &i: dp0) res = min(res, i);\n        return res;\n    }\n};\n```\n","source":"_posts/Minimum-Falling-Path-Sum.md","raw":"---\ntitle: Minimum Falling Path Sum\ndate: 2019-03-04T08:32:48.000Z\ntags:\n  - LeetCode\n  - 动态规划\ncategories:\n  - LeetCode\n---\n\n> 第5天，早起刷题的一天。\n\n今天的题目是[Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/)\n\n一道典型的动态规划题，动态规划的题目一般都可以分为多步走，一旦执行完一步，走下一步时可以利用之前几步的结果来快速的选择下一步要怎么走。\n\n关键就是要找出怎么利用之前几步的结果。\n\n如这里的，我们要知道走到最后一行的最短路径，那么如果我们已经知道了走到倒数第二行（即上一行）的最短路径，我们就可以很快的算出走到最后一行的最短路径，即：\n\n`dp[i][j] = min(dp[i-1][j-1], dp[i][j], dp[i][j+1]) + A[i][j]`\n\n然后很顺手的我们可以用两个数组来优化代码的空间复杂度，即把二维数组转成两个一维数组。\n\n因此代码如下:\n\n```c++\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& A) {\n        int h = A.size(), w;\n        if (h == 0) return 0;\n        w = A[0].size();\n        \n        vector<int> dp0 = A[0];\n        vector<int> dp1(w, INT_MAX);\n        \n        for(int i = 1; i < h; i++) {\n            for(int j = 0;j < w; j++) {\n                dp1[j] = INT_MAX;\n                if (j > 0) dp1[j] = min(dp0[j-1], dp1[j]);\n                dp1[j] = min(dp0[j], dp1[j]);\n                if (j + 1 < w) dp1[j] = min(dp0[j+1], dp1[j]);\n                dp1[j] += A[i][j];\n                \n            }\n            swap(dp1, dp0);\n        }\n        \n        int res = INT_MAX;\n        for(auto &i: dp0) res = min(res, i);\n        return res;\n    }\n};\n```\n","slug":"Minimum-Falling-Path-Sum","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oz00a5qmcm0du88tw7","content":"<blockquote>\n<p>第5天，早起刷题的一天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/minimum-falling-path-sum/\">Minimum Falling Path Sum</a></p>\n<p>一道典型的动态规划题，动态规划的题目一般都可以分为多步走，一旦执行完一步，走下一步时可以利用之前几步的结果来快速的选择下一步要怎么走。</p>\n<p>关键就是要找出怎么利用之前几步的结果。</p>\n<p>如这里的，我们要知道走到最后一行的最短路径，那么如果我们已经知道了走到倒数第二行（即上一行）的最短路径，我们就可以很快的算出走到最后一行的最短路径，即：</p>\n<p><code>dp[i][j] = min(dp[i-1][j-1], dp[i][j], dp[i][j+1]) + A[i][j]</code></p>\n<p>然后很顺手的我们可以用两个数组来优化代码的空间复杂度，即把二维数组转成两个一维数组。</p>\n<p>因此代码如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minFallingPathSum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = A.size(), w;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        w = A[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; dp0 = A[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp1</span><span class=\"params\">(w, INT_MAX)</span></span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; h; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; w; j++) &#123;</span><br><span class=\"line\">                dp1[j] = INT_MAX;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span>) dp1[j] = min(dp0[j<span class=\"number\">-1</span>], dp1[j]);</span><br><span class=\"line\">                dp1[j] = min(dp0[j], dp1[j]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; w) dp1[j] = min(dp0[j+<span class=\"number\">1</span>], dp1[j]);</span><br><span class=\"line\">                dp1[j] += A[i][j];</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(dp1, dp0);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;i: dp0) res = min(res, i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第5天，早起刷题的一天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/minimum-falling-path-sum/\">Minimum Falling Path Sum</a></p>\n<p>一道典型的动态规划题，动态规划的题目一般都可以分为多步走，一旦执行完一步，走下一步时可以利用之前几步的结果来快速的选择下一步要怎么走。</p>\n<p>关键就是要找出怎么利用之前几步的结果。</p>\n<p>如这里的，我们要知道走到最后一行的最短路径，那么如果我们已经知道了走到倒数第二行（即上一行）的最短路径，我们就可以很快的算出走到最后一行的最短路径，即：</p>\n<p><code>dp[i][j] = min(dp[i-1][j-1], dp[i][j], dp[i][j+1]) + A[i][j]</code></p>\n<p>然后很顺手的我们可以用两个数组来优化代码的空间复杂度，即把二维数组转成两个一维数组。</p>\n<p>因此代码如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minFallingPathSum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = A.size(), w;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        w = A[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; dp0 = A[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp1</span><span class=\"params\">(w, INT_MAX)</span></span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; h; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; w; j++) &#123;</span><br><span class=\"line\">                dp1[j] = INT_MAX;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span>) dp1[j] = min(dp0[j<span class=\"number\">-1</span>], dp1[j]);</span><br><span class=\"line\">                dp1[j] = min(dp0[j], dp1[j]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; w) dp1[j] = min(dp0[j+<span class=\"number\">1</span>], dp1[j]);</span><br><span class=\"line\">                dp1[j] += A[i][j];</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(dp1, dp0);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;i: dp0) res = min(res, i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Minimum Moves to Equal Array Elements II","date":"2019-11-24T02:53:34.000Z","_content":"\n> 第20天。\n\n今天的题目是[ Minimum Moves to Equal Array Elements II ]( https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ )：\n\n---\n\nGiven a **non-empty** integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\n\nYou may assume the array's length is at most 10,000.\n\n**Example:**\n\n```\nInput:\n[1,2,3]\n\nOutput:\n2\n\nExplanation:\nOnly two moves are needed (remember each move increments or decrements one element):\n\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n```\n\n---\n\n这道题需要一些数学推导，它的目标就是：\n\n$$\nmin_k \\{ \\sum_{i=1}^n |n_i - n_k| \\}\n$$\n其中 $n_i$ 表示数组排序后中第 $i$ 个元素。\n\n我们将式子展开可以得到：\n$$\nmin_k \\{ \\sum_{i=1}^n |n_i - n_k| \\} = \n\nmin_k \\{ \\sum_{i=1}^k (n_k-n_i) + \\sum_{i=k+1}^n(n_i-n_k) \\} \\\\\n\n= min_k \\{ \\sum_{i=1}^k n_k - \\sum_{i=1}^k n_i + \\sum_{i=k+1}^n n_i - \\sum_{i=k+1}^n n_k  \\} \\\\\n\n= min_k \\{ \\sum_{i=k+1}^n n_i - \\sum_{i=1}^k n_i + (2k - n)n_k  \\}\n$$\n因此，我们可以写出如下代码：\n\n```c++\nint minMoves2(vector<int>& nums) {\n    long long res = LONG_MAX;\n    sort(nums.begin(), nums.end());\n    long long rightSum = 0;\n    for(auto i: nums) rightSum += i;\n    long long leftSum = 0;\n    int n = nums.size();\n\n    for(int i = 0;i < n; ++i) {\n        res = min(res, rightSum - leftSum + (2*i - n) * (long long)nums[i]);\n        rightSum -= nums[i];\n        leftSum += nums[i];\n        // cout << res << endl;\n    }\n\n    return res;\n}\n```\n\n这样还不是最优解，然而最优解我没看懂（捂脸），为什么用中位数求就是对的呢？：\n\n```c++\n    int minMoves2(vector<int>& nums) {\n                \n        sort(nums.begin(), nums.end());\n        \n        int mid;\n        \n        if (nums.size() % 2 == 0){\n            \n            mid = (nums[nums.size()/2] + nums[(nums.size()/2) - 1])/2;\n            \n        }else{\n            \n            mid = nums[nums.size()/2];\n            \n        }\n        \n        int result = 0;\n        \n        for (int i = 0; i < nums.size(); i++){\n            \n            result += abs(nums[i] - mid);\n            \n        }\n        \n        return result;\n        \n    }\n```\n\n","source":"_posts/Minimum-Moves-to-Equal-Array-Elements-II.md","raw":"---\ntitle: Minimum Moves to Equal Array Elements II\ndate: 2019-11-24T10:53:34.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第20天。\n\n今天的题目是[ Minimum Moves to Equal Array Elements II ]( https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ )：\n\n---\n\nGiven a **non-empty** integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\n\nYou may assume the array's length is at most 10,000.\n\n**Example:**\n\n```\nInput:\n[1,2,3]\n\nOutput:\n2\n\nExplanation:\nOnly two moves are needed (remember each move increments or decrements one element):\n\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n```\n\n---\n\n这道题需要一些数学推导，它的目标就是：\n\n$$\nmin_k \\{ \\sum_{i=1}^n |n_i - n_k| \\}\n$$\n其中 $n_i$ 表示数组排序后中第 $i$ 个元素。\n\n我们将式子展开可以得到：\n$$\nmin_k \\{ \\sum_{i=1}^n |n_i - n_k| \\} = \n\nmin_k \\{ \\sum_{i=1}^k (n_k-n_i) + \\sum_{i=k+1}^n(n_i-n_k) \\} \\\\\n\n= min_k \\{ \\sum_{i=1}^k n_k - \\sum_{i=1}^k n_i + \\sum_{i=k+1}^n n_i - \\sum_{i=k+1}^n n_k  \\} \\\\\n\n= min_k \\{ \\sum_{i=k+1}^n n_i - \\sum_{i=1}^k n_i + (2k - n)n_k  \\}\n$$\n因此，我们可以写出如下代码：\n\n```c++\nint minMoves2(vector<int>& nums) {\n    long long res = LONG_MAX;\n    sort(nums.begin(), nums.end());\n    long long rightSum = 0;\n    for(auto i: nums) rightSum += i;\n    long long leftSum = 0;\n    int n = nums.size();\n\n    for(int i = 0;i < n; ++i) {\n        res = min(res, rightSum - leftSum + (2*i - n) * (long long)nums[i]);\n        rightSum -= nums[i];\n        leftSum += nums[i];\n        // cout << res << endl;\n    }\n\n    return res;\n}\n```\n\n这样还不是最优解，然而最优解我没看懂（捂脸），为什么用中位数求就是对的呢？：\n\n```c++\n    int minMoves2(vector<int>& nums) {\n                \n        sort(nums.begin(), nums.end());\n        \n        int mid;\n        \n        if (nums.size() % 2 == 0){\n            \n            mid = (nums[nums.size()/2] + nums[(nums.size()/2) - 1])/2;\n            \n        }else{\n            \n            mid = nums[nums.size()/2];\n            \n        }\n        \n        int result = 0;\n        \n        for (int i = 0; i < nums.size(); i++){\n            \n            result += abs(nums[i] - mid);\n            \n        }\n        \n        return result;\n        \n    }\n```\n\n","slug":"Minimum-Moves-to-Equal-Array-Elements-II","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69oz00a8qmcma9t886yk","content":"<blockquote>\n<p>第20天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/\"> Minimum Moves to Equal Array Elements II </a>：</p>\n<hr>\n<p>Given a <strong>non-empty</strong> integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>\n<p>You may assume the array’s length is at most 10,000.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[1,2,3]</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">2</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Only two moves are needed (remember each move increments or decrements one element):</span><br><span class=\"line\"></span><br><span class=\"line\">[1,2,3]  &#x3D;&gt;  [2,2,3]  &#x3D;&gt;  [2,2,2]</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>这道题需要一些数学推导，它的目标就是：</p>\n<p>$$<br>min_k { \\sum_{i=1}^n |n_i - n_k| }<br>$$<br>其中 $n_i$ 表示数组排序后中第 $i$ 个元素。</p>\n<p>我们将式子展开可以得到：<br>$$<br>min_k { \\sum_{i=1}^n |n_i - n_k| } = </p>\n<p>min_k { \\sum_{i=1}^k (n_k-n_i) + \\sum_{i=k+1}^n(n_i-n_k) } \\</p>\n<p>= min_k { \\sum_{i=1}^k n_k - \\sum_{i=1}^k n_i + \\sum_{i=k+1}^n n_i - \\sum_{i=k+1}^n n_k  } \\</p>\n<p>= min_k { \\sum_{i=k+1}^n n_i - \\sum_{i=1}^k n_i + (2k - n)n_k  }<br>$$<br>因此，我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minMoves2</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = LONG_MAX;</span><br><span class=\"line\">    sort(nums.begin(), nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> rightSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i: nums) rightSum += i;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> leftSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n; ++i) &#123;</span><br><span class=\"line\">        res = min(res, rightSum - leftSum + (<span class=\"number\">2</span>*i - n) * (<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)nums[i]);</span><br><span class=\"line\">        rightSum -= nums[i];</span><br><span class=\"line\">        leftSum += nums[i];</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样还不是最优解，然而最优解我没看懂（捂脸），为什么用中位数求就是对的呢？：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minMoves2</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">    sort(nums.begin(), nums.end());</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        mid = (nums[nums.size()/<span class=\"number\">2</span>] + nums[(nums.size()/<span class=\"number\">2</span>) - <span class=\"number\">1</span>])/<span class=\"number\">2</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        mid = nums[nums.size()/<span class=\"number\">2</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        result += <span class=\"built_in\">abs</span>(nums[i] - mid);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第20天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/\"> Minimum Moves to Equal Array Elements II </a>：</p>\n<hr>\n<p>Given a <strong>non-empty</strong> integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>\n<p>You may assume the array’s length is at most 10,000.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[1,2,3]</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">2</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Only two moves are needed (remember each move increments or decrements one element):</span><br><span class=\"line\"></span><br><span class=\"line\">[1,2,3]  &#x3D;&gt;  [2,2,3]  &#x3D;&gt;  [2,2,2]</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>这道题需要一些数学推导，它的目标就是：</p>\n<p>$$<br>min_k { \\sum_{i=1}^n |n_i - n_k| }<br>$$<br>其中 $n_i$ 表示数组排序后中第 $i$ 个元素。</p>\n<p>我们将式子展开可以得到：<br>$$<br>min_k { \\sum_{i=1}^n |n_i - n_k| } = </p>\n<p>min_k { \\sum_{i=1}^k (n_k-n_i) + \\sum_{i=k+1}^n(n_i-n_k) } \\</p>\n<p>= min_k { \\sum_{i=1}^k n_k - \\sum_{i=1}^k n_i + \\sum_{i=k+1}^n n_i - \\sum_{i=k+1}^n n_k  } \\</p>\n<p>= min_k { \\sum_{i=k+1}^n n_i - \\sum_{i=1}^k n_i + (2k - n)n_k  }<br>$$<br>因此，我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minMoves2</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = LONG_MAX;</span><br><span class=\"line\">    sort(nums.begin(), nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> rightSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i: nums) rightSum += i;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> leftSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n; ++i) &#123;</span><br><span class=\"line\">        res = min(res, rightSum - leftSum + (<span class=\"number\">2</span>*i - n) * (<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)nums[i]);</span><br><span class=\"line\">        rightSum -= nums[i];</span><br><span class=\"line\">        leftSum += nums[i];</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样还不是最优解，然而最优解我没看懂（捂脸），为什么用中位数求就是对的呢？：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minMoves2</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">    sort(nums.begin(), nums.end());</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        mid = (nums[nums.size()/<span class=\"number\">2</span>] + nums[(nums.size()/<span class=\"number\">2</span>) - <span class=\"number\">1</span>])/<span class=\"number\">2</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        mid = nums[nums.size()/<span class=\"number\">2</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        result += <span class=\"built_in\">abs</span>(nums[i] - mid);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Move-Zeroes","date":"2017-11-09T00:07:21.000Z","_content":"\n第44天。\n\n今天的题目是[Move Zeroes](https://leetcode.com/problems/move-zeroes/description/):\n\n> Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n>\n> For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\n>\n> Note:\n> You must do this in-place without making a copy of the array.\n> Minimize the total number of operations.\n\n这道题目要求我们原地的移动元素，而且还要保持序列本身的顺序。\n\n我们可以利用一下计数排序的思想，反正最后都是`0`,我只要算出有几个`0`要放在最后，我就可以很方便的产生后缀啦，所以这里先遍历一遍序列记录`0`的个数，然后我们发现其实每个元素向前移动多少格是和它前面有多少个`0`有关的,so ：\n\n\n```c++\nvoid moveZeroes(vector<int>& nums) {\n    int zero = 0,size = nums.size(),i,j;\n    for(i = 0;i < size;i++) {\n        if (nums[i] == 0) zero++;\n        else if (zero != 0) nums[i-zero] = nums[i];\n    }\n    j = size - 1;\n    size -= zero;\n    while(j >= size) nums[j--] = 0;\n}\n```\n\n虽然写的不是很优雅的样子，但是这个思路是正确的，还有`dicuss`中的解法也是这个思路。\n\n```c++\nvoid moveZeroes(vector<int>& nums) {\n    int j = 0;\n    // move all the nonzero elements advance\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[j++] = nums[i];\n        }\n    }\n    for (;j < nums.size(); j++) {\n        nums[j] = 0;\n    }\n}\n```\n","source":"_posts/Move-Zeroes.md","raw":"---\ntitle: Move-Zeroes\ndate: 2017-11-09T08:07:21.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第44天。\n\n今天的题目是[Move Zeroes](https://leetcode.com/problems/move-zeroes/description/):\n\n> Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n>\n> For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\n>\n> Note:\n> You must do this in-place without making a copy of the array.\n> Minimize the total number of operations.\n\n这道题目要求我们原地的移动元素，而且还要保持序列本身的顺序。\n\n我们可以利用一下计数排序的思想，反正最后都是`0`,我只要算出有几个`0`要放在最后，我就可以很方便的产生后缀啦，所以这里先遍历一遍序列记录`0`的个数，然后我们发现其实每个元素向前移动多少格是和它前面有多少个`0`有关的,so ：\n\n\n```c++\nvoid moveZeroes(vector<int>& nums) {\n    int zero = 0,size = nums.size(),i,j;\n    for(i = 0;i < size;i++) {\n        if (nums[i] == 0) zero++;\n        else if (zero != 0) nums[i-zero] = nums[i];\n    }\n    j = size - 1;\n    size -= zero;\n    while(j >= size) nums[j--] = 0;\n}\n```\n\n虽然写的不是很优雅的样子，但是这个思路是正确的，还有`dicuss`中的解法也是这个思路。\n\n```c++\nvoid moveZeroes(vector<int>& nums) {\n    int j = 0;\n    // move all the nonzero elements advance\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[j++] = nums[i];\n        }\n    }\n    for (;j < nums.size(); j++) {\n        nums[j] = 0;\n    }\n}\n```\n","slug":"Move-Zeroes","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p000abqmcm0uvv73qr","content":"<p>第44天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/move-zeroes/description/\">Move Zeroes</a>:</p>\n<blockquote>\n<p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>\n<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>\n<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>\n</blockquote>\n<p>这道题目要求我们原地的移动元素，而且还要保持序列本身的顺序。</p>\n<p>我们可以利用一下计数排序的思想，反正最后都是<code>0</code>,我只要算出有几个<code>0</code>要放在最后，我就可以很方便的产生后缀啦，所以这里先遍历一遍序列记录<code>0</code>的个数，然后我们发现其实每个元素向前移动多少格是和它前面有多少个<code>0</code>有关的,so ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> zero = <span class=\"number\">0</span>,size = nums.size(),i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; size;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">0</span>) zero++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zero != <span class=\"number\">0</span>) nums[i-zero] = nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    j = size - <span class=\"number\">1</span>;</span><br><span class=\"line\">    size -= zero;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &gt;= size) nums[j--] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然写的不是很优雅的样子，但是这个思路是正确的，还有<code>dicuss</code>中的解法也是这个思路。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// move all the nonzero elements advance</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            nums[j++] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;j &lt; nums.size(); j++) &#123;</span><br><span class=\"line\">        nums[j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第44天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/move-zeroes/description/\">Move Zeroes</a>:</p>\n<blockquote>\n<p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>\n<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>\n<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>\n</blockquote>\n<p>这道题目要求我们原地的移动元素，而且还要保持序列本身的顺序。</p>\n<p>我们可以利用一下计数排序的思想，反正最后都是<code>0</code>,我只要算出有几个<code>0</code>要放在最后，我就可以很方便的产生后缀啦，所以这里先遍历一遍序列记录<code>0</code>的个数，然后我们发现其实每个元素向前移动多少格是和它前面有多少个<code>0</code>有关的,so ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> zero = <span class=\"number\">0</span>,size = nums.size(),i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; size;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">0</span>) zero++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zero != <span class=\"number\">0</span>) nums[i-zero] = nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    j = size - <span class=\"number\">1</span>;</span><br><span class=\"line\">    size -= zero;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &gt;= size) nums[j--] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然写的不是很优雅的样子，但是这个思路是正确的，还有<code>dicuss</code>中的解法也是这个思路。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// move all the nonzero elements advance</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            nums[j++] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;j &lt; nums.size(); j++) &#123;</span><br><span class=\"line\">        nums[j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"N-ary Tree Level Order Traversal","date":"2019-11-23T02:09:08.000Z","_content":"\n> 第19天。\n\n今天的题目是[ N-ary Tree Level Order Traversal ]( https://leetcode.com/problems/n-ary-tree-level-order-traversal/ ):\n\n---\n\nGiven an n-ary tree, return the *level order* traversal of its nodes' values.\n\n*Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).*\n\n \n\n**Example 1:**\n\n![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n\n```\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: [[1],[3,2,4],[5,6]]\n```\n\n**Example 2:**\n\n![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n\n```\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n```\n\n \n\n**Constraints:**\n\n- The height of the n-ary tree is less than or equal to `1000`\n- The total number of nodes is between `[0, 10^4]`\n\n---\n\n一道水题，简单的`BFS`或`DFS`即可，除了是一个多叉树外，和另外一道题基本是一样的。\n\n```c++\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n```\n\n所以，我们既可以用队列去做层次遍历(BFS)，也可以用递归来实现DFS，然后按当前节点所在的高度插入到对于的数组即可：\n\n1. DFS\n\n```c++\nvector<vector<int>> res;\nvector<vector<int>> levelOrder(Node* root) {\n    dfsWithHeight(root, 0);\n    return res;\n}\nvoid dfsWithHeight(Node *root, int h) {\n    if (root == nullptr) return;\n    if (h == res.size()) res.push_back(vector<int>());\n    res[h].push_back(root->val);\n    for(int i = 0;i < root->children.size(); i++) {\n        dfsWithHeight(root->children[i], h + 1);\n    }\n}\n```\n\n2. BFS\n\n```c++\nvector<vector<int>> levelOrder2(Node* root) {\n    vector<vector<int>> res;\n    if (root == nullptr) {\n        return res;\n    }\n    vector<int> vec;\n    queue<Node *> q;\n    q.push(root);\n    q.push(nullptr);\n    while(q.size() != 1) {\n        vec.clear();\n        root = q.front();\n        while(root) {\n            q.pop();\n            vec.push_back(root->val);\n            // cout << root->val << endl;\n            for(int i = 0;i < root->children.size(); i++) {\n                q.push(root->children[i]);\n            }\n            root = q.front();\n        }\n        q.pop();\n        q.push(nullptr);\n        res.push_back(vec);\n    }\n\n    return res;\n}\n\nvector<vector<int>> levelOrder1(Node* root) {\n    vector<vector<int>> res;\n    if (root == nullptr) {\n        return res;\n    }\n    vector<int> vec;\n    vector<Node *> nodes;\n    vector<Node *> nextLevelNodes;\n    nodes.push_back(root);\n    while(!nodes.empty()) {\n        vec.clear();\n        nextLevelNodes.clear();\n        for(int i = 0;i < nodes.size(); i++) {\n            vec.push_back(nodes[i]->val);\n            for(int j = 0;j < nodes[i]->children.size(); j++) {\n                nextLevelNodes.push_back(nodes[i]->children[j]);\n            }\n        }\n        swap(nodes, nextLevelNodes);\n        res.push_back(vec);\n    }\n    return res;\n}\n```\n\n","source":"_posts/N-ary-Tree-Level-Order-Traversal.md","raw":"---\ntitle: N-ary Tree Level Order Traversal\ndate: 2019-11-23T10:09:08.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第19天。\n\n今天的题目是[ N-ary Tree Level Order Traversal ]( https://leetcode.com/problems/n-ary-tree-level-order-traversal/ ):\n\n---\n\nGiven an n-ary tree, return the *level order* traversal of its nodes' values.\n\n*Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).*\n\n \n\n**Example 1:**\n\n![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n\n```\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: [[1],[3,2,4],[5,6]]\n```\n\n**Example 2:**\n\n![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n\n```\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n```\n\n \n\n**Constraints:**\n\n- The height of the n-ary tree is less than or equal to `1000`\n- The total number of nodes is between `[0, 10^4]`\n\n---\n\n一道水题，简单的`BFS`或`DFS`即可，除了是一个多叉树外，和另外一道题基本是一样的。\n\n```c++\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n```\n\n所以，我们既可以用队列去做层次遍历(BFS)，也可以用递归来实现DFS，然后按当前节点所在的高度插入到对于的数组即可：\n\n1. DFS\n\n```c++\nvector<vector<int>> res;\nvector<vector<int>> levelOrder(Node* root) {\n    dfsWithHeight(root, 0);\n    return res;\n}\nvoid dfsWithHeight(Node *root, int h) {\n    if (root == nullptr) return;\n    if (h == res.size()) res.push_back(vector<int>());\n    res[h].push_back(root->val);\n    for(int i = 0;i < root->children.size(); i++) {\n        dfsWithHeight(root->children[i], h + 1);\n    }\n}\n```\n\n2. BFS\n\n```c++\nvector<vector<int>> levelOrder2(Node* root) {\n    vector<vector<int>> res;\n    if (root == nullptr) {\n        return res;\n    }\n    vector<int> vec;\n    queue<Node *> q;\n    q.push(root);\n    q.push(nullptr);\n    while(q.size() != 1) {\n        vec.clear();\n        root = q.front();\n        while(root) {\n            q.pop();\n            vec.push_back(root->val);\n            // cout << root->val << endl;\n            for(int i = 0;i < root->children.size(); i++) {\n                q.push(root->children[i]);\n            }\n            root = q.front();\n        }\n        q.pop();\n        q.push(nullptr);\n        res.push_back(vec);\n    }\n\n    return res;\n}\n\nvector<vector<int>> levelOrder1(Node* root) {\n    vector<vector<int>> res;\n    if (root == nullptr) {\n        return res;\n    }\n    vector<int> vec;\n    vector<Node *> nodes;\n    vector<Node *> nextLevelNodes;\n    nodes.push_back(root);\n    while(!nodes.empty()) {\n        vec.clear();\n        nextLevelNodes.clear();\n        for(int i = 0;i < nodes.size(); i++) {\n            vec.push_back(nodes[i]->val);\n            for(int j = 0;j < nodes[i]->children.size(); j++) {\n                nextLevelNodes.push_back(nodes[i]->children[j]);\n            }\n        }\n        swap(nodes, nextLevelNodes);\n        res.push_back(vec);\n    }\n    return res;\n}\n```\n\n","slug":"N-ary-Tree-Level-Order-Traversal","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p100aeqmcma8vcb0ch","content":"<blockquote>\n<p>第19天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/n-ary-tree-level-order-traversal/\"> N-ary Tree Level Order Traversal </a>:</p>\n<hr>\n<p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes’ values.</p>\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n<p><strong>Example 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class=\"line\">Output: [[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class=\"line\">Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Constraints:</strong></p>\n<ul>\n<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n<li>The total number of nodes is between <code>[0, 10^4]</code></li>\n</ul>\n<hr>\n<p>一道水题，简单的<code>BFS</code>或<code>DFS</code>即可，除了是一个多叉树外，和另外一道题基本是一样的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Node*&gt; children;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> _val, <span class=\"built_in\">vector</span>&lt;Node*&gt; _children) &#123;</span><br><span class=\"line\">        val = _val;</span><br><span class=\"line\">        children = _children;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>所以，我们既可以用队列去做层次遍历(BFS)，也可以用递归来实现DFS，然后按当前节点所在的高度插入到对于的数组即可：</p>\n<ol>\n<li>DFS</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class=\"line\">    dfsWithHeight(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfsWithHeight</span><span class=\"params\">(Node *root, <span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == res.size()) res.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    res[h].push_back(root-&gt;val);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; root-&gt;children.size(); i++) &#123;</span><br><span class=\"line\">        dfsWithHeight(root-&gt;children[i], h + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>BFS</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder2(Node* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;Node *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(q.size() != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        root = q.front();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">            vec.push_back(root-&gt;val);</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; root-&gt;children.size(); i++) &#123;</span><br><span class=\"line\">                q.push(root-&gt;children[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = q.front();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\">        q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        res.push_back(vec);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder1(Node* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Node *&gt; nodes;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Node *&gt; nextLevelNodes;</span><br><span class=\"line\">    nodes.push_back(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!nodes.empty()) &#123;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        nextLevelNodes.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nodes.size(); i++) &#123;</span><br><span class=\"line\">            vec.push_back(nodes[i]-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; nodes[i]-&gt;children.size(); j++) &#123;</span><br><span class=\"line\">                nextLevelNodes.push_back(nodes[i]-&gt;children[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nodes, nextLevelNodes);</span><br><span class=\"line\">        res.push_back(vec);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第19天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/n-ary-tree-level-order-traversal/\"> N-ary Tree Level Order Traversal </a>:</p>\n<hr>\n<p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes’ values.</p>\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n<p><strong>Example 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class=\"line\">Output: [[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class=\"line\">Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Constraints:</strong></p>\n<ul>\n<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n<li>The total number of nodes is between <code>[0, 10^4]</code></li>\n</ul>\n<hr>\n<p>一道水题，简单的<code>BFS</code>或<code>DFS</code>即可，除了是一个多叉树外，和另外一道题基本是一样的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Node*&gt; children;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> _val, <span class=\"built_in\">vector</span>&lt;Node*&gt; _children) &#123;</span><br><span class=\"line\">        val = _val;</span><br><span class=\"line\">        children = _children;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>所以，我们既可以用队列去做层次遍历(BFS)，也可以用递归来实现DFS，然后按当前节点所在的高度插入到对于的数组即可：</p>\n<ol>\n<li>DFS</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class=\"line\">    dfsWithHeight(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfsWithHeight</span><span class=\"params\">(Node *root, <span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == res.size()) res.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    res[h].push_back(root-&gt;val);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; root-&gt;children.size(); i++) &#123;</span><br><span class=\"line\">        dfsWithHeight(root-&gt;children[i], h + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>BFS</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder2(Node* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;Node *&gt; q;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(q.size() != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        root = q.front();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">            vec.push_back(root-&gt;val);</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; root-&gt;children.size(); i++) &#123;</span><br><span class=\"line\">                q.push(root-&gt;children[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = q.front();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\">        q.push(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        res.push_back(vec);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder1(Node* root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Node *&gt; nodes;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Node *&gt; nextLevelNodes;</span><br><span class=\"line\">    nodes.push_back(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!nodes.empty()) &#123;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        nextLevelNodes.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nodes.size(); i++) &#123;</span><br><span class=\"line\">            vec.push_back(nodes[i]-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; nodes[i]-&gt;children.size(); j++) &#123;</span><br><span class=\"line\">                nextLevelNodes.push_back(nodes[i]-&gt;children[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nodes, nextLevelNodes);</span><br><span class=\"line\">        res.push_back(vec);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Network Delay Time","date":"2019-12-16T06:22:11.000Z","_content":"\n> 第40天。\n\n今天的题目是[Network Delay Time](https://leetcode.com/problems/network-delay-time/):\n\n一道图的题目，比较常规，用Dijkstra求单源最短路，然后取距离最远的那个即可得到`Network Delay Time`:\n\n```c++\nint minDisNode(vector<bool> &visited, vector<int> &dis) {\n    int min_v = INT_MAX, min_i = -1;;\n    for(int j = 0;j < dis.size();j++) {\n        if (!visited[j] && dis[j] < min_v) {\n            min_v = dis[j];\n            min_i = j;\n        }\n    }\n    return min_i;\n}\nint networkDelayTime(vector<vector<int>>& times, int N, int K) {\n    if (times.size() == 0 || N==0 || K <= 0) return -1; \n    //build graph;\n    vector<vector<int>> graph(N, vector<int>(N, INT_MAX));\n    for(auto &t: times) {\n        graph[t[0]-1][t[1]-1] = t[2];\n    }\n\n    K--;\n    vector<int> dis(N, INT_MAX);\n    vector<bool> visited(N, false);\n    visited[K] = true;\n    for(int i = 0;i < dis.size(); i++) {\n        dis[i] = graph[K][i];\n    }\n    dis[K] = 0;\n\n    for(int i = 1;i < N; i++) {\n        // find a unvisited node which dis is min\n        int j = minDisNode(visited, dis);\n        if (j == -1) return -1;\n        \n        visited[j] = true;\n        for(int k = 0;k < dis.size(); k++) {\n            if (graph[j][k] != INT_MAX) {\n                dis[k] = min(dis[k], dis[j] + graph[j][k]);\n            }\n        }\n    }\n    \n    int res = 0;\n    for(int i = 0;i < N;i++) {\n        if (dis[i] != INT_MAX)\n            res = max(res, dis[i]);\n    }\n    return res;\n}\n```\n","source":"_posts/Network-Delay-Time.md","raw":"---\ntitle: Network Delay Time\ndate: 2019-12-16T14:22:11.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第40天。\n\n今天的题目是[Network Delay Time](https://leetcode.com/problems/network-delay-time/):\n\n一道图的题目，比较常规，用Dijkstra求单源最短路，然后取距离最远的那个即可得到`Network Delay Time`:\n\n```c++\nint minDisNode(vector<bool> &visited, vector<int> &dis) {\n    int min_v = INT_MAX, min_i = -1;;\n    for(int j = 0;j < dis.size();j++) {\n        if (!visited[j] && dis[j] < min_v) {\n            min_v = dis[j];\n            min_i = j;\n        }\n    }\n    return min_i;\n}\nint networkDelayTime(vector<vector<int>>& times, int N, int K) {\n    if (times.size() == 0 || N==0 || K <= 0) return -1; \n    //build graph;\n    vector<vector<int>> graph(N, vector<int>(N, INT_MAX));\n    for(auto &t: times) {\n        graph[t[0]-1][t[1]-1] = t[2];\n    }\n\n    K--;\n    vector<int> dis(N, INT_MAX);\n    vector<bool> visited(N, false);\n    visited[K] = true;\n    for(int i = 0;i < dis.size(); i++) {\n        dis[i] = graph[K][i];\n    }\n    dis[K] = 0;\n\n    for(int i = 1;i < N; i++) {\n        // find a unvisited node which dis is min\n        int j = minDisNode(visited, dis);\n        if (j == -1) return -1;\n        \n        visited[j] = true;\n        for(int k = 0;k < dis.size(); k++) {\n            if (graph[j][k] != INT_MAX) {\n                dis[k] = min(dis[k], dis[j] + graph[j][k]);\n            }\n        }\n    }\n    \n    int res = 0;\n    for(int i = 0;i < N;i++) {\n        if (dis[i] != INT_MAX)\n            res = max(res, dis[i]);\n    }\n    return res;\n}\n```\n","slug":"Network-Delay-Time","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p200ahqmcmfm0ag0x2","content":"<blockquote>\n<p>第40天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/network-delay-time/\">Network Delay Time</a>:</p>\n<p>一道图的题目，比较常规，用Dijkstra求单源最短路，然后取距离最远的那个即可得到<code>Network Delay Time</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDisNode</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &amp;visited, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;dis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_v = INT_MAX, min_i = <span class=\"number\">-1</span>;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; dis.size();j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[j] &amp;&amp; dis[j] &lt; min_v) &#123;</span><br><span class=\"line\">            min_v = dis[j];</span><br><span class=\"line\">            min_i = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min_i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">networkDelayTime</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; times, <span class=\"keyword\">int</span> N, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (times.size() == <span class=\"number\">0</span> || N==<span class=\"number\">0</span> || K &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    <span class=\"comment\">//build graph;</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; graph(N, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(N, INT_MAX));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;t: times) &#123;</span><br><span class=\"line\">        graph[t[<span class=\"number\">0</span>]<span class=\"number\">-1</span>][t[<span class=\"number\">1</span>]<span class=\"number\">-1</span>] = t[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    K--;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dis</span><span class=\"params\">(N, INT_MAX)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(N, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    visited[K] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; dis.size(); i++) &#123;</span><br><span class=\"line\">        dis[i] = graph[K][i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dis[K] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; N; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// find a unvisited node which dis is min</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = minDisNode(visited, dis);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        visited[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;k &lt; dis.size(); k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (graph[j][k] != INT_MAX) &#123;</span><br><span class=\"line\">                dis[k] = min(dis[k], dis[j] + graph[j][k]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; N;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dis[i] != INT_MAX)</span><br><span class=\"line\">            res = max(res, dis[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第40天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/network-delay-time/\">Network Delay Time</a>:</p>\n<p>一道图的题目，比较常规，用Dijkstra求单源最短路，然后取距离最远的那个即可得到<code>Network Delay Time</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDisNode</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &amp;visited, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;dis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_v = INT_MAX, min_i = <span class=\"number\">-1</span>;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; dis.size();j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[j] &amp;&amp; dis[j] &lt; min_v) &#123;</span><br><span class=\"line\">            min_v = dis[j];</span><br><span class=\"line\">            min_i = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min_i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">networkDelayTime</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; times, <span class=\"keyword\">int</span> N, <span class=\"keyword\">int</span> K)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (times.size() == <span class=\"number\">0</span> || N==<span class=\"number\">0</span> || K &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">    <span class=\"comment\">//build graph;</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; graph(N, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(N, INT_MAX));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;t: times) &#123;</span><br><span class=\"line\">        graph[t[<span class=\"number\">0</span>]<span class=\"number\">-1</span>][t[<span class=\"number\">1</span>]<span class=\"number\">-1</span>] = t[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    K--;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dis</span><span class=\"params\">(N, INT_MAX)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(N, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    visited[K] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; dis.size(); i++) &#123;</span><br><span class=\"line\">        dis[i] = graph[K][i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dis[K] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; N; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// find a unvisited node which dis is min</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = minDisNode(visited, dis);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        visited[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;k &lt; dis.size(); k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (graph[j][k] != INT_MAX) &#123;</span><br><span class=\"line\">                dis[k] = min(dis[k], dis[j] + graph[j][k]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; N;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dis[i] != INT_MAX)</span><br><span class=\"line\">            res = max(res, dis[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Next Greater Element III","date":"2019-11-13T14:47:20.000Z","_content":"\n> 第9天了。\n\n今天的题目是[ Next Greater Element III ]( https://leetcode.com/problems/next-greater-element-iii/ ):\n\n---\n\nGiven a positive **32-bit** integer **n**, you need to find the smallest **32-bit** integer which has exactly the same digits existing in the integer **n** and is greater in value than n. If no such positive **32-bit** integer exists, you need to return -1.\n\n**Example 1:**\n\n```\nInput: 12\nOutput: 21\n```\n\n \n\n**Example 2:**\n\n```\nInput: 21\nOutput: -1\n```\n\n---\n\n这道题我的解法是：\n\n1. 先将数字转换成数组，由于是除法和取余解析出来的数组，所以整个数组是倒过来的，即`123`得到`[3,2,1]`\n2. 从前向后遍历找到第一个逆序（即`vec[i-1] > vec[i`)的情况。\n3. 从`vec[0: i]`找到第一个小于等于`vec[i]`的元素`vec[j]`。\n4. 交换`vec[i]`和`vec[j]`，然后将`vec[0: i]`逆序。\n5. 将`vec`转换回数字，最后判断一下是否溢出即可。\n\n```c++\nint nextGreaterElement(int n) {\n    long res = 0;\n    vector<int> vec;\n    while(n) {\n        vec.push_back(n % 10);\n        n /= 10;\n    }\n    int i, j;\n    for(i = 1;i < vec.size() && vec[i-1] <= vec[i] ;++i) {   \n\n    }\n    if (i == vec.size()) return -1;\n\n    for(j = 0;vec[i] >= vec[j];++j) {\n\n    }\n    swap(vec[i], vec[j]);\n    for(j = 0, i = i - 1; j < i; j++, i--) {\n        swap(vec[i], vec[j]);\n    }\n\n    for(i = vec.size() -1;i >= 0; i--) {\n\n        res = res * 10 + vec[i];\n    }\n    if (res > INT_MAX) return -1;\n    return res;\n}\n```\n\n其实写到这里基本上发现，这道题就是找全排列中的下一个元素，而这个功能，在C++中提供了一个好用的函数：` next_permutation `，所以我们可以先用`to_string`转换成字符数组，然后用`next_permutation`来解这道题：\n\n```c++\nint nextGreaterElement(int n) {\n    string s = to_string(n);\n    if (next_permutation(s.begin(), s.end())) {\n        long temp = atol(s.c_str());\n        if (temp <= INT_MAX)  return temp;\n        else return -1;\n    }\n    return -1;\n}\n```\n\n","source":"_posts/Next-Greater-Element-III.md","raw":"---\ntitle: Next Greater Element III\ndate: 2019-11-13T22:47:20.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第9天了。\n\n今天的题目是[ Next Greater Element III ]( https://leetcode.com/problems/next-greater-element-iii/ ):\n\n---\n\nGiven a positive **32-bit** integer **n**, you need to find the smallest **32-bit** integer which has exactly the same digits existing in the integer **n** and is greater in value than n. If no such positive **32-bit** integer exists, you need to return -1.\n\n**Example 1:**\n\n```\nInput: 12\nOutput: 21\n```\n\n \n\n**Example 2:**\n\n```\nInput: 21\nOutput: -1\n```\n\n---\n\n这道题我的解法是：\n\n1. 先将数字转换成数组，由于是除法和取余解析出来的数组，所以整个数组是倒过来的，即`123`得到`[3,2,1]`\n2. 从前向后遍历找到第一个逆序（即`vec[i-1] > vec[i`)的情况。\n3. 从`vec[0: i]`找到第一个小于等于`vec[i]`的元素`vec[j]`。\n4. 交换`vec[i]`和`vec[j]`，然后将`vec[0: i]`逆序。\n5. 将`vec`转换回数字，最后判断一下是否溢出即可。\n\n```c++\nint nextGreaterElement(int n) {\n    long res = 0;\n    vector<int> vec;\n    while(n) {\n        vec.push_back(n % 10);\n        n /= 10;\n    }\n    int i, j;\n    for(i = 1;i < vec.size() && vec[i-1] <= vec[i] ;++i) {   \n\n    }\n    if (i == vec.size()) return -1;\n\n    for(j = 0;vec[i] >= vec[j];++j) {\n\n    }\n    swap(vec[i], vec[j]);\n    for(j = 0, i = i - 1; j < i; j++, i--) {\n        swap(vec[i], vec[j]);\n    }\n\n    for(i = vec.size() -1;i >= 0; i--) {\n\n        res = res * 10 + vec[i];\n    }\n    if (res > INT_MAX) return -1;\n    return res;\n}\n```\n\n其实写到这里基本上发现，这道题就是找全排列中的下一个元素，而这个功能，在C++中提供了一个好用的函数：` next_permutation `，所以我们可以先用`to_string`转换成字符数组，然后用`next_permutation`来解这道题：\n\n```c++\nint nextGreaterElement(int n) {\n    string s = to_string(n);\n    if (next_permutation(s.begin(), s.end())) {\n        long temp = atol(s.c_str());\n        if (temp <= INT_MAX)  return temp;\n        else return -1;\n    }\n    return -1;\n}\n```\n\n","slug":"Next-Greater-Element-III","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p200akqmcmclvnamje","content":"<blockquote>\n<p>第9天了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/next-greater-element-iii/\"> Next Greater Element III </a>:</p>\n<hr>\n<p>Given a positive <strong>32-bit</strong> integer <strong>n</strong>, you need to find the smallest <strong>32-bit</strong> integer which has exactly the same digits existing in the integer <strong>n</strong> and is greater in value than n. If no such positive <strong>32-bit</strong> integer exists, you need to return -1.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: 12</span><br><span class=\"line\">Output: 21</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: 21</span><br><span class=\"line\">Output: -1</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>这道题我的解法是：</p>\n<ol>\n<li>先将数字转换成数组，由于是除法和取余解析出来的数组，所以整个数组是倒过来的，即<code>123</code>得到<code>[3,2,1]</code></li>\n<li>从前向后遍历找到第一个逆序（即<code>vec[i-1] &gt; vec[i</code>)的情况。</li>\n<li>从<code>vec[0: i]</code>找到第一个小于等于<code>vec[i]</code>的元素<code>vec[j]</code>。</li>\n<li>交换<code>vec[i]</code>和<code>vec[j]</code>，然后将<code>vec[0: i]</code>逆序。</li>\n<li>将<code>vec</code>转换回数字，最后判断一下是否溢出即可。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nextGreaterElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">        vec.push_back(n % <span class=\"number\">10</span>);</span><br><span class=\"line\">        n /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>;i &lt; vec.size() &amp;&amp; vec[i<span class=\"number\">-1</span>] &lt;= vec[i] ;++i) &#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == vec.size()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>;vec[i] &gt;= vec[j];++j) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(vec[i], vec[j]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>, i = i - <span class=\"number\">1</span>; j &lt; i; j++, i--) &#123;</span><br><span class=\"line\">        swap(vec[i], vec[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = vec.size() <span class=\"number\">-1</span>;i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        res = res * <span class=\"number\">10</span> + vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res &gt; INT_MAX) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实写到这里基本上发现，这道题就是找全排列中的下一个元素，而这个功能，在C++中提供了一个好用的函数：<code>next_permutation</code>，所以我们可以先用<code>to_string</code>转换成字符数组，然后用<code>next_permutation</code>来解这道题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nextGreaterElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s = to_string(n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next_permutation(s.begin(), s.end())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> temp = atol(s.c_str());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp &lt;= INT_MAX)  <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第9天了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/next-greater-element-iii/\"> Next Greater Element III </a>:</p>\n<hr>\n<p>Given a positive <strong>32-bit</strong> integer <strong>n</strong>, you need to find the smallest <strong>32-bit</strong> integer which has exactly the same digits existing in the integer <strong>n</strong> and is greater in value than n. If no such positive <strong>32-bit</strong> integer exists, you need to return -1.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: 12</span><br><span class=\"line\">Output: 21</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: 21</span><br><span class=\"line\">Output: -1</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>这道题我的解法是：</p>\n<ol>\n<li>先将数字转换成数组，由于是除法和取余解析出来的数组，所以整个数组是倒过来的，即<code>123</code>得到<code>[3,2,1]</code></li>\n<li>从前向后遍历找到第一个逆序（即<code>vec[i-1] &gt; vec[i</code>)的情况。</li>\n<li>从<code>vec[0: i]</code>找到第一个小于等于<code>vec[i]</code>的元素<code>vec[j]</code>。</li>\n<li>交换<code>vec[i]</code>和<code>vec[j]</code>，然后将<code>vec[0: i]</code>逆序。</li>\n<li>将<code>vec</code>转换回数字，最后判断一下是否溢出即可。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nextGreaterElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">        vec.push_back(n % <span class=\"number\">10</span>);</span><br><span class=\"line\">        n /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>;i &lt; vec.size() &amp;&amp; vec[i<span class=\"number\">-1</span>] &lt;= vec[i] ;++i) &#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == vec.size()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>;vec[i] &gt;= vec[j];++j) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(vec[i], vec[j]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>, i = i - <span class=\"number\">1</span>; j &lt; i; j++, i--) &#123;</span><br><span class=\"line\">        swap(vec[i], vec[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = vec.size() <span class=\"number\">-1</span>;i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        res = res * <span class=\"number\">10</span> + vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res &gt; INT_MAX) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实写到这里基本上发现，这道题就是找全排列中的下一个元素，而这个功能，在C++中提供了一个好用的函数：<code>next_permutation</code>，所以我们可以先用<code>to_string</code>转换成字符数组，然后用<code>next_permutation</code>来解这道题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nextGreaterElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s = to_string(n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next_permutation(s.begin(), s.end())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> temp = atol(s.c_str());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp &lt;= INT_MAX)  <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Next-Permutation","date":"2017-10-10T04:50:17.000Z","_content":"\n打卡，第17天\n\n恩，又是一道有趣的题目，不知不觉刷了12道`Medium`级别的题目了，要不要找个时间试试`hard`的？？\n\n> Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n>\n> If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n>\n> The replacement must be in-place, do not allocate extra memory.\n>\n> Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n> 1,2,3 → 1,3,2\n> 3,2,1 → 1,2,3\n> 1,1,5 → 1,5,1\n\n我们再观察几个示例：\n\n> 1,2,5,4,3 -> 1,3,2,4,5\n> 1,3,2,5,4 -> 1,3,4,2,5\n\n我们的目的是：让这个序列变大一点，显然从后向前考虑会比较容易得出结果。\n\n对于`1,2,5,4,3`，观察序列的最后，我们可以发现`4,3`是降序的，我们要让整个序列变得大一点，显然如果只修改对于`5,4,3`这个序列的顺序，我们是没法让整个序列变大的，所以我们要引入下一个数字，但是`5,4,3`也是降序的，所以我们也无法只修改后三个数字来是的序列变大，但是如果考虑`2,5,4,3`，这个序列再变大一点就是`3,2,4,5`,如果多试几次的话，就可以找出规律了：\n\n* 我们从后向前找一个最长升序序列`nums[i:]`\n* 如果`i=0`，按照题目要求，我们就应该给出一个最小的组合，就直接对`nums`进行排序即可。\n* 如果`i!=0`，那么我们从后向前找第一个比`nums[i-1]`大的数字`nums[k]`，而且我们肯定能找出。交换`nums[i-1]`和`nums[k]`,然后再对`nums[i:]`进行一个排序即可。\n\n```c++\nvoid nextPermutation(vector<int>& nums) {\n    for(int i = nums.size() - 1;i > 0;i--){\n        if (nums[i-1] < nums[i]){\n            int key = nums[i -1];\n            int j;\n            for(j = i;j < nums.size() && nums[j] > key;j++)\n                /*do nothing*/;\n            cout << nums[j-1] <<\" \" << nums[i-1];\n            swap(nums[j-1],nums[i-1]);\n            sort(nums.begin() + i,nums.end());\n            return ;\n        }\n    }\n    sort(nums.begin(),nums.end());\n}\n```\n\n这样的话，时间复杂度是`O(nlogn)`了。其实我们要排序的序列，在某种程度上来说，他其实是降序的，我们只需要把降序换成升序即可。\n\n```c++\nvoid nextPermutation(vector<int>& nums) {\n    int i,j = -1;\n    for(i = nums.size() - 1;i > 0 && nums[i-1]>= nums[i] ;i--)\n        /*do nothing*/;\n\n    int first = i,last = nums.size()-1;\n\n    while(first <= last) {\n        if (i > 0 && nums[last] > nums[i-1]) {\n            swap(nums[i-1],nums[last]);\n            break;\n        } else if (i > 0 && nums[first+1] <= nums[i-1] ) {\n            swap(nums[i-1],nums[first]);\n            break;\n        }\n        swap(nums[first++],nums[last--]);\n    }\n    while(first < last)\n        swap(nums[first++],nums[last--]);\n    return ;\n}\n```\n\n还可以先对`nums[i:]`进行`reverse`,在找出第一个比`nums[i-1]`大的数和`nums[i-1]`进行交换。\n\n```c++\nvoid nextPermutation(vector<int>& nums) {\n    if (nums.size() < 2) return ;\n    int i,j = -1;\n    for(i = nums.size() - 1;i > 0 && nums[i-1]>= nums[i] ;i--)\n        /*do nothing*/;\n\n    int first = i,last = nums.size()-1;\n    while(first < last)\n        swap(nums[first++],nums[last--]);\n    //cout << i << endl;\n    if (i > 0) {\n        auto beg = nums.begin() + i;\n        auto it = lower_bound(beg,nums.end(),nums[i-1]);\n        //cout << *it << endl;\n        while (*it == nums[i-1])\n            it++;\n        //cout << *it << nums[i-1] << endl;\n        swap(*it,nums[i-1]);\n    }\n    return ;\n}\n```\n\n由于`dicuss`中的都大同小异，所以就不贴`dicuss`中的算法了。\n","source":"_posts/Next-Permutation.md","raw":"---\ntitle: Next-Permutation\ndate: 2017-10-10T12:50:17.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n打卡，第17天\n\n恩，又是一道有趣的题目，不知不觉刷了12道`Medium`级别的题目了，要不要找个时间试试`hard`的？？\n\n> Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n>\n> If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n>\n> The replacement must be in-place, do not allocate extra memory.\n>\n> Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n> 1,2,3 → 1,3,2\n> 3,2,1 → 1,2,3\n> 1,1,5 → 1,5,1\n\n我们再观察几个示例：\n\n> 1,2,5,4,3 -> 1,3,2,4,5\n> 1,3,2,5,4 -> 1,3,4,2,5\n\n我们的目的是：让这个序列变大一点，显然从后向前考虑会比较容易得出结果。\n\n对于`1,2,5,4,3`，观察序列的最后，我们可以发现`4,3`是降序的，我们要让整个序列变得大一点，显然如果只修改对于`5,4,3`这个序列的顺序，我们是没法让整个序列变大的，所以我们要引入下一个数字，但是`5,4,3`也是降序的，所以我们也无法只修改后三个数字来是的序列变大，但是如果考虑`2,5,4,3`，这个序列再变大一点就是`3,2,4,5`,如果多试几次的话，就可以找出规律了：\n\n* 我们从后向前找一个最长升序序列`nums[i:]`\n* 如果`i=0`，按照题目要求，我们就应该给出一个最小的组合，就直接对`nums`进行排序即可。\n* 如果`i!=0`，那么我们从后向前找第一个比`nums[i-1]`大的数字`nums[k]`，而且我们肯定能找出。交换`nums[i-1]`和`nums[k]`,然后再对`nums[i:]`进行一个排序即可。\n\n```c++\nvoid nextPermutation(vector<int>& nums) {\n    for(int i = nums.size() - 1;i > 0;i--){\n        if (nums[i-1] < nums[i]){\n            int key = nums[i -1];\n            int j;\n            for(j = i;j < nums.size() && nums[j] > key;j++)\n                /*do nothing*/;\n            cout << nums[j-1] <<\" \" << nums[i-1];\n            swap(nums[j-1],nums[i-1]);\n            sort(nums.begin() + i,nums.end());\n            return ;\n        }\n    }\n    sort(nums.begin(),nums.end());\n}\n```\n\n这样的话，时间复杂度是`O(nlogn)`了。其实我们要排序的序列，在某种程度上来说，他其实是降序的，我们只需要把降序换成升序即可。\n\n```c++\nvoid nextPermutation(vector<int>& nums) {\n    int i,j = -1;\n    for(i = nums.size() - 1;i > 0 && nums[i-1]>= nums[i] ;i--)\n        /*do nothing*/;\n\n    int first = i,last = nums.size()-1;\n\n    while(first <= last) {\n        if (i > 0 && nums[last] > nums[i-1]) {\n            swap(nums[i-1],nums[last]);\n            break;\n        } else if (i > 0 && nums[first+1] <= nums[i-1] ) {\n            swap(nums[i-1],nums[first]);\n            break;\n        }\n        swap(nums[first++],nums[last--]);\n    }\n    while(first < last)\n        swap(nums[first++],nums[last--]);\n    return ;\n}\n```\n\n还可以先对`nums[i:]`进行`reverse`,在找出第一个比`nums[i-1]`大的数和`nums[i-1]`进行交换。\n\n```c++\nvoid nextPermutation(vector<int>& nums) {\n    if (nums.size() < 2) return ;\n    int i,j = -1;\n    for(i = nums.size() - 1;i > 0 && nums[i-1]>= nums[i] ;i--)\n        /*do nothing*/;\n\n    int first = i,last = nums.size()-1;\n    while(first < last)\n        swap(nums[first++],nums[last--]);\n    //cout << i << endl;\n    if (i > 0) {\n        auto beg = nums.begin() + i;\n        auto it = lower_bound(beg,nums.end(),nums[i-1]);\n        //cout << *it << endl;\n        while (*it == nums[i-1])\n            it++;\n        //cout << *it << nums[i-1] << endl;\n        swap(*it,nums[i-1]);\n    }\n    return ;\n}\n```\n\n由于`dicuss`中的都大同小异，所以就不贴`dicuss`中的算法了。\n","slug":"Next-Permutation","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p300anqmcm89pmfesc","content":"<p>打卡，第17天</p>\n<p>恩，又是一道有趣的题目，不知不觉刷了12道<code>Medium</code>级别的题目了，要不要找个时间试试<code>hard</code>的？？</p>\n<blockquote>\n<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>\n<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>\n<p>The replacement must be in-place, do not allocate extra memory.</p>\n<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>\n</blockquote>\n<p>我们再观察几个示例：</p>\n<blockquote>\n<p>1,2,5,4,3 -&gt; 1,3,2,4,5<br>1,3,2,5,4 -&gt; 1,3,4,2,5</p>\n</blockquote>\n<p>我们的目的是：让这个序列变大一点，显然从后向前考虑会比较容易得出结果。</p>\n<p>对于<code>1,2,5,4,3</code>，观察序列的最后，我们可以发现<code>4,3</code>是降序的，我们要让整个序列变得大一点，显然如果只修改对于<code>5,4,3</code>这个序列的顺序，我们是没法让整个序列变大的，所以我们要引入下一个数字，但是<code>5,4,3</code>也是降序的，所以我们也无法只修改后三个数字来是的序列变大，但是如果考虑<code>2,5,4,3</code>，这个序列再变大一点就是<code>3,2,4,5</code>,如果多试几次的话，就可以找出规律了：</p>\n<ul>\n<li>我们从后向前找一个最长升序序列<code>nums[i:]</code></li>\n<li>如果<code>i=0</code>，按照题目要求，我们就应该给出一个最小的组合，就直接对<code>nums</code>进行排序即可。</li>\n<li>如果<code>i!=0</code>，那么我们从后向前找第一个比<code>nums[i-1]</code>大的数字<code>nums[k]</code>，而且我们肯定能找出。交换<code>nums[i-1]</code>和<code>nums[k]</code>,然后再对<code>nums[i:]</code>进行一个排序即可。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nums.size() - <span class=\"number\">1</span>;i &gt; <span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i<span class=\"number\">-1</span>] &lt; nums[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> key = nums[i <span class=\"number\">-1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j = i;j &lt; nums.size() &amp;&amp; nums[j] &gt; key;j++)</span><br><span class=\"line\">                <span class=\"comment\">/*do nothing*/</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; nums[j<span class=\"number\">-1</span>] &lt;&lt;<span class=\"string\">&quot; &quot;</span> &lt;&lt; nums[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            swap(nums[j<span class=\"number\">-1</span>],nums[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            sort(nums.begin() + i,nums.end());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(nums.begin(),nums.end());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，时间复杂度是<code>O(nlogn)</code>了。其实我们要排序的序列，在某种程度上来说，他其实是降序的，我们只需要把降序换成升序即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = nums.size() - <span class=\"number\">1</span>;i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i<span class=\"number\">-1</span>]&gt;= nums[i] ;i--)</span><br><span class=\"line\">        <span class=\"comment\">/*do nothing*/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = i,last = nums.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[last] &gt; nums[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">            swap(nums[i<span class=\"number\">-1</span>],nums[last]);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[first+<span class=\"number\">1</span>] &lt;= nums[i<span class=\"number\">-1</span>] ) &#123;</span><br><span class=\"line\">            swap(nums[i<span class=\"number\">-1</span>],nums[first]);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums[first++],nums[last--]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt; last)</span><br><span class=\"line\">        swap(nums[first++],nums[last--]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以先对<code>nums[i:]</code>进行<code>reverse</code>,在找出第一个比<code>nums[i-1]</code>大的数和<code>nums[i-1]</code>进行交换。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = nums.size() - <span class=\"number\">1</span>;i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i<span class=\"number\">-1</span>]&gt;= nums[i] ;i--)</span><br><span class=\"line\">        <span class=\"comment\">/*do nothing*/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = i,last = nums.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt; last)</span><br><span class=\"line\">        swap(nums[first++],nums[last--]);</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> beg = nums.begin() + i;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = lower_bound(beg,nums.end(),nums[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; *it &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (*it == nums[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">            it++;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; *it &lt;&lt; nums[i-1] &lt;&lt; endl;</span></span><br><span class=\"line\">        swap(*it,nums[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>dicuss</code>中的都大同小异，所以就不贴<code>dicuss</code>中的算法了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第17天</p>\n<p>恩，又是一道有趣的题目，不知不觉刷了12道<code>Medium</code>级别的题目了，要不要找个时间试试<code>hard</code>的？？</p>\n<blockquote>\n<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>\n<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>\n<p>The replacement must be in-place, do not allocate extra memory.</p>\n<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>\n</blockquote>\n<p>我们再观察几个示例：</p>\n<blockquote>\n<p>1,2,5,4,3 -&gt; 1,3,2,4,5<br>1,3,2,5,4 -&gt; 1,3,4,2,5</p>\n</blockquote>\n<p>我们的目的是：让这个序列变大一点，显然从后向前考虑会比较容易得出结果。</p>\n<p>对于<code>1,2,5,4,3</code>，观察序列的最后，我们可以发现<code>4,3</code>是降序的，我们要让整个序列变得大一点，显然如果只修改对于<code>5,4,3</code>这个序列的顺序，我们是没法让整个序列变大的，所以我们要引入下一个数字，但是<code>5,4,3</code>也是降序的，所以我们也无法只修改后三个数字来是的序列变大，但是如果考虑<code>2,5,4,3</code>，这个序列再变大一点就是<code>3,2,4,5</code>,如果多试几次的话，就可以找出规律了：</p>\n<ul>\n<li>我们从后向前找一个最长升序序列<code>nums[i:]</code></li>\n<li>如果<code>i=0</code>，按照题目要求，我们就应该给出一个最小的组合，就直接对<code>nums</code>进行排序即可。</li>\n<li>如果<code>i!=0</code>，那么我们从后向前找第一个比<code>nums[i-1]</code>大的数字<code>nums[k]</code>，而且我们肯定能找出。交换<code>nums[i-1]</code>和<code>nums[k]</code>,然后再对<code>nums[i:]</code>进行一个排序即可。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nums.size() - <span class=\"number\">1</span>;i &gt; <span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i<span class=\"number\">-1</span>] &lt; nums[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> key = nums[i <span class=\"number\">-1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j = i;j &lt; nums.size() &amp;&amp; nums[j] &gt; key;j++)</span><br><span class=\"line\">                <span class=\"comment\">/*do nothing*/</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; nums[j<span class=\"number\">-1</span>] &lt;&lt;<span class=\"string\">&quot; &quot;</span> &lt;&lt; nums[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            swap(nums[j<span class=\"number\">-1</span>],nums[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            sort(nums.begin() + i,nums.end());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(nums.begin(),nums.end());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，时间复杂度是<code>O(nlogn)</code>了。其实我们要排序的序列，在某种程度上来说，他其实是降序的，我们只需要把降序换成升序即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = nums.size() - <span class=\"number\">1</span>;i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i<span class=\"number\">-1</span>]&gt;= nums[i] ;i--)</span><br><span class=\"line\">        <span class=\"comment\">/*do nothing*/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = i,last = nums.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[last] &gt; nums[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">            swap(nums[i<span class=\"number\">-1</span>],nums[last]);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[first+<span class=\"number\">1</span>] &lt;= nums[i<span class=\"number\">-1</span>] ) &#123;</span><br><span class=\"line\">            swap(nums[i<span class=\"number\">-1</span>],nums[first]);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums[first++],nums[last--]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt; last)</span><br><span class=\"line\">        swap(nums[first++],nums[last--]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以先对<code>nums[i:]</code>进行<code>reverse</code>,在找出第一个比<code>nums[i-1]</code>大的数和<code>nums[i-1]</code>进行交换。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = nums.size() - <span class=\"number\">1</span>;i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i<span class=\"number\">-1</span>]&gt;= nums[i] ;i--)</span><br><span class=\"line\">        <span class=\"comment\">/*do nothing*/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = i,last = nums.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt; last)</span><br><span class=\"line\">        swap(nums[first++],nums[last--]);</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> beg = nums.begin() + i;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = lower_bound(beg,nums.end(),nums[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; *it &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (*it == nums[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">            it++;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; *it &lt;&lt; nums[i-1] &lt;&lt; endl;</span></span><br><span class=\"line\">        swap(*it,nums[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>dicuss</code>中的都大同小异，所以就不贴<code>dicuss</code>中的算法了。</p>\n"},{"title":"Nim-Game","date":"2018-01-25T02:52:41.000Z","_content":"\n第94天。\n\n今天的题目有点智障。。。\n\n今天的题目是[Nim Game](https://leetcode.com/problems/nim-game/description/):\n\n> You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n>\n> Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n>\n> For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.\n\n很自然的想到用`dp`去做，然而时间超限了：\n\n```c++\nbool canWinNim1(int n) {\n    if (n <= 3) return true;\n    vector<bool> dp(n+1,false);\n    dp[1] = dp[2] = dp[3] = true;\n    for(int i = 4;i <= n;i++) {\n        dp[i] = !(dp[i-1] && dp[i-2] && dp[i-3]);\n   //     if (dp[i] == false) cout << i << \" \";\n    }\n    // cout << endl;\n    return dp[n];\n}\n```\n\n把`false`的值输出来之后，发现，只要不是4的倍数就会赢。\n\n```c++\nbool canWinNim(int n) {\n    return n % 4;\n}\n```\n","source":"_posts/Nim-Game.md","raw":"---\ntitle: Nim-Game\ndate: 2018-01-25T10:52:41.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第94天。\n\n今天的题目有点智障。。。\n\n今天的题目是[Nim Game](https://leetcode.com/problems/nim-game/description/):\n\n> You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n>\n> Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n>\n> For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.\n\n很自然的想到用`dp`去做，然而时间超限了：\n\n```c++\nbool canWinNim1(int n) {\n    if (n <= 3) return true;\n    vector<bool> dp(n+1,false);\n    dp[1] = dp[2] = dp[3] = true;\n    for(int i = 4;i <= n;i++) {\n        dp[i] = !(dp[i-1] && dp[i-2] && dp[i-3]);\n   //     if (dp[i] == false) cout << i << \" \";\n    }\n    // cout << endl;\n    return dp[n];\n}\n```\n\n把`false`的值输出来之后，发现，只要不是4的倍数就会赢。\n\n```c++\nbool canWinNim(int n) {\n    return n % 4;\n}\n```\n","slug":"Nim-Game","published":1,"updated":"2021-03-10T13:47:05.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p400aqqmcm0zwz1r02","content":"<p>第94天。</p>\n<p>今天的题目有点智障。。。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/nim-game/description/\">Nim Game</a>:</p>\n<blockquote>\n<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>\n<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>\n<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>\n</blockquote>\n<p>很自然的想到用<code>dp</code>去做，然而时间超限了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canWinNim1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">3</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">1</span>,<span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = dp[<span class=\"number\">2</span>] = dp[<span class=\"number\">3</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">4</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        dp[i] = !(dp[i<span class=\"number\">-1</span>] &amp;&amp; dp[i<span class=\"number\">-2</span>] &amp;&amp; dp[i<span class=\"number\">-3</span>]);</span><br><span class=\"line\">   <span class=\"comment\">//     if (dp[i] == false) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把<code>false</code>的值输出来之后，发现，只要不是4的倍数就会赢。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canWinNim</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n % <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第94天。</p>\n<p>今天的题目有点智障。。。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/nim-game/description/\">Nim Game</a>:</p>\n<blockquote>\n<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>\n<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>\n<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>\n</blockquote>\n<p>很自然的想到用<code>dp</code>去做，然而时间超限了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canWinNim1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">3</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">1</span>,<span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = dp[<span class=\"number\">2</span>] = dp[<span class=\"number\">3</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">4</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        dp[i] = !(dp[i<span class=\"number\">-1</span>] &amp;&amp; dp[i<span class=\"number\">-2</span>] &amp;&amp; dp[i<span class=\"number\">-3</span>]);</span><br><span class=\"line\">   <span class=\"comment\">//     if (dp[i] == false) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把<code>false</code>的值输出来之后，发现，只要不是4的倍数就会赢。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canWinNim</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n % <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Number of Islands","date":"2017-11-01T02:25:07.000Z","_content":"\n第37天。\n\n今天的题目[Number of Islands](https://leetcode.com/problems/number-of-islands/description/)比较简单，而且感觉好像做过的样子：\n\n> Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n>\n> Example 1:\n>\n> 11110\n> 11010\n> 11000\n> 00000\n> Answer: 1\n>\n> Example 2:\n>\n> 11000\n> 11000\n> 00100\n> 00011\n> Answer: 3\n\n解法相当简单，只要遍历所有点，然后如何当前点是`1`,就将计数加一，然后进行扩展，所谓的扩展就是将当前点的值至为`0`,然后向上下左右进行查找，如果还是`1`就递归调用扩展。\n\n```c++\n    int numIslands(vector<vector<char>>& grid) {\n        if (grid.size() == 0 || grid[0].size() == 0) return 0;\n        int count = 0;\n\n        for(int i = 0;i < grid.size();i++) {\n            for(int j = 0;j < grid[0].size();j++) {\n                if (grid[i][j] == '1') {\n                    cout << \"(\" << i << \",\" << j << \")\\n\";\n                    count++;\n                    expend(grid,i,j);\n                }\n            }\n        }\n        return count;\n    }\n    void expend(vector<vector<char> > &grid,int x,int y) {\n        if ( x < 0 || y < 0 ||\n            x >= grid.size() || y >= grid[0].size() ||\n           grid[x][y] == '0' ) return;\n        //cout << x << \" \" << y << endl;\n        grid[x][y] = '0';\n        expend(grid,x-1,y);\n        expend(grid,x+1,y);\n        expend(grid,x,y-1);\n        expend(grid,x,y+1);\n    }\n``\n\n因为`dicuss`中的做法都是一样的，所以就不贴`dicuss`的代码了。\n","source":"_posts/Number-of-Islands.md","raw":"---\ntitle: Number of Islands\ndate: 2017-11-01T10:25:07.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第37天。\n\n今天的题目[Number of Islands](https://leetcode.com/problems/number-of-islands/description/)比较简单，而且感觉好像做过的样子：\n\n> Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n>\n> Example 1:\n>\n> 11110\n> 11010\n> 11000\n> 00000\n> Answer: 1\n>\n> Example 2:\n>\n> 11000\n> 11000\n> 00100\n> 00011\n> Answer: 3\n\n解法相当简单，只要遍历所有点，然后如何当前点是`1`,就将计数加一，然后进行扩展，所谓的扩展就是将当前点的值至为`0`,然后向上下左右进行查找，如果还是`1`就递归调用扩展。\n\n```c++\n    int numIslands(vector<vector<char>>& grid) {\n        if (grid.size() == 0 || grid[0].size() == 0) return 0;\n        int count = 0;\n\n        for(int i = 0;i < grid.size();i++) {\n            for(int j = 0;j < grid[0].size();j++) {\n                if (grid[i][j] == '1') {\n                    cout << \"(\" << i << \",\" << j << \")\\n\";\n                    count++;\n                    expend(grid,i,j);\n                }\n            }\n        }\n        return count;\n    }\n    void expend(vector<vector<char> > &grid,int x,int y) {\n        if ( x < 0 || y < 0 ||\n            x >= grid.size() || y >= grid[0].size() ||\n           grid[x][y] == '0' ) return;\n        //cout << x << \" \" << y << endl;\n        grid[x][y] = '0';\n        expend(grid,x-1,y);\n        expend(grid,x+1,y);\n        expend(grid,x,y-1);\n        expend(grid,x,y+1);\n    }\n``\n\n因为`dicuss`中的做法都是一样的，所以就不贴`dicuss`的代码了。\n","slug":"Number-of-Islands","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p400atqmcmaotp763x","content":"<p>第37天。</p>\n<p>今天的题目<a href=\"https://leetcode.com/problems/number-of-islands/description/\">Number of Islands</a>比较简单，而且感觉好像做过的样子：</p>\n<blockquote>\n<p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n<p>Example 1:</p>\n<p>11110<br>11010<br>11000<br>00000<br>Answer: 1</p>\n<p>Example 2:</p>\n<p>11000<br>11000<br>00100<br>00011<br>Answer: 3</p>\n</blockquote>\n<p>解法相当简单，只要遍历所有点，然后如何当前点是<code>1</code>,就将计数加一，然后进行扩展，所谓的扩展就是将当前点的值至为<code>0</code>,然后向上下左右进行查找，如果还是<code>1</code>就递归调用扩展。</p>\n<pre><code class=\"c++\">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;\n        if (grid.size() == 0 || grid[0].size() == 0) return 0;\n        int count = 0;\n\n        for(int i = 0;i &lt; grid.size();i++) &#123;\n            for(int j = 0;j &lt; grid[0].size();j++) &#123;\n                if (grid[i][j] == &#39;1&#39;) &#123;\n                    cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)\\n&quot;;\n                    count++;\n                    expend(grid,i,j);\n                &#125;\n            &#125;\n        &#125;\n        return count;\n    &#125;\n    void expend(vector&lt;vector&lt;char&gt; &gt; &amp;grid,int x,int y) &#123;\n        if ( x &lt; 0 || y &lt; 0 ||\n            x &gt;= grid.size() || y &gt;= grid[0].size() ||\n           grid[x][y] == &#39;0&#39; ) return;\n        //cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;\n        grid[x][y] = &#39;0&#39;;\n        expend(grid,x-1,y);\n        expend(grid,x+1,y);\n        expend(grid,x,y-1);\n        expend(grid,x,y+1);\n    &#125;\n``\n\n因为`dicuss`中的做法都是一样的，所以就不贴`dicuss`的代码了。\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>第37天。</p>\n<p>今天的题目<a href=\"https://leetcode.com/problems/number-of-islands/description/\">Number of Islands</a>比较简单，而且感觉好像做过的样子：</p>\n<blockquote>\n<p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n<p>Example 1:</p>\n<p>11110<br>11010<br>11000<br>00000<br>Answer: 1</p>\n<p>Example 2:</p>\n<p>11000<br>11000<br>00100<br>00011<br>Answer: 3</p>\n</blockquote>\n<p>解法相当简单，只要遍历所有点，然后如何当前点是<code>1</code>,就将计数加一，然后进行扩展，所谓的扩展就是将当前点的值至为<code>0</code>,然后向上下左右进行查找，如果还是<code>1</code>就递归调用扩展。</p>\n<pre><code class=\"c++\">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;\n        if (grid.size() == 0 || grid[0].size() == 0) return 0;\n        int count = 0;\n\n        for(int i = 0;i &lt; grid.size();i++) &#123;\n            for(int j = 0;j &lt; grid[0].size();j++) &#123;\n                if (grid[i][j] == &#39;1&#39;) &#123;\n                    cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)\\n&quot;;\n                    count++;\n                    expend(grid,i,j);\n                &#125;\n            &#125;\n        &#125;\n        return count;\n    &#125;\n    void expend(vector&lt;vector&lt;char&gt; &gt; &amp;grid,int x,int y) &#123;\n        if ( x &lt; 0 || y &lt; 0 ||\n            x &gt;= grid.size() || y &gt;= grid[0].size() ||\n           grid[x][y] == &#39;0&#39; ) return;\n        //cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;\n        grid[x][y] = &#39;0&#39;;\n        expend(grid,x-1,y);\n        expend(grid,x+1,y);\n        expend(grid,x,y-1);\n        expend(grid,x,y+1);\n    &#125;\n``\n\n因为`dicuss`中的做法都是一样的，所以就不贴`dicuss`的代码了。\n</code></pre>\n"},{"title":"Odd Even Linked List","date":"2019-03-09T04:12:09.000Z","_content":"\n> 第10天，今天的题目总感觉做过，但是翻记录又没有，难道是在学校的OJ上做的？？？\n\n今天的题目是 [Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list/)。\n\n好久没碰到链表的题了，这题比较简单。我们用一个新的链表来存奇数位的元素即可，而且这里没必要重新建立一个链表，只需要把原来链表里面的连接过来就好了，完成后，自然就把一个链表分成两个链表了。\n\n区分奇偶数位，可以用一个 flag 来标识当前元素是奇数还是偶数，然后每移动一次就翻转该 flag ，当然更简单的是，我们循环一次移动两个元素，这样看起来会简洁一点，而且在循环内部不需要任何的条件判断，只需要在循环结束后做一些后处理即可。\n\n\n```c++\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) return head;\n        \n        ListNode even(0);\n        ListNode *p = head;\n        ListNode *q = &even;\n        \n        while(p->next && p->next->next) {\n            q->next = p->next;\n            p->next = p->next->next;\n            p = p->next;\n            q = q->next;\n        }\n        if (p->next != nullptr) {\n            q->next = p->next;\n            q = q->next;\n        }\n        p->next = even.next;\n        q->next = nullptr;\n        return head;\n    }\n};\n```\n","source":"_posts/Odd-Even-Linked-List.md","raw":"---\ntitle: Odd Even Linked List\ndate: 2019-03-09T12:12:09.000Z\ntags:\n  - LeetCode\n  - Linked List\ncategories:\n  - LeetCode\n---\n\n> 第10天，今天的题目总感觉做过，但是翻记录又没有，难道是在学校的OJ上做的？？？\n\n今天的题目是 [Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list/)。\n\n好久没碰到链表的题了，这题比较简单。我们用一个新的链表来存奇数位的元素即可，而且这里没必要重新建立一个链表，只需要把原来链表里面的连接过来就好了，完成后，自然就把一个链表分成两个链表了。\n\n区分奇偶数位，可以用一个 flag 来标识当前元素是奇数还是偶数，然后每移动一次就翻转该 flag ，当然更简单的是，我们循环一次移动两个元素，这样看起来会简洁一点，而且在循环内部不需要任何的条件判断，只需要在循环结束后做一些后处理即可。\n\n\n```c++\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) return head;\n        \n        ListNode even(0);\n        ListNode *p = head;\n        ListNode *q = &even;\n        \n        while(p->next && p->next->next) {\n            q->next = p->next;\n            p->next = p->next->next;\n            p = p->next;\n            q = q->next;\n        }\n        if (p->next != nullptr) {\n            q->next = p->next;\n            q = q->next;\n        }\n        p->next = even.next;\n        q->next = nullptr;\n        return head;\n    }\n};\n```\n","slug":"Odd-Even-Linked-List","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p500awqmcm6pxl1se4","content":"<blockquote>\n<p>第10天，今天的题目总感觉做过，但是翻记录又没有，难道是在学校的OJ上做的？？？</p>\n</blockquote>\n<p>今天的题目是 <a href=\"https://leetcode.com/problems/odd-even-linked-list/\">Odd Even Linked List</a>。</p>\n<p>好久没碰到链表的题了，这题比较简单。我们用一个新的链表来存奇数位的元素即可，而且这里没必要重新建立一个链表，只需要把原来链表里面的连接过来就好了，完成后，自然就把一个链表分成两个链表了。</p>\n<p>区分奇偶数位，可以用一个 flag 来标识当前元素是奇数还是偶数，然后每移动一次就翻转该 flag ，当然更简单的是，我们循环一次移动两个元素，这样看起来会简洁一点，而且在循环内部不需要任何的条件判断，只需要在循环结束后做一些后处理即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">oddEvenList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\">ListNode <span class=\"title\">even</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        ListNode *p = head;</span><br><span class=\"line\">        ListNode *q = &amp;even;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class=\"line\">            q-&gt;next = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            q = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            q-&gt;next = p-&gt;next;</span><br><span class=\"line\">            q = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;next = even.next;</span><br><span class=\"line\">        q-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第10天，今天的题目总感觉做过，但是翻记录又没有，难道是在学校的OJ上做的？？？</p>\n</blockquote>\n<p>今天的题目是 <a href=\"https://leetcode.com/problems/odd-even-linked-list/\">Odd Even Linked List</a>。</p>\n<p>好久没碰到链表的题了，这题比较简单。我们用一个新的链表来存奇数位的元素即可，而且这里没必要重新建立一个链表，只需要把原来链表里面的连接过来就好了，完成后，自然就把一个链表分成两个链表了。</p>\n<p>区分奇偶数位，可以用一个 flag 来标识当前元素是奇数还是偶数，然后每移动一次就翻转该 flag ，当然更简单的是，我们循环一次移动两个元素，这样看起来会简洁一点，而且在循环内部不需要任何的条件判断，只需要在循环结束后做一些后处理即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">oddEvenList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\">ListNode <span class=\"title\">even</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        ListNode *p = head;</span><br><span class=\"line\">        ListNode *q = &amp;even;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class=\"line\">            q-&gt;next = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            q = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            q-&gt;next = p-&gt;next;</span><br><span class=\"line\">            q = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;next = even.next;</span><br><span class=\"line\">        q-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Palindrome Linked List","date":"2017-11-06T01:30:54.000Z","_content":"\n第42天。\n\n今天的题目是[Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/description/):\n\n> Given a singly linked list, determine if it is a palindrome.\n>\n> Follow up:\n> Could you do it in O(n) time and O(1) space?\n\n如果不考虑`O(1)`的空间复杂度的话，可以直接用一个栈保存，然后在对比，不过我没有实现这个方法。我的解法是先用快慢指针求链表中点，然后在翻转后面的链表（只需要`O(n)`的时间复杂度和`O(1)`的空间复杂度），然后在对比。\n\n```c++\nbool isPalindrome(ListNode* head) {\n    if (!head || !head->next) return true;\n\n    ListNode *fast = head;\n    ListNode *slow = head;\n    ListNode *pre = slow;\n    while(fast && fast->next) {\n        fast = fast->next->next;\n        pre = slow;\n        slow = slow->next;\n    }\n    fast = pre->next;\n    pre->next = nullptr;\n\n    fast = revertList(fast);\n\n    while(fast && head) {\n        if (fast->val != head->val)\n            return false;\n        fast = fast->next;\n        head = head->next;\n    }\n    return true;\n}\nListNode *revertList(ListNode *head) {\n    if(!head || !head->next) return head;\n    ListNode *pre = head;\n    ListNode *cur = head;\n    while(cur) {\n        ListNode *t = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = t;\n    }\n    head = head->next;\n    return pre;\n}\n```\n\n然后是在`dicuss`中看到的解法，相当有趣的技巧：\n\n```c++\nListNode* temp;\nbool isPalindrome(ListNode* head) {\n    temp = head;\n    return check(head);\n}\n\nbool check(ListNode* p) {\n    if (NULL == p) return true;\n    bool isPal = check(p->next) & (temp->val == p->val);\n    temp = temp->next;\n    return isPal;\n}\n```\n\n刚开始看的时候感觉好像是错的，但是仔细想想，这个方法相当美妙，利用函数调用来做栈，首先是递归调用`check(p->next)`,这样的话会一直到最后一个节点才开始比较`temp->val == p->val`，又因为`temp = temp->next`始终没有执行到，所以现在`temp`指向第一个元素，而`p`指向最后一个元素，判断完后，会执行到`temp = temp->next`，然后`check`会返回，返回后`p`就指向了倒数第二个元素，就这样一直迭代下去。\n\n不过这个方法的空间复杂度是`O(n)`.\n","source":"_posts/Palindrome-Linked-List.md","raw":"---\ntitle: Palindrome Linked List\ndate: 2017-11-06T09:30:54.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - LinkedList\n---\n\n第42天。\n\n今天的题目是[Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/description/):\n\n> Given a singly linked list, determine if it is a palindrome.\n>\n> Follow up:\n> Could you do it in O(n) time and O(1) space?\n\n如果不考虑`O(1)`的空间复杂度的话，可以直接用一个栈保存，然后在对比，不过我没有实现这个方法。我的解法是先用快慢指针求链表中点，然后在翻转后面的链表（只需要`O(n)`的时间复杂度和`O(1)`的空间复杂度），然后在对比。\n\n```c++\nbool isPalindrome(ListNode* head) {\n    if (!head || !head->next) return true;\n\n    ListNode *fast = head;\n    ListNode *slow = head;\n    ListNode *pre = slow;\n    while(fast && fast->next) {\n        fast = fast->next->next;\n        pre = slow;\n        slow = slow->next;\n    }\n    fast = pre->next;\n    pre->next = nullptr;\n\n    fast = revertList(fast);\n\n    while(fast && head) {\n        if (fast->val != head->val)\n            return false;\n        fast = fast->next;\n        head = head->next;\n    }\n    return true;\n}\nListNode *revertList(ListNode *head) {\n    if(!head || !head->next) return head;\n    ListNode *pre = head;\n    ListNode *cur = head;\n    while(cur) {\n        ListNode *t = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = t;\n    }\n    head = head->next;\n    return pre;\n}\n```\n\n然后是在`dicuss`中看到的解法，相当有趣的技巧：\n\n```c++\nListNode* temp;\nbool isPalindrome(ListNode* head) {\n    temp = head;\n    return check(head);\n}\n\nbool check(ListNode* p) {\n    if (NULL == p) return true;\n    bool isPal = check(p->next) & (temp->val == p->val);\n    temp = temp->next;\n    return isPal;\n}\n```\n\n刚开始看的时候感觉好像是错的，但是仔细想想，这个方法相当美妙，利用函数调用来做栈，首先是递归调用`check(p->next)`,这样的话会一直到最后一个节点才开始比较`temp->val == p->val`，又因为`temp = temp->next`始终没有执行到，所以现在`temp`指向第一个元素，而`p`指向最后一个元素，判断完后，会执行到`temp = temp->next`，然后`check`会返回，返回后`p`就指向了倒数第二个元素，就这样一直迭代下去。\n\n不过这个方法的空间复杂度是`O(n)`.\n","slug":"Palindrome-Linked-List","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p600azqmcm58cl1hpr","content":"<p>第42天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/palindrome-linked-list/description/\">Palindrome Linked List</a>:</p>\n<blockquote>\n<p>Given a singly linked list, determine if it is a palindrome.</p>\n<p>Follow up:<br>Could you do it in O(n) time and O(1) space?</p>\n</blockquote>\n<p>如果不考虑<code>O(1)</code>的空间复杂度的话，可以直接用一个栈保存，然后在对比，不过我没有实现这个方法。我的解法是先用快慢指针求链表中点，然后在翻转后面的链表（只需要<code>O(n)</code>的时间复杂度和<code>O(1)</code>的空间复杂度），然后在对比。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *fast = head;</span><br><span class=\"line\">    ListNode *slow = head;</span><br><span class=\"line\">    ListNode *pre = slow;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        pre = slow;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fast = pre-&gt;next;</span><br><span class=\"line\">    pre-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    fast = revertList(fast);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; head) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fast-&gt;val != head-&gt;val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">revertList</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *pre = head;</span><br><span class=\"line\">    ListNode *cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur) &#123;</span><br><span class=\"line\">        ListNode *t = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next = pre;</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        cur = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的解法，相当有趣的技巧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListNode* temp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    temp = head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> check(head);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(ListNode* p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == p) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isPal = check(p-&gt;next) &amp; (temp-&gt;val == p-&gt;val);</span><br><span class=\"line\">    temp = temp-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isPal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>刚开始看的时候感觉好像是错的，但是仔细想想，这个方法相当美妙，利用函数调用来做栈，首先是递归调用<code>check(p-&gt;next)</code>,这样的话会一直到最后一个节点才开始比较<code>temp-&gt;val == p-&gt;val</code>，又因为<code>temp = temp-&gt;next</code>始终没有执行到，所以现在<code>temp</code>指向第一个元素，而<code>p</code>指向最后一个元素，判断完后，会执行到<code>temp = temp-&gt;next</code>，然后<code>check</code>会返回，返回后<code>p</code>就指向了倒数第二个元素，就这样一直迭代下去。</p>\n<p>不过这个方法的空间复杂度是<code>O(n)</code>.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第42天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/palindrome-linked-list/description/\">Palindrome Linked List</a>:</p>\n<blockquote>\n<p>Given a singly linked list, determine if it is a palindrome.</p>\n<p>Follow up:<br>Could you do it in O(n) time and O(1) space?</p>\n</blockquote>\n<p>如果不考虑<code>O(1)</code>的空间复杂度的话，可以直接用一个栈保存，然后在对比，不过我没有实现这个方法。我的解法是先用快慢指针求链表中点，然后在翻转后面的链表（只需要<code>O(n)</code>的时间复杂度和<code>O(1)</code>的空间复杂度），然后在对比。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *fast = head;</span><br><span class=\"line\">    ListNode *slow = head;</span><br><span class=\"line\">    ListNode *pre = slow;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        pre = slow;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fast = pre-&gt;next;</span><br><span class=\"line\">    pre-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    fast = revertList(fast);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; head) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fast-&gt;val != head-&gt;val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">revertList</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *pre = head;</span><br><span class=\"line\">    ListNode *cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur) &#123;</span><br><span class=\"line\">        ListNode *t = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next = pre;</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        cur = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的解法，相当有趣的技巧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListNode* temp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    temp = head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> check(head);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(ListNode* p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == p) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isPal = check(p-&gt;next) &amp; (temp-&gt;val == p-&gt;val);</span><br><span class=\"line\">    temp = temp-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isPal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>刚开始看的时候感觉好像是错的，但是仔细想想，这个方法相当美妙，利用函数调用来做栈，首先是递归调用<code>check(p-&gt;next)</code>,这样的话会一直到最后一个节点才开始比较<code>temp-&gt;val == p-&gt;val</code>，又因为<code>temp = temp-&gt;next</code>始终没有执行到，所以现在<code>temp</code>指向第一个元素，而<code>p</code>指向最后一个元素，判断完后，会执行到<code>temp = temp-&gt;next</code>，然后<code>check</code>会返回，返回后<code>p</code>就指向了倒数第二个元素，就这样一直迭代下去。</p>\n<p>不过这个方法的空间复杂度是<code>O(n)</code>.</p>\n"},{"title":"Partition Labels","date":"2019-12-06T02:33:53.000Z","_content":"\n> 第30天，一个月了。\n\n今天的题目是[Partition Labels](https://leetcode.com/problems/partition-labels/):\n\n这道题的解法如下：\n\n先遍历一次字符串统计字符出现的次数保存在`c1`上，然后在遍历一次字符串，这次遍历时同样进行统计字符出现次数保存在`c2`上，并维护一个变量`cnum`，这个变量`cnum`表示当前出现过但是未出现完全的字符的种类数。当出现`cnum`为 0 时，就表示完成了一次划分。代码如下：\n\n```c++\nvector<int> partitionLabels(string S) {\n    vector<int> c1(26, 0);\n    for(int i = 0, size = S.size(); i < size; i++) {\n        c1[S[i] - 'a']++;\n    }\n    \n    vector<int> c2(26, 0);\n    vector<int> res;\n    int temp = 1, cnum = 0;\n    \n    for(int i = 0, size = S.size(); i < size; i++, temp++) {\n        int index = S[i] - 'a';\n        if (c2[index] == 0) {\n            cnum++;\n        }\n        if (++c2[index]== c1[index] && --cnum == 0) {\n            res.push_back(temp); temp = 0;\n        }\n    }\n    return res;\n}\n```\n","source":"_posts/Partition-Labels.md","raw":"---\ntitle: Partition Labels\ndate: 2019-12-06T10:33:53.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第30天，一个月了。\n\n今天的题目是[Partition Labels](https://leetcode.com/problems/partition-labels/):\n\n这道题的解法如下：\n\n先遍历一次字符串统计字符出现的次数保存在`c1`上，然后在遍历一次字符串，这次遍历时同样进行统计字符出现次数保存在`c2`上，并维护一个变量`cnum`，这个变量`cnum`表示当前出现过但是未出现完全的字符的种类数。当出现`cnum`为 0 时，就表示完成了一次划分。代码如下：\n\n```c++\nvector<int> partitionLabels(string S) {\n    vector<int> c1(26, 0);\n    for(int i = 0, size = S.size(); i < size; i++) {\n        c1[S[i] - 'a']++;\n    }\n    \n    vector<int> c2(26, 0);\n    vector<int> res;\n    int temp = 1, cnum = 0;\n    \n    for(int i = 0, size = S.size(); i < size; i++, temp++) {\n        int index = S[i] - 'a';\n        if (c2[index] == 0) {\n            cnum++;\n        }\n        if (++c2[index]== c1[index] && --cnum == 0) {\n            res.push_back(temp); temp = 0;\n        }\n    }\n    return res;\n}\n```\n","slug":"Partition-Labels","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p600b3qmcm58nc6zps","content":"<blockquote>\n<p>第30天，一个月了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/partition-labels/\">Partition Labels</a>:</p>\n<p>这道题的解法如下：</p>\n<p>先遍历一次字符串统计字符出现的次数保存在<code>c1</code>上，然后在遍历一次字符串，这次遍历时同样进行统计字符出现次数保存在<code>c2</code>上，并维护一个变量<code>cnum</code>，这个变量<code>cnum</code>表示当前出现过但是未出现完全的字符的种类数。当出现<code>cnum</code>为 0 时，就表示完成了一次划分。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">partitionLabels</span><span class=\"params\">(<span class=\"built_in\">string</span> S)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">c1</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = S.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        c1[S[i] - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">c2</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">1</span>, cnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = S.size(); i &lt; size; i++, temp++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = S[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c2[index] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cnum++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++c2[index]== c1[index] &amp;&amp; --cnum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.push_back(temp); temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第30天，一个月了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/partition-labels/\">Partition Labels</a>:</p>\n<p>这道题的解法如下：</p>\n<p>先遍历一次字符串统计字符出现的次数保存在<code>c1</code>上，然后在遍历一次字符串，这次遍历时同样进行统计字符出现次数保存在<code>c2</code>上，并维护一个变量<code>cnum</code>，这个变量<code>cnum</code>表示当前出现过但是未出现完全的字符的种类数。当出现<code>cnum</code>为 0 时，就表示完成了一次划分。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">partitionLabels</span><span class=\"params\">(<span class=\"built_in\">string</span> S)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">c1</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = S.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        c1[S[i] - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">c2</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">1</span>, cnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = S.size(); i &lt; size; i++, temp++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = S[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c2[index] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cnum++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++c2[index]== c1[index] &amp;&amp; --cnum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.push_back(temp); temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Partition to K Equal Sum Subsets","date":"2017-10-29T03:16:55.000Z","_content":"\n第35天。\n\n又一次一个早上没做出来，难道要跪在DP上了吗？\n\n今天的题目是[Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/):\n\n> Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal.\n>\n> Example 1:\n> Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4\n> Output: True\n> Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n> Note:\n>\n> 1 <= k <= len(nums) <= 16.\n> 0 < nums[i] < 10000.\n\n虽然一开始思路是对的，但是就是没想出来做递归，先讲讲我想到的：\n\n首先，他要我们分辨一组数字是否能被划分成K个相同的子集，我们可以对这个数组进行求和，如果和是K的倍数，那么这个倍数`a`就是每个子集的和，如果不是K的倍数，则肯定没法分成和相同的K个子集。\n\n现在问题变成了，找出k个子集使得它的和为`a`.\n\n然后，我就不会做了。\n\n然后是在`dicuss`中看到的方法，前面的思路是完全一样的，所以这里只讲讲他是怎么做求出k个子集使得和为`a`的.\n\n其实方法很简单，暴力搜而已。\n\n我们用一个大小为k的`vector`来记录每个子集的和（或者还差多少），然后我们从后面向前搜索，每次尝试将一个元素放入第i个vector中，然后考虑下一个元素，emmm，其实不好讲出来，但是代码挺简单的。\n\nbtw,这里好像没有制表啊，然后我还一直想着要怎么制表。算了，明天还是按顺序直接刷吧。\n\n```c++\nbool canPartitionKSubsets(vector<int>& nums, int k) {\n    if ( k <= 1 ) return true;\n    //return canPartitionKSubsets(nums.begin(),k/2);\n\n    sort(nums.begin(),nums.end());\n\n    int sum = 0;\n    for(auto i:nums) \n        sum +=i;\n    if (sum % k != 0) return false;\n    int a = sum / k;\n    vector<int> kdq(k,a);\n    return possible(nums,kdq,nums.size() - 1);\n}\nbool possible(vector<int> &nums,vector<int> &kdq,int index) {\n    if (index < 0) {\n        for(int i:kdq) if (i != 0) return false;\n        return true;\n    }\n    int n = nums[index];\n    for(auto &a:kdq) {\n        if (a >= n) {\n            a -= n;\n            if (possible(nums,kdq,index-1)) return true;\n            a += n;\n        }\n    }\n    return false;\n}\n```\n","source":"_posts/Partition-to-K-Equal-Sum-Subsets.md","raw":"---\ntitle: Partition to K Equal Sum Subsets\ndate: 2017-10-29T11:16:55.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - DP\n---\n\n第35天。\n\n又一次一个早上没做出来，难道要跪在DP上了吗？\n\n今天的题目是[Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/):\n\n> Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal.\n>\n> Example 1:\n> Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4\n> Output: True\n> Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n> Note:\n>\n> 1 <= k <= len(nums) <= 16.\n> 0 < nums[i] < 10000.\n\n虽然一开始思路是对的，但是就是没想出来做递归，先讲讲我想到的：\n\n首先，他要我们分辨一组数字是否能被划分成K个相同的子集，我们可以对这个数组进行求和，如果和是K的倍数，那么这个倍数`a`就是每个子集的和，如果不是K的倍数，则肯定没法分成和相同的K个子集。\n\n现在问题变成了，找出k个子集使得它的和为`a`.\n\n然后，我就不会做了。\n\n然后是在`dicuss`中看到的方法，前面的思路是完全一样的，所以这里只讲讲他是怎么做求出k个子集使得和为`a`的.\n\n其实方法很简单，暴力搜而已。\n\n我们用一个大小为k的`vector`来记录每个子集的和（或者还差多少），然后我们从后面向前搜索，每次尝试将一个元素放入第i个vector中，然后考虑下一个元素，emmm，其实不好讲出来，但是代码挺简单的。\n\nbtw,这里好像没有制表啊，然后我还一直想着要怎么制表。算了，明天还是按顺序直接刷吧。\n\n```c++\nbool canPartitionKSubsets(vector<int>& nums, int k) {\n    if ( k <= 1 ) return true;\n    //return canPartitionKSubsets(nums.begin(),k/2);\n\n    sort(nums.begin(),nums.end());\n\n    int sum = 0;\n    for(auto i:nums) \n        sum +=i;\n    if (sum % k != 0) return false;\n    int a = sum / k;\n    vector<int> kdq(k,a);\n    return possible(nums,kdq,nums.size() - 1);\n}\nbool possible(vector<int> &nums,vector<int> &kdq,int index) {\n    if (index < 0) {\n        for(int i:kdq) if (i != 0) return false;\n        return true;\n    }\n    int n = nums[index];\n    for(auto &a:kdq) {\n        if (a >= n) {\n            a -= n;\n            if (possible(nums,kdq,index-1)) return true;\n            a += n;\n        }\n    }\n    return false;\n}\n```\n","slug":"Partition-to-K-Equal-Sum-Subsets","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p700b6qmcmffrqfhli","content":"<p>第35天。</p>\n<p>又一次一个早上没做出来，难道要跪在DP上了吗？</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/\">Partition to K Equal Sum Subsets</a>:</p>\n<blockquote>\n<p>Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal.</p>\n<p>Example 1:<br>Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>Output: True<br>Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.<br>Note:</p>\n<p>1 &lt;= k &lt;= len(nums) &lt;= 16.<br>0 &lt; nums[i] &lt; 10000.</p>\n</blockquote>\n<p>虽然一开始思路是对的，但是就是没想出来做递归，先讲讲我想到的：</p>\n<p>首先，他要我们分辨一组数字是否能被划分成K个相同的子集，我们可以对这个数组进行求和，如果和是K的倍数，那么这个倍数<code>a</code>就是每个子集的和，如果不是K的倍数，则肯定没法分成和相同的K个子集。</p>\n<p>现在问题变成了，找出k个子集使得它的和为<code>a</code>.</p>\n<p>然后，我就不会做了。</p>\n<p>然后是在<code>dicuss</code>中看到的方法，前面的思路是完全一样的，所以这里只讲讲他是怎么做求出k个子集使得和为<code>a</code>的.</p>\n<p>其实方法很简单，暴力搜而已。</p>\n<p>我们用一个大小为k的<code>vector</code>来记录每个子集的和（或者还差多少），然后我们从后面向前搜索，每次尝试将一个元素放入第i个vector中，然后考虑下一个元素，emmm，其实不好讲出来，但是代码挺简单的。</p>\n<p>btw,这里好像没有制表啊，然后我还一直想着要怎么制表。算了，明天还是按顺序直接刷吧。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canPartitionKSubsets</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( k &lt;= <span class=\"number\">1</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">//return canPartitionKSubsets(nums.begin(),k/2);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sort(nums.begin(),nums.end());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) </span><br><span class=\"line\">        sum +=i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sum % k != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = sum / k;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">kdq</span><span class=\"params\">(k,a)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> possible(nums,kdq,nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">possible</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;kdq,<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i:kdq) <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums[index];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;a:kdq) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &gt;= n) &#123;</span><br><span class=\"line\">            a -= n;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (possible(nums,kdq,index<span class=\"number\">-1</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            a += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第35天。</p>\n<p>又一次一个早上没做出来，难道要跪在DP上了吗？</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/\">Partition to K Equal Sum Subsets</a>:</p>\n<blockquote>\n<p>Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal.</p>\n<p>Example 1:<br>Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>Output: True<br>Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.<br>Note:</p>\n<p>1 &lt;= k &lt;= len(nums) &lt;= 16.<br>0 &lt; nums[i] &lt; 10000.</p>\n</blockquote>\n<p>虽然一开始思路是对的，但是就是没想出来做递归，先讲讲我想到的：</p>\n<p>首先，他要我们分辨一组数字是否能被划分成K个相同的子集，我们可以对这个数组进行求和，如果和是K的倍数，那么这个倍数<code>a</code>就是每个子集的和，如果不是K的倍数，则肯定没法分成和相同的K个子集。</p>\n<p>现在问题变成了，找出k个子集使得它的和为<code>a</code>.</p>\n<p>然后，我就不会做了。</p>\n<p>然后是在<code>dicuss</code>中看到的方法，前面的思路是完全一样的，所以这里只讲讲他是怎么做求出k个子集使得和为<code>a</code>的.</p>\n<p>其实方法很简单，暴力搜而已。</p>\n<p>我们用一个大小为k的<code>vector</code>来记录每个子集的和（或者还差多少），然后我们从后面向前搜索，每次尝试将一个元素放入第i个vector中，然后考虑下一个元素，emmm，其实不好讲出来，但是代码挺简单的。</p>\n<p>btw,这里好像没有制表啊，然后我还一直想着要怎么制表。算了，明天还是按顺序直接刷吧。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canPartitionKSubsets</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( k &lt;= <span class=\"number\">1</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">//return canPartitionKSubsets(nums.begin(),k/2);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sort(nums.begin(),nums.end());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) </span><br><span class=\"line\">        sum +=i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sum % k != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = sum / k;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">kdq</span><span class=\"params\">(k,a)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> possible(nums,kdq,nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">possible</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;kdq,<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i:kdq) <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums[index];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;a:kdq) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &gt;= n) &#123;</span><br><span class=\"line\">            a -= n;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (possible(nums,kdq,index<span class=\"number\">-1</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            a += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Path-Sum","date":"2017-11-29T04:50:19.000Z","_content":"\n第63天。\n\n赶算法实验，再水一题。\n\n今天的题目是[Path Sum](https://leetcode.com/problems/path-sum/description/):\n\n> Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n>\n> For example:\n> Given the below binary tree and sum = 22,\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n\n> return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.\n\n比较简单，但是有一些坑点。\n\n* 它要求一定要到`left`.\n* 然后空节点不能当成`0`.\n\n然后是代码：\n\n```c++\nbool hasPathSum(TreeNode* root, int sum) {\n    if (!root ) return false;\n    if (!root->left && !root->right) return sum == root->val;\n    if (!root->left) return hasPathSum(root->right,sum-root->val);\n    if (!root->right) return hasPathSum(root->left,sum - root->val);\n    return hasPathSum(root->left,sum - root->val) || hasPathSum(root->right,sum - root->val);\n}\n```\n\n其实`dicuss`中的更精炼一点：\n\n```c++\nbool hasPathSum(TreeNode *root, int sum) {\n    if (root == NULL) return false;\n    if (root->val == sum && root->left ==  NULL && root->right == NULL) return true;\n    return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\n}\n```\n","source":"_posts/Path-Sum.md","raw":"---\ntitle: Path-Sum\ndate: 2017-11-29T12:50:19.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第63天。\n\n赶算法实验，再水一题。\n\n今天的题目是[Path Sum](https://leetcode.com/problems/path-sum/description/):\n\n> Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n>\n> For example:\n> Given the below binary tree and sum = 22,\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n\n> return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.\n\n比较简单，但是有一些坑点。\n\n* 它要求一定要到`left`.\n* 然后空节点不能当成`0`.\n\n然后是代码：\n\n```c++\nbool hasPathSum(TreeNode* root, int sum) {\n    if (!root ) return false;\n    if (!root->left && !root->right) return sum == root->val;\n    if (!root->left) return hasPathSum(root->right,sum-root->val);\n    if (!root->right) return hasPathSum(root->left,sum - root->val);\n    return hasPathSum(root->left,sum - root->val) || hasPathSum(root->right,sum - root->val);\n}\n```\n\n其实`dicuss`中的更精炼一点：\n\n```c++\nbool hasPathSum(TreeNode *root, int sum) {\n    if (root == NULL) return false;\n    if (root->val == sum && root->left ==  NULL && root->right == NULL) return true;\n    return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\n}\n```\n","slug":"Path-Sum","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p800b9qmcmgslx9zdo","content":"<p>第63天。</p>\n<p>赶算法实验，再水一题。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/path-sum/description/\">Path Sum</a>:</p>\n<blockquote>\n<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>\n<p>For example:<br>Given the below binary tree and sum = 22,</p>\n</blockquote>\n<pre><code>          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\n</code></pre>\n<blockquote>\n<p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>\n</blockquote>\n<p>比较简单，但是有一些坑点。</p>\n<ul>\n<li>它要求一定要到<code>left</code>.</li>\n<li>然后空节点不能当成<code>0</code>.</li>\n</ul>\n<p>然后是代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class=\"keyword\">return</span> sum == root-&gt;val;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left) <span class=\"keyword\">return</span> hasPathSum(root-&gt;right,sum-root-&gt;val);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;right) <span class=\"keyword\">return</span> hasPathSum(root-&gt;left,sum - root-&gt;val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasPathSum(root-&gt;left,sum - root-&gt;val) || hasPathSum(root-&gt;right,sum - root-&gt;val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实<code>dicuss</code>中的更精炼一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val == sum &amp;&amp; root-&gt;left ==  <span class=\"literal\">NULL</span> &amp;&amp; root-&gt;right == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第63天。</p>\n<p>赶算法实验，再水一题。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/path-sum/description/\">Path Sum</a>:</p>\n<blockquote>\n<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>\n<p>For example:<br>Given the below binary tree and sum = 22,</p>\n</blockquote>\n<pre><code>          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\n</code></pre>\n<blockquote>\n<p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>\n</blockquote>\n<p>比较简单，但是有一些坑点。</p>\n<ul>\n<li>它要求一定要到<code>left</code>.</li>\n<li>然后空节点不能当成<code>0</code>.</li>\n</ul>\n<p>然后是代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class=\"keyword\">return</span> sum == root-&gt;val;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left) <span class=\"keyword\">return</span> hasPathSum(root-&gt;right,sum-root-&gt;val);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;right) <span class=\"keyword\">return</span> hasPathSum(root-&gt;left,sum - root-&gt;val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasPathSum(root-&gt;left,sum - root-&gt;val) || hasPathSum(root-&gt;right,sum - root-&gt;val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实<code>dicuss</code>中的更精炼一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val == sum &amp;&amp; root-&gt;left ==  <span class=\"literal\">NULL</span> &amp;&amp; root-&gt;right == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Perfect Squares","date":"2017-11-20T04:31:22.000Z","_content":"\n第54天。\n\n今天的题目是[Perfect-Squares](https://leetcode.com/problems/perfect-squares/description/):\n\n> Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n>\n> For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.\n\n这道题一开始看到还挺懵的，首先，它是需要用`square number`来做加法的，那我是不是要先判断一个数是不是一个`square number`,简单的思路就是将所有不大于n的`square number`生成出来，直接比较即可，假设我们就是用这样的方法，那么现在我们可能就有了所有不大于n的`square number`的序列。\n\n然后继续回到原来的问题，我好像是不需要求出这个表达式是由什么数组成的，而是只需要求出这个表达式由多少个`Square number`组成的就好了，这有点像动态规划的问题，我们用动态规划的思路去想这个问题：\n\n我们要求`numSquares(n)`，我们可以先尝试的假定这个表达式中有一个`1`,那么就可以写成`numSquares(n) = numSquares(n-1)+1`,那如果我们假定这个表达式中有一个`4`,那么就可以写成是`numSquares(n) = numSquares(n-4)+1`,我们可以按照这样思路写出这样的递推式：\n\n> numSquares(n) = Min{numSquares(n-k) + 1 | k is square number and k <= n}\n\n这样的话，我们就可以写出这样的表达式：\n\n```python\ndef numSquares(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [sys.maxsize]*(n+1)\n    dp[0] = 0\n    for i in range(1,n+1):\n        j = 1\n        t = j**2\n        while t <= i:\n            dp[i] = min(dp[i],dp[i-t]+1)\n            j+=1\n            t = j**2\n    return dp[-1]\n```\n\n很不幸，这样的方法会在6000之后的数据中超时，然后想了一早上的方式去优化，后来用`c++`去实现了一遍，然后。。。就过来，花了那么久的时间竟然因为语言的问题而一直解决不了。。。算了，以后还是用`c++`写吧，反正有时候用`python`,写的也很乱，还不如`c++`简洁：\n\n```c++\nint numSquares(int n) {\n    vector<int> dp(n+1,INT_MAX);\n    dp[0] = 0;\n    int t;\n    for(int i = 1;i <= n;i++) {\n        for(int j=1;(t = j*j) <= i;j++){\n            dp[i] = min(dp[i],dp[i-t]+1);\n        }\n        //cout << dp[i] << endl;\n    }\n    return dp[n];\n}\n```\n","source":"_posts/Perfect-Squares.md","raw":"---\ntitle: Perfect Squares\ndate: 2017-11-20T12:31:22.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - DP\n---\n\n第54天。\n\n今天的题目是[Perfect-Squares](https://leetcode.com/problems/perfect-squares/description/):\n\n> Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n>\n> For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.\n\n这道题一开始看到还挺懵的，首先，它是需要用`square number`来做加法的，那我是不是要先判断一个数是不是一个`square number`,简单的思路就是将所有不大于n的`square number`生成出来，直接比较即可，假设我们就是用这样的方法，那么现在我们可能就有了所有不大于n的`square number`的序列。\n\n然后继续回到原来的问题，我好像是不需要求出这个表达式是由什么数组成的，而是只需要求出这个表达式由多少个`Square number`组成的就好了，这有点像动态规划的问题，我们用动态规划的思路去想这个问题：\n\n我们要求`numSquares(n)`，我们可以先尝试的假定这个表达式中有一个`1`,那么就可以写成`numSquares(n) = numSquares(n-1)+1`,那如果我们假定这个表达式中有一个`4`,那么就可以写成是`numSquares(n) = numSquares(n-4)+1`,我们可以按照这样思路写出这样的递推式：\n\n> numSquares(n) = Min{numSquares(n-k) + 1 | k is square number and k <= n}\n\n这样的话，我们就可以写出这样的表达式：\n\n```python\ndef numSquares(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [sys.maxsize]*(n+1)\n    dp[0] = 0\n    for i in range(1,n+1):\n        j = 1\n        t = j**2\n        while t <= i:\n            dp[i] = min(dp[i],dp[i-t]+1)\n            j+=1\n            t = j**2\n    return dp[-1]\n```\n\n很不幸，这样的方法会在6000之后的数据中超时，然后想了一早上的方式去优化，后来用`c++`去实现了一遍，然后。。。就过来，花了那么久的时间竟然因为语言的问题而一直解决不了。。。算了，以后还是用`c++`写吧，反正有时候用`python`,写的也很乱，还不如`c++`简洁：\n\n```c++\nint numSquares(int n) {\n    vector<int> dp(n+1,INT_MAX);\n    dp[0] = 0;\n    int t;\n    for(int i = 1;i <= n;i++) {\n        for(int j=1;(t = j*j) <= i;j++){\n            dp[i] = min(dp[i],dp[i-t]+1);\n        }\n        //cout << dp[i] << endl;\n    }\n    return dp[n];\n}\n```\n","slug":"Perfect-Squares","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p800bdqmcm8pow5n9q","content":"<p>第54天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/perfect-squares/description/\">Perfect-Squares</a>:</p>\n<blockquote>\n<p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>\n<p>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>\n</blockquote>\n<p>这道题一开始看到还挺懵的，首先，它是需要用<code>square number</code>来做加法的，那我是不是要先判断一个数是不是一个<code>square number</code>,简单的思路就是将所有不大于n的<code>square number</code>生成出来，直接比较即可，假设我们就是用这样的方法，那么现在我们可能就有了所有不大于n的<code>square number</code>的序列。</p>\n<p>然后继续回到原来的问题，我好像是不需要求出这个表达式是由什么数组成的，而是只需要求出这个表达式由多少个<code>Square number</code>组成的就好了，这有点像动态规划的问题，我们用动态规划的思路去想这个问题：</p>\n<p>我们要求<code>numSquares(n)</code>，我们可以先尝试的假定这个表达式中有一个<code>1</code>,那么就可以写成<code>numSquares(n) = numSquares(n-1)+1</code>,那如果我们假定这个表达式中有一个<code>4</code>,那么就可以写成是<code>numSquares(n) = numSquares(n-4)+1</code>,我们可以按照这样思路写出这样的递推式：</p>\n<blockquote>\n<p>numSquares(n) = Min{numSquares(n-k) + 1 | k is square number and k &lt;= n}</p>\n</blockquote>\n<p>这样的话，我们就可以写出这样的表达式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSquares</span>(<span class=\"params\">self, n</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type n: int</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    dp = [sys.maxsize]*(n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        j = <span class=\"number\">1</span></span><br><span class=\"line\">        t = j**<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> t &lt;= i:</span><br><span class=\"line\">            dp[i] = <span class=\"built_in\">min</span>(dp[i],dp[i-t]+<span class=\"number\">1</span>)</span><br><span class=\"line\">            j+=<span class=\"number\">1</span></span><br><span class=\"line\">            t = j**<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>很不幸，这样的方法会在6000之后的数据中超时，然后想了一早上的方式去优化，后来用<code>c++</code>去实现了一遍，然后。。。就过来，花了那么久的时间竟然因为语言的问题而一直解决不了。。。算了，以后还是用<code>c++</code>写吧，反正有时候用<code>python</code>,写的也很乱，还不如<code>c++</code>简洁：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numSquares</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">1</span>,INT_MAX)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;(t = j*j) &lt;= i;j++)&#123;</span><br><span class=\"line\">            dp[i] = min(dp[i],dp[i-t]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; dp[i] &lt;&lt; endl;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第54天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/perfect-squares/description/\">Perfect-Squares</a>:</p>\n<blockquote>\n<p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>\n<p>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>\n</blockquote>\n<p>这道题一开始看到还挺懵的，首先，它是需要用<code>square number</code>来做加法的，那我是不是要先判断一个数是不是一个<code>square number</code>,简单的思路就是将所有不大于n的<code>square number</code>生成出来，直接比较即可，假设我们就是用这样的方法，那么现在我们可能就有了所有不大于n的<code>square number</code>的序列。</p>\n<p>然后继续回到原来的问题，我好像是不需要求出这个表达式是由什么数组成的，而是只需要求出这个表达式由多少个<code>Square number</code>组成的就好了，这有点像动态规划的问题，我们用动态规划的思路去想这个问题：</p>\n<p>我们要求<code>numSquares(n)</code>，我们可以先尝试的假定这个表达式中有一个<code>1</code>,那么就可以写成<code>numSquares(n) = numSquares(n-1)+1</code>,那如果我们假定这个表达式中有一个<code>4</code>,那么就可以写成是<code>numSquares(n) = numSquares(n-4)+1</code>,我们可以按照这样思路写出这样的递推式：</p>\n<blockquote>\n<p>numSquares(n) = Min{numSquares(n-k) + 1 | k is square number and k &lt;= n}</p>\n</blockquote>\n<p>这样的话，我们就可以写出这样的表达式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSquares</span>(<span class=\"params\">self, n</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type n: int</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    dp = [sys.maxsize]*(n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        j = <span class=\"number\">1</span></span><br><span class=\"line\">        t = j**<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> t &lt;= i:</span><br><span class=\"line\">            dp[i] = <span class=\"built_in\">min</span>(dp[i],dp[i-t]+<span class=\"number\">1</span>)</span><br><span class=\"line\">            j+=<span class=\"number\">1</span></span><br><span class=\"line\">            t = j**<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>很不幸，这样的方法会在6000之后的数据中超时，然后想了一早上的方式去优化，后来用<code>c++</code>去实现了一遍，然后。。。就过来，花了那么久的时间竟然因为语言的问题而一直解决不了。。。算了，以后还是用<code>c++</code>写吧，反正有时候用<code>python</code>,写的也很乱，还不如<code>c++</code>简洁：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numSquares</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">1</span>,INT_MAX)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;(t = j*j) &lt;= i;j++)&#123;</span><br><span class=\"line\">            dp[i] = min(dp[i],dp[i-t]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; dp[i] &lt;&lt; endl;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Permutations","date":"2017-10-13T01:17:05.000Z","_content":"\n第20天，第二次超级快的刷完了一道题。。。要不明天试试刷`hard`\n\n今天的题目是[Permutations](https://leetcode.com/problems/permutations/description/),emmm,之前好像好几次都忘记加地址了。\n\n> Given a collection of distinct numbers, return all possible permutations.\n> For example,\n> [1,2,3] have the following permutations:\n\n```python\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n总感觉之前遇到过类似的题目，然后思路也是很简单的，直接递归的做就好了：\n\n这里如果不算是`push_back`中的拷贝数组，应该已经是拷贝数组次数最少的了，做的时候以为`push_back`不会拷贝，不过在`dicuss`中看的做法是只在`push_back`中进行拷贝。\n\n```c++\nvector<vector<int> > ret;\nvector<vector<int>> permute(vector<int>& nums) {\n    //if (nums.size() == 0 || nums.size() == 1) return {nums};\n    permute(nums,0);\n    return ret;\n}\nvoid permute(vector<int> &nums,int beg) {\n    if (nums.size() - beg <= 1) {\n        ret.push_back(nums);\n        return ;\n    }\n    permute(nums,beg+1);\n    for(int i = beg+1;i<nums.size();i++) {\n        vector<int> vec = nums;\n        swap(vec[beg],vec[i]);\n        permute(vec,beg+1);\n    }\n}\n```\n\n`dicuss`中的做法：\n\n```c++\nvector<vector<int> > permute(vector<int> &num) {\n    vector<vector<int> > result;\n\n    permuteRecursive(num, 0, result);\n    return result;\n}\n\n// permute num[begin..end]\n// invariant: num[0..begin-1] have been fixed/permuted\nvoid permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)\t{\n    if (begin >= num.size()) {\n        // one permutation instance\n        result.push_back(num);\n        return;\n    }\n\n    for (int i = begin; i < num.size(); i++) {\n        swap(num[begin], num[i]);\n        permuteRecursive(num, begin + 1, result);\n        // reset\n        swap(num[begin], num[i]);\n    }\n}\n```\n\n他的做法和我一开始的时候类似，但是我没想到可以换回来。。。\n","source":"_posts/Permutations.md","raw":"---\ntitle: Permutations\ndate: 2017-10-13T09:17:05.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第20天，第二次超级快的刷完了一道题。。。要不明天试试刷`hard`\n\n今天的题目是[Permutations](https://leetcode.com/problems/permutations/description/),emmm,之前好像好几次都忘记加地址了。\n\n> Given a collection of distinct numbers, return all possible permutations.\n> For example,\n> [1,2,3] have the following permutations:\n\n```python\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n总感觉之前遇到过类似的题目，然后思路也是很简单的，直接递归的做就好了：\n\n这里如果不算是`push_back`中的拷贝数组，应该已经是拷贝数组次数最少的了，做的时候以为`push_back`不会拷贝，不过在`dicuss`中看的做法是只在`push_back`中进行拷贝。\n\n```c++\nvector<vector<int> > ret;\nvector<vector<int>> permute(vector<int>& nums) {\n    //if (nums.size() == 0 || nums.size() == 1) return {nums};\n    permute(nums,0);\n    return ret;\n}\nvoid permute(vector<int> &nums,int beg) {\n    if (nums.size() - beg <= 1) {\n        ret.push_back(nums);\n        return ;\n    }\n    permute(nums,beg+1);\n    for(int i = beg+1;i<nums.size();i++) {\n        vector<int> vec = nums;\n        swap(vec[beg],vec[i]);\n        permute(vec,beg+1);\n    }\n}\n```\n\n`dicuss`中的做法：\n\n```c++\nvector<vector<int> > permute(vector<int> &num) {\n    vector<vector<int> > result;\n\n    permuteRecursive(num, 0, result);\n    return result;\n}\n\n// permute num[begin..end]\n// invariant: num[0..begin-1] have been fixed/permuted\nvoid permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)\t{\n    if (begin >= num.size()) {\n        // one permutation instance\n        result.push_back(num);\n        return;\n    }\n\n    for (int i = begin; i < num.size(); i++) {\n        swap(num[begin], num[i]);\n        permuteRecursive(num, begin + 1, result);\n        // reset\n        swap(num[begin], num[i]);\n    }\n}\n```\n\n他的做法和我一开始的时候类似，但是我没想到可以换回来。。。\n","slug":"Permutations","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69p900bgqmcm06846ewm","content":"<p>第20天，第二次超级快的刷完了一道题。。。要不明天试试刷<code>hard</code></p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/permutations/description/\">Permutations</a>,emmm,之前好像好几次都忘记加地址了。</p>\n<blockquote>\n<p>Given a collection of distinct numbers, return all possible permutations.<br>For example,<br>[1,2,3] have the following permutations:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>总感觉之前遇到过类似的题目，然后思路也是很简单的，直接递归的做就好了：</p>\n<p>这里如果不算是<code>push_back</code>中的拷贝数组，应该已经是拷贝数组次数最少的了，做的时候以为<code>push_back</code>不会拷贝，不过在<code>dicuss</code>中看的做法是只在<code>push_back</code>中进行拷贝。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; permute(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//if (nums.size() == 0 || nums.size() == 1) return &#123;nums&#125;;</span></span><br><span class=\"line\">    permute(nums,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">permute</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> beg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() - beg &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ret.push_back(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    permute(nums,beg+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg+<span class=\"number\">1</span>;i&lt;nums.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = nums;</span><br><span class=\"line\">        swap(vec[beg],vec[i]);</span><br><span class=\"line\">        permute(vec,beg+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中的做法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; permute(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; result;</span><br><span class=\"line\"></span><br><span class=\"line\">    permuteRecursive(num, <span class=\"number\">0</span>, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// permute num[begin..end]</span></span><br><span class=\"line\"><span class=\"comment\">// invariant: num[0..begin-1] have been fixed/permuted</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">permuteRecursive</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> begin, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;result)</span>\t</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (begin &gt;= num.size()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// one permutation instance</span></span><br><span class=\"line\">        result.push_back(num);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = begin; i &lt; num.size(); i++) &#123;</span><br><span class=\"line\">        swap(num[begin], num[i]);</span><br><span class=\"line\">        permuteRecursive(num, begin + <span class=\"number\">1</span>, result);</span><br><span class=\"line\">        <span class=\"comment\">// reset</span></span><br><span class=\"line\">        swap(num[begin], num[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>他的做法和我一开始的时候类似，但是我没想到可以换回来。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第20天，第二次超级快的刷完了一道题。。。要不明天试试刷<code>hard</code></p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/permutations/description/\">Permutations</a>,emmm,之前好像好几次都忘记加地址了。</p>\n<blockquote>\n<p>Given a collection of distinct numbers, return all possible permutations.<br>For example,<br>[1,2,3] have the following permutations:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>总感觉之前遇到过类似的题目，然后思路也是很简单的，直接递归的做就好了：</p>\n<p>这里如果不算是<code>push_back</code>中的拷贝数组，应该已经是拷贝数组次数最少的了，做的时候以为<code>push_back</code>不会拷贝，不过在<code>dicuss</code>中看的做法是只在<code>push_back</code>中进行拷贝。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; permute(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//if (nums.size() == 0 || nums.size() == 1) return &#123;nums&#125;;</span></span><br><span class=\"line\">    permute(nums,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">permute</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> beg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() - beg &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ret.push_back(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    permute(nums,beg+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg+<span class=\"number\">1</span>;i&lt;nums.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec = nums;</span><br><span class=\"line\">        swap(vec[beg],vec[i]);</span><br><span class=\"line\">        permute(vec,beg+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中的做法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; permute(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; result;</span><br><span class=\"line\"></span><br><span class=\"line\">    permuteRecursive(num, <span class=\"number\">0</span>, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// permute num[begin..end]</span></span><br><span class=\"line\"><span class=\"comment\">// invariant: num[0..begin-1] have been fixed/permuted</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">permuteRecursive</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> begin, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;result)</span>\t</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (begin &gt;= num.size()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// one permutation instance</span></span><br><span class=\"line\">        result.push_back(num);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = begin; i &lt; num.size(); i++) &#123;</span><br><span class=\"line\">        swap(num[begin], num[i]);</span><br><span class=\"line\">        permuteRecursive(num, begin + <span class=\"number\">1</span>, result);</span><br><span class=\"line\">        <span class=\"comment\">// reset</span></span><br><span class=\"line\">        swap(num[begin], num[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>他的做法和我一开始的时候类似，但是我没想到可以换回来。。。</p>\n"},{"title":"Plus-One","date":"2017-11-28T14:52:56.000Z","_content":"\n第62天。\n\n今天很不在状态啊，明明是课最少的一天，却把那么多事拖到了晚上。\n\n今天的题目是[Plus One](https://leetcode.com/problems/plus-one/discuss/):\n\n> Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.\n>\n> You may assume the integer do not contain any leading zero, except the number 0 itself.\n>\n> The digits are stored such that the most significant digit is at the head of the list.\n\n比较简单的一道的题目，就是给你一个数组来表示一个数字，而且又不没有负数什么的，只需要从后往前遍历一遍，对当前元素进行加一再模上10，如果变成了`0`,那么说明有进位，我们继续遍历，如果不是`0`,说明后面的元素都没有改变，直接返回即可。\n\n然后需要考虑的就是`99`这种类型，因为他本来是用两个数字即可表示,但是加一后需要3个数字：\n\n```c++\nvector<int> plusOne(vector<int>& digits) {\n    for(auto it = digits.rbegin();it != digits.rend();it++) {\n        *it = (*it + 1) % 10;\n        if (*it != 0) return digits;\n    }\n    if (*digits.begin() == 0) digits.insert(digits.begin(),1);\n    return digits;\n}\n```\n","source":"_posts/Plus-One.md","raw":"---\ntitle: Plus-One\ndate: 2017-11-28T22:52:56.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第62天。\n\n今天很不在状态啊，明明是课最少的一天，却把那么多事拖到了晚上。\n\n今天的题目是[Plus One](https://leetcode.com/problems/plus-one/discuss/):\n\n> Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.\n>\n> You may assume the integer do not contain any leading zero, except the number 0 itself.\n>\n> The digits are stored such that the most significant digit is at the head of the list.\n\n比较简单的一道的题目，就是给你一个数组来表示一个数字，而且又不没有负数什么的，只需要从后往前遍历一遍，对当前元素进行加一再模上10，如果变成了`0`,那么说明有进位，我们继续遍历，如果不是`0`,说明后面的元素都没有改变，直接返回即可。\n\n然后需要考虑的就是`99`这种类型，因为他本来是用两个数字即可表示,但是加一后需要3个数字：\n\n```c++\nvector<int> plusOne(vector<int>& digits) {\n    for(auto it = digits.rbegin();it != digits.rend();it++) {\n        *it = (*it + 1) % 10;\n        if (*it != 0) return digits;\n    }\n    if (*digits.begin() == 0) digits.insert(digits.begin(),1);\n    return digits;\n}\n```\n","slug":"Plus-One","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pa00bjqmcmhuctbaif","content":"<p>第62天。</p>\n<p>今天很不在状态啊，明明是课最少的一天，却把那么多事拖到了晚上。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/plus-one/discuss/\">Plus One</a>:</p>\n<blockquote>\n<p>Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.</p>\n<p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p>\n<p>The digits are stored such that the most significant digit is at the head of the list.</p>\n</blockquote>\n<p>比较简单的一道的题目，就是给你一个数组来表示一个数字，而且又不没有负数什么的，只需要从后往前遍历一遍，对当前元素进行加一再模上10，如果变成了<code>0</code>,那么说明有进位，我们继续遍历，如果不是<code>0</code>,说明后面的元素都没有改变，直接返回即可。</p>\n<p>然后需要考虑的就是<code>99</code>这种类型，因为他本来是用两个数字即可表示,但是加一后需要3个数字：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">plusOne</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = digits.rbegin();it != digits.rend();it++) &#123;</span><br><span class=\"line\">        *it = (*it + <span class=\"number\">1</span>) % <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*it != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*digits.begin() == <span class=\"number\">0</span>) digits.insert(digits.begin(),<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第62天。</p>\n<p>今天很不在状态啊，明明是课最少的一天，却把那么多事拖到了晚上。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/plus-one/discuss/\">Plus One</a>:</p>\n<blockquote>\n<p>Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.</p>\n<p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p>\n<p>The digits are stored such that the most significant digit is at the head of the list.</p>\n</blockquote>\n<p>比较简单的一道的题目，就是给你一个数组来表示一个数字，而且又不没有负数什么的，只需要从后往前遍历一遍，对当前元素进行加一再模上10，如果变成了<code>0</code>,那么说明有进位，我们继续遍历，如果不是<code>0</code>,说明后面的元素都没有改变，直接返回即可。</p>\n<p>然后需要考虑的就是<code>99</code>这种类型，因为他本来是用两个数字即可表示,但是加一后需要3个数字：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">plusOne</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = digits.rbegin();it != digits.rend();it++) &#123;</span><br><span class=\"line\">        *it = (*it + <span class=\"number\">1</span>) % <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*it != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*digits.begin() == <span class=\"number\">0</span>) digits.insert(digits.begin(),<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Populating Next Right Pointers in Each Node II","date":"2019-11-14T14:53:14.000Z","_content":"\n> 第10天了。\n\n今天的题目是[ 117. Populating Next Right Pointers in Each Node II ]( https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ )：\n\n---\n\nGiven a binary tree\n\n```\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.\n\n![](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)\n\n **Example:** \n\n```\nInput: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":null,\"right\":null,\"val\":4},\"next\":null,\"right\":{\"$id\":\"4\",\"left\":null,\"next\":null,\"right\":null,\"val\":5},\"val\":2},\"next\":null,\"right\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"val\":3},\"val\":1}\n\nOutput: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":{\"$id\":\"4\",\"left\":null,\"next\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"right\":null,\"val\":5},\"right\":null,\"val\":4},\"next\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":{\"$ref\":\"5\"},\"val\":3},\"right\":{\"$ref\":\"4\"},\"val\":2},\"next\":null,\"right\":{\"$ref\":\"6\"},\"val\":1}\n\nExplanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.\n```\n\n**Note:**\n\n- You may only use constant extra space.\n- Recursive approach is fine, implicit stack space does not count as extra space for this problem.\n\n---\n\n这是一道之前没做出来的问题，最开始想出来的解法也和之前差不多，大概的想法是递归求解时返回子树的最左和最右节点，然后通过一些判断来相连，但是这个问题主要是没法处理两个子树高度不一样的问题。\n\n后面尝试用分治的方法来做，主要的想法是，假设我现在已经有了连接好的左子树和右子树，现在只需要将两个子树连接起来即可。而连接方法就是一层一层的去连接两个子树：\n\n```c++\nNode *nextLayer(Node *root) {\n    while(root) {\n        if (root->left) return root->left;\n        if (root->right) return root->right;\n        root = root->next;\n    }\n    return nullptr;\n}\nvoid connectLeftRight(Node *left, Node *right) {\n    // level 1\n    Node *pl, *pr;\n    while(left && right) {\n        pl = left;\n        pr = right;\n\n        // next layer\n        left = nextLayer(left);\n        right = nextLayer(right);\n\n        // connect left and right tree in this layer\n        while(pl->next) pl = pl->next;\n        pl->next = pr;\n    }\n}\n\nNode* connect1(Node* root) {\n    if (root == nullptr) return nullptr;\n    Node *left = connect1(root->left);\n    Node *right = connect1(root->right);\n    connectLeftRight(left, right);\n    return root;\n}\n```\n\n这个方法的时间复杂度大概是`O(h^2)`，其中`h`是树的高度。\n\n后面又发现一种方法，这种方法大概的思路是连接孩子，然后在递归求解。这样会保证在求解到`root`节点时，`root`节点的`next`是已知的，同时在连接孩子时，需要利用到右子树的`next`指针，所以需要先求解右子树再求解左子树。\n\n```c++\nvoid connectChild(Node *root) {\n    if (root == nullptr) return;\n\n    if (root->left) {\n        if (root->right) root->left->next = root->right;\n        else root->left->next = helper(root->next);\n    }\n    if (root->right) {\n        root->right->next = helper(root->next);\n    }\n\n}\n\nNode *helper(Node *root) {\n    if (root == nullptr) return nullptr;\n    else if (root->left) return root->left;\n    else if (root->right) return root->right;\n    else return helper(root->next);\n}\n\nNode* connect2(Node* root) {\n    if (root ==nullptr) return nullptr; \n    connectChild(root);\n    // 先求右边的。\n    connect2(root->right);\n    connect3(root->left);\n    return root;\n}\n```\n\n","source":"_posts/Populating-Next-Right-Pointers-in-Each-Node-II.md","raw":"---\ntitle: Populating Next Right Pointers in Each Node II\ndate: 2019-11-14T22:53:14.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第10天了。\n\n今天的题目是[ 117. Populating Next Right Pointers in Each Node II ]( https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ )：\n\n---\n\nGiven a binary tree\n\n```\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.\n\n![](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)\n\n **Example:** \n\n```\nInput: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":null,\"right\":null,\"val\":4},\"next\":null,\"right\":{\"$id\":\"4\",\"left\":null,\"next\":null,\"right\":null,\"val\":5},\"val\":2},\"next\":null,\"right\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"val\":3},\"val\":1}\n\nOutput: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":{\"$id\":\"4\",\"left\":null,\"next\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"right\":null,\"val\":5},\"right\":null,\"val\":4},\"next\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":{\"$ref\":\"5\"},\"val\":3},\"right\":{\"$ref\":\"4\"},\"val\":2},\"next\":null,\"right\":{\"$ref\":\"6\"},\"val\":1}\n\nExplanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.\n```\n\n**Note:**\n\n- You may only use constant extra space.\n- Recursive approach is fine, implicit stack space does not count as extra space for this problem.\n\n---\n\n这是一道之前没做出来的问题，最开始想出来的解法也和之前差不多，大概的想法是递归求解时返回子树的最左和最右节点，然后通过一些判断来相连，但是这个问题主要是没法处理两个子树高度不一样的问题。\n\n后面尝试用分治的方法来做，主要的想法是，假设我现在已经有了连接好的左子树和右子树，现在只需要将两个子树连接起来即可。而连接方法就是一层一层的去连接两个子树：\n\n```c++\nNode *nextLayer(Node *root) {\n    while(root) {\n        if (root->left) return root->left;\n        if (root->right) return root->right;\n        root = root->next;\n    }\n    return nullptr;\n}\nvoid connectLeftRight(Node *left, Node *right) {\n    // level 1\n    Node *pl, *pr;\n    while(left && right) {\n        pl = left;\n        pr = right;\n\n        // next layer\n        left = nextLayer(left);\n        right = nextLayer(right);\n\n        // connect left and right tree in this layer\n        while(pl->next) pl = pl->next;\n        pl->next = pr;\n    }\n}\n\nNode* connect1(Node* root) {\n    if (root == nullptr) return nullptr;\n    Node *left = connect1(root->left);\n    Node *right = connect1(root->right);\n    connectLeftRight(left, right);\n    return root;\n}\n```\n\n这个方法的时间复杂度大概是`O(h^2)`，其中`h`是树的高度。\n\n后面又发现一种方法，这种方法大概的思路是连接孩子，然后在递归求解。这样会保证在求解到`root`节点时，`root`节点的`next`是已知的，同时在连接孩子时，需要利用到右子树的`next`指针，所以需要先求解右子树再求解左子树。\n\n```c++\nvoid connectChild(Node *root) {\n    if (root == nullptr) return;\n\n    if (root->left) {\n        if (root->right) root->left->next = root->right;\n        else root->left->next = helper(root->next);\n    }\n    if (root->right) {\n        root->right->next = helper(root->next);\n    }\n\n}\n\nNode *helper(Node *root) {\n    if (root == nullptr) return nullptr;\n    else if (root->left) return root->left;\n    else if (root->right) return root->right;\n    else return helper(root->next);\n}\n\nNode* connect2(Node* root) {\n    if (root ==nullptr) return nullptr; \n    connectChild(root);\n    // 先求右边的。\n    connect2(root->right);\n    connect3(root->left);\n    return root;\n}\n```\n\n","slug":"Populating-Next-Right-Pointers-in-Each-Node-II","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pb00bmqmcmhss8acyl","content":"<blockquote>\n<p>第10天了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\"> 117. Populating Next Right Pointers in Each Node II </a>：</p>\n<hr>\n<p>Given a binary tree</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Node &#123;</span><br><span class=\"line\">  int val;</span><br><span class=\"line\">  Node *left;</span><br><span class=\"line\">  Node *right;</span><br><span class=\"line\">  Node *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/02/15/117_sample.png\"></p>\n<p> <strong>Example:</strong> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Output: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ul>\n<li>You may only use constant extra space.</li>\n<li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li>\n</ul>\n<hr>\n<p>这是一道之前没做出来的问题，最开始想出来的解法也和之前差不多，大概的想法是递归求解时返回子树的最左和最右节点，然后通过一些判断来相连，但是这个问题主要是没法处理两个子树高度不一样的问题。</p>\n<p>后面尝试用分治的方法来做，主要的想法是，假设我现在已经有了连接好的左子树和右子树，现在只需要将两个子树连接起来即可。而连接方法就是一层一层的去连接两个子树：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">nextLayer</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) <span class=\"keyword\">return</span> root-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) <span class=\"keyword\">return</span> root-&gt;right;</span><br><span class=\"line\">        root = root-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connectLeftRight</span><span class=\"params\">(Node *left, Node *right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// level 1</span></span><br><span class=\"line\">    Node *pl, *pr;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &amp;&amp; right) &#123;</span><br><span class=\"line\">        pl = left;</span><br><span class=\"line\">        pr = right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// next layer</span></span><br><span class=\"line\">        left = nextLayer(left);</span><br><span class=\"line\">        right = nextLayer(right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// connect left and right tree in this layer</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pl-&gt;next) pl = pl-&gt;next;</span><br><span class=\"line\">        pl-&gt;next = pr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect1</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    Node *left = connect1(root-&gt;left);</span><br><span class=\"line\">    Node *right = connect1(root-&gt;right);</span><br><span class=\"line\">    connectLeftRight(left, right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法的时间复杂度大概是<code>O(h^2)</code>，其中<code>h</code>是树的高度。</p>\n<p>后面又发现一种方法，这种方法大概的思路是连接孩子，然后在递归求解。这样会保证在求解到<code>root</code>节点时，<code>root</code>节点的<code>next</code>是已知的，同时在连接孩子时，需要利用到右子树的<code>next</code>指针，所以需要先求解右子树再求解左子树。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connectChild</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) root-&gt;left-&gt;next = root-&gt;right;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> root-&gt;left-&gt;next = helper(root-&gt;next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right) &#123;</span><br><span class=\"line\">        root-&gt;right-&gt;next = helper(root-&gt;next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">helper</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left) <span class=\"keyword\">return</span> root-&gt;left;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;right) <span class=\"keyword\">return</span> root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> helper(root-&gt;next);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect2</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root ==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; </span><br><span class=\"line\">    connectChild(root);</span><br><span class=\"line\">    <span class=\"comment\">// 先求右边的。</span></span><br><span class=\"line\">    connect2(root-&gt;right);</span><br><span class=\"line\">    connect3(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第10天了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\"> 117. Populating Next Right Pointers in Each Node II </a>：</p>\n<hr>\n<p>Given a binary tree</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Node &#123;</span><br><span class=\"line\">  int val;</span><br><span class=\"line\">  Node *left;</span><br><span class=\"line\">  Node *right;</span><br><span class=\"line\">  Node *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/02/15/117_sample.png\"></p>\n<p> <strong>Example:</strong> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Output: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ul>\n<li>You may only use constant extra space.</li>\n<li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li>\n</ul>\n<hr>\n<p>这是一道之前没做出来的问题，最开始想出来的解法也和之前差不多，大概的想法是递归求解时返回子树的最左和最右节点，然后通过一些判断来相连，但是这个问题主要是没法处理两个子树高度不一样的问题。</p>\n<p>后面尝试用分治的方法来做，主要的想法是，假设我现在已经有了连接好的左子树和右子树，现在只需要将两个子树连接起来即可。而连接方法就是一层一层的去连接两个子树：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">nextLayer</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) <span class=\"keyword\">return</span> root-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) <span class=\"keyword\">return</span> root-&gt;right;</span><br><span class=\"line\">        root = root-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connectLeftRight</span><span class=\"params\">(Node *left, Node *right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// level 1</span></span><br><span class=\"line\">    Node *pl, *pr;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &amp;&amp; right) &#123;</span><br><span class=\"line\">        pl = left;</span><br><span class=\"line\">        pr = right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// next layer</span></span><br><span class=\"line\">        left = nextLayer(left);</span><br><span class=\"line\">        right = nextLayer(right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// connect left and right tree in this layer</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pl-&gt;next) pl = pl-&gt;next;</span><br><span class=\"line\">        pl-&gt;next = pr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect1</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    Node *left = connect1(root-&gt;left);</span><br><span class=\"line\">    Node *right = connect1(root-&gt;right);</span><br><span class=\"line\">    connectLeftRight(left, right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法的时间复杂度大概是<code>O(h^2)</code>，其中<code>h</code>是树的高度。</p>\n<p>后面又发现一种方法，这种方法大概的思路是连接孩子，然后在递归求解。这样会保证在求解到<code>root</code>节点时，<code>root</code>节点的<code>next</code>是已知的，同时在连接孩子时，需要利用到右子树的<code>next</code>指针，所以需要先求解右子树再求解左子树。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connectChild</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) root-&gt;left-&gt;next = root-&gt;right;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> root-&gt;left-&gt;next = helper(root-&gt;next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right) &#123;</span><br><span class=\"line\">        root-&gt;right-&gt;next = helper(root-&gt;next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">helper</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left) <span class=\"keyword\">return</span> root-&gt;left;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;right) <span class=\"keyword\">return</span> root-&gt;right;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> helper(root-&gt;next);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect2</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root ==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; </span><br><span class=\"line\">    connectChild(root);</span><br><span class=\"line\">    <span class=\"comment\">// 先求右边的。</span></span><br><span class=\"line\">    connect2(root-&gt;right);</span><br><span class=\"line\">    connect3(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Possible Bipartition","date":"2019-11-26T08:13:42.000Z","_content":"\n> 第22天\n\n今天的题目是[ Possible Bipartition ]( https://leetcode.com/problems/possible-bipartition/ )：\n\n---\n\nGiven a set of `N` people (numbered `1, 2, ..., N`), we would like to split everyone into two groups of **any** size.\n\nEach person may dislike some other people, and they should not go into the same group. \n\nFormally, if `dislikes[i] = [a, b]`, it means it is not allowed to put the people numbered `a` and `b` into the same group.\n\nReturn `true` if and only if it is possible to split everyone into two groups in this way.\n\n \n\n**Example 1:**\n\n```\nInput: N = 4, dislikes = [[1,2],[1,3],[2,4]]\nOutput: true\nExplanation: group1 [1,4], group2 [2,3]\n```\n\n**Example 2:**\n\n```\nInput: N = 3, dislikes = [[1,2],[1,3],[2,3]]\nOutput: false\n```\n\n**Example 3:**\n\n```\nInput: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\nOutput: false\n```\n\n \n\n**Note:**\n\n1. `1 <= N <= 2000`\n2. `0 <= dislikes.length <= 10000`\n3. `1 <= dislikes[i][j] <= N`\n4. `dislikes[i][0] < dislikes[i][1]`\n5. There does not exist `i != j` for which `dislikes[i] == dislikes[j]`.\n\n---\n\n又是一道图的题目，而且和昨天的题目思路是一样的，先遍历染色，然后再判断是否满足即可。\n\n这里有些不同的是，这道题给出的输入是边的列表，然后我们需要手动建个图。同时，这道题还可以用在遍历时判断是否已经不符合了，进而可以提前退出。代码如下：\n\n```c++\nbool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n    vector<vector<int>> graph(N);\n    for(int i = 0;i < dislikes.size(); i++) {\n        graph[dislikes[i][0]-1].push_back(dislikes[i][1]-1);\n        graph[dislikes[i][1]-1].push_back(dislikes[i][0]-1);\n    }\n    char color = 'b';\n    vector<char> visited(N, 'w');\n    for(int i = 0;i < N;i++) {\n        if (visited[i] == 'w' && dfs(graph, visited ,i, color) == false) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool dfs(vector<vector<int>> &graph, vector<char> &visited, int index, char color) {\n    visited[index] = color;\n\n    for(int i = 0;i < graph[index].size(); i++) {\n        int j = graph[index][i];\n        if ((visited[j] == 'w' && !dfs(graph, visited, j, ~color)) || visited[j] == color){\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n","source":"_posts/Possible-Bipartition.md","raw":"---\ntitle: Possible Bipartition\ndate: 2019-11-26T16:13:42.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第22天\n\n今天的题目是[ Possible Bipartition ]( https://leetcode.com/problems/possible-bipartition/ )：\n\n---\n\nGiven a set of `N` people (numbered `1, 2, ..., N`), we would like to split everyone into two groups of **any** size.\n\nEach person may dislike some other people, and they should not go into the same group. \n\nFormally, if `dislikes[i] = [a, b]`, it means it is not allowed to put the people numbered `a` and `b` into the same group.\n\nReturn `true` if and only if it is possible to split everyone into two groups in this way.\n\n \n\n**Example 1:**\n\n```\nInput: N = 4, dislikes = [[1,2],[1,3],[2,4]]\nOutput: true\nExplanation: group1 [1,4], group2 [2,3]\n```\n\n**Example 2:**\n\n```\nInput: N = 3, dislikes = [[1,2],[1,3],[2,3]]\nOutput: false\n```\n\n**Example 3:**\n\n```\nInput: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\nOutput: false\n```\n\n \n\n**Note:**\n\n1. `1 <= N <= 2000`\n2. `0 <= dislikes.length <= 10000`\n3. `1 <= dislikes[i][j] <= N`\n4. `dislikes[i][0] < dislikes[i][1]`\n5. There does not exist `i != j` for which `dislikes[i] == dislikes[j]`.\n\n---\n\n又是一道图的题目，而且和昨天的题目思路是一样的，先遍历染色，然后再判断是否满足即可。\n\n这里有些不同的是，这道题给出的输入是边的列表，然后我们需要手动建个图。同时，这道题还可以用在遍历时判断是否已经不符合了，进而可以提前退出。代码如下：\n\n```c++\nbool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n    vector<vector<int>> graph(N);\n    for(int i = 0;i < dislikes.size(); i++) {\n        graph[dislikes[i][0]-1].push_back(dislikes[i][1]-1);\n        graph[dislikes[i][1]-1].push_back(dislikes[i][0]-1);\n    }\n    char color = 'b';\n    vector<char> visited(N, 'w');\n    for(int i = 0;i < N;i++) {\n        if (visited[i] == 'w' && dfs(graph, visited ,i, color) == false) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool dfs(vector<vector<int>> &graph, vector<char> &visited, int index, char color) {\n    visited[index] = color;\n\n    for(int i = 0;i < graph[index].size(); i++) {\n        int j = graph[index][i];\n        if ((visited[j] == 'w' && !dfs(graph, visited, j, ~color)) || visited[j] == color){\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n","slug":"Possible-Bipartition","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pc00bpqmcm5i0ae60t","content":"<blockquote>\n<p>第22天</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/possible-bipartition/\"> Possible Bipartition </a>：</p>\n<hr>\n<p>Given a set of <code>N</code> people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of <strong>any</strong> size.</p>\n<p>Each person may dislike some other people, and they should not go into the same group. </p>\n<p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered <code>a</code> and <code>b</code> into the same group.</p>\n<p>Return <code>true</code> if and only if it is possible to split everyone into two groups in this way.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: N &#x3D; 5, dislikes &#x3D; [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= N &lt;= 2000</code></li>\n<li><code>0 &lt;= dislikes.length &lt;= 10000</code></li>\n<li><code>1 &lt;= dislikes[i][j] &lt;= N</code></li>\n<li><code>dislikes[i][0] &lt; dislikes[i][1]</code></li>\n<li>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j]</code>.</li>\n</ol>\n<hr>\n<p>又是一道图的题目，而且和昨天的题目思路是一样的，先遍历染色，然后再判断是否满足即可。</p>\n<p>这里有些不同的是，这道题给出的输入是边的列表，然后我们需要手动建个图。同时，这道题还可以用在遍历时判断是否已经不符合了，进而可以提前退出。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">possibleBipartition</span><span class=\"params\">(<span class=\"keyword\">int</span> N, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; graph(N);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; dislikes.size(); i++) &#123;</span><br><span class=\"line\">        graph[dislikes[i][<span class=\"number\">0</span>]<span class=\"number\">-1</span>].push_back(dislikes[i][<span class=\"number\">1</span>]<span class=\"number\">-1</span>);</span><br><span class=\"line\">        graph[dislikes[i][<span class=\"number\">1</span>]<span class=\"number\">-1</span>].push_back(dislikes[i][<span class=\"number\">0</span>]<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> color = <span class=\"string\">&#x27;b&#x27;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(N, <span class=\"string\">&#x27;w&#x27;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; N;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"string\">&#x27;w&#x27;</span> &amp;&amp; dfs(graph, visited ,i, color) == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &amp;visited, <span class=\"keyword\">int</span> index, <span class=\"keyword\">char</span> color)</span> </span>&#123;</span><br><span class=\"line\">    visited[index] = color;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; graph[index].size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = graph[index][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((visited[j] == <span class=\"string\">&#x27;w&#x27;</span> &amp;&amp; !dfs(graph, visited, j, ~color)) || visited[j] == color)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第22天</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/possible-bipartition/\"> Possible Bipartition </a>：</p>\n<hr>\n<p>Given a set of <code>N</code> people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of <strong>any</strong> size.</p>\n<p>Each person may dislike some other people, and they should not go into the same group. </p>\n<p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered <code>a</code> and <code>b</code> into the same group.</p>\n<p>Return <code>true</code> if and only if it is possible to split everyone into two groups in this way.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: N &#x3D; 5, dislikes &#x3D; [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1 &lt;= N &lt;= 2000</code></li>\n<li><code>0 &lt;= dislikes.length &lt;= 10000</code></li>\n<li><code>1 &lt;= dislikes[i][j] &lt;= N</code></li>\n<li><code>dislikes[i][0] &lt; dislikes[i][1]</code></li>\n<li>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j]</code>.</li>\n</ol>\n<hr>\n<p>又是一道图的题目，而且和昨天的题目思路是一样的，先遍历染色，然后再判断是否满足即可。</p>\n<p>这里有些不同的是，这道题给出的输入是边的列表，然后我们需要手动建个图。同时，这道题还可以用在遍历时判断是否已经不符合了，进而可以提前退出。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">possibleBipartition</span><span class=\"params\">(<span class=\"keyword\">int</span> N, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; graph(N);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; dislikes.size(); i++) &#123;</span><br><span class=\"line\">        graph[dislikes[i][<span class=\"number\">0</span>]<span class=\"number\">-1</span>].push_back(dislikes[i][<span class=\"number\">1</span>]<span class=\"number\">-1</span>);</span><br><span class=\"line\">        graph[dislikes[i][<span class=\"number\">1</span>]<span class=\"number\">-1</span>].push_back(dislikes[i][<span class=\"number\">0</span>]<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> color = <span class=\"string\">&#x27;b&#x27;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(N, <span class=\"string\">&#x27;w&#x27;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; N;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"string\">&#x27;w&#x27;</span> &amp;&amp; dfs(graph, visited ,i, color) == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;graph, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &amp;visited, <span class=\"keyword\">int</span> index, <span class=\"keyword\">char</span> color)</span> </span>&#123;</span><br><span class=\"line\">    visited[index] = color;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; graph[index].size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = graph[index][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((visited[j] == <span class=\"string\">&#x27;w&#x27;</span> &amp;&amp; !dfs(graph, visited, j, ~color)) || visited[j] == color)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Pow(x,n)","author":"wuxiaobai24","date":"2017-09-26T04:17:00.000Z","_content":"\n打卡第三天！！！\n\n今天刷的题是[Pow(x,n)](https://leetcode.com/problems/powx-n/description/)\n\n> implement pow(x,n)\n\n题目相当简洁，看起来好像也不会很难的样子，不过他竟然是一道`Medium`的题目（万万没想到）.\n`pow(x,n)`大家应该都多少有接触过，就是求x的n次方嘛。\n我们可以把n分成三种情况去考虑：\n- `n > 0` ： 可以转化成求`myPow(1/x,-n)`\n- `n == 0` ：直接`return 1`即可\n- `n < 0` ：这个是我们实现的关键，只要完成这个就可以AC这道题了。\n\n首先，一个最简单的思路就是n个`x`相乘.\n```c++\ndouble ret = 1\nfor(int i = 0;i < n;i++)\n\tret *= x;\nreturn ret\n```\n这样需要做n次乘法，时间复杂度是`O(n)`,在`LeetCode`中，这样做是会超时的，我们需要找到一个 时间复杂度更小的算法。\n\n可以考虑使用分治法去完成：\n也就是说，我们要求`myPow(x,n)`的值，那我们可以转化成求`myPow(x,n/2)`的值，然后将其返回值乘二即可（n为奇数，还需要 乘多一个x）。\n```c++\ndouble ret = myPow(x,n/2);\nreturn (n%2)?(ret*ret*x):(ret*ret);\n```\n这是递归的做法，显然这已经能够完成了,这也是我的做法。\n这里面还有一个坑点没提到，就是在`n < 0`的情况下，我们前面的做法是直接`return myPow(1/x,-n)`的，但是这样是会出错的：\n当`n=-2147483648`时，会出现`RunTime Error`，也就是那个`-n`是求不出来的，因为`int`类型的最大值为2147483647。\n这里用了一个小技巧：\n`return myPow(1/x, -(n + 1) ) *1/x;`\n 因为这里的`n`满足`n < 0`，所以可以不用考虑正溢出的情况。\n 完整的代码为：\n```C++\ndouble myPow(double x, int n) {\n    if (n == 0) return 1;\n    else if (n > 0) {\n        double ret = myPow(x,n/2);\n        return (n%2)?ret*ret*x:ret*ret;\n    } else {\n        //n < 0\n        return myPow(1/x,-(n + 1 )) * 1/x;\n    }\n}\n```\n\n恩，按照惯例，看看`dicuss`中别人的做法:\n```c++\ndouble myPow(double x, int n) {\n\tdouble ans;\n\tunsigned long long;\n\tif ( n < 0 ) {\n\t\tp = -n;\n\t\tx = 1/x;\n\t} else {\n\t\tp = n;\n\t}\n\n\twhile(p) {\n\t\tif (p & 1)\n\t\t\tans *= x;\n\t\tx *= x;\n\t\tp >>= 1;\n\t}\n\n}\n```\n\n看到这个做法的第一眼就想起了某位老师说的：\n> “有时候你需要从二进制的角度去看问题。”\n\n我们来考虑`myPow(a,7)`的情况：\n`7`的二进制编码为：`0000 0111`,也就是`7 = 4 + 2 + 1`\n而 $ a^{7} = a^{4} * a^{2} * a^{1} $  \n相信上面的代码应该能够很容易的看懂了。\n另外我们还可以看到，他用`unsigned long long`来避免溢出的情况，这也是一个小技巧。\n","source":"_posts/Pow(x,y).md","raw":"---\ntitle: 'Pow(x,n)'\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 算法\nauthor: wuxiaobai24\ndate: 2017-09-26T12:17:00.000Z\n---\n\n打卡第三天！！！\n\n今天刷的题是[Pow(x,n)](https://leetcode.com/problems/powx-n/description/)\n\n> implement pow(x,n)\n\n题目相当简洁，看起来好像也不会很难的样子，不过他竟然是一道`Medium`的题目（万万没想到）.\n`pow(x,n)`大家应该都多少有接触过，就是求x的n次方嘛。\n我们可以把n分成三种情况去考虑：\n- `n > 0` ： 可以转化成求`myPow(1/x,-n)`\n- `n == 0` ：直接`return 1`即可\n- `n < 0` ：这个是我们实现的关键，只要完成这个就可以AC这道题了。\n\n首先，一个最简单的思路就是n个`x`相乘.\n```c++\ndouble ret = 1\nfor(int i = 0;i < n;i++)\n\tret *= x;\nreturn ret\n```\n这样需要做n次乘法，时间复杂度是`O(n)`,在`LeetCode`中，这样做是会超时的，我们需要找到一个 时间复杂度更小的算法。\n\n可以考虑使用分治法去完成：\n也就是说，我们要求`myPow(x,n)`的值，那我们可以转化成求`myPow(x,n/2)`的值，然后将其返回值乘二即可（n为奇数，还需要 乘多一个x）。\n```c++\ndouble ret = myPow(x,n/2);\nreturn (n%2)?(ret*ret*x):(ret*ret);\n```\n这是递归的做法，显然这已经能够完成了,这也是我的做法。\n这里面还有一个坑点没提到，就是在`n < 0`的情况下，我们前面的做法是直接`return myPow(1/x,-n)`的，但是这样是会出错的：\n当`n=-2147483648`时，会出现`RunTime Error`，也就是那个`-n`是求不出来的，因为`int`类型的最大值为2147483647。\n这里用了一个小技巧：\n`return myPow(1/x, -(n + 1) ) *1/x;`\n 因为这里的`n`满足`n < 0`，所以可以不用考虑正溢出的情况。\n 完整的代码为：\n```C++\ndouble myPow(double x, int n) {\n    if (n == 0) return 1;\n    else if (n > 0) {\n        double ret = myPow(x,n/2);\n        return (n%2)?ret*ret*x:ret*ret;\n    } else {\n        //n < 0\n        return myPow(1/x,-(n + 1 )) * 1/x;\n    }\n}\n```\n\n恩，按照惯例，看看`dicuss`中别人的做法:\n```c++\ndouble myPow(double x, int n) {\n\tdouble ans;\n\tunsigned long long;\n\tif ( n < 0 ) {\n\t\tp = -n;\n\t\tx = 1/x;\n\t} else {\n\t\tp = n;\n\t}\n\n\twhile(p) {\n\t\tif (p & 1)\n\t\t\tans *= x;\n\t\tx *= x;\n\t\tp >>= 1;\n\t}\n\n}\n```\n\n看到这个做法的第一眼就想起了某位老师说的：\n> “有时候你需要从二进制的角度去看问题。”\n\n我们来考虑`myPow(a,7)`的情况：\n`7`的二进制编码为：`0000 0111`,也就是`7 = 4 + 2 + 1`\n而 $ a^{7} = a^{4} * a^{2} * a^{1} $  \n相信上面的代码应该能够很容易的看懂了。\n另外我们还可以看到，他用`unsigned long long`来避免溢出的情况，这也是一个小技巧。\n","slug":"Pow(x,y)","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pc00bsqmcm7hrfe3zy","content":"<p>打卡第三天！！！</p>\n<p>今天刷的题是<a href=\"https://leetcode.com/problems/powx-n/description/\">Pow(x,n)</a></p>\n<blockquote>\n<p>implement pow(x,n)</p>\n</blockquote>\n<p>题目相当简洁，看起来好像也不会很难的样子，不过他竟然是一道<code>Medium</code>的题目（万万没想到）.<br><code>pow(x,n)</code>大家应该都多少有接触过，就是求x的n次方嘛。<br>我们可以把n分成三种情况去考虑：</p>\n<ul>\n<li><code>n &gt; 0</code> ： 可以转化成求<code>myPow(1/x,-n)</code></li>\n<li><code>n == 0</code> ：直接<code>return 1</code>即可</li>\n<li><code>n &lt; 0</code> ：这个是我们实现的关键，只要完成这个就可以AC这道题了。</li>\n</ul>\n<p>首先，一个最简单的思路就是n个<code>x</code>相乘.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> ret = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)</span><br><span class=\"line\">\tret *= x;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure>\n<p>这样需要做n次乘法，时间复杂度是<code>O(n)</code>,在<code>LeetCode</code>中，这样做是会超时的，我们需要找到一个 时间复杂度更小的算法。</p>\n<p>可以考虑使用分治法去完成：<br>也就是说，我们要求<code>myPow(x,n)</code>的值，那我们可以转化成求<code>myPow(x,n/2)</code>的值，然后将其返回值乘二即可（n为奇数，还需要 乘多一个x）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> ret = myPow(x,n/<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> (n%<span class=\"number\">2</span>)?(ret*ret*x):(ret*ret);</span><br></pre></td></tr></table></figure>\n<p>这是递归的做法，显然这已经能够完成了,这也是我的做法。<br>这里面还有一个坑点没提到，就是在<code>n &lt; 0</code>的情况下，我们前面的做法是直接<code>return myPow(1/x,-n)</code>的，但是这样是会出错的：<br>当<code>n=-2147483648</code>时，会出现<code>RunTime Error</code>，也就是那个<code>-n</code>是求不出来的，因为<code>int</code>类型的最大值为2147483647。<br>这里用了一个小技巧：<br><code>return myPow(1/x, -(n + 1) ) *1/x;</code><br> 因为这里的<code>n</code>满足<code>n &lt; 0</code>，所以可以不用考虑正溢出的情况。<br> 完整的代码为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> ret = myPow(x,n/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n%<span class=\"number\">2</span>)?ret*ret*x:ret*ret;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//n &lt; 0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myPow(<span class=\"number\">1</span>/x,-(n + <span class=\"number\">1</span> )) * <span class=\"number\">1</span>/x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，按照惯例，看看<code>dicuss</code>中别人的做法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( n &lt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">\t\tp = -n;</span><br><span class=\"line\">\t\tx = <span class=\"number\">1</span>/x;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tp = n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tans *= x;</span><br><span class=\"line\">\t\tx *= x;</span><br><span class=\"line\">\t\tp &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到这个做法的第一眼就想起了某位老师说的：</p>\n<blockquote>\n<p>“有时候你需要从二进制的角度去看问题。”</p>\n</blockquote>\n<p>我们来考虑<code>myPow(a,7)</code>的情况：<br><code>7</code>的二进制编码为：<code>0000 0111</code>,也就是<code>7 = 4 + 2 + 1</code><br>而 $ a^{7} = a^{4} * a^{2} * a^{1} $<br>相信上面的代码应该能够很容易的看懂了。<br>另外我们还可以看到，他用<code>unsigned long long</code>来避免溢出的情况，这也是一个小技巧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡第三天！！！</p>\n<p>今天刷的题是<a href=\"https://leetcode.com/problems/powx-n/description/\">Pow(x,n)</a></p>\n<blockquote>\n<p>implement pow(x,n)</p>\n</blockquote>\n<p>题目相当简洁，看起来好像也不会很难的样子，不过他竟然是一道<code>Medium</code>的题目（万万没想到）.<br><code>pow(x,n)</code>大家应该都多少有接触过，就是求x的n次方嘛。<br>我们可以把n分成三种情况去考虑：</p>\n<ul>\n<li><code>n &gt; 0</code> ： 可以转化成求<code>myPow(1/x,-n)</code></li>\n<li><code>n == 0</code> ：直接<code>return 1</code>即可</li>\n<li><code>n &lt; 0</code> ：这个是我们实现的关键，只要完成这个就可以AC这道题了。</li>\n</ul>\n<p>首先，一个最简单的思路就是n个<code>x</code>相乘.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> ret = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)</span><br><span class=\"line\">\tret *= x;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure>\n<p>这样需要做n次乘法，时间复杂度是<code>O(n)</code>,在<code>LeetCode</code>中，这样做是会超时的，我们需要找到一个 时间复杂度更小的算法。</p>\n<p>可以考虑使用分治法去完成：<br>也就是说，我们要求<code>myPow(x,n)</code>的值，那我们可以转化成求<code>myPow(x,n/2)</code>的值，然后将其返回值乘二即可（n为奇数，还需要 乘多一个x）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> ret = myPow(x,n/<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> (n%<span class=\"number\">2</span>)?(ret*ret*x):(ret*ret);</span><br></pre></td></tr></table></figure>\n<p>这是递归的做法，显然这已经能够完成了,这也是我的做法。<br>这里面还有一个坑点没提到，就是在<code>n &lt; 0</code>的情况下，我们前面的做法是直接<code>return myPow(1/x,-n)</code>的，但是这样是会出错的：<br>当<code>n=-2147483648</code>时，会出现<code>RunTime Error</code>，也就是那个<code>-n</code>是求不出来的，因为<code>int</code>类型的最大值为2147483647。<br>这里用了一个小技巧：<br><code>return myPow(1/x, -(n + 1) ) *1/x;</code><br> 因为这里的<code>n</code>满足<code>n &lt; 0</code>，所以可以不用考虑正溢出的情况。<br> 完整的代码为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> ret = myPow(x,n/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n%<span class=\"number\">2</span>)?ret*ret*x:ret*ret;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//n &lt; 0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myPow(<span class=\"number\">1</span>/x,-(n + <span class=\"number\">1</span> )) * <span class=\"number\">1</span>/x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，按照惯例，看看<code>dicuss</code>中别人的做法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( n &lt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">\t\tp = -n;</span><br><span class=\"line\">\t\tx = <span class=\"number\">1</span>/x;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tp = n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tans *= x;</span><br><span class=\"line\">\t\tx *= x;</span><br><span class=\"line\">\t\tp &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到这个做法的第一眼就想起了某位老师说的：</p>\n<blockquote>\n<p>“有时候你需要从二进制的角度去看问题。”</p>\n</blockquote>\n<p>我们来考虑<code>myPow(a,7)</code>的情况：<br><code>7</code>的二进制编码为：<code>0000 0111</code>,也就是<code>7 = 4 + 2 + 1</code><br>而 $ a^{7} = a^{4} * a^{2} * a^{1} $<br>相信上面的代码应该能够很容易的看懂了。<br>另外我们还可以看到，他用<code>unsigned long long</code>来避免溢出的情况，这也是一个小技巧。</p>\n"},{"title":"Print FooBar Alternately","date":"2019-12-12T02:40:17.000Z","_content":"\n> 第36天。\n\n今天的题目是[Print FooBar Alternately](https://leetcode.com/problems/print-foobar-alternately/):\n\n一道简单的并发的题目，交替输出`Foo`和`Bar`，就是要并发的两个线程，按顺序交替执行，我们可以用两个`mutxe`去实现：\n\n```c++\nclass FooBar {\nprivate:\n    int n;\n    mutex m1, m2;\npublic:\n    FooBar(int n) {\n        this->n = n;\n        m2.lock();\n    }\n\n    void foo(function<void()> printFoo) {\n        \n        for (int i = 0; i < n; i++) {\n            m1.lock();\n        \t// printFoo() outputs \"foo\". Do not change or remove this line.\n        \tprintFoo();\n            m2.unlock();\n        }\n    }\n\n    void bar(function<void()> printBar) {\n        \n        for (int i = 0; i < n; i++) {\n            m2.lock();\n        \t// printBar() outputs \"bar\". Do not change or remove this line.\n        \tprintBar();\n            m1.unlock();\n        }\n    }\n};\n```\n","source":"_posts/Print-FooBar-Alternately.md","raw":"---\ntitle: Print FooBar Alternately\ndate: 2019-12-12T10:40:17.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第36天。\n\n今天的题目是[Print FooBar Alternately](https://leetcode.com/problems/print-foobar-alternately/):\n\n一道简单的并发的题目，交替输出`Foo`和`Bar`，就是要并发的两个线程，按顺序交替执行，我们可以用两个`mutxe`去实现：\n\n```c++\nclass FooBar {\nprivate:\n    int n;\n    mutex m1, m2;\npublic:\n    FooBar(int n) {\n        this->n = n;\n        m2.lock();\n    }\n\n    void foo(function<void()> printFoo) {\n        \n        for (int i = 0; i < n; i++) {\n            m1.lock();\n        \t// printFoo() outputs \"foo\". Do not change or remove this line.\n        \tprintFoo();\n            m2.unlock();\n        }\n    }\n\n    void bar(function<void()> printBar) {\n        \n        for (int i = 0; i < n; i++) {\n            m2.lock();\n        \t// printBar() outputs \"bar\". Do not change or remove this line.\n        \tprintBar();\n            m1.unlock();\n        }\n    }\n};\n```\n","slug":"Print-FooBar-Alternately","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pe00bvqmcmczq85ida","content":"<blockquote>\n<p>第36天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/print-foobar-alternately/\">Print FooBar Alternately</a>:</p>\n<p>一道简单的并发的题目，交替输出<code>Foo</code>和<code>Bar</code>，就是要并发的两个线程，按顺序交替执行，我们可以用两个<code>mutxe</code>去实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooBar</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    mutex m1, m2;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    FooBar(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;n = n;</span><br><span class=\"line\">        m2.lock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(function&lt;<span class=\"keyword\">void</span>()&gt; printFoo)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            m1.lock();</span><br><span class=\"line\">        \t<span class=\"comment\">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class=\"line\">        \tprintFoo();</span><br><span class=\"line\">            m2.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(function&lt;<span class=\"keyword\">void</span>()&gt; printBar)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            m2.lock();</span><br><span class=\"line\">        \t<span class=\"comment\">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class=\"line\">        \tprintBar();</span><br><span class=\"line\">            m1.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第36天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/print-foobar-alternately/\">Print FooBar Alternately</a>:</p>\n<p>一道简单的并发的题目，交替输出<code>Foo</code>和<code>Bar</code>，就是要并发的两个线程，按顺序交替执行，我们可以用两个<code>mutxe</code>去实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooBar</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    mutex m1, m2;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    FooBar(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;n = n;</span><br><span class=\"line\">        m2.lock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(function&lt;<span class=\"keyword\">void</span>()&gt; printFoo)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            m1.lock();</span><br><span class=\"line\">        \t<span class=\"comment\">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class=\"line\">        \tprintFoo();</span><br><span class=\"line\">            m2.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(function&lt;<span class=\"keyword\">void</span>()&gt; printBar)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            m2.lock();</span><br><span class=\"line\">        \t<span class=\"comment\">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class=\"line\">        \tprintBar();</span><br><span class=\"line\">            m1.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Product of Array Except Self","date":"2017-11-08T14:55:58.000Z","_content":"\n第43天。\n\n今天的题目是[Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/description/):\n\n> Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\n>\n> Solve it without division and in O(n).\n>\n> For example, given [1,2,3,4], return [24,12,8,6].\n>\n> Follow up:\n> Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)\n\n\n这里说不能使用除法，我的想法就是自己实现一个除法:\n\n```c++\nint Div(unsigned  a,unsigned b) {\n    int x,y;\n    int ans = 0;\n    while(a >= b) {\n        x = b;\n        y = 1;\n        while( a >= (x<<1)) {\n            x <<= 1;\n            y <<= 1;\n        }\n        a -= x;\n        ans += y;\n    }\n    return ans;\n}\nint div(int a,int b) {\n    if (a > 0 && b > 0) return Div(a,b);\n    else if (a < 0 && b < 0) return Div(-a,-b);\n    else if (a < 0) return -Div(-a,b);\n    else return -Div(a,-b);\n}\n```\n\n然后剩下的东西就是将`0`这个特例排除掉了：\n\n```c++\nvector<int> productExceptSelf(vector<int>& nums) {\n    vector<int> ret(nums.size(),0);\n    long long product = 1;\n    int zero_count = 0;\n    for(auto i:nums)\n        if (i != 0) product*=i;\n        else zero_count++;\n    cout << zero_count << endl;\n\n    if (zero_count > 1) return ret;\n\n    if (zero_count == 1) {\n        for(int i = 0;i < nums.size();i++) {\n            if (nums[i] != 0) ret[i] = 0;\n            else ret[i] = product;\n        }\n        return ret;\n    }\n\n    for(int i = 0;i < ret.size();i++) {\n    //    if (nums[i] == 0) ret[i] = product[i];\n        ret[i] = div((int)product,nums[i]);\n    }\n    return ret;\n}\n```\n\n但是看了`dicuss`的做法，我感觉的理解是错的：\n\n```python\ndef productExceptSelf(self, nums):\n        p = 1\n        n = len(nums)\n        output = []\n        for i in range(0,n):\n            output.append(p)\n            p = p * nums[i]\n        p = 1\n        for i in range(n-1,-1,-1):\n            output[i] = output[i] * p\n            p = p * nums[i]\n        return output\n```\n\n恩，今天写的有点急，因为我周五安全导论还要考试，然而我还一堆东西不会。。。\n","source":"_posts/Product-of-Array-Except-Self.md","raw":"---\ntitle: Product of Array Except Self\ndate: 2017-11-08T22:55:58.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第43天。\n\n今天的题目是[Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/description/):\n\n> Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\n>\n> Solve it without division and in O(n).\n>\n> For example, given [1,2,3,4], return [24,12,8,6].\n>\n> Follow up:\n> Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)\n\n\n这里说不能使用除法，我的想法就是自己实现一个除法:\n\n```c++\nint Div(unsigned  a,unsigned b) {\n    int x,y;\n    int ans = 0;\n    while(a >= b) {\n        x = b;\n        y = 1;\n        while( a >= (x<<1)) {\n            x <<= 1;\n            y <<= 1;\n        }\n        a -= x;\n        ans += y;\n    }\n    return ans;\n}\nint div(int a,int b) {\n    if (a > 0 && b > 0) return Div(a,b);\n    else if (a < 0 && b < 0) return Div(-a,-b);\n    else if (a < 0) return -Div(-a,b);\n    else return -Div(a,-b);\n}\n```\n\n然后剩下的东西就是将`0`这个特例排除掉了：\n\n```c++\nvector<int> productExceptSelf(vector<int>& nums) {\n    vector<int> ret(nums.size(),0);\n    long long product = 1;\n    int zero_count = 0;\n    for(auto i:nums)\n        if (i != 0) product*=i;\n        else zero_count++;\n    cout << zero_count << endl;\n\n    if (zero_count > 1) return ret;\n\n    if (zero_count == 1) {\n        for(int i = 0;i < nums.size();i++) {\n            if (nums[i] != 0) ret[i] = 0;\n            else ret[i] = product;\n        }\n        return ret;\n    }\n\n    for(int i = 0;i < ret.size();i++) {\n    //    if (nums[i] == 0) ret[i] = product[i];\n        ret[i] = div((int)product,nums[i]);\n    }\n    return ret;\n}\n```\n\n但是看了`dicuss`的做法，我感觉的理解是错的：\n\n```python\ndef productExceptSelf(self, nums):\n        p = 1\n        n = len(nums)\n        output = []\n        for i in range(0,n):\n            output.append(p)\n            p = p * nums[i]\n        p = 1\n        for i in range(n-1,-1,-1):\n            output[i] = output[i] * p\n            p = p * nums[i]\n        return output\n```\n\n恩，今天写的有点急，因为我周五安全导论还要考试，然而我还一堆东西不会。。。\n","slug":"Product-of-Array-Except-Self","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pe00byqmcmcxfgd4hx","content":"<p>第43天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/product-of-array-except-self/description/\">Product of Array Except Self</a>:</p>\n<blockquote>\n<p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>\n<p>Solve it without division and in O(n).</p>\n<p>For example, given [1,2,3,4], return [24,12,8,6].</p>\n<p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p>\n</blockquote>\n<p>这里说不能使用除法，我的想法就是自己实现一个除法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Div</span><span class=\"params\">(<span class=\"keyword\">unsigned</span>  a,<span class=\"keyword\">unsigned</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a &gt;= b) &#123;</span><br><span class=\"line\">        x = b;</span><br><span class=\"line\">        y = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( a &gt;= (x&lt;&lt;<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            x &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            y &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a -= x;</span><br><span class=\"line\">        ans += y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">div</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span> &amp;&amp; b &gt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> Div(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span> &amp;&amp; b &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> Div(-a,-b);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -Div(-a,b);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> -Div(a,-b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后剩下的东西就是将<code>0</code>这个特例排除掉了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">productExceptSelf</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(nums.size(),<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> product = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> zero_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) product*=i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> zero_count++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; zero_count &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zero_count &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zero_count == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) ret[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ret[i] = product;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; ret.size();i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//    if (nums[i] == 0) ret[i] = product[i];</span></span><br><span class=\"line\">        ret[i] = div((<span class=\"keyword\">int</span>)product,nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是看了<code>dicuss</code>的做法，我感觉的理解是错的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">productExceptSelf</span>(<span class=\"params\">self, nums</span>):</span></span><br><span class=\"line\">        p = <span class=\"number\">1</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        output = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>,n):</span><br><span class=\"line\">            output.append(p)</span><br><span class=\"line\">            p = p * nums[i]</span><br><span class=\"line\">        p = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n-<span class=\"number\">1</span>,-<span class=\"number\">1</span>,-<span class=\"number\">1</span>):</span><br><span class=\"line\">            output[i] = output[i] * p</span><br><span class=\"line\">            p = p * nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br></pre></td></tr></table></figure>\n\n<p>恩，今天写的有点急，因为我周五安全导论还要考试，然而我还一堆东西不会。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第43天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/product-of-array-except-self/description/\">Product of Array Except Self</a>:</p>\n<blockquote>\n<p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>\n<p>Solve it without division and in O(n).</p>\n<p>For example, given [1,2,3,4], return [24,12,8,6].</p>\n<p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p>\n</blockquote>\n<p>这里说不能使用除法，我的想法就是自己实现一个除法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Div</span><span class=\"params\">(<span class=\"keyword\">unsigned</span>  a,<span class=\"keyword\">unsigned</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a &gt;= b) &#123;</span><br><span class=\"line\">        x = b;</span><br><span class=\"line\">        y = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( a &gt;= (x&lt;&lt;<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            x &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            y &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a -= x;</span><br><span class=\"line\">        ans += y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">div</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span> &amp;&amp; b &gt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> Div(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span> &amp;&amp; b &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> Div(-a,-b);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -Div(-a,b);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> -Div(a,-b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后剩下的东西就是将<code>0</code>这个特例排除掉了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">productExceptSelf</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(nums.size(),<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> product = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> zero_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) product*=i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> zero_count++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; zero_count &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zero_count &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zero_count == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) ret[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ret[i] = product;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; ret.size();i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//    if (nums[i] == 0) ret[i] = product[i];</span></span><br><span class=\"line\">        ret[i] = div((<span class=\"keyword\">int</span>)product,nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是看了<code>dicuss</code>的做法，我感觉的理解是错的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">productExceptSelf</span>(<span class=\"params\">self, nums</span>):</span></span><br><span class=\"line\">        p = <span class=\"number\">1</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        output = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>,n):</span><br><span class=\"line\">            output.append(p)</span><br><span class=\"line\">            p = p * nums[i]</span><br><span class=\"line\">        p = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n-<span class=\"number\">1</span>,-<span class=\"number\">1</span>,-<span class=\"number\">1</span>):</span><br><span class=\"line\">            output[i] = output[i] * p</span><br><span class=\"line\">            p = p * nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br></pre></td></tr></table></figure>\n\n<p>恩，今天写的有点急，因为我周五安全导论还要考试，然而我还一堆东西不会。。。</p>\n"},{"title":"Rectangle-Area","date":"2018-01-17T04:35:45.000Z","_content":"\n第86天。\n\n今天的题目是[Rectangle Area](https://leetcode.com/problems/rectangle-area/description/):\n\n> Find the total area covered by two rectilinear rectangles in a 2D plane.\n>\n> Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.\n![](https://leetcode.com/static/images/problemset/rectangle_area.png)\n> Assume that the total area is never beyond the maximum possible value of int.\n\n一开始以为是求两个矩形重合部分的面积，后来仔细看了一下才发现是求它们的覆盖面积，好在把重合部分面积求出来后，求他们覆盖面积也比较简单，只需要先求出两个矩形的面积和之后再减去重合部分的面积就可以得到覆盖面积了。\n\n```c++\nint area(int A,int B,int C,int D) {\n    return (C-A)*(D-B);\n}\nint intersect(int A, int B, int C, int D, int E, int F, int G, int H) {\n    //求重合部分的面积\n    if (!check(A, B, C, D, E, F, G, H)) return 0;\n    return min(min(C-E,G-A),min(G-E,C-A)) * min(min(D-F,H-B),min(D-B,H-F));\n}\nint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n    int a1 = area(A, B, C, D);\n    int a2 = area(E, F, G, H);\n    //cout << a1 << \" \" << a2 << endl;\n    return a1- intersect(A, B, C, D, E, F, G, H) + a2;\n}\nbool check(int A, int B, int C, int D, int E, int F, int G, int H) {\n    //判断是否重合\n    return ( abs(A+C-E-G) <= (abs(A-C) + abs(G-E)) )&& (abs(B+D-F-H) <= (abs(D-B) + abs(H-F))); \n}\n```\n\n然后是`dicuss`中比较简洁的解法：\n\n```c++\nint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n    int left = max(A,E), right = max(min(C,G), left);\n    int bottom = max(B,F), top = max(min(D,H), bottom);\n    return (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);\n}\n```\n\n","source":"_posts/Rectangle-Area.md","raw":"---\ntitle: Rectangle-Area\ndate: 2018-01-17T12:35:45.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第86天。\n\n今天的题目是[Rectangle Area](https://leetcode.com/problems/rectangle-area/description/):\n\n> Find the total area covered by two rectilinear rectangles in a 2D plane.\n>\n> Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.\n![](https://leetcode.com/static/images/problemset/rectangle_area.png)\n> Assume that the total area is never beyond the maximum possible value of int.\n\n一开始以为是求两个矩形重合部分的面积，后来仔细看了一下才发现是求它们的覆盖面积，好在把重合部分面积求出来后，求他们覆盖面积也比较简单，只需要先求出两个矩形的面积和之后再减去重合部分的面积就可以得到覆盖面积了。\n\n```c++\nint area(int A,int B,int C,int D) {\n    return (C-A)*(D-B);\n}\nint intersect(int A, int B, int C, int D, int E, int F, int G, int H) {\n    //求重合部分的面积\n    if (!check(A, B, C, D, E, F, G, H)) return 0;\n    return min(min(C-E,G-A),min(G-E,C-A)) * min(min(D-F,H-B),min(D-B,H-F));\n}\nint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n    int a1 = area(A, B, C, D);\n    int a2 = area(E, F, G, H);\n    //cout << a1 << \" \" << a2 << endl;\n    return a1- intersect(A, B, C, D, E, F, G, H) + a2;\n}\nbool check(int A, int B, int C, int D, int E, int F, int G, int H) {\n    //判断是否重合\n    return ( abs(A+C-E-G) <= (abs(A-C) + abs(G-E)) )&& (abs(B+D-F-H) <= (abs(D-B) + abs(H-F))); \n}\n```\n\n然后是`dicuss`中比较简洁的解法：\n\n```c++\nint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n    int left = max(A,E), right = max(min(C,G), left);\n    int bottom = max(B,F), top = max(min(D,H), bottom);\n    return (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);\n}\n```\n\n","slug":"Rectangle-Area","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pf00c1qmcma7k6ht2k","content":"<p>第86天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/rectangle-area/description/\">Rectangle Area</a>:</p>\n<blockquote>\n<p>Find the total area covered by two rectilinear rectangles in a 2D plane.</p>\n<p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.<br><img src=\"https://leetcode.com/static/images/problemset/rectangle_area.png\"><br>Assume that the total area is never beyond the maximum possible value of int.</p>\n</blockquote>\n<p>一开始以为是求两个矩形重合部分的面积，后来仔细看了一下才发现是求它们的覆盖面积，好在把重合部分面积求出来后，求他们覆盖面积也比较简单，只需要先求出两个矩形的面积和之后再减去重合部分的面积就可以得到覆盖面积了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">area</span><span class=\"params\">(<span class=\"keyword\">int</span> A,<span class=\"keyword\">int</span> B,<span class=\"keyword\">int</span> C,<span class=\"keyword\">int</span> D)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (C-A)*(D-B);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">intersect</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> D, <span class=\"keyword\">int</span> E, <span class=\"keyword\">int</span> F, <span class=\"keyword\">int</span> G, <span class=\"keyword\">int</span> H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//求重合部分的面积</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!check(A, B, C, D, E, F, G, H)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(min(C-E,G-A),min(G-E,C-A)) * min(min(D-F,H-B),min(D-B,H-F));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">computeArea</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> D, <span class=\"keyword\">int</span> E, <span class=\"keyword\">int</span> F, <span class=\"keyword\">int</span> G, <span class=\"keyword\">int</span> H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a1 = area(A, B, C, D);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2 = area(E, F, G, H);</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2 &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a1- intersect(A, B, C, D, E, F, G, H) + a2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> D, <span class=\"keyword\">int</span> E, <span class=\"keyword\">int</span> F, <span class=\"keyword\">int</span> G, <span class=\"keyword\">int</span> H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否重合</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ( <span class=\"built_in\">abs</span>(A+C-E-G) &lt;= (<span class=\"built_in\">abs</span>(A-C) + <span class=\"built_in\">abs</span>(G-E)) )&amp;&amp; (<span class=\"built_in\">abs</span>(B+D-F-H) &lt;= (<span class=\"built_in\">abs</span>(D-B) + <span class=\"built_in\">abs</span>(H-F))); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中比较简洁的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">computeArea</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> D, <span class=\"keyword\">int</span> E, <span class=\"keyword\">int</span> F, <span class=\"keyword\">int</span> G, <span class=\"keyword\">int</span> H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = max(A,E), right = max(min(C,G), left);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bottom = max(B,F), top = max(min(D,H), bottom);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>第86天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/rectangle-area/description/\">Rectangle Area</a>:</p>\n<blockquote>\n<p>Find the total area covered by two rectilinear rectangles in a 2D plane.</p>\n<p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.<br><img src=\"https://leetcode.com/static/images/problemset/rectangle_area.png\"><br>Assume that the total area is never beyond the maximum possible value of int.</p>\n</blockquote>\n<p>一开始以为是求两个矩形重合部分的面积，后来仔细看了一下才发现是求它们的覆盖面积，好在把重合部分面积求出来后，求他们覆盖面积也比较简单，只需要先求出两个矩形的面积和之后再减去重合部分的面积就可以得到覆盖面积了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">area</span><span class=\"params\">(<span class=\"keyword\">int</span> A,<span class=\"keyword\">int</span> B,<span class=\"keyword\">int</span> C,<span class=\"keyword\">int</span> D)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (C-A)*(D-B);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">intersect</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> D, <span class=\"keyword\">int</span> E, <span class=\"keyword\">int</span> F, <span class=\"keyword\">int</span> G, <span class=\"keyword\">int</span> H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//求重合部分的面积</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!check(A, B, C, D, E, F, G, H)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(min(C-E,G-A),min(G-E,C-A)) * min(min(D-F,H-B),min(D-B,H-F));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">computeArea</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> D, <span class=\"keyword\">int</span> E, <span class=\"keyword\">int</span> F, <span class=\"keyword\">int</span> G, <span class=\"keyword\">int</span> H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a1 = area(A, B, C, D);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2 = area(E, F, G, H);</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2 &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a1- intersect(A, B, C, D, E, F, G, H) + a2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> D, <span class=\"keyword\">int</span> E, <span class=\"keyword\">int</span> F, <span class=\"keyword\">int</span> G, <span class=\"keyword\">int</span> H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否重合</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ( <span class=\"built_in\">abs</span>(A+C-E-G) &lt;= (<span class=\"built_in\">abs</span>(A-C) + <span class=\"built_in\">abs</span>(G-E)) )&amp;&amp; (<span class=\"built_in\">abs</span>(B+D-F-H) &lt;= (<span class=\"built_in\">abs</span>(D-B) + <span class=\"built_in\">abs</span>(H-F))); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中比较简洁的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">computeArea</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> D, <span class=\"keyword\">int</span> E, <span class=\"keyword\">int</span> F, <span class=\"keyword\">int</span> G, <span class=\"keyword\">int</span> H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = max(A,E), right = max(min(C,G), left);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bottom = max(B,F), top = max(min(D,H), bottom);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Redundant Connection","date":"2019-12-13T03:31:41.000Z","_content":"\n> 第37天。\n\n今天的题目是[Redundant Connection](https://leetcode.com/problems/redundant-connection/):\n\n这道题用并查集可以解决掉，具体思路如下：\n\n首先初始化一个并查集，然后遍历输入`edges`，使用并查集查找两个节点所在的集合，如果两个节点在同一个节点中，那么往图里面加入这条边就会出现环，即无法构成树，因此这条边就是我们要求的边；如果不在集合，那么就将这条边插入到图中（即合并两个集合）。具体实现如下：\n\n```c++\nint root(vector<int> &ids, int i) {\n    while(ids[i] != i) i = ids[i];\n    return i;\n}\nvector<int> findRedundantConnection(vector<vector<int>>& edges) {\n    if (edges.size() == 0) return vector<int>();\n    vector<int> ids(edges.size());\n    for(int i = 0;i < ids.size(); i++) ids[i] = i;\n    \n    for(auto &e: edges) {\n        int n1 = root(ids, e[0]-1), n2 = root(ids, e[1]-1);\n        if (n1 == n2) return e;\n        ids[n1] = n2;\n    }\n    return *edges.rbegin();\n}\n```\n","source":"_posts/Redundant-Connection.md","raw":"---\ntitle: Redundant Connection\ndate: 2019-12-13T11:31:41.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第37天。\n\n今天的题目是[Redundant Connection](https://leetcode.com/problems/redundant-connection/):\n\n这道题用并查集可以解决掉，具体思路如下：\n\n首先初始化一个并查集，然后遍历输入`edges`，使用并查集查找两个节点所在的集合，如果两个节点在同一个节点中，那么往图里面加入这条边就会出现环，即无法构成树，因此这条边就是我们要求的边；如果不在集合，那么就将这条边插入到图中（即合并两个集合）。具体实现如下：\n\n```c++\nint root(vector<int> &ids, int i) {\n    while(ids[i] != i) i = ids[i];\n    return i;\n}\nvector<int> findRedundantConnection(vector<vector<int>>& edges) {\n    if (edges.size() == 0) return vector<int>();\n    vector<int> ids(edges.size());\n    for(int i = 0;i < ids.size(); i++) ids[i] = i;\n    \n    for(auto &e: edges) {\n        int n1 = root(ids, e[0]-1), n2 = root(ids, e[1]-1);\n        if (n1 == n2) return e;\n        ids[n1] = n2;\n    }\n    return *edges.rbegin();\n}\n```\n","slug":"Redundant-Connection","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pg00c4qmcm3f8r4pz2","content":"<blockquote>\n<p>第37天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/redundant-connection/\">Redundant Connection</a>:</p>\n<p>这道题用并查集可以解决掉，具体思路如下：</p>\n<p>首先初始化一个并查集，然后遍历输入<code>edges</code>，使用并查集查找两个节点所在的集合，如果两个节点在同一个节点中，那么往图里面加入这条边就会出现环，即无法构成树，因此这条边就是我们要求的边；如果不在集合，那么就将这条边插入到图中（即合并两个集合）。具体实现如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;ids, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ids[i] != i) i = ids[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findRedundantConnection</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (edges.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ids</span><span class=\"params\">(edges.size())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; ids.size(); i++) ids[i] = i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;e: edges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n1 = root(ids, e[<span class=\"number\">0</span>]<span class=\"number\">-1</span>), n2 = root(ids, e[<span class=\"number\">1</span>]<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n1 == n2) <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        ids[n1] = n2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *edges.rbegin();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第37天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/redundant-connection/\">Redundant Connection</a>:</p>\n<p>这道题用并查集可以解决掉，具体思路如下：</p>\n<p>首先初始化一个并查集，然后遍历输入<code>edges</code>，使用并查集查找两个节点所在的集合，如果两个节点在同一个节点中，那么往图里面加入这条边就会出现环，即无法构成树，因此这条边就是我们要求的边；如果不在集合，那么就将这条边插入到图中（即合并两个集合）。具体实现如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;ids, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ids[i] != i) i = ids[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findRedundantConnection</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (edges.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ids</span><span class=\"params\">(edges.size())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; ids.size(); i++) ids[i] = i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;e: edges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n1 = root(ids, e[<span class=\"number\">0</span>]<span class=\"number\">-1</span>), n2 = root(ids, e[<span class=\"number\">1</span>]<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n1 == n2) <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        ids[n1] = n2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *edges.rbegin();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Remove-Duplicates-from-Sorted-Array","date":"2018-01-15T03:10:38.000Z","_content":"\n第84天。\n\nAll right,最终还是在期末考的时候断了。\n\n今天的题目是[Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/):\n\n> Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n>\n> Example:\n>\n> Given nums = [1,1,2],\n>\n> Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.\n\n\n明明是道水题，但是还是做了挺久的，而且效率也不高：\n\n```c++\nint removeDuplicates1(vector<int>& nums) {\n    int size = nums.size();\n    for(int i = size - 1;i >= 1;i--) {\n        if (nums[i] == nums[i-1]) {\n            swap(nums[i],nums[--size]);\n        }\n    }\n    sort(nums.begin(),nums.begin() + size);\n    return size;\n}\n```\n\n说他效率不高的原因就在于最后要做一次排序。\n\n然后是`dicuss`中给出的`O(n)`的解法：\n\n```c++\nint removeDuplicates(vector<int>& nums) {\n    if (nums.size() <= 1) return nums.size();\n    int end = 1;\n    for(int i = 1;i < nums.size();i++) {\n        if (nums[i] != nums[i-1]) nums[end++] = nums[i];\n    }\n    return end;\n}\n```\n","source":"_posts/Remove-Duplicates-from-Sorted-Array.md","raw":"---\ntitle: Remove-Duplicates-from-Sorted-Array\ndate: 2018-01-15T11:10:38.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第84天。\n\nAll right,最终还是在期末考的时候断了。\n\n今天的题目是[Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/):\n\n> Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n>\n> Example:\n>\n> Given nums = [1,1,2],\n>\n> Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.\n\n\n明明是道水题，但是还是做了挺久的，而且效率也不高：\n\n```c++\nint removeDuplicates1(vector<int>& nums) {\n    int size = nums.size();\n    for(int i = size - 1;i >= 1;i--) {\n        if (nums[i] == nums[i-1]) {\n            swap(nums[i],nums[--size]);\n        }\n    }\n    sort(nums.begin(),nums.begin() + size);\n    return size;\n}\n```\n\n说他效率不高的原因就在于最后要做一次排序。\n\n然后是`dicuss`中给出的`O(n)`的解法：\n\n```c++\nint removeDuplicates(vector<int>& nums) {\n    if (nums.size() <= 1) return nums.size();\n    int end = 1;\n    for(int i = 1;i < nums.size();i++) {\n        if (nums[i] != nums[i-1]) nums[end++] = nums[i];\n    }\n    return end;\n}\n```\n","slug":"Remove-Duplicates-from-Sorted-Array","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pg00c7qmcm894xciwe","content":"<p>第84天。</p>\n<p>All right,最终还是在期末考的时候断了。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/\">Remove Duplicates from Sorted Array</a>:</p>\n<blockquote>\n<p>Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>\n<p>Example:</p>\n<p>Given nums = [1,1,2],</p>\n<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>\n</blockquote>\n<p>明明是道水题，但是还是做了挺久的，而且效率也不高：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">1</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] == nums[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">            swap(nums[i],nums[--size]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(nums.begin(),nums.begin() + size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说他效率不高的原因就在于最后要做一次排序。</p>\n<p>然后是<code>dicuss</code>中给出的<code>O(n)</code>的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != nums[i<span class=\"number\">-1</span>]) nums[end++] = nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第84天。</p>\n<p>All right,最终还是在期末考的时候断了。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/\">Remove Duplicates from Sorted Array</a>:</p>\n<blockquote>\n<p>Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>\n<p>Example:</p>\n<p>Given nums = [1,1,2],</p>\n<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>\n</blockquote>\n<p>明明是道水题，但是还是做了挺久的，而且效率也不高：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">1</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] == nums[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">            swap(nums[i],nums[--size]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(nums.begin(),nums.begin() + size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说他效率不高的原因就在于最后要做一次排序。</p>\n<p>然后是<code>dicuss</code>中给出的<code>O(n)</code>的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != nums[i<span class=\"number\">-1</span>]) nums[end++] = nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Remove-Element","date":"2017-12-17T02:54:14.000Z","_content":"\n第81天。\n\n今天的题目是[Remove Element](https://leetcode.com/problems/remove-element/description/):\n\n> Given an array and a value, remove all instances of that value in-place and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n>\n> The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n>\n> Example:\n>\n> Given nums = [3,2,2,3], val = 3,\n>\n> Your function should return length = 2, with the first two elements of nums being 2.\n\n简单的我们可以遍历数组，然后找到和`val`相同的元素，然后删除，但是这样对于多个相同的元素效率不高，所以我们先不删除元素，而是把他移动到最后面去，知道遍历完才删除。\n\n```c++\nint removeElement(vector<int>& nums, int val) {\n    int last = nums.size();\n    for(int i = 0;i < last;i++) {\n        if (nums[i] == val) swap(nums[--last],nums[i--]);\n    }\n    nums.erase(nums.begin() + last,nums.end());\n    return nums.size();\n}\n```\n\n`dicuss`中另一个方法也很精妙：\n\n```c\nint removeElement(int A[], int n, int elem) {\n    int begin=0;\n    for(int i=0;i<n;i++) if(A[i]!=elem) A[begin++]=A[i];\n    return begin;\n}\n```\n","source":"_posts/Remove-Element.md","raw":"---\ntitle: Remove-Element\ndate: 2017-12-17T10:54:14.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第81天。\n\n今天的题目是[Remove Element](https://leetcode.com/problems/remove-element/description/):\n\n> Given an array and a value, remove all instances of that value in-place and return the new length.\n>\n> Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n>\n> The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n>\n> Example:\n>\n> Given nums = [3,2,2,3], val = 3,\n>\n> Your function should return length = 2, with the first two elements of nums being 2.\n\n简单的我们可以遍历数组，然后找到和`val`相同的元素，然后删除，但是这样对于多个相同的元素效率不高，所以我们先不删除元素，而是把他移动到最后面去，知道遍历完才删除。\n\n```c++\nint removeElement(vector<int>& nums, int val) {\n    int last = nums.size();\n    for(int i = 0;i < last;i++) {\n        if (nums[i] == val) swap(nums[--last],nums[i--]);\n    }\n    nums.erase(nums.begin() + last,nums.end());\n    return nums.size();\n}\n```\n\n`dicuss`中另一个方法也很精妙：\n\n```c\nint removeElement(int A[], int n, int elem) {\n    int begin=0;\n    for(int i=0;i<n;i++) if(A[i]!=elem) A[begin++]=A[i];\n    return begin;\n}\n```\n","slug":"Remove-Element","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ph00caqmcmbztx47s1","content":"<p>第81天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/remove-element/description/\">Remove Element</a>:</p>\n<blockquote>\n<p>Given an array and a value, remove all instances of that value in-place and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>\n<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>\n<p>Example:</p>\n<p>Given nums = [3,2,2,3], val = 3,</p>\n<p>Your function should return length = 2, with the first two elements of nums being 2.</p>\n</blockquote>\n<p>简单的我们可以遍历数组，然后找到和<code>val</code>相同的元素，然后删除，但是这样对于多个相同的元素效率不高，所以我们先不删除元素，而是把他移动到最后面去，知道遍历完才删除。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; last;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] == val) swap(nums[--last],nums[i--]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums.erase(nums.begin() + last,nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中另一个方法也很精妙：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> elem)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) <span class=\"keyword\">if</span>(A[i]!=elem) A[begin++]=A[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> begin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第81天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/remove-element/description/\">Remove Element</a>:</p>\n<blockquote>\n<p>Given an array and a value, remove all instances of that value in-place and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>\n<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>\n<p>Example:</p>\n<p>Given nums = [3,2,2,3], val = 3,</p>\n<p>Your function should return length = 2, with the first two elements of nums being 2.</p>\n</blockquote>\n<p>简单的我们可以遍历数组，然后找到和<code>val</code>相同的元素，然后删除，但是这样对于多个相同的元素效率不高，所以我们先不删除元素，而是把他移动到最后面去，知道遍历完才删除。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; last;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] == val) swap(nums[--last],nums[i--]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums.erase(nums.begin() + last,nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中另一个方法也很精妙：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> elem)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) <span class=\"keyword\">if</span>(A[i]!=elem) A[begin++]=A[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> begin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Remove Nth Node From End of List","date":"2017-10-07T05:57:00.000Z","_content":"\n打卡，第14天\n\n今天的题目是[Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/),一开始以为是道很简单的题目，后来看`dicuss`时才发现是自己没看清题目。\n\n> Given a linked list, remove the nth node from the end of list and return its head.\n>\n> For example,\n> Given linked list: 1->2->3->4->5, and n = 2.\n>\n> After removing the second node from the end, the linked list becomes 1->2->3->5. \n> Note:\n> Given n will always be valid.\n> Try to do this in one pass.\n\n一开始没看到`Try to do this in one pass.`,然后就用两遍遍历方法去做了:\n\n```c++\nint getRightN(ListNode *head,int n) {\n    ListNode *p = head;\n    int size = 0;\n    while(p != nullptr) {\n        p = p->next;\n        size++;\n    }\n    return size - n;\n}\nListNode* removeNthFromEnd(ListNode* head, int n) {\n    ListNode h(0);\n    h.next = head;\n    ListNode *p = &h;\n\n    int k = getRightN(p,n);\n    while(--k)\n        p=p->next;\n\n    head = p->next;\n    p->next = head->next;\n    delete head;\n    return h.next;\n}\n```\n\n上面这个方法太简单了，还是看看在`dicuss`中的方法吧：\n\n```c++\nListNode *removeNthFromEnd(ListNode *head, int n) \n{\n    if (!head)\n        return nullptr;\n\n    ListNode new_head(-1);\n    new_head.next = head;\n\n    ListNode *slow = &new_head, *fast = &new_head;\n\n    for (int i = 0; i < n; i++)\n        fast = fast->next;\n\n    while (fast->next)\n    {\n        fast = fast->next;\n        slow = slow->next;\n    }\n\n    ListNode *to_de_deleted = slow->next;\n    slow->next = slow->next->next;\n\n    delete to_be_deleted;\n\n    return new_head.next;\n}\n```\n\n这个看起来会比较简单，想法就是利用快慢指针去做，先让`fast`指针先走`n`步，然后在`fast`指针和`slow`指针一起移动，这样`fast`和`slow`始终保持着n个节点的距离，当`fast`为最后一个节点时，`slow`就指向倒数第n+1个节点，这时就可以把倒数第n个节点删掉了。\n\n有一个更简洁的版本，不过有点难懂就是了：\n\n```c++\nListNode* removeNthFromEnd(ListNode* head, int n)\n{\n    ListNode** t1 = &head, *t2 = head;\n    for(int i = 1; i < n; ++i)\n    {\n        t2 = t2->next;\n    }\n    while(t2->next != NULL)\n    {\n        t1 = &((*t1)->next);\n        t2 = t2->next;\n    }\n    *t1 = (*t1)->next;\n    return head;\n}\n```\n\n这个和上一个的思路其实是完全一样的，只是实现方法思路不一样就是，这里的`t1`是指向某个节点(包括一开始时虚拟的头结点）的`next`指针的指针。\n","source":"_posts/Remove-Nth-Node-From-End-of-List.md","raw":"---\ntitle: Remove Nth Node From End of List\ndate: 2017-10-07T13:57:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - 链表\n  - LeetCode\n---\n\n打卡，第14天\n\n今天的题目是[Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/),一开始以为是道很简单的题目，后来看`dicuss`时才发现是自己没看清题目。\n\n> Given a linked list, remove the nth node from the end of list and return its head.\n>\n> For example,\n> Given linked list: 1->2->3->4->5, and n = 2.\n>\n> After removing the second node from the end, the linked list becomes 1->2->3->5. \n> Note:\n> Given n will always be valid.\n> Try to do this in one pass.\n\n一开始没看到`Try to do this in one pass.`,然后就用两遍遍历方法去做了:\n\n```c++\nint getRightN(ListNode *head,int n) {\n    ListNode *p = head;\n    int size = 0;\n    while(p != nullptr) {\n        p = p->next;\n        size++;\n    }\n    return size - n;\n}\nListNode* removeNthFromEnd(ListNode* head, int n) {\n    ListNode h(0);\n    h.next = head;\n    ListNode *p = &h;\n\n    int k = getRightN(p,n);\n    while(--k)\n        p=p->next;\n\n    head = p->next;\n    p->next = head->next;\n    delete head;\n    return h.next;\n}\n```\n\n上面这个方法太简单了，还是看看在`dicuss`中的方法吧：\n\n```c++\nListNode *removeNthFromEnd(ListNode *head, int n) \n{\n    if (!head)\n        return nullptr;\n\n    ListNode new_head(-1);\n    new_head.next = head;\n\n    ListNode *slow = &new_head, *fast = &new_head;\n\n    for (int i = 0; i < n; i++)\n        fast = fast->next;\n\n    while (fast->next)\n    {\n        fast = fast->next;\n        slow = slow->next;\n    }\n\n    ListNode *to_de_deleted = slow->next;\n    slow->next = slow->next->next;\n\n    delete to_be_deleted;\n\n    return new_head.next;\n}\n```\n\n这个看起来会比较简单，想法就是利用快慢指针去做，先让`fast`指针先走`n`步，然后在`fast`指针和`slow`指针一起移动，这样`fast`和`slow`始终保持着n个节点的距离，当`fast`为最后一个节点时，`slow`就指向倒数第n+1个节点，这时就可以把倒数第n个节点删掉了。\n\n有一个更简洁的版本，不过有点难懂就是了：\n\n```c++\nListNode* removeNthFromEnd(ListNode* head, int n)\n{\n    ListNode** t1 = &head, *t2 = head;\n    for(int i = 1; i < n; ++i)\n    {\n        t2 = t2->next;\n    }\n    while(t2->next != NULL)\n    {\n        t1 = &((*t1)->next);\n        t2 = t2->next;\n    }\n    *t1 = (*t1)->next;\n    return head;\n}\n```\n\n这个和上一个的思路其实是完全一样的，只是实现方法思路不一样就是，这里的`t1`是指向某个节点(包括一开始时虚拟的头结点）的`next`指针的指针。\n","slug":"Remove-Nth-Node-From-End-of-List","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ph00cdqmcm4ncyeqy2","content":"<p>打卡，第14天</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/\">Remove Nth Node From End of List</a>,一开始以为是道很简单的题目，后来看<code>dicuss</code>时才发现是自己没看清题目。</p>\n<blockquote>\n<p>Given a linked list, remove the nth node from the end of list and return its head.</p>\n<p>For example,<br>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>\n<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p>\n</blockquote>\n<p>一开始没看到<code>Try to do this in one pass.</code>,然后就用两遍遍历方法去做了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRightN</span><span class=\"params\">(ListNode *head,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    ListNode *p = head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size - n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">h</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    h.next = head;</span><br><span class=\"line\">    ListNode *p = &amp;h;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = getRightN(p,n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(--k)</span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    head = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个方法太简单了，还是看看在<code>dicuss</code>中的方法吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode *head, <span class=\"keyword\">int</span> n)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">new_head</span><span class=\"params\">(<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    new_head.next = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *slow = &amp;new_head, *fast = &amp;new_head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast-&gt;next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *to_de_deleted = slow-&gt;next;</span><br><span class=\"line\">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> to_be_deleted;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_head.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个看起来会比较简单，想法就是利用快慢指针去做，先让<code>fast</code>指针先走<code>n</code>步，然后在<code>fast</code>指针和<code>slow</code>指针一起移动，这样<code>fast</code>和<code>slow</code>始终保持着n个节点的距离，当<code>fast</code>为最后一个节点时，<code>slow</code>就指向倒数第n+1个节点，这时就可以把倒数第n个节点删掉了。</p>\n<p>有一个更简洁的版本，不过有点难懂就是了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ListNode** t1 = &amp;head, *t2 = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t2 = t2-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t2-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t1 = &amp;((*t1)-&gt;next);</span><br><span class=\"line\">        t2 = t2-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *t1 = (*t1)-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个和上一个的思路其实是完全一样的，只是实现方法思路不一样就是，这里的<code>t1</code>是指向某个节点(包括一开始时虚拟的头结点）的<code>next</code>指针的指针。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第14天</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/\">Remove Nth Node From End of List</a>,一开始以为是道很简单的题目，后来看<code>dicuss</code>时才发现是自己没看清题目。</p>\n<blockquote>\n<p>Given a linked list, remove the nth node from the end of list and return its head.</p>\n<p>For example,<br>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>\n<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p>\n</blockquote>\n<p>一开始没看到<code>Try to do this in one pass.</code>,然后就用两遍遍历方法去做了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRightN</span><span class=\"params\">(ListNode *head,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    ListNode *p = head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size - n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">h</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    h.next = head;</span><br><span class=\"line\">    ListNode *p = &amp;h;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = getRightN(p,n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(--k)</span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    head = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个方法太简单了，还是看看在<code>dicuss</code>中的方法吧：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode *head, <span class=\"keyword\">int</span> n)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">new_head</span><span class=\"params\">(<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    new_head.next = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *slow = &amp;new_head, *fast = &amp;new_head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast-&gt;next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *to_de_deleted = slow-&gt;next;</span><br><span class=\"line\">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> to_be_deleted;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_head.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个看起来会比较简单，想法就是利用快慢指针去做，先让<code>fast</code>指针先走<code>n</code>步，然后在<code>fast</code>指针和<code>slow</code>指针一起移动，这样<code>fast</code>和<code>slow</code>始终保持着n个节点的距离，当<code>fast</code>为最后一个节点时，<code>slow</code>就指向倒数第n+1个节点，这时就可以把倒数第n个节点删掉了。</p>\n<p>有一个更简洁的版本，不过有点难懂就是了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ListNode** t1 = &amp;head, *t2 = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t2 = t2-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t2-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t1 = &amp;((*t1)-&gt;next);</span><br><span class=\"line\">        t2 = t2-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *t1 = (*t1)-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个和上一个的思路其实是完全一样的，只是实现方法思路不一样就是，这里的<code>t1</code>是指向某个节点(包括一开始时虚拟的头结点）的<code>next</code>指针的指针。</p>\n"},{"title":"Repeated-Substring-Pattern","date":"2018-01-22T02:54:49.000Z","_content":"\n第91天。\n\n今天的题目是[Repeated Substring Pattern](https://leetcode.com/problems/repeated-substring-pattern/description/):\n\n> Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\n> Example 1:\n> Input: \"abab\"\n>\n> Output: True\n>\n> Explanation: It's the substring \"ab\" twice.\n> Example 2:\n> Input: \"aba\"\n>\n> Output: False\n> Example 3:\n> Input: \"abcabcabcabc\"\n>\n> Output: True\n>\n> Explanation: It's the substring \"abc\" four times. (And the substring \"abcabc\" twice.)\n\n一开始没看清，以为只有重复一次的情况，后来发现还可以重复多次，这样的话就不得不多扫描几遍了,有点希尔排序的解法：\n\n```c++\nbool repeatedSubstringPattern1(string s) {\n    for(int i = 1;i < s.size();i++)\n        if (repeatedSubstringPattern(s,i)) return true;\n    return false;\n}\nbool repeatedSubstringPattern(string &s,int p) {\n    // cout << p << endl;\n    int size = s.size();\n    if (size % p) return false;\n    for(int i = 0;i < p;i++) {\n        for(int j = i+p;j < size;j += p) {\n            //cout << s[i] << \" \" << s[j] << endl;\n            if (s[i] != s[j]) return false;\n        }\n    }\n    return true;\n}\n```\n\n然后是在`dicuss`中的利用`kmp`的解法，但我还是没看懂为什么可以这样做。\n\n```c++\nbool repeatedSubstringPattern(string str) {\n    int i = 1, j = 0, n = str.size();\n    vector<int> dp(n+1,0);\n    while( i < str.size() ){\n        if( str[i] == str[j] ) dp[++i]=++j;\n        else if( j == 0 ) i++;\n        else j = dp[j];\n    }\n    return dp[n]&&dp[n]%(n-dp[n])==0;\n}\n```\n","source":"_posts/Repeated-Substring-Pattern.md","raw":"---\ntitle: Repeated-Substring-Pattern\ndate: 2018-01-22T10:54:49.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第91天。\n\n今天的题目是[Repeated Substring Pattern](https://leetcode.com/problems/repeated-substring-pattern/description/):\n\n> Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\n> Example 1:\n> Input: \"abab\"\n>\n> Output: True\n>\n> Explanation: It's the substring \"ab\" twice.\n> Example 2:\n> Input: \"aba\"\n>\n> Output: False\n> Example 3:\n> Input: \"abcabcabcabc\"\n>\n> Output: True\n>\n> Explanation: It's the substring \"abc\" four times. (And the substring \"abcabc\" twice.)\n\n一开始没看清，以为只有重复一次的情况，后来发现还可以重复多次，这样的话就不得不多扫描几遍了,有点希尔排序的解法：\n\n```c++\nbool repeatedSubstringPattern1(string s) {\n    for(int i = 1;i < s.size();i++)\n        if (repeatedSubstringPattern(s,i)) return true;\n    return false;\n}\nbool repeatedSubstringPattern(string &s,int p) {\n    // cout << p << endl;\n    int size = s.size();\n    if (size % p) return false;\n    for(int i = 0;i < p;i++) {\n        for(int j = i+p;j < size;j += p) {\n            //cout << s[i] << \" \" << s[j] << endl;\n            if (s[i] != s[j]) return false;\n        }\n    }\n    return true;\n}\n```\n\n然后是在`dicuss`中的利用`kmp`的解法，但我还是没看懂为什么可以这样做。\n\n```c++\nbool repeatedSubstringPattern(string str) {\n    int i = 1, j = 0, n = str.size();\n    vector<int> dp(n+1,0);\n    while( i < str.size() ){\n        if( str[i] == str[j] ) dp[++i]=++j;\n        else if( j == 0 ) i++;\n        else j = dp[j];\n    }\n    return dp[n]&&dp[n]%(n-dp[n])==0;\n}\n```\n","slug":"Repeated-Substring-Pattern","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pi00cgqmcm2xftb1jm","content":"<p>第91天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/repeated-substring-pattern/description/\">Repeated Substring Pattern</a>:</p>\n<blockquote>\n<p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.<br>Example 1:<br>Input: “abab”</p>\n<p>Output: True</p>\n<p>Explanation: It’s the substring “ab” twice.<br>Example 2:<br>Input: “aba”</p>\n<p>Output: False<br>Example 3:<br>Input: “abcabcabcabc”</p>\n<p>Output: True</p>\n<p>Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.)</p>\n</blockquote>\n<p>一开始没看清，以为只有重复一次的情况，后来发现还可以重复多次，这样的话就不得不多扫描几遍了,有点希尔排序的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">repeatedSubstringPattern1</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; s.size();i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (repeatedSubstringPattern(s,i)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">repeatedSubstringPattern</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s,<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; p &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = s.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size % p) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; p;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+p;j &lt; size;j += p) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; s[i] &lt;&lt; &quot; &quot; &lt;&lt; s[j] &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] != s[j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中的利用<code>kmp</code>的解法，但我还是没看懂为什么可以这样做。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">repeatedSubstringPattern</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>, n = str.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( i &lt; str.size() )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( str[i] == str[j] ) dp[++i]=++j;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( j == <span class=\"number\">0</span> ) i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> j = dp[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n]&amp;&amp;dp[n]%(n-dp[n])==<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第91天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/repeated-substring-pattern/description/\">Repeated Substring Pattern</a>:</p>\n<blockquote>\n<p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.<br>Example 1:<br>Input: “abab”</p>\n<p>Output: True</p>\n<p>Explanation: It’s the substring “ab” twice.<br>Example 2:<br>Input: “aba”</p>\n<p>Output: False<br>Example 3:<br>Input: “abcabcabcabc”</p>\n<p>Output: True</p>\n<p>Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.)</p>\n</blockquote>\n<p>一开始没看清，以为只有重复一次的情况，后来发现还可以重复多次，这样的话就不得不多扫描几遍了,有点希尔排序的解法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">repeatedSubstringPattern1</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; s.size();i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (repeatedSubstringPattern(s,i)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">repeatedSubstringPattern</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;s,<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; p &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = s.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size % p) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; p;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+p;j &lt; size;j += p) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; s[i] &lt;&lt; &quot; &quot; &lt;&lt; s[j] &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] != s[j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中的利用<code>kmp</code>的解法，但我还是没看懂为什么可以这样做。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">repeatedSubstringPattern</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>, n = str.size();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n+<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( i &lt; str.size() )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( str[i] == str[j] ) dp[++i]=++j;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( j == <span class=\"number\">0</span> ) i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> j = dp[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n]&amp;&amp;dp[n]%(n-dp[n])==<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Replace Words","date":"2019-11-12T05:35:18.000Z","_content":"\n> 第8天。\n\n今天的题目是[ Replace Words ]( https://leetcode.com/problems/replace-words/ )\n\n---\n\nIn English, we have a concept called `root`, which can be followed by some other words to form another longer word - let's call this word `successor`. For example, the root `an`, followed by `other`, which can form another word `another`.\n\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the `successor` in the sentence with the `root` forming it. If a `successor` has many `roots` can form it, replace it with the root with the shortest length.\n\nYou need to output the sentence after the replacement.\n\n**Example 1:**\n\n```\nInput: dict = [\"cat\", \"bat\", \"rat\"]\nsentence = \"the cattle was rattled by the battery\"\nOutput: \"the cat was rat by the bat\"\n```\n\n \n\n**Note:**\n\n1. The input will only have lower-case letters.\n2. 1 <= dict words number <= 1000\n3. 1 <= sentence words number <= 1000\n4. 1 <= root length <= 100\n5. 1 <= sentence words length <= 1000\n\n---\n\n看到题目给出了一个字符串字典，然后要根据单词中是否包含字典中的前缀来生成结果，想都不用想，就是用前缀树/字典树来做，关于前缀树的介绍可以看 https://oi-wiki.org/string/trie/ 。\n\n首先先根据字典建立字典树，然后根据空格分隔单词，然后检查是否有前缀，如果没有前缀就将原始的单词插入结果中，如果有，则将前缀插入。由于在进行检查时，每次从一个节点跳到其子节点时都会检查者是否是一个在词典出现的前缀，所以所求的前缀一定是最短的。\n\n具体代码如下：\n\n```c++\nstruct Node {\n    struct Node* childs[26];\n    bool isLeaf;\n    Node():isLeaf(false){\n        for(int i = 0;i < 26;i++) childs[i] = nullptr;\n    }\n    ~Node() {\n        for(int i = 0;i < 26;i++) if (childs[i]) delete childs[i];\n    }\n\n};\n\nvoid insert(struct Node *root, string &s) {\n    for(int i = 0, size = s.size(); i < size; i++) {\n        int index = s[i] - 'a';\n        if (root->childs[index] == nullptr) root->childs[index] = new Node;\n        root = root->childs[index];\n    }\n    root->isLeaf = true;\n}\nint getMinLen(struct Node *root, string &sentence, int beg, int end) {\n    for(int i = beg;i < end; i++) {\n        int index = sentence[i] - 'a';\n        if (root->childs[index] == nullptr) return end;\n        root = root->childs[index];\n        if (root->isLeaf) return i + 1;\n    }\n    return end;\n}\nstring replaceWords(vector<string>& dict, string sentence) {\n    // sort(dict.begin(), dict.end());\n\n    // build dict tree\n    struct Node *root = new Node();\n    for(int i = 0;i < dict.size(); ++i) {\n        insert(root, dict[i]);\n    }\n\n    struct Node * p = root;\n\n    // parse sentence\n    string res, word;\n    int beg = 0;\n    for(int i = 0, size = sentence.size(); i < size; i++) {\n        if (sentence[i] == ' ') {\n            int end = getMinLen(root, sentence, beg, i);\n            for(int j = beg;j < end; j++) res.push_back(sentence[j]);\n            res.push_back(' ');\n            beg = i + 1;\n            word = \"\";\n\n        }\n    }\n\n    int end = getMinLen(root, sentence, beg, sentence.size());\n    for(int j = beg;j < end; j++) res.push_back(sentence[j]);\n    delete root;\n    return res;\n}\n```\n\n\n","source":"_posts/Replace-Words.md","raw":"---\ntitle: Replace Words\ndate: 2019-11-12T13:35:18.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第8天。\n\n今天的题目是[ Replace Words ]( https://leetcode.com/problems/replace-words/ )\n\n---\n\nIn English, we have a concept called `root`, which can be followed by some other words to form another longer word - let's call this word `successor`. For example, the root `an`, followed by `other`, which can form another word `another`.\n\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the `successor` in the sentence with the `root` forming it. If a `successor` has many `roots` can form it, replace it with the root with the shortest length.\n\nYou need to output the sentence after the replacement.\n\n**Example 1:**\n\n```\nInput: dict = [\"cat\", \"bat\", \"rat\"]\nsentence = \"the cattle was rattled by the battery\"\nOutput: \"the cat was rat by the bat\"\n```\n\n \n\n**Note:**\n\n1. The input will only have lower-case letters.\n2. 1 <= dict words number <= 1000\n3. 1 <= sentence words number <= 1000\n4. 1 <= root length <= 100\n5. 1 <= sentence words length <= 1000\n\n---\n\n看到题目给出了一个字符串字典，然后要根据单词中是否包含字典中的前缀来生成结果，想都不用想，就是用前缀树/字典树来做，关于前缀树的介绍可以看 https://oi-wiki.org/string/trie/ 。\n\n首先先根据字典建立字典树，然后根据空格分隔单词，然后检查是否有前缀，如果没有前缀就将原始的单词插入结果中，如果有，则将前缀插入。由于在进行检查时，每次从一个节点跳到其子节点时都会检查者是否是一个在词典出现的前缀，所以所求的前缀一定是最短的。\n\n具体代码如下：\n\n```c++\nstruct Node {\n    struct Node* childs[26];\n    bool isLeaf;\n    Node():isLeaf(false){\n        for(int i = 0;i < 26;i++) childs[i] = nullptr;\n    }\n    ~Node() {\n        for(int i = 0;i < 26;i++) if (childs[i]) delete childs[i];\n    }\n\n};\n\nvoid insert(struct Node *root, string &s) {\n    for(int i = 0, size = s.size(); i < size; i++) {\n        int index = s[i] - 'a';\n        if (root->childs[index] == nullptr) root->childs[index] = new Node;\n        root = root->childs[index];\n    }\n    root->isLeaf = true;\n}\nint getMinLen(struct Node *root, string &sentence, int beg, int end) {\n    for(int i = beg;i < end; i++) {\n        int index = sentence[i] - 'a';\n        if (root->childs[index] == nullptr) return end;\n        root = root->childs[index];\n        if (root->isLeaf) return i + 1;\n    }\n    return end;\n}\nstring replaceWords(vector<string>& dict, string sentence) {\n    // sort(dict.begin(), dict.end());\n\n    // build dict tree\n    struct Node *root = new Node();\n    for(int i = 0;i < dict.size(); ++i) {\n        insert(root, dict[i]);\n    }\n\n    struct Node * p = root;\n\n    // parse sentence\n    string res, word;\n    int beg = 0;\n    for(int i = 0, size = sentence.size(); i < size; i++) {\n        if (sentence[i] == ' ') {\n            int end = getMinLen(root, sentence, beg, i);\n            for(int j = beg;j < end; j++) res.push_back(sentence[j]);\n            res.push_back(' ');\n            beg = i + 1;\n            word = \"\";\n\n        }\n    }\n\n    int end = getMinLen(root, sentence, beg, sentence.size());\n    for(int j = beg;j < end; j++) res.push_back(sentence[j]);\n    delete root;\n    return res;\n}\n```\n\n\n","slug":"Replace-Words","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pj00cjqmcmbwec5qzn","content":"<blockquote>\n<p>第8天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/replace-words/\"> Replace Words </a></p>\n<hr>\n<p>In English, we have a concept called <code>root</code>, which can be followed by some other words to form another longer word - let’s call this word <code>successor</code>. For example, the root <code>an</code>, followed by <code>other</code>, which can form another word <code>another</code>.</p>\n<p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the <code>successor</code> in the sentence with the <code>root</code> forming it. If a <code>successor</code> has many <code>roots</code> can form it, replace it with the root with the shortest length.</p>\n<p>You need to output the sentence after the replacement.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: dict &#x3D; [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]</span><br><span class=\"line\">sentence &#x3D; &quot;the cattle was rattled by the battery&quot;</span><br><span class=\"line\">Output: &quot;the cat was rat by the bat&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li>The input will only have lower-case letters.</li>\n<li>1 &lt;= dict words number &lt;= 1000</li>\n<li>1 &lt;= sentence words number &lt;= 1000</li>\n<li>1 &lt;= root length &lt;= 100</li>\n<li>1 &lt;= sentence words length &lt;= 1000</li>\n</ol>\n<hr>\n<p>看到题目给出了一个字符串字典，然后要根据单词中是否包含字典中的前缀来生成结果，想都不用想，就是用前缀树/字典树来做，关于前缀树的介绍可以看 <a href=\"https://oi-wiki.org/string/trie/\">https://oi-wiki.org/string/trie/</a> 。</p>\n<p>首先先根据字典建立字典树，然后根据空格分隔单词，然后检查是否有前缀，如果没有前缀就将原始的单词插入结果中，如果有，则将前缀插入。由于在进行检查时，每次从一个节点跳到其子节点时都会检查者是否是一个在词典出现的前缀，所以所求的前缀一定是最短的。</p>\n<p>具体代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>* <span class=\"title\">childs</span>[26];</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isLeaf;</span><br><span class=\"line\">    Node():isLeaf(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">26</span>;i++) childs[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Node() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (childs[i]) <span class=\"keyword\">delete</span> childs[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(struct Node *root, <span class=\"built_in\">string</span> &amp;s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = s.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;childs[index] == <span class=\"literal\">nullptr</span>) root-&gt;childs[index] = <span class=\"keyword\">new</span> Node;</span><br><span class=\"line\">        root = root-&gt;childs[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root-&gt;isLeaf = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMinLen</span><span class=\"params\">(struct Node *root, <span class=\"built_in\">string</span> &amp;sentence, <span class=\"keyword\">int</span> beg, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg;i &lt; end; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = sentence[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;childs[index] == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">        root = root-&gt;childs[index];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;isLeaf) <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">replaceWords</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; dict, <span class=\"built_in\">string</span> sentence)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// sort(dict.begin(), dict.end());</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// build dict tree</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">root</span> =</span> <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; dict.size(); ++i) &#123;</span><br><span class=\"line\">        insert(root, dict[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> * <span class=\"title\">p</span> =</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// parse sentence</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> res, word;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = sentence.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sentence[i] == <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> end = getMinLen(root, sentence, beg, i);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = beg;j &lt; end; j++) res.push_back(sentence[j]);</span><br><span class=\"line\">            res.push_back(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">            beg = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            word = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = getMinLen(root, sentence, beg, sentence.size());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = beg;j &lt; end; j++) res.push_back(sentence[j]);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第8天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/replace-words/\"> Replace Words </a></p>\n<hr>\n<p>In English, we have a concept called <code>root</code>, which can be followed by some other words to form another longer word - let’s call this word <code>successor</code>. For example, the root <code>an</code>, followed by <code>other</code>, which can form another word <code>another</code>.</p>\n<p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the <code>successor</code> in the sentence with the <code>root</code> forming it. If a <code>successor</code> has many <code>roots</code> can form it, replace it with the root with the shortest length.</p>\n<p>You need to output the sentence after the replacement.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: dict &#x3D; [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]</span><br><span class=\"line\">sentence &#x3D; &quot;the cattle was rattled by the battery&quot;</span><br><span class=\"line\">Output: &quot;the cat was rat by the bat&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note:</strong></p>\n<ol>\n<li>The input will only have lower-case letters.</li>\n<li>1 &lt;= dict words number &lt;= 1000</li>\n<li>1 &lt;= sentence words number &lt;= 1000</li>\n<li>1 &lt;= root length &lt;= 100</li>\n<li>1 &lt;= sentence words length &lt;= 1000</li>\n</ol>\n<hr>\n<p>看到题目给出了一个字符串字典，然后要根据单词中是否包含字典中的前缀来生成结果，想都不用想，就是用前缀树/字典树来做，关于前缀树的介绍可以看 <a href=\"https://oi-wiki.org/string/trie/\">https://oi-wiki.org/string/trie/</a> 。</p>\n<p>首先先根据字典建立字典树，然后根据空格分隔单词，然后检查是否有前缀，如果没有前缀就将原始的单词插入结果中，如果有，则将前缀插入。由于在进行检查时，每次从一个节点跳到其子节点时都会检查者是否是一个在词典出现的前缀，所以所求的前缀一定是最短的。</p>\n<p>具体代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>* <span class=\"title\">childs</span>[26];</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isLeaf;</span><br><span class=\"line\">    Node():isLeaf(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">26</span>;i++) childs[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Node() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (childs[i]) <span class=\"keyword\">delete</span> childs[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(struct Node *root, <span class=\"built_in\">string</span> &amp;s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = s.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;childs[index] == <span class=\"literal\">nullptr</span>) root-&gt;childs[index] = <span class=\"keyword\">new</span> Node;</span><br><span class=\"line\">        root = root-&gt;childs[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root-&gt;isLeaf = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMinLen</span><span class=\"params\">(struct Node *root, <span class=\"built_in\">string</span> &amp;sentence, <span class=\"keyword\">int</span> beg, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg;i &lt; end; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = sentence[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;childs[index] == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">        root = root-&gt;childs[index];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;isLeaf) <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">replaceWords</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; dict, <span class=\"built_in\">string</span> sentence)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// sort(dict.begin(), dict.end());</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// build dict tree</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">root</span> =</span> <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; dict.size(); ++i) &#123;</span><br><span class=\"line\">        insert(root, dict[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> * <span class=\"title\">p</span> =</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// parse sentence</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> res, word;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = sentence.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sentence[i] == <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> end = getMinLen(root, sentence, beg, i);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = beg;j &lt; end; j++) res.push_back(sentence[j]);</span><br><span class=\"line\">            res.push_back(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">            beg = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            word = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = getMinLen(root, sentence, beg, sentence.size());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = beg;j &lt; end; j++) res.push_back(sentence[j]);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Reverse Linked List","date":"2017-11-04T11:01:34.000Z","_content":"\n第40天。\n\n今天的题目是[Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/discuss/):\n\n> Reverse a singly linked list.\n> Hint:\n> A linked list can be reversed either iteratively or recursively. Could you implement both?\n\n简单的想法就是直接用一个栈来完成这种后进先出的操作:\n\n```c++\nListNode* reverseList1(ListNode* head) {\n    ListNode ret(0);\n    ListNode *p = &ret;\n    stack<ListNode *> st;\n    while(head!=nullptr) { st.push(head); head = head->next; }\n    while(!st.empty()) {\n        p->next = st.top();\n        st.pop();\n        p = p->next;\n    }\n    p->next = nullptr;\n    return ret.next;\n}\n```\n\n但是这种方法效率不高，下面是迭代的方法：\n\n```c++\nListNode* reverseList(ListNode* head) {\n    ListNode *pre = nullptr;\n    ListNode *cur = head;\n    while(cur != nullptr) {\n        ListNode *t = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = t;\n    }\n    return pre;\n}\n```\n\n以及递归的方法:\n\n```c++\nListNode *reverseList(ListNode *head) {\n    if (head==nullptr || head->next == nullptr) return head;\n    ListNode *ret = reverseList(head->next);\n    head->next->next = head;\n    head->next = nullptr;\n    return ret;\n}\n```\n","source":"_posts/Reverse-Linked-List.md","raw":"---\ntitle: Reverse Linked List\ndate: 2017-11-04T19:01:34.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - LinkedList\n---\n\n第40天。\n\n今天的题目是[Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/discuss/):\n\n> Reverse a singly linked list.\n> Hint:\n> A linked list can be reversed either iteratively or recursively. Could you implement both?\n\n简单的想法就是直接用一个栈来完成这种后进先出的操作:\n\n```c++\nListNode* reverseList1(ListNode* head) {\n    ListNode ret(0);\n    ListNode *p = &ret;\n    stack<ListNode *> st;\n    while(head!=nullptr) { st.push(head); head = head->next; }\n    while(!st.empty()) {\n        p->next = st.top();\n        st.pop();\n        p = p->next;\n    }\n    p->next = nullptr;\n    return ret.next;\n}\n```\n\n但是这种方法效率不高，下面是迭代的方法：\n\n```c++\nListNode* reverseList(ListNode* head) {\n    ListNode *pre = nullptr;\n    ListNode *cur = head;\n    while(cur != nullptr) {\n        ListNode *t = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = t;\n    }\n    return pre;\n}\n```\n\n以及递归的方法:\n\n```c++\nListNode *reverseList(ListNode *head) {\n    if (head==nullptr || head->next == nullptr) return head;\n    ListNode *ret = reverseList(head->next);\n    head->next->next = head;\n    head->next = nullptr;\n    return ret;\n}\n```\n","slug":"Reverse-Linked-List","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pj00cmqmcme28rgt2f","content":"<p>第40天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/reverse-linked-list/discuss/\">Reverse Linked List</a>:</p>\n<blockquote>\n<p>Reverse a singly linked list.<br>Hint:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n</blockquote>\n<p>简单的想法就是直接用一个栈来完成这种后进先出的操作:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList1</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    ListNode *p = &amp;ret;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;ListNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head!=<span class=\"literal\">nullptr</span>) &#123; st.push(head); head = head-&gt;next; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">        p-&gt;next = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这种方法效率不高，下面是迭代的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    ListNode *pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    ListNode *cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        ListNode *t = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next = pre;</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        cur = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及递归的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">reverseList</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head==<span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *ret = reverseList(head-&gt;next);</span><br><span class=\"line\">    head-&gt;next-&gt;next = head;</span><br><span class=\"line\">    head-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第40天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/reverse-linked-list/discuss/\">Reverse Linked List</a>:</p>\n<blockquote>\n<p>Reverse a singly linked list.<br>Hint:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n</blockquote>\n<p>简单的想法就是直接用一个栈来完成这种后进先出的操作:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList1</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    ListNode *p = &amp;ret;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;ListNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head!=<span class=\"literal\">nullptr</span>) &#123; st.push(head); head = head-&gt;next; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">        p-&gt;next = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这种方法效率不高，下面是迭代的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    ListNode *pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    ListNode *cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        ListNode *t = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next = pre;</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        cur = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及递归的方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">reverseList</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head==<span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *ret = reverseList(head-&gt;next);</span><br><span class=\"line\">    head-&gt;next-&gt;next = head;</span><br><span class=\"line\">    head-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Reverse-String","date":"2017-12-16T11:36:01.000Z","_content":"\n第80天。\n\n\n今天的题目是[Reverse String](https://leetcode.com/problems/reverse-string/description/):\n\n> Write a function that takes a string as input and returns the string reversed.\n>\n> Example:\n> Given s = \"hello\", return \"olleh\".\n\n水的不能再水的题目.\n\n```c++\nstring reverseString(string s) {\n    int i = 0,j = s.size() - 1;\n    while(i < j) {\n        swap(s[i++],s[j--]);\n    }\n    return s;\n}\n```\n\n如果用`python`话：\n\n```python\ndef reverseString(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    return s[::-1]\n```\n","source":"_posts/Reverse-String.md","raw":"---\ntitle: Reverse-String\ndate: 2017-12-16T19:36:01.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - String\n---\n\n第80天。\n\n\n今天的题目是[Reverse String](https://leetcode.com/problems/reverse-string/description/):\n\n> Write a function that takes a string as input and returns the string reversed.\n>\n> Example:\n> Given s = \"hello\", return \"olleh\".\n\n水的不能再水的题目.\n\n```c++\nstring reverseString(string s) {\n    int i = 0,j = s.size() - 1;\n    while(i < j) {\n        swap(s[i++],s[j--]);\n    }\n    return s;\n}\n```\n\n如果用`python`话：\n\n```python\ndef reverseString(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    return s[::-1]\n```\n","slug":"Reverse-String","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pk00cpqmcm0giu0de1","content":"<p>第80天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/reverse-string/description/\">Reverse String</a>:</p>\n<blockquote>\n<p>Write a function that takes a string as input and returns the string reversed.</p>\n<p>Example:<br>Given s = “hello”, return “olleh”.</p>\n</blockquote>\n<p>水的不能再水的题目.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseString</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = s.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; j) &#123;</span><br><span class=\"line\">        swap(s[i++],s[j--]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用<code>python</code>话：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseString</span>(<span class=\"params\">self, s</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type s: str</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[::-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第80天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/reverse-string/description/\">Reverse String</a>:</p>\n<blockquote>\n<p>Write a function that takes a string as input and returns the string reversed.</p>\n<p>Example:<br>Given s = “hello”, return “olleh”.</p>\n</blockquote>\n<p>水的不能再水的题目.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseString</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = s.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; j) &#123;</span><br><span class=\"line\">        swap(s[i++],s[j--]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用<code>python</code>话：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseString</span>(<span class=\"params\">self, s</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type s: str</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[::-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n"},{"title":"Reverse Substrings Between Each Pair of Parentheses","date":"2019-11-09T03:03:51.000Z","_content":"\n> 第5天。\n\n今天的题目是：[Reverse Substrings Between Each Pair of Parentheses](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/)：\n\n---\n\nYou are given a string `s` that consists of lower case English letters and brackets. \n\nReverse the strings in each pair of matching parentheses, starting from the innermost one.\n\nYour result should **not** contain any brackets.\n\n \n\n**Example 1:**\n\n```\nInput: s = \"(abcd)\"\nOutput: \"dcba\"\n```\n\n**Example 2:**\n\n```\nInput: s = \"(u(love)i)\"\nOutput: \"iloveu\"\nExplanation: The substring \"love\" is reversed first, then the whole string is reversed.\n```\n\n**Example 3:**\n\n```\nInput: s = \"(ed(et(oc))el)\"\nOutput: \"leetcode\"\nExplanation: First, we reverse the substring \"oc\", then \"etco\", and finally, the whole string.\n```\n\n**Example 4:**\n\n```\nInput: s = \"a(bcdefghijkl(mno)p)q\"\nOutput: \"apmnolkjihgfedcbq\"\n```\n\n \n\n**Constraints:**\n\n- `0 <= s.length <= 2000`\n- `s` only contains lower case English characters and parentheses.\n- It's guaranteed that all parentheses are balanced.\n\n---\n\n很简单的一道题，和昨天那道差不多的思路，都是用栈来解决嵌套问题就好了，甚至比昨天那道题还要简单，所以直接放代码了：\n\n```c++\nstring reverseParentheses(string s) {\n    stack<string> st;\n    st.push(string());\n    for(int i = 0;i < s.size(); i++) {\n        if (s[i] == '(') {\n            st.push(string());\n        } else if (s[i] == ')') {\n            string s = st.top(); st.pop();\n            st.top() += string(s.rbegin(), s.rend());\n        } else {\n            st.top().push_back(s[i]);\n        }\n    }\n    return st.top();\n}\n```\n","source":"_posts/Reverse-Substrings-Between-Each-Pair-of-Parentheses.md","raw":"---\ntitle: Reverse Substrings Between Each Pair of Parentheses\ndate: 2019-11-09T11:03:51.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第5天。\n\n今天的题目是：[Reverse Substrings Between Each Pair of Parentheses](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/)：\n\n---\n\nYou are given a string `s` that consists of lower case English letters and brackets. \n\nReverse the strings in each pair of matching parentheses, starting from the innermost one.\n\nYour result should **not** contain any brackets.\n\n \n\n**Example 1:**\n\n```\nInput: s = \"(abcd)\"\nOutput: \"dcba\"\n```\n\n**Example 2:**\n\n```\nInput: s = \"(u(love)i)\"\nOutput: \"iloveu\"\nExplanation: The substring \"love\" is reversed first, then the whole string is reversed.\n```\n\n**Example 3:**\n\n```\nInput: s = \"(ed(et(oc))el)\"\nOutput: \"leetcode\"\nExplanation: First, we reverse the substring \"oc\", then \"etco\", and finally, the whole string.\n```\n\n**Example 4:**\n\n```\nInput: s = \"a(bcdefghijkl(mno)p)q\"\nOutput: \"apmnolkjihgfedcbq\"\n```\n\n \n\n**Constraints:**\n\n- `0 <= s.length <= 2000`\n- `s` only contains lower case English characters and parentheses.\n- It's guaranteed that all parentheses are balanced.\n\n---\n\n很简单的一道题，和昨天那道差不多的思路，都是用栈来解决嵌套问题就好了，甚至比昨天那道题还要简单，所以直接放代码了：\n\n```c++\nstring reverseParentheses(string s) {\n    stack<string> st;\n    st.push(string());\n    for(int i = 0;i < s.size(); i++) {\n        if (s[i] == '(') {\n            st.push(string());\n        } else if (s[i] == ')') {\n            string s = st.top(); st.pop();\n            st.top() += string(s.rbegin(), s.rend());\n        } else {\n            st.top().push_back(s[i]);\n        }\n    }\n    return st.top();\n}\n```\n","slug":"Reverse-Substrings-Between-Each-Pair-of-Parentheses","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pk00csqmcm536n33a8","content":"<blockquote>\n<p>第5天。</p>\n</blockquote>\n<p>今天的题目是：<a href=\"https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/\">Reverse Substrings Between Each Pair of Parentheses</a>：</p>\n<hr>\n<p>You are given a string <code>s</code> that consists of lower case English letters and brackets. </p>\n<p>Reverse the strings in each pair of matching parentheses, starting from the innermost one.</p>\n<p>Your result should <strong>not</strong> contain any brackets.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;(abcd)&quot;</span><br><span class=\"line\">Output: &quot;dcba&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;(u(love)i)&quot;</span><br><span class=\"line\">Output: &quot;iloveu&quot;</span><br><span class=\"line\">Explanation: The substring &quot;love&quot; is reversed first, then the whole string is reversed.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;(ed(et(oc))el)&quot;</span><br><span class=\"line\">Output: &quot;leetcode&quot;</span><br><span class=\"line\">Explanation: First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;a(bcdefghijkl(mno)p)q&quot;</span><br><span class=\"line\">Output: &quot;apmnolkjihgfedcbq&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Constraints:</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 2000</code></li>\n<li><code>s</code> only contains lower case English characters and parentheses.</li>\n<li>It’s guaranteed that all parentheses are balanced.</li>\n</ul>\n<hr>\n<p>很简单的一道题，和昨天那道差不多的思路，都是用栈来解决嵌套问题就好了，甚至比昨天那道题还要简单，所以直接放代码了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseParentheses</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">string</span>&gt; st;</span><br><span class=\"line\">    st.push(<span class=\"built_in\">string</span>());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;(&#x27;</span>) &#123;</span><br><span class=\"line\">            st.push(<span class=\"built_in\">string</span>());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> s = st.top(); st.pop();</span><br><span class=\"line\">            st.top() += <span class=\"built_in\">string</span>(s.rbegin(), s.rend());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            st.top().push_back(s[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第5天。</p>\n</blockquote>\n<p>今天的题目是：<a href=\"https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/\">Reverse Substrings Between Each Pair of Parentheses</a>：</p>\n<hr>\n<p>You are given a string <code>s</code> that consists of lower case English letters and brackets. </p>\n<p>Reverse the strings in each pair of matching parentheses, starting from the innermost one.</p>\n<p>Your result should <strong>not</strong> contain any brackets.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;(abcd)&quot;</span><br><span class=\"line\">Output: &quot;dcba&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;(u(love)i)&quot;</span><br><span class=\"line\">Output: &quot;iloveu&quot;</span><br><span class=\"line\">Explanation: The substring &quot;love&quot; is reversed first, then the whole string is reversed.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;(ed(et(oc))el)&quot;</span><br><span class=\"line\">Output: &quot;leetcode&quot;</span><br><span class=\"line\">Explanation: First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;a(bcdefghijkl(mno)p)q&quot;</span><br><span class=\"line\">Output: &quot;apmnolkjihgfedcbq&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Constraints:</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 2000</code></li>\n<li><code>s</code> only contains lower case English characters and parentheses.</li>\n<li>It’s guaranteed that all parentheses are balanced.</li>\n</ul>\n<hr>\n<p>很简单的一道题，和昨天那道差不多的思路，都是用栈来解决嵌套问题就好了，甚至比昨天那道题还要简单，所以直接放代码了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseParentheses</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">string</span>&gt; st;</span><br><span class=\"line\">    st.push(<span class=\"built_in\">string</span>());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;(&#x27;</span>) &#123;</span><br><span class=\"line\">            st.push(<span class=\"built_in\">string</span>());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> s = st.top(); st.pop();</span><br><span class=\"line\">            st.top() += <span class=\"built_in\">string</span>(s.rbegin(), s.rend());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            st.top().push_back(s[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Reverse-Words-in-a-String-III","date":"2017-12-15T01:29:55.000Z","_content":"\n第79天。\n\n今天的题目是[Reverse Words in a String III](https://leetcode.com/problems/reverse-words-in-a-string-iii/description/):\n\n> Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n>\n> Example 1:\n> Input: \"Let's take LeetCode contest\"\n> Output: \"s'teL ekat edoCteeL tsetnoc\"\n> Note: In the string, each word is separated by single space and there will not be > any extra space in the string.\n\n用`python`的话就很简单了：\n\n```python\ndef reverseWords(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    words = s.split()\n    for i in range(len(words)):\n        words[i] = words[i][::-1]\n    return ' '.join(words)\n```\n\n然后是`dicuss`中的`c`解法：\n\n```c\nvoid reverse(int b, int e, char *s){\n    while(b < e) {\n        s[b] = s[b] ^ s[e];\n        s[e] = s[b] ^ s[e];\n        s[b] = s[b] ^ s[e];\n        b++;\n        e--;\n    }\n}\n\nchar* reverseWords(char* s) {\n    int i, s_len = strlen(s), index = 0;\n\n    for(i = 0; i <= s_len; i++) {\n        if((s[i] == ' ') || (s[i] == '\\0')){\n            reverse(index, i - 1, s);\n            index = i + 1;\n        }\n    }\n    return s;\n}\n```\n","source":"_posts/Reverse-Words-in-a-String-III.md","raw":"---\ntitle: Reverse-Words-in-a-String-III\ndate: 2017-12-15T09:29:55.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - String\n---\n\n第79天。\n\n今天的题目是[Reverse Words in a String III](https://leetcode.com/problems/reverse-words-in-a-string-iii/description/):\n\n> Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n>\n> Example 1:\n> Input: \"Let's take LeetCode contest\"\n> Output: \"s'teL ekat edoCteeL tsetnoc\"\n> Note: In the string, each word is separated by single space and there will not be > any extra space in the string.\n\n用`python`的话就很简单了：\n\n```python\ndef reverseWords(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    words = s.split()\n    for i in range(len(words)):\n        words[i] = words[i][::-1]\n    return ' '.join(words)\n```\n\n然后是`dicuss`中的`c`解法：\n\n```c\nvoid reverse(int b, int e, char *s){\n    while(b < e) {\n        s[b] = s[b] ^ s[e];\n        s[e] = s[b] ^ s[e];\n        s[b] = s[b] ^ s[e];\n        b++;\n        e--;\n    }\n}\n\nchar* reverseWords(char* s) {\n    int i, s_len = strlen(s), index = 0;\n\n    for(i = 0; i <= s_len; i++) {\n        if((s[i] == ' ') || (s[i] == '\\0')){\n            reverse(index, i - 1, s);\n            index = i + 1;\n        }\n    }\n    return s;\n}\n```\n","slug":"Reverse-Words-in-a-String-III","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pl00cwqmcmgil0eh7q","content":"<p>第79天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/reverse-words-in-a-string-iii/description/\">Reverse Words in a String III</a>:</p>\n<blockquote>\n<p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>\n<p>Example 1:<br>Input: “Let’s take LeetCode contest”<br>Output: “s’teL ekat edoCteeL tsetnoc”<br>Note: In the string, each word is separated by single space and there will not be &gt; any extra space in the string.</p>\n</blockquote>\n<p>用<code>python</code>的话就很简单了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseWords</span>(<span class=\"params\">self, s</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type s: str</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    words = s.split()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(words)):</span><br><span class=\"line\">        words[i] = words[i][::-<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27; &#x27;</span>.join(words)</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的<code>c</code>解法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> e, <span class=\"keyword\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b &lt; e) &#123;</span><br><span class=\"line\">        s[b] = s[b] ^ s[e];</span><br><span class=\"line\">        s[e] = s[b] ^ s[e];</span><br><span class=\"line\">        s[b] = s[b] ^ s[e];</span><br><span class=\"line\">        b++;</span><br><span class=\"line\">        e--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">reverseWords</span><span class=\"params\">(<span class=\"keyword\">char</span>* s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, s_len = <span class=\"built_in\">strlen</span>(s), index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;= s_len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((s[i] == <span class=\"string\">&#x27; &#x27;</span>) || (s[i] == <span class=\"string\">&#x27;\\0&#x27;</span>))&#123;</span><br><span class=\"line\">            reverse(index, i - <span class=\"number\">1</span>, s);</span><br><span class=\"line\">            index = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第79天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/reverse-words-in-a-string-iii/description/\">Reverse Words in a String III</a>:</p>\n<blockquote>\n<p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>\n<p>Example 1:<br>Input: “Let’s take LeetCode contest”<br>Output: “s’teL ekat edoCteeL tsetnoc”<br>Note: In the string, each word is separated by single space and there will not be &gt; any extra space in the string.</p>\n</blockquote>\n<p>用<code>python</code>的话就很简单了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseWords</span>(<span class=\"params\">self, s</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type s: str</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    words = s.split()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(words)):</span><br><span class=\"line\">        words[i] = words[i][::-<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27; &#x27;</span>.join(words)</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的<code>c</code>解法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> e, <span class=\"keyword\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b &lt; e) &#123;</span><br><span class=\"line\">        s[b] = s[b] ^ s[e];</span><br><span class=\"line\">        s[e] = s[b] ^ s[e];</span><br><span class=\"line\">        s[b] = s[b] ^ s[e];</span><br><span class=\"line\">        b++;</span><br><span class=\"line\">        e--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">reverseWords</span><span class=\"params\">(<span class=\"keyword\">char</span>* s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, s_len = <span class=\"built_in\">strlen</span>(s), index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;= s_len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((s[i] == <span class=\"string\">&#x27; &#x27;</span>) || (s[i] == <span class=\"string\">&#x27;\\0&#x27;</span>))&#123;</span><br><span class=\"line\">            reverse(index, i - <span class=\"number\">1</span>, s);</span><br><span class=\"line\">            index = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Rotate Function","date":"2019-12-08T03:04:58.000Z","_content":"\n> 第32天。\n\n今天的题目是[Rotate Function](https://leetcode.com/problems/rotate-function/)。\n\n这道题是一道数学题，直接求解的话显然复杂度很高，然后这道题也没法把大问题化简到小问题，所以用常规的分治、动规和贪心去想这道题的话，是没法找到答案的。\n\n为了解决这道题，我们先把 $F(k)$ 的写出来：\n\n$$\nF(k) = 0 * B_k[0] + 1 * B_k[1] + ... + (n - 1) * B_k[n-1]\n$$\n\n然后我们通过题意可以知道 $B_k[i] = A[(i+k) \\% n]$ ，所以：\n\n$$\n\\begin{aligned}\nF(k) &= 0 * B_k[0] + 1 * B_k[1] + ... + (n - 1) * B_k[n-1] \\\\\n     &= 0 * A[(0+k) \\% n] + A[(1+k) \\% n] + ... + (n - 1) * A[(n-1+k) \\% n] \\\\\n     &= \\sum_{i=0}^{n-1} i * A[(i+k) \\% n]\n\\end{aligned}\n$$\n\n我们可以尝试把 $(i + k) \\% n$ 中的 取模运算去掉：\n\n$$\n\n\\begin{aligned}\nF(k) &= \\sum_{i=0}^{n-1} i * A[(i+k) \\% n] \\\\\n     &= \\sum_{i=1}^{n-k-1} i * A[i+k] + \\sum_{i=n-k}^{n-1} i * A[i + k -n] \\\\\n\\end{aligned}\n\n$$\n\n我们把 $j = i - k$ 代入 $\\sum_{i=1}^{n-k-1} i * A[i+k]$ 和 $j = i + k -n$ 代入 $\\sum_{i=n-k}^{n-1} i * A[i + k -n]$ :\n\n$$\n\\begin{aligned}\nF(k) &= \\sum_{j=k}^{n-1} (j - k) * A[j] + \\sum_{j=0}^{k-1} (j + n -k) * A[j] \\\\\n     & = \\sum_{j=0}^{n-1} j * A[j] + n * \\sum_{j=0}^{k-1} A[j] - k * \\sum_{j=0}^{n-1} A[j]\n\\end{aligned}\n$$\n\n上面的公式中 $\\sum_{j=0}^{n-1} j * A[j]$ 和 $\\sum_{j=0}^{n-1} A[j]$ 都是常数，因此我们可以可以用 $O(n)$ 的时间复杂度解决这道题：\n\n```c++\nint maxRotateFunction(vector<int>& A) {\n    if (A.size() == 0) return 0;\n    long long s1 = 0, s2 = 0;\n    for(int i = 0, size = A.size(); i < size; i++) {\n        s1 += A[i];\n        s2 += i*A[i];\n    }\n    long long res = LONG_MIN;\n    long long t = 0;\n    for(int k = 0, n = A.size();k < n; k++) {\n        t += A[k];\n        res = max(res,n * t - (k+1) * s1);\n    }\n    return res + s2;\n}\n```\n","source":"_posts/Rotate-Function.md","raw":"---\ntitle: Rotate Function\ndate: 2019-12-08T11:04:58.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第32天。\n\n今天的题目是[Rotate Function](https://leetcode.com/problems/rotate-function/)。\n\n这道题是一道数学题，直接求解的话显然复杂度很高，然后这道题也没法把大问题化简到小问题，所以用常规的分治、动规和贪心去想这道题的话，是没法找到答案的。\n\n为了解决这道题，我们先把 $F(k)$ 的写出来：\n\n$$\nF(k) = 0 * B_k[0] + 1 * B_k[1] + ... + (n - 1) * B_k[n-1]\n$$\n\n然后我们通过题意可以知道 $B_k[i] = A[(i+k) \\% n]$ ，所以：\n\n$$\n\\begin{aligned}\nF(k) &= 0 * B_k[0] + 1 * B_k[1] + ... + (n - 1) * B_k[n-1] \\\\\n     &= 0 * A[(0+k) \\% n] + A[(1+k) \\% n] + ... + (n - 1) * A[(n-1+k) \\% n] \\\\\n     &= \\sum_{i=0}^{n-1} i * A[(i+k) \\% n]\n\\end{aligned}\n$$\n\n我们可以尝试把 $(i + k) \\% n$ 中的 取模运算去掉：\n\n$$\n\n\\begin{aligned}\nF(k) &= \\sum_{i=0}^{n-1} i * A[(i+k) \\% n] \\\\\n     &= \\sum_{i=1}^{n-k-1} i * A[i+k] + \\sum_{i=n-k}^{n-1} i * A[i + k -n] \\\\\n\\end{aligned}\n\n$$\n\n我们把 $j = i - k$ 代入 $\\sum_{i=1}^{n-k-1} i * A[i+k]$ 和 $j = i + k -n$ 代入 $\\sum_{i=n-k}^{n-1} i * A[i + k -n]$ :\n\n$$\n\\begin{aligned}\nF(k) &= \\sum_{j=k}^{n-1} (j - k) * A[j] + \\sum_{j=0}^{k-1} (j + n -k) * A[j] \\\\\n     & = \\sum_{j=0}^{n-1} j * A[j] + n * \\sum_{j=0}^{k-1} A[j] - k * \\sum_{j=0}^{n-1} A[j]\n\\end{aligned}\n$$\n\n上面的公式中 $\\sum_{j=0}^{n-1} j * A[j]$ 和 $\\sum_{j=0}^{n-1} A[j]$ 都是常数，因此我们可以可以用 $O(n)$ 的时间复杂度解决这道题：\n\n```c++\nint maxRotateFunction(vector<int>& A) {\n    if (A.size() == 0) return 0;\n    long long s1 = 0, s2 = 0;\n    for(int i = 0, size = A.size(); i < size; i++) {\n        s1 += A[i];\n        s2 += i*A[i];\n    }\n    long long res = LONG_MIN;\n    long long t = 0;\n    for(int k = 0, n = A.size();k < n; k++) {\n        t += A[k];\n        res = max(res,n * t - (k+1) * s1);\n    }\n    return res + s2;\n}\n```\n","slug":"Rotate-Function","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pm00czqmcm7ukd5ao0","content":"<blockquote>\n<p>第32天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/rotate-function/\">Rotate Function</a>。</p>\n<p>这道题是一道数学题，直接求解的话显然复杂度很高，然后这道题也没法把大问题化简到小问题，所以用常规的分治、动规和贪心去想这道题的话，是没法找到答案的。</p>\n<p>为了解决这道题，我们先把 $F(k)$ 的写出来：</p>\n<p>$$<br>F(k) = 0 * B_k[0] + 1 * B_k[1] + … + (n - 1) * B_k[n-1]<br>$$</p>\n<p>然后我们通过题意可以知道 $B_k[i] = A[(i+k) % n]$ ，所以：</p>\n<p>$$<br>\\begin{aligned}<br>F(k) &amp;= 0 * B_k[0] + 1 * B_k[1] + … + (n - 1) * B_k[n-1] \\<br>     &amp;= 0 * A[(0+k) % n] + A[(1+k) % n] + … + (n - 1) * A[(n-1+k) % n] \\<br>     &amp;= \\sum_{i=0}^{n-1} i * A[(i+k) % n]<br>\\end{aligned}<br>$$</p>\n<p>我们可以尝试把 $(i + k) % n$ 中的 取模运算去掉：</p>\n<p>$$</p>\n<p>\\begin{aligned}<br>F(k) &amp;= \\sum_{i=0}^{n-1} i * A[(i+k) % n] \\<br>     &amp;= \\sum_{i=1}^{n-k-1} i * A[i+k] + \\sum_{i=n-k}^{n-1} i * A[i + k -n] \\<br>\\end{aligned}</p>\n<p>$$</p>\n<p>我们把 $j = i - k$ 代入 $\\sum_{i=1}^{n-k-1} i * A[i+k]$ 和 $j = i + k -n$ 代入 $\\sum_{i=n-k}^{n-1} i * A[i + k -n]$ :</p>\n<p>$$<br>\\begin{aligned}<br>F(k) &amp;= \\sum_{j=k}^{n-1} (j - k) * A[j] + \\sum_{j=0}^{k-1} (j + n -k) * A[j] \\<br>     &amp; = \\sum_{j=0}^{n-1} j * A[j] + n * \\sum_{j=0}^{k-1} A[j] - k * \\sum_{j=0}^{n-1} A[j]<br>\\end{aligned}<br>$$</p>\n<p>上面的公式中 $\\sum_{j=0}^{n-1} j * A[j]$ 和 $\\sum_{j=0}^{n-1} A[j]$ 都是常数，因此我们可以可以用 $O(n)$ 的时间复杂度解决这道题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxRotateFunction</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = A.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        s1 += A[i];</span><br><span class=\"line\">        s2 += i*A[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = LONG_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>, n = A.size();k &lt; n; k++) &#123;</span><br><span class=\"line\">        t += A[k];</span><br><span class=\"line\">        res = max(res,n * t - (k+<span class=\"number\">1</span>) * s1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res + s2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第32天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/rotate-function/\">Rotate Function</a>。</p>\n<p>这道题是一道数学题，直接求解的话显然复杂度很高，然后这道题也没法把大问题化简到小问题，所以用常规的分治、动规和贪心去想这道题的话，是没法找到答案的。</p>\n<p>为了解决这道题，我们先把 $F(k)$ 的写出来：</p>\n<p>$$<br>F(k) = 0 * B_k[0] + 1 * B_k[1] + … + (n - 1) * B_k[n-1]<br>$$</p>\n<p>然后我们通过题意可以知道 $B_k[i] = A[(i+k) % n]$ ，所以：</p>\n<p>$$<br>\\begin{aligned}<br>F(k) &amp;= 0 * B_k[0] + 1 * B_k[1] + … + (n - 1) * B_k[n-1] \\<br>     &amp;= 0 * A[(0+k) % n] + A[(1+k) % n] + … + (n - 1) * A[(n-1+k) % n] \\<br>     &amp;= \\sum_{i=0}^{n-1} i * A[(i+k) % n]<br>\\end{aligned}<br>$$</p>\n<p>我们可以尝试把 $(i + k) % n$ 中的 取模运算去掉：</p>\n<p>$$</p>\n<p>\\begin{aligned}<br>F(k) &amp;= \\sum_{i=0}^{n-1} i * A[(i+k) % n] \\<br>     &amp;= \\sum_{i=1}^{n-k-1} i * A[i+k] + \\sum_{i=n-k}^{n-1} i * A[i + k -n] \\<br>\\end{aligned}</p>\n<p>$$</p>\n<p>我们把 $j = i - k$ 代入 $\\sum_{i=1}^{n-k-1} i * A[i+k]$ 和 $j = i + k -n$ 代入 $\\sum_{i=n-k}^{n-1} i * A[i + k -n]$ :</p>\n<p>$$<br>\\begin{aligned}<br>F(k) &amp;= \\sum_{j=k}^{n-1} (j - k) * A[j] + \\sum_{j=0}^{k-1} (j + n -k) * A[j] \\<br>     &amp; = \\sum_{j=0}^{n-1} j * A[j] + n * \\sum_{j=0}^{k-1} A[j] - k * \\sum_{j=0}^{n-1} A[j]<br>\\end{aligned}<br>$$</p>\n<p>上面的公式中 $\\sum_{j=0}^{n-1} j * A[j]$ 和 $\\sum_{j=0}^{n-1} A[j]$ 都是常数，因此我们可以可以用 $O(n)$ 的时间复杂度解决这道题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxRotateFunction</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = A.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        s1 += A[i];</span><br><span class=\"line\">        s2 += i*A[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = LONG_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>, n = A.size();k &lt; n; k++) &#123;</span><br><span class=\"line\">        t += A[k];</span><br><span class=\"line\">        res = max(res,n * t - (k+<span class=\"number\">1</span>) * s1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res + s2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Rotate-Image","date":"2018-01-23T04:28:20.000Z","_content":"\n第92天。\n\n今天的题目是[Rotate Image](https://leetcode.com/problems/rotate-image/description/):\n\n> You are given an n x n 2D matrix representing an image.\n>\n> Rotate the image by 90 degrees (clockwise).\n>\n> Note:\n> You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n>\n> Example 1:\n\n```python\nGiven input matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\nrotate the input matrix in-place such that it becomes:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n```\n\n> Example 2:\n\n```python\nGiven input matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\nrotate the input matrix in-place such that it becomes:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n```\n\n虽然是一道`Medium`的题目，但是还是比较简单的。\n\n主要的思路是一圈一圈的进行旋转，不断缩减，直到不需要旋转的时候：\n\n```c++\nvoid rotate(vector<vector<int>>& matrix) {\n    int beg = 0, end = matrix.size() - 1;\n    int temp;\n    while(beg < end) {\n        int size = end - beg;\n        for(int i = 0;i < size;i++) {\n            temp = matrix[beg+i][beg];\n            matrix[beg+i][beg] = matrix[end][beg+i];\n            matrix[end][beg+i] = matrix[end-i][end];\n            matrix[end-i][end] = matrix[beg][end-i];\n            matrix[beg][end-i] = temp;\n        }\n        beg++; end--;\n    }\n}\n```\n","source":"_posts/Rotate-Image.md","raw":"---\ntitle: Rotate-Image\ndate: 2018-01-23T12:28:20.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第92天。\n\n今天的题目是[Rotate Image](https://leetcode.com/problems/rotate-image/description/):\n\n> You are given an n x n 2D matrix representing an image.\n>\n> Rotate the image by 90 degrees (clockwise).\n>\n> Note:\n> You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n>\n> Example 1:\n\n```python\nGiven input matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\nrotate the input matrix in-place such that it becomes:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n```\n\n> Example 2:\n\n```python\nGiven input matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\nrotate the input matrix in-place such that it becomes:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n```\n\n虽然是一道`Medium`的题目，但是还是比较简单的。\n\n主要的思路是一圈一圈的进行旋转，不断缩减，直到不需要旋转的时候：\n\n```c++\nvoid rotate(vector<vector<int>>& matrix) {\n    int beg = 0, end = matrix.size() - 1;\n    int temp;\n    while(beg < end) {\n        int size = end - beg;\n        for(int i = 0;i < size;i++) {\n            temp = matrix[beg+i][beg];\n            matrix[beg+i][beg] = matrix[end][beg+i];\n            matrix[end][beg+i] = matrix[end-i][end];\n            matrix[end-i][end] = matrix[beg][end-i];\n            matrix[beg][end-i] = temp;\n        }\n        beg++; end--;\n    }\n}\n```\n","slug":"Rotate-Image","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pm00d2qmcmdhfldwvj","content":"<p>第92天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/rotate-image/description/\">Rotate Image</a>:</p>\n<blockquote>\n<p>You are given an n x n 2D matrix representing an image.</p>\n<p>Rotate the image by 90 degrees (clockwise).</p>\n<p>Note:<br>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>\n<p>Example 1:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given <span class=\"built_in\">input</span> matrix = </span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">],</span><br><span class=\"line\"></span><br><span class=\"line\">rotate the <span class=\"built_in\">input</span> matrix <span class=\"keyword\">in</span>-place such that it becomes:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Example 2:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given <span class=\"built_in\">input</span> matrix =</span><br><span class=\"line\">[</span><br><span class=\"line\">  [ <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>,<span class=\"number\">11</span>],</span><br><span class=\"line\">  [ <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">  [<span class=\"number\">13</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">14</span>,<span class=\"number\">12</span>,<span class=\"number\">16</span>]</span><br><span class=\"line\">], </span><br><span class=\"line\"></span><br><span class=\"line\">rotate the <span class=\"built_in\">input</span> matrix <span class=\"keyword\">in</span>-place such that it becomes:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">13</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">14</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">12</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">  [<span class=\"number\">16</span>, <span class=\"number\">7</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>虽然是一道<code>Medium</code>的题目，但是还是比较简单的。</p>\n<p>主要的思路是一圈一圈的进行旋转，不断缩减，直到不需要旋转的时候：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>, end = matrix.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg &lt; end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = end - beg;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size;i++) &#123;</span><br><span class=\"line\">            temp = matrix[beg+i][beg];</span><br><span class=\"line\">            matrix[beg+i][beg] = matrix[end][beg+i];</span><br><span class=\"line\">            matrix[end][beg+i] = matrix[end-i][end];</span><br><span class=\"line\">            matrix[end-i][end] = matrix[beg][end-i];</span><br><span class=\"line\">            matrix[beg][end-i] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        beg++; end--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第92天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/rotate-image/description/\">Rotate Image</a>:</p>\n<blockquote>\n<p>You are given an n x n 2D matrix representing an image.</p>\n<p>Rotate the image by 90 degrees (clockwise).</p>\n<p>Note:<br>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>\n<p>Example 1:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given <span class=\"built_in\">input</span> matrix = </span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">],</span><br><span class=\"line\"></span><br><span class=\"line\">rotate the <span class=\"built_in\">input</span> matrix <span class=\"keyword\">in</span>-place such that it becomes:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Example 2:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given <span class=\"built_in\">input</span> matrix =</span><br><span class=\"line\">[</span><br><span class=\"line\">  [ <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>,<span class=\"number\">11</span>],</span><br><span class=\"line\">  [ <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">  [<span class=\"number\">13</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">14</span>,<span class=\"number\">12</span>,<span class=\"number\">16</span>]</span><br><span class=\"line\">], </span><br><span class=\"line\"></span><br><span class=\"line\">rotate the <span class=\"built_in\">input</span> matrix <span class=\"keyword\">in</span>-place such that it becomes:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">13</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">14</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">12</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">  [<span class=\"number\">16</span>, <span class=\"number\">7</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>虽然是一道<code>Medium</code>的题目，但是还是比较简单的。</p>\n<p>主要的思路是一圈一圈的进行旋转，不断缩减，直到不需要旋转的时候：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>, end = matrix.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg &lt; end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = end - beg;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size;i++) &#123;</span><br><span class=\"line\">            temp = matrix[beg+i][beg];</span><br><span class=\"line\">            matrix[beg+i][beg] = matrix[end][beg+i];</span><br><span class=\"line\">            matrix[end][beg+i] = matrix[end-i][end];</span><br><span class=\"line\">            matrix[end-i][end] = matrix[beg][end-i];</span><br><span class=\"line\">            matrix[beg][end-i] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        beg++; end--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Same-Tree","date":"2018-01-26T03:44:17.000Z","_content":"\n第95天。\n\n今天的题目比较水。\n\n今天的题目是[Same Tree](https://leetcode.com/problems/same-tree/description/):\n\n> Given two binary trees, write a function to check if they are the same or not.\n\n> Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\n\n太简单了，不做太多解释了:\n\n```c++\nbool isSameTree(TreeNode* p, TreeNode* q) {\n    if (p == nullptr && q == nullptr) return true;\n    else if (p && q) {\n        return q->val == p->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    } else return false;\n}\n```\n","source":"_posts/Same-Tree.md","raw":"---\ntitle: Same-Tree\ndate: 2018-01-26T11:44:17.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第95天。\n\n今天的题目比较水。\n\n今天的题目是[Same Tree](https://leetcode.com/problems/same-tree/description/):\n\n> Given two binary trees, write a function to check if they are the same or not.\n\n> Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\n\n太简单了，不做太多解释了:\n\n```c++\nbool isSameTree(TreeNode* p, TreeNode* q) {\n    if (p == nullptr && q == nullptr) return true;\n    else if (p && q) {\n        return q->val == p->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    } else return false;\n}\n```\n","slug":"Same-Tree","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pn00d6qmcm2kyx3gwy","content":"<p>第95天。</p>\n<p>今天的题目比较水。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/same-tree/description/\">Same Tree</a>:</p>\n<blockquote>\n<p>Given two binary trees, write a function to check if they are the same or not.</p>\n</blockquote>\n<blockquote>\n<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>\n</blockquote>\n<p>太简单了，不做太多解释了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span> &amp;&amp; q == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p &amp;&amp; q) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q-&gt;val == p-&gt;val &amp;&amp; isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第95天。</p>\n<p>今天的题目比较水。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/same-tree/description/\">Same Tree</a>:</p>\n<blockquote>\n<p>Given two binary trees, write a function to check if they are the same or not.</p>\n</blockquote>\n<blockquote>\n<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>\n</blockquote>\n<p>太简单了，不做太多解释了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span> &amp;&amp; q == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p &amp;&amp; q) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q-&gt;val == p-&gt;val &amp;&amp; isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Satisfiability of Equality Equations","date":"2019-12-28T09:04:19.000Z","_content":"\n> 第51天，考完期末了，hhh。\n> 虽然还有一门恶心的Survey没写。\n\n今天的题目是[Satisfiability of Equality Equations](https://leetcode.com/problems/satisfiability-of-equality-equations/):\n\n一道并查集的题目，先遍历一次`==`的式子，建立并查集，然后再遍历一次`!=`的式子，判断`!=`两边的字符是否属于不同的两个集合即可。\n\n```c++\nbool equationsPossible(vector<string>& equations) {\n    vector<int> imap(26);\n    for(int i = 0;i < 26; i++) imap[i] = i;\n    for(auto &e: equations) {\n        if (e[1] == '!') continue;\n        int i1 = e[0] - 'a', i2 = e[3] - 'a';\n        while(imap[i1] != i1) i1 = imap[i1];\n        while(imap[i2] != i2) i2 = imap[i2];\n        imap[i1] = i2;\n    }\n    \n    for(auto &e: equations) {\n        if (e[1] == '=') continue;\n        int i1 = e[0] - 'a', i2 = e[3] - 'a';\n        while(imap[i1] != i1) i1 = imap[i1];\n        while(imap[i2] != i2) i2 = imap[i2];\n        if (i1 == i2) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```\n","source":"_posts/Satisfiability-of-Equality-Equations.md","raw":"---\ntitle: Satisfiability of Equality Equations\ndate: 2019-12-28T17:04:19.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第51天，考完期末了，hhh。\n> 虽然还有一门恶心的Survey没写。\n\n今天的题目是[Satisfiability of Equality Equations](https://leetcode.com/problems/satisfiability-of-equality-equations/):\n\n一道并查集的题目，先遍历一次`==`的式子，建立并查集，然后再遍历一次`!=`的式子，判断`!=`两边的字符是否属于不同的两个集合即可。\n\n```c++\nbool equationsPossible(vector<string>& equations) {\n    vector<int> imap(26);\n    for(int i = 0;i < 26; i++) imap[i] = i;\n    for(auto &e: equations) {\n        if (e[1] == '!') continue;\n        int i1 = e[0] - 'a', i2 = e[3] - 'a';\n        while(imap[i1] != i1) i1 = imap[i1];\n        while(imap[i2] != i2) i2 = imap[i2];\n        imap[i1] = i2;\n    }\n    \n    for(auto &e: equations) {\n        if (e[1] == '=') continue;\n        int i1 = e[0] - 'a', i2 = e[3] - 'a';\n        while(imap[i1] != i1) i1 = imap[i1];\n        while(imap[i2] != i2) i2 = imap[i2];\n        if (i1 == i2) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```\n","slug":"Satisfiability-of-Equality-Equations","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69po00d9qmcmhvft8dne","content":"<blockquote>\n<p>第51天，考完期末了，hhh。<br>虽然还有一门恶心的Survey没写。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/satisfiability-of-equality-equations/\">Satisfiability of Equality Equations</a>:</p>\n<p>一道并查集的题目，先遍历一次<code>==</code>的式子，建立并查集，然后再遍历一次<code>!=</code>的式子，判断<code>!=</code>两边的字符是否属于不同的两个集合即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">equationsPossible</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">imap</span><span class=\"params\">(<span class=\"number\">26</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">26</span>; i++) imap[i] = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;e: equations) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;!&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i1 = e[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;a&#x27;</span>, i2 = e[<span class=\"number\">3</span>] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imap[i1] != i1) i1 = imap[i1];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imap[i2] != i2) i2 = imap[i2];</span><br><span class=\"line\">        imap[i1] = i2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;e: equations) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;=&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i1 = e[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;a&#x27;</span>, i2 = e[<span class=\"number\">3</span>] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imap[i1] != i1) i1 = imap[i1];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imap[i2] != i2) i2 = imap[i2];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i1 == i2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第51天，考完期末了，hhh。<br>虽然还有一门恶心的Survey没写。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/satisfiability-of-equality-equations/\">Satisfiability of Equality Equations</a>:</p>\n<p>一道并查集的题目，先遍历一次<code>==</code>的式子，建立并查集，然后再遍历一次<code>!=</code>的式子，判断<code>!=</code>两边的字符是否属于不同的两个集合即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">equationsPossible</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">imap</span><span class=\"params\">(<span class=\"number\">26</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">26</span>; i++) imap[i] = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;e: equations) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;!&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i1 = e[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;a&#x27;</span>, i2 = e[<span class=\"number\">3</span>] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imap[i1] != i1) i1 = imap[i1];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imap[i2] != i2) i2 = imap[i2];</span><br><span class=\"line\">        imap[i1] = i2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;e: equations) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;=&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i1 = e[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;a&#x27;</span>, i2 = e[<span class=\"number\">3</span>] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imap[i1] != i1) i1 = imap[i1];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imap[i2] != i2) i2 = imap[i2];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i1 == i2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Search-a-2D-Matrix-II","date":"2018-01-27T02:30:43.000Z","_content":"\n第96天。\n\n今天的题目是[Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/description/):\n\n> Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n>\n> Integers in each row are sorted in ascending from left to right.\n> Integers in each column are sorted in ascending from top to bottom.\n> For example,\n>\n> Consider the following matrix:\n>\n\n```python\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n```\n\n> Given target = 5, return true.\n>\n> Given target = 20, return false.\n\n以前好像看过这道题，但是应该嫌麻烦没做，今天做了一下，感觉好像也不是很难的样子，二分查找的升级版（在2维情况下）：\n\n```c++\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int n = matrix.size();\n    if (n == 0) return false;\n    int m = matrix[0].size();\n    return searchMatrix(matrix,0,n-1,0,m-1,target);\n}\n\nbool searchMatrix(vector<vector<int> > &matrix, int xlow, int xhigh, int ylow, int yhigh, int target) {\n\n    //cout << xlow << \" \" << xhigh << endl\n    //   << ylow << \" \" << yhigh << endl;\n\n    if (xlow > xhigh || ylow > yhigh) return false;\n    int xmid = (xlow + xhigh)/2, ymid = (ylow + yhigh)/2;\n    if (matrix[xmid][ymid] == target) return true;\n    else if (matrix[xmid][ymid] < target) \n        return searchMatrix(matrix,xmid + 1, xhigh, ylow, yhigh,target) ||\n                searchMatrix(matrix,xlow, xhigh, ymid + 1, yhigh, target);\n    else \n        return searchMatrix(matrix, xlow, xmid-1, ylow, yhigh,target) ||\n                searchMatrix(matrix,xlow, xhigh, ylow, ymid-1, target);\n}\n```\n\n\n为什么`dicuss`的解法大多都是:\n\n```c++\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int i = 0;\n    int j = matrix[0].size() - 1;\n\n    while(i < matrix.size() && j >= 0) {\n        if(matrix[i][j] == target)\n            return true;\n\n        if(matrix[i][j] < target)\n            i++;\n        else\n            j--;\n    }\n\n    return false;\n}\n```\n","source":"_posts/Search-a-2D-Matrix-II.md","raw":"---\ntitle: Search-a-2D-Matrix-II\ndate: 2018-01-27T10:30:43.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第96天。\n\n今天的题目是[Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/description/):\n\n> Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n>\n> Integers in each row are sorted in ascending from left to right.\n> Integers in each column are sorted in ascending from top to bottom.\n> For example,\n>\n> Consider the following matrix:\n>\n\n```python\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n```\n\n> Given target = 5, return true.\n>\n> Given target = 20, return false.\n\n以前好像看过这道题，但是应该嫌麻烦没做，今天做了一下，感觉好像也不是很难的样子，二分查找的升级版（在2维情况下）：\n\n```c++\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int n = matrix.size();\n    if (n == 0) return false;\n    int m = matrix[0].size();\n    return searchMatrix(matrix,0,n-1,0,m-1,target);\n}\n\nbool searchMatrix(vector<vector<int> > &matrix, int xlow, int xhigh, int ylow, int yhigh, int target) {\n\n    //cout << xlow << \" \" << xhigh << endl\n    //   << ylow << \" \" << yhigh << endl;\n\n    if (xlow > xhigh || ylow > yhigh) return false;\n    int xmid = (xlow + xhigh)/2, ymid = (ylow + yhigh)/2;\n    if (matrix[xmid][ymid] == target) return true;\n    else if (matrix[xmid][ymid] < target) \n        return searchMatrix(matrix,xmid + 1, xhigh, ylow, yhigh,target) ||\n                searchMatrix(matrix,xlow, xhigh, ymid + 1, yhigh, target);\n    else \n        return searchMatrix(matrix, xlow, xmid-1, ylow, yhigh,target) ||\n                searchMatrix(matrix,xlow, xhigh, ylow, ymid-1, target);\n}\n```\n\n\n为什么`dicuss`的解法大多都是:\n\n```c++\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int i = 0;\n    int j = matrix[0].size() - 1;\n\n    while(i < matrix.size() && j >= 0) {\n        if(matrix[i][j] == target)\n            return true;\n\n        if(matrix[i][j] < target)\n            i++;\n        else\n            j--;\n    }\n\n    return false;\n}\n```\n","slug":"Search-a-2D-Matrix-II","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69po00dcqmcmht6db56k","content":"<p>第96天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/search-a-2d-matrix-ii/description/\">Search a 2D Matrix II</a>:</p>\n<blockquote>\n<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>\n<p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,</p>\n<p>Consider the following matrix:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,   <span class=\"number\">4</span>,  <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,   <span class=\"number\">5</span>,  <span class=\"number\">8</span>, <span class=\"number\">12</span>, <span class=\"number\">19</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>,   <span class=\"number\">6</span>,  <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">22</span>],</span><br><span class=\"line\">  [<span class=\"number\">10</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">17</span>, <span class=\"number\">24</span>],</span><br><span class=\"line\">  [<span class=\"number\">18</span>, <span class=\"number\">21</span>, <span class=\"number\">23</span>, <span class=\"number\">26</span>, <span class=\"number\">30</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Given target = 5, return true.</p>\n<p>Given target = 20, return false.</p>\n</blockquote>\n<p>以前好像看过这道题，但是应该嫌麻烦没做，今天做了一下，感觉好像也不是很难的样子，二分查找的升级版（在2维情况下）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = matrix.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = matrix[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> searchMatrix(matrix,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>,m<span class=\"number\">-1</span>,target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;matrix, <span class=\"keyword\">int</span> xlow, <span class=\"keyword\">int</span> xhigh, <span class=\"keyword\">int</span> ylow, <span class=\"keyword\">int</span> yhigh, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; xlow &lt;&lt; &quot; &quot; &lt;&lt; xhigh &lt;&lt; endl</span></span><br><span class=\"line\">    <span class=\"comment\">//   &lt;&lt; ylow &lt;&lt; &quot; &quot; &lt;&lt; yhigh &lt;&lt; endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xlow &gt; xhigh || ylow &gt; yhigh) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> xmid = (xlow + xhigh)/<span class=\"number\">2</span>, ymid = (ylow + yhigh)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[xmid][ymid] == target) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (matrix[xmid][ymid] &lt; target) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchMatrix(matrix,xmid + <span class=\"number\">1</span>, xhigh, ylow, yhigh,target) ||</span><br><span class=\"line\">                searchMatrix(matrix,xlow, xhigh, ymid + <span class=\"number\">1</span>, yhigh, target);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchMatrix(matrix, xlow, xmid<span class=\"number\">-1</span>, ylow, yhigh,target) ||</span><br><span class=\"line\">                searchMatrix(matrix,xlow, xhigh, ylow, ymid<span class=\"number\">-1</span>, target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>为什么<code>dicuss</code>的解法大多都是:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = matrix[<span class=\"number\">0</span>].size() - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; matrix.size() &amp;&amp; j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(matrix[i][j] == target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(matrix[i][j] &lt; target)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第96天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/search-a-2d-matrix-ii/description/\">Search a 2D Matrix II</a>:</p>\n<blockquote>\n<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>\n<p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,</p>\n<p>Consider the following matrix:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,   <span class=\"number\">4</span>,  <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,   <span class=\"number\">5</span>,  <span class=\"number\">8</span>, <span class=\"number\">12</span>, <span class=\"number\">19</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>,   <span class=\"number\">6</span>,  <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">22</span>],</span><br><span class=\"line\">  [<span class=\"number\">10</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">17</span>, <span class=\"number\">24</span>],</span><br><span class=\"line\">  [<span class=\"number\">18</span>, <span class=\"number\">21</span>, <span class=\"number\">23</span>, <span class=\"number\">26</span>, <span class=\"number\">30</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Given target = 5, return true.</p>\n<p>Given target = 20, return false.</p>\n</blockquote>\n<p>以前好像看过这道题，但是应该嫌麻烦没做，今天做了一下，感觉好像也不是很难的样子，二分查找的升级版（在2维情况下）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = matrix.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = matrix[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> searchMatrix(matrix,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,<span class=\"number\">0</span>,m<span class=\"number\">-1</span>,target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;matrix, <span class=\"keyword\">int</span> xlow, <span class=\"keyword\">int</span> xhigh, <span class=\"keyword\">int</span> ylow, <span class=\"keyword\">int</span> yhigh, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; xlow &lt;&lt; &quot; &quot; &lt;&lt; xhigh &lt;&lt; endl</span></span><br><span class=\"line\">    <span class=\"comment\">//   &lt;&lt; ylow &lt;&lt; &quot; &quot; &lt;&lt; yhigh &lt;&lt; endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xlow &gt; xhigh || ylow &gt; yhigh) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> xmid = (xlow + xhigh)/<span class=\"number\">2</span>, ymid = (ylow + yhigh)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[xmid][ymid] == target) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (matrix[xmid][ymid] &lt; target) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchMatrix(matrix,xmid + <span class=\"number\">1</span>, xhigh, ylow, yhigh,target) ||</span><br><span class=\"line\">                searchMatrix(matrix,xlow, xhigh, ymid + <span class=\"number\">1</span>, yhigh, target);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchMatrix(matrix, xlow, xmid<span class=\"number\">-1</span>, ylow, yhigh,target) ||</span><br><span class=\"line\">                searchMatrix(matrix,xlow, xhigh, ylow, ymid<span class=\"number\">-1</span>, target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>为什么<code>dicuss</code>的解法大多都是:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = matrix[<span class=\"number\">0</span>].size() - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; matrix.size() &amp;&amp; j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(matrix[i][j] == target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(matrix[i][j] &lt; target)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Search-in-Rotated-Sorted-Array","date":"2017-10-09T12:47:01.000Z","_content":"\n打卡，第16天\n\n失眠的感觉真难受。。。一天都想睡觉，但是却睡不着，sad。\n\n> Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n>\n> (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n>\n> You are given a target value to search. If found in the array return its index, otherwise return -1.\n>\n> You may assume no duplicate exists in the array.\n\n在有序的数组中进行查找，显然第一个想到的就是二分查找啦，不过题目给的数组是多了一个限定条件，就是这个数组被`rotated`了，所以，显然直接用二分查找是不行的。\n\n观察`4 5 6 7 0 1 2`，我们可以发现如果我们可以找到`7`这个位置，我们就可以得到两个有序数组，可以进行二分查找，所以一个简单直观的想法就是：\n\n```c++\nif (nums[first] > nums[last]) {\n    while(last >= 0 && nums[first] > nums[last] && nums[last] < target)\n        last--;\n    while(first <= last &&  nums[first] > nums[last] && nums[first] > target)\n        first++;\n}\n//binarySearch\n```\n\n但是这样的时间复杂度就是`O(n)`了，显然不是我们想要的结果，我们可以对这个转折点进行一次二分查找：\n\n```c++\nif(nums[first] > nums[last]) {\n    int f= first,l = last;\n    //找转折点\n    while(f <= l) {\n        mid = (f + l)/2;\n        if (nums[mid] > nums[mid + 1]) break;\n        else if (nums[mid] > nums[first]) f = mid + 1;\n        else if (nums[mid] < nums[last]) l = mid;\n    }\n    if (target > nums[last]) last = mid;\n    else if (target < nums[first]) first = mid + 1;\n    else if (target == nums[first]) return first;\n    else return last;\n}\n//binary Serarch\n```\n\n这样的时间复杂度就是`O(2*logn)`了。\n\n完整代码：\n\n```c++\nint search(vector<int>& nums, int target) {\n    int first = 0,last = nums.size() - 1;\n    int mid;\n\n    if (last < 0) return -1;\n\n    if(nums[first] > nums[last]) {\n        int f= first,l = last;\n        //找转折点\n        while(f <= l) {\n            mid = (f + l)/2;\n            if (nums[mid] > nums[mid + 1]) break;\n            else if (nums[mid] > nums[first]) f = mid + 1;\n            else if (nums[mid] < nums[last]) l = mid;\n        }\n        if (target > nums[last]) last = mid;\n        else if (target < nums[first]) first = mid + 1;\n        else if (target == nums[first]) return first;\n        else return last;\n    }\n    cout << first << last;\n    //binary search\n    while(first <= last) {\n        int mid = (first + last)/2;\n        if (nums[mid] == target) return mid;\n        else if (nums[mid] < target) first = mid + 1;\n        else last = mid - 1;\n    }\n    return -1;\n}\n```\n\n不过显然这不是最优的方法啦，毕竟要`O(2*logn)`,事实上只需要对二分查找进行修改，就可以直接运用了,恩，这是在`dicuss`中看到的方法：\n\n```java\npublic int search(int[] A, int target) {\n    int lo = 0;\n    int hi = A.length - 1;\n    while (lo < hi) {\n        int mid = (lo + hi) / 2;\n        if (A[mid] == target) return mid;\n\n        if (A[lo] <= A[mid]) {\n            if (target >= A[lo] && target < A[mid]) {\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        } else {\n            if (target > A[mid] && target <= A[hi]) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    return A[lo] == target ? lo : -1;\n}\n```\n","source":"_posts/Search-in-Rotated-Sorted-Array.md","raw":"---\ntitle: Search-in-Rotated-Sorted-Array\ndate: 2017-10-09T20:47:01.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Search\n---\n\n打卡，第16天\n\n失眠的感觉真难受。。。一天都想睡觉，但是却睡不着，sad。\n\n> Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n>\n> (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n>\n> You are given a target value to search. If found in the array return its index, otherwise return -1.\n>\n> You may assume no duplicate exists in the array.\n\n在有序的数组中进行查找，显然第一个想到的就是二分查找啦，不过题目给的数组是多了一个限定条件，就是这个数组被`rotated`了，所以，显然直接用二分查找是不行的。\n\n观察`4 5 6 7 0 1 2`，我们可以发现如果我们可以找到`7`这个位置，我们就可以得到两个有序数组，可以进行二分查找，所以一个简单直观的想法就是：\n\n```c++\nif (nums[first] > nums[last]) {\n    while(last >= 0 && nums[first] > nums[last] && nums[last] < target)\n        last--;\n    while(first <= last &&  nums[first] > nums[last] && nums[first] > target)\n        first++;\n}\n//binarySearch\n```\n\n但是这样的时间复杂度就是`O(n)`了，显然不是我们想要的结果，我们可以对这个转折点进行一次二分查找：\n\n```c++\nif(nums[first] > nums[last]) {\n    int f= first,l = last;\n    //找转折点\n    while(f <= l) {\n        mid = (f + l)/2;\n        if (nums[mid] > nums[mid + 1]) break;\n        else if (nums[mid] > nums[first]) f = mid + 1;\n        else if (nums[mid] < nums[last]) l = mid;\n    }\n    if (target > nums[last]) last = mid;\n    else if (target < nums[first]) first = mid + 1;\n    else if (target == nums[first]) return first;\n    else return last;\n}\n//binary Serarch\n```\n\n这样的时间复杂度就是`O(2*logn)`了。\n\n完整代码：\n\n```c++\nint search(vector<int>& nums, int target) {\n    int first = 0,last = nums.size() - 1;\n    int mid;\n\n    if (last < 0) return -1;\n\n    if(nums[first] > nums[last]) {\n        int f= first,l = last;\n        //找转折点\n        while(f <= l) {\n            mid = (f + l)/2;\n            if (nums[mid] > nums[mid + 1]) break;\n            else if (nums[mid] > nums[first]) f = mid + 1;\n            else if (nums[mid] < nums[last]) l = mid;\n        }\n        if (target > nums[last]) last = mid;\n        else if (target < nums[first]) first = mid + 1;\n        else if (target == nums[first]) return first;\n        else return last;\n    }\n    cout << first << last;\n    //binary search\n    while(first <= last) {\n        int mid = (first + last)/2;\n        if (nums[mid] == target) return mid;\n        else if (nums[mid] < target) first = mid + 1;\n        else last = mid - 1;\n    }\n    return -1;\n}\n```\n\n不过显然这不是最优的方法啦，毕竟要`O(2*logn)`,事实上只需要对二分查找进行修改，就可以直接运用了,恩，这是在`dicuss`中看到的方法：\n\n```java\npublic int search(int[] A, int target) {\n    int lo = 0;\n    int hi = A.length - 1;\n    while (lo < hi) {\n        int mid = (lo + hi) / 2;\n        if (A[mid] == target) return mid;\n\n        if (A[lo] <= A[mid]) {\n            if (target >= A[lo] && target < A[mid]) {\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        } else {\n            if (target > A[mid] && target <= A[hi]) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    return A[lo] == target ? lo : -1;\n}\n```\n","slug":"Search-in-Rotated-Sorted-Array","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pp00dfqmcmh98x2iod","content":"<p>打卡，第16天</p>\n<p>失眠的感觉真难受。。。一天都想睡觉，但是却睡不着，sad。</p>\n<blockquote>\n<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>\n<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>\n<p>You may assume no duplicate exists in the array.</p>\n</blockquote>\n<p>在有序的数组中进行查找，显然第一个想到的就是二分查找啦，不过题目给的数组是多了一个限定条件，就是这个数组被<code>rotated</code>了，所以，显然直接用二分查找是不行的。</p>\n<p>观察<code>4 5 6 7 0 1 2</code>，我们可以发现如果我们可以找到<code>7</code>这个位置，我们就可以得到两个有序数组，可以进行二分查找，所以一个简单直观的想法就是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[first] &gt; nums[last]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(last &gt;= <span class=\"number\">0</span> &amp;&amp; nums[first] &gt; nums[last] &amp;&amp; nums[last] &lt; target)</span><br><span class=\"line\">        last--;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last &amp;&amp;  nums[first] &gt; nums[last] &amp;&amp; nums[first] &gt; target)</span><br><span class=\"line\">        first++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//binarySearch</span></span><br></pre></td></tr></table></figure>\n\n<p>但是这样的时间复杂度就是<code>O(n)</code>了，显然不是我们想要的结果，我们可以对这个转折点进行一次二分查找：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(nums[first] &gt; nums[last]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f= first,l = last;</span><br><span class=\"line\">    <span class=\"comment\">//找转折点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(f &lt;= l) &#123;</span><br><span class=\"line\">        mid = (f + l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] &gt; nums[mid + <span class=\"number\">1</span>]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; nums[first]) f = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; nums[last]) l = mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target &gt; nums[last]) last = mid;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[first]) first = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target == nums[first]) <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//binary Serarch</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的时间复杂度就是<code>O(2*logn)</code>了。</p>\n<p>完整代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = <span class=\"number\">0</span>,last = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[first] &gt; nums[last]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> f= first,l = last;</span><br><span class=\"line\">        <span class=\"comment\">//找转折点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(f &lt;= l) &#123;</span><br><span class=\"line\">            mid = (f + l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; nums[mid + <span class=\"number\">1</span>]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; nums[first]) f = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; nums[last]) l = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &gt; nums[last]) last = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[first]) first = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target == nums[first]) <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; first &lt;&lt; last;</span><br><span class=\"line\">    <span class=\"comment\">//binary search</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (first + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] == target) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) first = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> last = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过显然这不是最优的方法啦，毕竟要<code>O(2*logn)</code>,事实上只需要对二分查找进行修改，就可以直接运用了,恩，这是在<code>dicuss</code>中看到的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>[] A, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hi = A.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (lo + hi) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[mid] == target) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[lo] &lt;= A[mid]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123;</span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A[lo] == target ? lo : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>打卡，第16天</p>\n<p>失眠的感觉真难受。。。一天都想睡觉，但是却睡不着，sad。</p>\n<blockquote>\n<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>\n<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>\n<p>You may assume no duplicate exists in the array.</p>\n</blockquote>\n<p>在有序的数组中进行查找，显然第一个想到的就是二分查找啦，不过题目给的数组是多了一个限定条件，就是这个数组被<code>rotated</code>了，所以，显然直接用二分查找是不行的。</p>\n<p>观察<code>4 5 6 7 0 1 2</code>，我们可以发现如果我们可以找到<code>7</code>这个位置，我们就可以得到两个有序数组，可以进行二分查找，所以一个简单直观的想法就是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[first] &gt; nums[last]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(last &gt;= <span class=\"number\">0</span> &amp;&amp; nums[first] &gt; nums[last] &amp;&amp; nums[last] &lt; target)</span><br><span class=\"line\">        last--;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last &amp;&amp;  nums[first] &gt; nums[last] &amp;&amp; nums[first] &gt; target)</span><br><span class=\"line\">        first++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//binarySearch</span></span><br></pre></td></tr></table></figure>\n\n<p>但是这样的时间复杂度就是<code>O(n)</code>了，显然不是我们想要的结果，我们可以对这个转折点进行一次二分查找：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(nums[first] &gt; nums[last]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f= first,l = last;</span><br><span class=\"line\">    <span class=\"comment\">//找转折点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(f &lt;= l) &#123;</span><br><span class=\"line\">        mid = (f + l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] &gt; nums[mid + <span class=\"number\">1</span>]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; nums[first]) f = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; nums[last]) l = mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target &gt; nums[last]) last = mid;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[first]) first = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target == nums[first]) <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//binary Serarch</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的时间复杂度就是<code>O(2*logn)</code>了。</p>\n<p>完整代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = <span class=\"number\">0</span>,last = nums.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[first] &gt; nums[last]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> f= first,l = last;</span><br><span class=\"line\">        <span class=\"comment\">//找转折点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(f &lt;= l) &#123;</span><br><span class=\"line\">            mid = (f + l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; nums[mid + <span class=\"number\">1</span>]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; nums[first]) f = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; nums[last]) l = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &gt; nums[last]) last = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[first]) first = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target == nums[first]) <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; first &lt;&lt; last;</span><br><span class=\"line\">    <span class=\"comment\">//binary search</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (first + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] == target) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) first = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> last = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过显然这不是最优的方法啦，毕竟要<code>O(2*logn)</code>,事实上只需要对二分查找进行修改，就可以直接运用了,恩，这是在<code>dicuss</code>中看到的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>[] A, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hi = A.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (lo + hi) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[mid] == target) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[lo] &lt;= A[mid]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123;</span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123;</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A[lo] == target ? lo : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Serialize and Deserialize BST","originContent":"","toc":false,"date":"2019-11-07T03:48:04.000Z","_content":"\n# Serialize and Deserialize BST\n\n> 第三天。\n\n今天的题是[https://leetcode.com/problems/serialize-and-deserialize-bst/](Serialize and Deserialize BST):\n\n---\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a **binary search tree**. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n**The encoded string should be as compact as possible.**\n\n**Note:** Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\n\n---\n\n这个题目需要我们实现两个函数，一个对BST进行序列化，一个对BST进行反序列化。总的来说对算法要求不高（时间上），但是要求序列化出来的字符串尽量小。\n\n首先要解决两个问题：\n\n- 如何序列化一个正常节点\n- 如何序列化一个NULL节点\n\n这里面我们采取这样一个方法，一个正常的节点由以下结构组成：\n\n```c++\nstruct {\n\tchar flag = 'Y';\n\tunion INT {\n\t\tint iv;\n\t\tchar cv[4];\n\t};\n};\n```\n\n其中flag来标识，这是一个正常的节点，而INT则是存放节点的值，通过`union`,我们可以方便的将int转换为char数组。\n\n一个NULL的节点当然也可以通过上面的结构组成，但是对于NULL节点来说，后面的INT其实没有必要，所以我们直接通过字符`N`来标识NULL节点。\n\n因此，我们的实现如下：\n\n\n```c++\nclass Codec {\npublic:\n    \n    union INT {\n        int iv;\n        unsigned char cv[4];\n    };\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string str;\n        serialize(root, str);\n        return str;\n    }\n    \n    void serialize(TreeNode *root, string &str) {\n        if (root == NULL) {\n            \n            str.push_back('N');\n            return;\n        }\n        \n        INT val;\n        val.iv = root->val;\n        \n        str.push_back('Y');\n        for(int i = 0;i < 4;i++) { \n            str.push_back(val.cv[i]);\n        }\n        \n        \n        serialize(root->left, str);\n        serialize(root->right, str);\n    }\n    \n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        int index = 0;\n        return deserialize(data, index);\n    }\n    \n    TreeNode *deserialize(string &data, int &index) {\n        if (index >= data.size() || data[index] == 'N') {\n            index += 1;\n            return nullptr;  \n        } \n        index += 1;\n        INT val;\n        for(int i = 0;i < 4;i++) val.cv[i] = (unsigned char)data[index + i];\n        \n        \n        index += 4;\n        TreeNode *root = new TreeNode(val.iv);\n        root->left = deserialize(data, index);\n        root->right = deserialize(data, index);\n         \n        return root;\n    }\n};\n```\n","source":"_posts/Serialize-and-Deserialize-BST.md","raw":"---\ntitle: Serialize and Deserialize BST\ntags:\n  - LeetCode\n  - 二叉树\ncategories:\n  - LeetCode\noriginContent: ''\ntoc: false\ndate: 2019-11-07T11:48:04.000Z\n---\n\n# Serialize and Deserialize BST\n\n> 第三天。\n\n今天的题是[https://leetcode.com/problems/serialize-and-deserialize-bst/](Serialize and Deserialize BST):\n\n---\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a **binary search tree**. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n**The encoded string should be as compact as possible.**\n\n**Note:** Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\n\n---\n\n这个题目需要我们实现两个函数，一个对BST进行序列化，一个对BST进行反序列化。总的来说对算法要求不高（时间上），但是要求序列化出来的字符串尽量小。\n\n首先要解决两个问题：\n\n- 如何序列化一个正常节点\n- 如何序列化一个NULL节点\n\n这里面我们采取这样一个方法，一个正常的节点由以下结构组成：\n\n```c++\nstruct {\n\tchar flag = 'Y';\n\tunion INT {\n\t\tint iv;\n\t\tchar cv[4];\n\t};\n};\n```\n\n其中flag来标识，这是一个正常的节点，而INT则是存放节点的值，通过`union`,我们可以方便的将int转换为char数组。\n\n一个NULL的节点当然也可以通过上面的结构组成，但是对于NULL节点来说，后面的INT其实没有必要，所以我们直接通过字符`N`来标识NULL节点。\n\n因此，我们的实现如下：\n\n\n```c++\nclass Codec {\npublic:\n    \n    union INT {\n        int iv;\n        unsigned char cv[4];\n    };\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string str;\n        serialize(root, str);\n        return str;\n    }\n    \n    void serialize(TreeNode *root, string &str) {\n        if (root == NULL) {\n            \n            str.push_back('N');\n            return;\n        }\n        \n        INT val;\n        val.iv = root->val;\n        \n        str.push_back('Y');\n        for(int i = 0;i < 4;i++) { \n            str.push_back(val.cv[i]);\n        }\n        \n        \n        serialize(root->left, str);\n        serialize(root->right, str);\n    }\n    \n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        int index = 0;\n        return deserialize(data, index);\n    }\n    \n    TreeNode *deserialize(string &data, int &index) {\n        if (index >= data.size() || data[index] == 'N') {\n            index += 1;\n            return nullptr;  \n        } \n        index += 1;\n        INT val;\n        for(int i = 0;i < 4;i++) val.cv[i] = (unsigned char)data[index + i];\n        \n        \n        index += 4;\n        TreeNode *root = new TreeNode(val.iv);\n        root->left = deserialize(data, index);\n        root->right = deserialize(data, index);\n         \n        return root;\n    }\n};\n```\n","slug":"Serialize-and-Deserialize-BST","published":1,"updated":"2021-03-10T13:47:05.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pq00diqmcmdgzycmmc","content":"<h1 id=\"Serialize-and-Deserialize-BST\"><a href=\"#Serialize-and-Deserialize-BST\" class=\"headerlink\" title=\"Serialize and Deserialize BST\"></a>Serialize and Deserialize BST</h1><blockquote>\n<p>第三天。</p>\n</blockquote>\n<p>今天的题是[<a href=\"https://leetcode.com/problems/serialize-and-deserialize-bst/]\">https://leetcode.com/problems/serialize-and-deserialize-bst/]</a>(Serialize and Deserialize BST):</p>\n<hr>\n<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n<p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n<p><strong>The encoded string should be as compact as possible.</strong></p>\n<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>\n<hr>\n<p>这个题目需要我们实现两个函数，一个对BST进行序列化，一个对BST进行反序列化。总的来说对算法要求不高（时间上），但是要求序列化出来的字符串尽量小。</p>\n<p>首先要解决两个问题：</p>\n<ul>\n<li>如何序列化一个正常节点</li>\n<li>如何序列化一个NULL节点</li>\n</ul>\n<p>这里面我们采取这样一个方法，一个正常的节点由以下结构组成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> flag = <span class=\"string\">&#x27;Y&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">INT</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> iv;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> cv[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中flag来标识，这是一个正常的节点，而INT则是存放节点的值，通过<code>union</code>,我们可以方便的将int转换为char数组。</p>\n<p>一个NULL的节点当然也可以通过上面的结构组成，但是对于NULL节点来说，后面的INT其实没有必要，所以我们直接通过字符<code>N</code>来标识NULL节点。</p>\n<p>因此，我们的实现如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Codec</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">INT</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> iv;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> cv[<span class=\"number\">4</span>];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Encodes a tree to a single string.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">serialize</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">        serialize(root, str);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">serialize</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">string</span> &amp;str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            str.push_back(<span class=\"string\">&#x27;N&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        INT val;</span><br><span class=\"line\">        val.iv = root-&gt;val;</span><br><span class=\"line\">        </span><br><span class=\"line\">        str.push_back(<span class=\"string\">&#x27;Y&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">4</span>;i++) &#123; </span><br><span class=\"line\">            str.push_back(val.cv[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        serialize(root-&gt;left, str);</span><br><span class=\"line\">        serialize(root-&gt;right, str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Decodes your encoded data to tree.</span></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">deserialize</span><span class=\"params\">(<span class=\"built_in\">string</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> deserialize(data, index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">TreeNode *<span class=\"title\">deserialize</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;data, <span class=\"keyword\">int</span> &amp;index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= data.size() || data[index] == <span class=\"string\">&#x27;N&#x27;</span>) &#123;</span><br><span class=\"line\">            index += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;  </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        index += <span class=\"number\">1</span>;</span><br><span class=\"line\">        INT val;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">4</span>;i++) val.cv[i] = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)data[index + i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        index += <span class=\"number\">4</span>;</span><br><span class=\"line\">        TreeNode *root = <span class=\"keyword\">new</span> TreeNode(val.iv);</span><br><span class=\"line\">        root-&gt;left = deserialize(data, index);</span><br><span class=\"line\">        root-&gt;right = deserialize(data, index);</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Serialize-and-Deserialize-BST\"><a href=\"#Serialize-and-Deserialize-BST\" class=\"headerlink\" title=\"Serialize and Deserialize BST\"></a>Serialize and Deserialize BST</h1><blockquote>\n<p>第三天。</p>\n</blockquote>\n<p>今天的题是[<a href=\"https://leetcode.com/problems/serialize-and-deserialize-bst/]\">https://leetcode.com/problems/serialize-and-deserialize-bst/]</a>(Serialize and Deserialize BST):</p>\n<hr>\n<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n<p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n<p><strong>The encoded string should be as compact as possible.</strong></p>\n<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>\n<hr>\n<p>这个题目需要我们实现两个函数，一个对BST进行序列化，一个对BST进行反序列化。总的来说对算法要求不高（时间上），但是要求序列化出来的字符串尽量小。</p>\n<p>首先要解决两个问题：</p>\n<ul>\n<li>如何序列化一个正常节点</li>\n<li>如何序列化一个NULL节点</li>\n</ul>\n<p>这里面我们采取这样一个方法，一个正常的节点由以下结构组成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> flag = <span class=\"string\">&#x27;Y&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">INT</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> iv;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> cv[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中flag来标识，这是一个正常的节点，而INT则是存放节点的值，通过<code>union</code>,我们可以方便的将int转换为char数组。</p>\n<p>一个NULL的节点当然也可以通过上面的结构组成，但是对于NULL节点来说，后面的INT其实没有必要，所以我们直接通过字符<code>N</code>来标识NULL节点。</p>\n<p>因此，我们的实现如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Codec</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">INT</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> iv;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> cv[<span class=\"number\">4</span>];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Encodes a tree to a single string.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">serialize</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">        serialize(root, str);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">serialize</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">string</span> &amp;str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            str.push_back(<span class=\"string\">&#x27;N&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        INT val;</span><br><span class=\"line\">        val.iv = root-&gt;val;</span><br><span class=\"line\">        </span><br><span class=\"line\">        str.push_back(<span class=\"string\">&#x27;Y&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">4</span>;i++) &#123; </span><br><span class=\"line\">            str.push_back(val.cv[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        serialize(root-&gt;left, str);</span><br><span class=\"line\">        serialize(root-&gt;right, str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Decodes your encoded data to tree.</span></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">deserialize</span><span class=\"params\">(<span class=\"built_in\">string</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> deserialize(data, index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">TreeNode *<span class=\"title\">deserialize</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;data, <span class=\"keyword\">int</span> &amp;index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= data.size() || data[index] == <span class=\"string\">&#x27;N&#x27;</span>) &#123;</span><br><span class=\"line\">            index += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;  </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        index += <span class=\"number\">1</span>;</span><br><span class=\"line\">        INT val;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">4</span>;i++) val.cv[i] = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)data[index + i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        index += <span class=\"number\">4</span>;</span><br><span class=\"line\">        TreeNode *root = <span class=\"keyword\">new</span> TreeNode(val.iv);</span><br><span class=\"line\">        root-&gt;left = deserialize(data, index);</span><br><span class=\"line\">        root-&gt;right = deserialize(data, index);</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Shifting Letters","date":"2019-11-30T07:05:17.000Z","_content":"\n\n> 第25天。我决定以后不贴题目了。\n\n今天的题目是[Shifting Letters](https://leetcode.com/problems/shifting-letters/)。\n\n\n---\n\n\n混进 Medium 的 Easy 题目，简单的取模和循环就能解决的问题。\n\n代码如下：\n\n\n```c++\nstring shiftingLetters(string S, vector<int>& shifts) {\n    int temp = 0;\n    for(int i = shifts.size() - 1 ; i >= 0; --i) {\n        temp = (shifts[i] + temp) % 26;\n        S[i] = ((S[i] - 'a') + temp) % 26 + 'a';\n        // cout << shifts[i] << endl;\n    }\n    return S;\n}\n```\n","source":"_posts/Shifting-Letters.md","raw":"---\ntitle: Shifting Letters\ndate: 2019-11-30T15:05:17.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n\n> 第25天。我决定以后不贴题目了。\n\n今天的题目是[Shifting Letters](https://leetcode.com/problems/shifting-letters/)。\n\n\n---\n\n\n混进 Medium 的 Easy 题目，简单的取模和循环就能解决的问题。\n\n代码如下：\n\n\n```c++\nstring shiftingLetters(string S, vector<int>& shifts) {\n    int temp = 0;\n    for(int i = shifts.size() - 1 ; i >= 0; --i) {\n        temp = (shifts[i] + temp) % 26;\n        S[i] = ((S[i] - 'a') + temp) % 26 + 'a';\n        // cout << shifts[i] << endl;\n    }\n    return S;\n}\n```\n","slug":"Shifting-Letters","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pq00dmqmcma6g7hg1f","content":"<blockquote>\n<p>第25天。我决定以后不贴题目了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/shifting-letters/\">Shifting Letters</a>。</p>\n<hr>\n<p>混进 Medium 的 Easy 题目，简单的取模和循环就能解决的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">shiftingLetters</span><span class=\"params\">(<span class=\"built_in\">string</span> S, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = shifts.size() - <span class=\"number\">1</span> ; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        temp = (shifts[i] + temp) % <span class=\"number\">26</span>;</span><br><span class=\"line\">        S[i] = ((S[i] - <span class=\"string\">&#x27;a&#x27;</span>) + temp) % <span class=\"number\">26</span> + <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; shifts[i] &lt;&lt; endl;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> S;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第25天。我决定以后不贴题目了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/shifting-letters/\">Shifting Letters</a>。</p>\n<hr>\n<p>混进 Medium 的 Easy 题目，简单的取模和循环就能解决的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">shiftingLetters</span><span class=\"params\">(<span class=\"built_in\">string</span> S, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = shifts.size() - <span class=\"number\">1</span> ; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        temp = (shifts[i] + temp) % <span class=\"number\">26</span>;</span><br><span class=\"line\">        S[i] = ((S[i] - <span class=\"string\">&#x27;a&#x27;</span>) + temp) % <span class=\"number\">26</span> + <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; shifts[i] &lt;&lt; endl;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> S;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Simplify Path","date":"2019-03-02T15:27:32.000Z","_content":"\n> 第三天（hhh，好像又很久没刷了）, 又AC掉了逻辑题，或者说又是一道用`if else`加状态机搞定的题。\n\n今天的题目是[71. Simplify Path](https://leetcode.com/problems/simplify-path/)\n\n以后还是不`copy`题目到这里来了，有点麻烦的感觉。。。\n\n对于这种纯看逻辑的题目，可以先分析一下给出的测例，然后通过题目来分析要注意什么：\n\n1. \"/home/\"\n2. \"/../\"\n3. \"/home//foo/\"\n4. \"/a/./b/../../c/\"\n5. \"/a/../../b/../c//.//\"\n6. \"/a//b////c/d//././/..\"\n\n从上面我们大概可以知道要注意的一些点有：\n\n- 首先疑似最开始的符号一定是'/'？\n- 通过`/`来分割单词，这意味着我们可以用`python`中的`split`或者先做一次遍历来分割单词，这样做会简化逻辑（但我没用这种方法）\n- 要区分`.`和`..`\n- `.`表示当前目录，`..`表示上级目录\n- 遇到多个`/`，就当成一个\n\n事实上在后面的测试中，我发现一个很坑的点，就是`...`和`..a`这种并不是一个特殊的字符串，可以作为路径名。\n\n我们现在尝试写一个基于状态机的方法，首先定义一下遍历时需要的状态：\n\n\n0. 前面是一个正常的字符\n    - 遇到`/`,就插入到结果字符串中，并跳转到`1`。\n    - 遇到`.`，就跳转到`2`。\n    - 遇到一个正常的字符，插入到结果字符串中。\n1. 前面是`/`\n    - 如果遇到一个`/`，就直接跳过\n    - 如果遇到一个`.`,跳转到`2`\n    - 如果是一个正常字符，就插入到结果字符串中并跳转到`0`\n2. 前面是`.`\n    - 如果遇到一个`/`, 就跳转到`1`\n    - 如果遇到一个`.`,就跳转到`3`\n    - 如果遇到一个正常字符，就插入`.`和这个字符，并跳转到`0`\n3. 前面是`..`\n    - 如果遇到一个`/`,就开始回溯删除到前面一个`/`\n    - 其余则插入一个`..`和这个字符，并跳转到`0`\n\n\n```c++\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        string res;\n        \n        // some flag to kepp state.\n        int state = 0;  // 0: last char is [char]\n                        // 1: last char is '/'\n                        // 2: last char is '.'\n                        // 3: last char is \"..\"\n        \n        if (path.size() != 0 && path[path.size()-1]!='/') path.push_back('/');\n        \n        int len = path.size();\n        for(int i = 0; i < len; i++) {\n            char c = path[i];\n            \n            if (state == 0) {\n                if (c == '/') { res.push_back('/'); state = 1; }\n                else if (c == '.') state = 2;\n                else res.push_back(c);\n            } else if (state == 1) {\n                if (c == '/') {}\n                else if (c == '.') { state = 2; }\n                else {\n                    res.push_back(c); state = 0;\n                }\n            } else if (state == 2) {\n                if (c == '/') state = 1;\n                else if (c == '.') {\n                    // '..'\n                    state = 3;\n                } else {\n                    res.push_back('.'); res.push_back(c); state = 0;\n                }\n            } else if (state == 3) {\n                if (c == '/') {\n                    // go back\n                    res.pop_back(); // pop '/'\n                    while(res.size() != 0 && *res.rbegin() != '/') {\n                        res.pop_back(); // pop anthing until '/'\n                    }\n                    if (res.size() == 0) res.push_back('/');\n                    state = 1;\n                } else {\n                    res.push_back('.'); \n                    res.push_back('.');\n                    res.push_back(c);\n                    state = 0;\n                }\n            }\n            //cout << state << \" \" << c << \" \" << res <<  endl;\n        }\n        \n        if ((state == 1 && res.size() != 1)) res.pop_back();\n        return res;\n    }\n};\n```\n\n> update at 2020-03-23\n\n状态转移图：\n\n![FSM](https://g.gravizo.com/svg?%20digraph%20G%20{%20State0%20[shape%20=%20circle]%20State1%20[shape%20=%20circle]%20State2%20[shape%20=%20circle]%20State3%20[shape%20=%20circle]%20State0%20-%3E%20State1%20[label%20=%20%22slash%22];%20State0%20-%3E%20State0%20[label%20=%20%22char%22];%20State0%20-%3E%20State2%20[label%20=%20%22point%22];%20State1%20-%3E%20State0%20[label%20=%20%22char%22];%20State1%20-%3E%20State1%20[label%20=%20%22slash%22];%20State1%20-%3E%20State2%20[label%20=%20%22point%22];%20State2%20-%3E%20State3%20[label%20=%20%22point%22];%20State2%20-%3E%20State0%20[label%20=%20%22char%22];%20State2%20-%3E%20State1%20[label%20=%20%22slash%22];%20State3%20-%3E%20State0%20[label%20=%20%22char%20and%20point%22];%20State3%20-%3E%20State1%20[label%20=%20%22slash%22];%20})\n\n这道题其实用栈会更简单一点：\n\n```c++\nstring simplifyPath(string path) {\n    \n    vector<string> st;\n    int beg = 0;\n    path.push_back('/');\n    for(int i = 0, sz = path.size(); i < sz; i++) {\n        if (path[i] == '/') {\n            auto s = path.substr(beg, i-beg);\n            beg = i + 1;\n            if (s == \".\" || s.size() == 0) {\n                // do nothing\n            } else if (s == \"..\") {\n                if (st.size() != 0) st.pop_back(); // make sure '/../' is ok\n            } else st.push_back(s);\n        }\n    }\n    string res;\n    for(auto &s: st) {\n        // cout << s << endl;\n        res.push_back('/');\n        res += s;\n    }\n    if (res.size() == 0) res.push_back('/'); \n    return res;\n}\n```\n\n用`stringstream`和`getline`来进行字符串分割：\n\n```c++\nstring simplifyPath(string path) {\n    string buf;\n    istringstream ss(path);\n    vector<string> st;\n    while(getline(ss, buf, '/')) {\n        // cout << buf << endl;\n        if (buf == \".\" || buf.size() == 0) {\n\n        } else if (buf == \"..\"){\n            if (st.size() != 0) st.pop_back();\n        }\n        else st.push_back(buf);\n    }\n    string res;\n    for (auto &s: st) {\n        res.push_back('/');\n        res += s;\n    }\n    if (res.size() == 0) res.push_back('/');\n    return res;\n}\n```\n","source":"_posts/Simplify-Path.md","raw":"---\ntitle: Simplify Path\ndate: 2019-03-02T23:27:32.000Z\ntags:\n  - LeetCode\n  - Stack\n  - FSM\n  - String\ncategories:\n  - LeetCode\n---\n\n> 第三天（hhh，好像又很久没刷了）, 又AC掉了逻辑题，或者说又是一道用`if else`加状态机搞定的题。\n\n今天的题目是[71. Simplify Path](https://leetcode.com/problems/simplify-path/)\n\n以后还是不`copy`题目到这里来了，有点麻烦的感觉。。。\n\n对于这种纯看逻辑的题目，可以先分析一下给出的测例，然后通过题目来分析要注意什么：\n\n1. \"/home/\"\n2. \"/../\"\n3. \"/home//foo/\"\n4. \"/a/./b/../../c/\"\n5. \"/a/../../b/../c//.//\"\n6. \"/a//b////c/d//././/..\"\n\n从上面我们大概可以知道要注意的一些点有：\n\n- 首先疑似最开始的符号一定是'/'？\n- 通过`/`来分割单词，这意味着我们可以用`python`中的`split`或者先做一次遍历来分割单词，这样做会简化逻辑（但我没用这种方法）\n- 要区分`.`和`..`\n- `.`表示当前目录，`..`表示上级目录\n- 遇到多个`/`，就当成一个\n\n事实上在后面的测试中，我发现一个很坑的点，就是`...`和`..a`这种并不是一个特殊的字符串，可以作为路径名。\n\n我们现在尝试写一个基于状态机的方法，首先定义一下遍历时需要的状态：\n\n\n0. 前面是一个正常的字符\n    - 遇到`/`,就插入到结果字符串中，并跳转到`1`。\n    - 遇到`.`，就跳转到`2`。\n    - 遇到一个正常的字符，插入到结果字符串中。\n1. 前面是`/`\n    - 如果遇到一个`/`，就直接跳过\n    - 如果遇到一个`.`,跳转到`2`\n    - 如果是一个正常字符，就插入到结果字符串中并跳转到`0`\n2. 前面是`.`\n    - 如果遇到一个`/`, 就跳转到`1`\n    - 如果遇到一个`.`,就跳转到`3`\n    - 如果遇到一个正常字符，就插入`.`和这个字符，并跳转到`0`\n3. 前面是`..`\n    - 如果遇到一个`/`,就开始回溯删除到前面一个`/`\n    - 其余则插入一个`..`和这个字符，并跳转到`0`\n\n\n```c++\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        string res;\n        \n        // some flag to kepp state.\n        int state = 0;  // 0: last char is [char]\n                        // 1: last char is '/'\n                        // 2: last char is '.'\n                        // 3: last char is \"..\"\n        \n        if (path.size() != 0 && path[path.size()-1]!='/') path.push_back('/');\n        \n        int len = path.size();\n        for(int i = 0; i < len; i++) {\n            char c = path[i];\n            \n            if (state == 0) {\n                if (c == '/') { res.push_back('/'); state = 1; }\n                else if (c == '.') state = 2;\n                else res.push_back(c);\n            } else if (state == 1) {\n                if (c == '/') {}\n                else if (c == '.') { state = 2; }\n                else {\n                    res.push_back(c); state = 0;\n                }\n            } else if (state == 2) {\n                if (c == '/') state = 1;\n                else if (c == '.') {\n                    // '..'\n                    state = 3;\n                } else {\n                    res.push_back('.'); res.push_back(c); state = 0;\n                }\n            } else if (state == 3) {\n                if (c == '/') {\n                    // go back\n                    res.pop_back(); // pop '/'\n                    while(res.size() != 0 && *res.rbegin() != '/') {\n                        res.pop_back(); // pop anthing until '/'\n                    }\n                    if (res.size() == 0) res.push_back('/');\n                    state = 1;\n                } else {\n                    res.push_back('.'); \n                    res.push_back('.');\n                    res.push_back(c);\n                    state = 0;\n                }\n            }\n            //cout << state << \" \" << c << \" \" << res <<  endl;\n        }\n        \n        if ((state == 1 && res.size() != 1)) res.pop_back();\n        return res;\n    }\n};\n```\n\n> update at 2020-03-23\n\n状态转移图：\n\n![FSM](https://g.gravizo.com/svg?%20digraph%20G%20{%20State0%20[shape%20=%20circle]%20State1%20[shape%20=%20circle]%20State2%20[shape%20=%20circle]%20State3%20[shape%20=%20circle]%20State0%20-%3E%20State1%20[label%20=%20%22slash%22];%20State0%20-%3E%20State0%20[label%20=%20%22char%22];%20State0%20-%3E%20State2%20[label%20=%20%22point%22];%20State1%20-%3E%20State0%20[label%20=%20%22char%22];%20State1%20-%3E%20State1%20[label%20=%20%22slash%22];%20State1%20-%3E%20State2%20[label%20=%20%22point%22];%20State2%20-%3E%20State3%20[label%20=%20%22point%22];%20State2%20-%3E%20State0%20[label%20=%20%22char%22];%20State2%20-%3E%20State1%20[label%20=%20%22slash%22];%20State3%20-%3E%20State0%20[label%20=%20%22char%20and%20point%22];%20State3%20-%3E%20State1%20[label%20=%20%22slash%22];%20})\n\n这道题其实用栈会更简单一点：\n\n```c++\nstring simplifyPath(string path) {\n    \n    vector<string> st;\n    int beg = 0;\n    path.push_back('/');\n    for(int i = 0, sz = path.size(); i < sz; i++) {\n        if (path[i] == '/') {\n            auto s = path.substr(beg, i-beg);\n            beg = i + 1;\n            if (s == \".\" || s.size() == 0) {\n                // do nothing\n            } else if (s == \"..\") {\n                if (st.size() != 0) st.pop_back(); // make sure '/../' is ok\n            } else st.push_back(s);\n        }\n    }\n    string res;\n    for(auto &s: st) {\n        // cout << s << endl;\n        res.push_back('/');\n        res += s;\n    }\n    if (res.size() == 0) res.push_back('/'); \n    return res;\n}\n```\n\n用`stringstream`和`getline`来进行字符串分割：\n\n```c++\nstring simplifyPath(string path) {\n    string buf;\n    istringstream ss(path);\n    vector<string> st;\n    while(getline(ss, buf, '/')) {\n        // cout << buf << endl;\n        if (buf == \".\" || buf.size() == 0) {\n\n        } else if (buf == \"..\"){\n            if (st.size() != 0) st.pop_back();\n        }\n        else st.push_back(buf);\n    }\n    string res;\n    for (auto &s: st) {\n        res.push_back('/');\n        res += s;\n    }\n    if (res.size() == 0) res.push_back('/');\n    return res;\n}\n```\n","slug":"Simplify-Path","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pr00dpqmcm2g3w9thp","content":"<blockquote>\n<p>第三天（hhh，好像又很久没刷了）, 又AC掉了逻辑题，或者说又是一道用<code>if else</code>加状态机搞定的题。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/simplify-path/\">71. Simplify Path</a></p>\n<p>以后还是不<code>copy</code>题目到这里来了，有点麻烦的感觉。。。</p>\n<p>对于这种纯看逻辑的题目，可以先分析一下给出的测例，然后通过题目来分析要注意什么：</p>\n<ol>\n<li>“/home/“</li>\n<li>“/../“</li>\n<li>“/home//foo/“</li>\n<li>“/a/./b/../../c/“</li>\n<li>“/a/../../b/../c//.//“</li>\n<li>“/a//b////c/d//././/..”</li>\n</ol>\n<p>从上面我们大概可以知道要注意的一些点有：</p>\n<ul>\n<li>首先疑似最开始的符号一定是’/‘？</li>\n<li>通过<code>/</code>来分割单词，这意味着我们可以用<code>python</code>中的<code>split</code>或者先做一次遍历来分割单词，这样做会简化逻辑（但我没用这种方法）</li>\n<li>要区分<code>.</code>和<code>..</code></li>\n<li><code>.</code>表示当前目录，<code>..</code>表示上级目录</li>\n<li>遇到多个<code>/</code>，就当成一个</li>\n</ul>\n<p>事实上在后面的测试中，我发现一个很坑的点，就是<code>...</code>和<code>..a</code>这种并不是一个特殊的字符串，可以作为路径名。</p>\n<p>我们现在尝试写一个基于状态机的方法，首先定义一下遍历时需要的状态：</p>\n<ol start=\"0\">\n<li>前面是一个正常的字符<ul>\n<li>遇到<code>/</code>,就插入到结果字符串中，并跳转到<code>1</code>。</li>\n<li>遇到<code>.</code>，就跳转到<code>2</code>。</li>\n<li>遇到一个正常的字符，插入到结果字符串中。</li>\n</ul>\n</li>\n<li>前面是<code>/</code><ul>\n<li>如果遇到一个<code>/</code>，就直接跳过</li>\n<li>如果遇到一个<code>.</code>,跳转到<code>2</code></li>\n<li>如果是一个正常字符，就插入到结果字符串中并跳转到<code>0</code></li>\n</ul>\n</li>\n<li>前面是<code>.</code><ul>\n<li>如果遇到一个<code>/</code>, 就跳转到<code>1</code></li>\n<li>如果遇到一个<code>.</code>,就跳转到<code>3</code></li>\n<li>如果遇到一个正常字符，就插入<code>.</code>和这个字符，并跳转到<code>0</code></li>\n</ul>\n</li>\n<li>前面是<code>..</code><ul>\n<li>如果遇到一个<code>/</code>,就开始回溯删除到前面一个<code>/</code></li>\n<li>其余则插入一个<code>..</code>和这个字符，并跳转到<code>0</code></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// some flag to kepp state.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> state = <span class=\"number\">0</span>;  <span class=\"comment\">// 0: last char is [char]</span></span><br><span class=\"line\">                        <span class=\"comment\">// 1: last char is &#x27;/&#x27;</span></span><br><span class=\"line\">                        <span class=\"comment\">// 2: last char is &#x27;.&#x27;</span></span><br><span class=\"line\">                        <span class=\"comment\">// 3: last char is &quot;..&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() != <span class=\"number\">0</span> &amp;&amp; path[path.size()<span class=\"number\">-1</span>]!=<span class=\"string\">&#x27;/&#x27;</span>) path.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = path.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = path[i];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (state == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;/&#x27;</span>) &#123; res.push_back(<span class=\"string\">&#x27;/&#x27;</span>); state = <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) state = <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> res.push_back(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;/&#x27;</span>) &#123;&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123; state = <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.push_back(c); state = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;/&#x27;</span>) state = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// &#x27;..&#x27;</span></span><br><span class=\"line\">                    state = <span class=\"number\">3</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.push_back(<span class=\"string\">&#x27;.&#x27;</span>); res.push_back(c); state = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// go back</span></span><br><span class=\"line\">                    res.pop_back(); <span class=\"comment\">// pop &#x27;/&#x27;</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(res.size() != <span class=\"number\">0</span> &amp;&amp; *res.rbegin() != <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">                        res.pop_back(); <span class=\"comment\">// pop anthing until &#x27;/&#x27;</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (res.size() == <span class=\"number\">0</span>) res.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">                    state = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.push_back(<span class=\"string\">&#x27;.&#x27;</span>); </span><br><span class=\"line\">                    res.push_back(<span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">                    res.push_back(c);</span><br><span class=\"line\">                    state = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; state &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; res &lt;&lt;  endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((state == <span class=\"number\">1</span> &amp;&amp; res.size() != <span class=\"number\">1</span>)) res.pop_back();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>update at 2020-03-23</p>\n</blockquote>\n<p>状态转移图：</p>\n<p><img src=\"https://g.gravizo.com/svg?%20digraph%20G%20%7B%20State0%20%5Bshape%20=%20circle%5D%20State1%20%5Bshape%20=%20circle%5D%20State2%20%5Bshape%20=%20circle%5D%20State3%20%5Bshape%20=%20circle%5D%20State0%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20State0%20-%3E%20State0%20%5Blabel%20=%20%22char%22%5D;%20State0%20-%3E%20State2%20%5Blabel%20=%20%22point%22%5D;%20State1%20-%3E%20State0%20%5Blabel%20=%20%22char%22%5D;%20State1%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20State1%20-%3E%20State2%20%5Blabel%20=%20%22point%22%5D;%20State2%20-%3E%20State3%20%5Blabel%20=%20%22point%22%5D;%20State2%20-%3E%20State0%20%5Blabel%20=%20%22char%22%5D;%20State2%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20State3%20-%3E%20State0%20%5Blabel%20=%20%22char%20and%20point%22%5D;%20State3%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20%7D\" alt=\"FSM\"></p>\n<p>这道题其实用栈会更简单一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    path.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, sz = path.size(); i &lt; sz; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path[i] == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> s = path.substr(beg, i-beg);</span><br><span class=\"line\">            beg = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s == <span class=\"string\">&quot;.&quot;</span> || s.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s == <span class=\"string\">&quot;..&quot;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (st.size() != <span class=\"number\">0</span>) st.pop_back(); <span class=\"comment\">// make sure &#x27;/../&#x27; is ok</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> st.push_back(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s: st) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class=\"line\">        res.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        res += s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.size() == <span class=\"number\">0</span>) res.push_back(<span class=\"string\">&#x27;/&#x27;</span>); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>stringstream</code>和<code>getline</code>来进行字符串分割：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> buf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">istringstream</span> <span class=\"title\">ss</span><span class=\"params\">(path)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(getline(ss, buf, <span class=\"string\">&#x27;/&#x27;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buf == <span class=\"string\">&quot;.&quot;</span> || buf.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (buf == <span class=\"string\">&quot;..&quot;</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (st.size() != <span class=\"number\">0</span>) st.pop_back();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st.push_back(buf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;s: st) &#123;</span><br><span class=\"line\">        res.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        res += s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.size() == <span class=\"number\">0</span>) res.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第三天（hhh，好像又很久没刷了）, 又AC掉了逻辑题，或者说又是一道用<code>if else</code>加状态机搞定的题。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/simplify-path/\">71. Simplify Path</a></p>\n<p>以后还是不<code>copy</code>题目到这里来了，有点麻烦的感觉。。。</p>\n<p>对于这种纯看逻辑的题目，可以先分析一下给出的测例，然后通过题目来分析要注意什么：</p>\n<ol>\n<li>“/home/“</li>\n<li>“/../“</li>\n<li>“/home//foo/“</li>\n<li>“/a/./b/../../c/“</li>\n<li>“/a/../../b/../c//.//“</li>\n<li>“/a//b////c/d//././/..”</li>\n</ol>\n<p>从上面我们大概可以知道要注意的一些点有：</p>\n<ul>\n<li>首先疑似最开始的符号一定是’/‘？</li>\n<li>通过<code>/</code>来分割单词，这意味着我们可以用<code>python</code>中的<code>split</code>或者先做一次遍历来分割单词，这样做会简化逻辑（但我没用这种方法）</li>\n<li>要区分<code>.</code>和<code>..</code></li>\n<li><code>.</code>表示当前目录，<code>..</code>表示上级目录</li>\n<li>遇到多个<code>/</code>，就当成一个</li>\n</ul>\n<p>事实上在后面的测试中，我发现一个很坑的点，就是<code>...</code>和<code>..a</code>这种并不是一个特殊的字符串，可以作为路径名。</p>\n<p>我们现在尝试写一个基于状态机的方法，首先定义一下遍历时需要的状态：</p>\n<ol start=\"0\">\n<li>前面是一个正常的字符<ul>\n<li>遇到<code>/</code>,就插入到结果字符串中，并跳转到<code>1</code>。</li>\n<li>遇到<code>.</code>，就跳转到<code>2</code>。</li>\n<li>遇到一个正常的字符，插入到结果字符串中。</li>\n</ul>\n</li>\n<li>前面是<code>/</code><ul>\n<li>如果遇到一个<code>/</code>，就直接跳过</li>\n<li>如果遇到一个<code>.</code>,跳转到<code>2</code></li>\n<li>如果是一个正常字符，就插入到结果字符串中并跳转到<code>0</code></li>\n</ul>\n</li>\n<li>前面是<code>.</code><ul>\n<li>如果遇到一个<code>/</code>, 就跳转到<code>1</code></li>\n<li>如果遇到一个<code>.</code>,就跳转到<code>3</code></li>\n<li>如果遇到一个正常字符，就插入<code>.</code>和这个字符，并跳转到<code>0</code></li>\n</ul>\n</li>\n<li>前面是<code>..</code><ul>\n<li>如果遇到一个<code>/</code>,就开始回溯删除到前面一个<code>/</code></li>\n<li>其余则插入一个<code>..</code>和这个字符，并跳转到<code>0</code></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// some flag to kepp state.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> state = <span class=\"number\">0</span>;  <span class=\"comment\">// 0: last char is [char]</span></span><br><span class=\"line\">                        <span class=\"comment\">// 1: last char is &#x27;/&#x27;</span></span><br><span class=\"line\">                        <span class=\"comment\">// 2: last char is &#x27;.&#x27;</span></span><br><span class=\"line\">                        <span class=\"comment\">// 3: last char is &quot;..&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() != <span class=\"number\">0</span> &amp;&amp; path[path.size()<span class=\"number\">-1</span>]!=<span class=\"string\">&#x27;/&#x27;</span>) path.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = path.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = path[i];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (state == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;/&#x27;</span>) &#123; res.push_back(<span class=\"string\">&#x27;/&#x27;</span>); state = <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) state = <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> res.push_back(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;/&#x27;</span>) &#123;&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123; state = <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.push_back(c); state = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;/&#x27;</span>) state = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// &#x27;..&#x27;</span></span><br><span class=\"line\">                    state = <span class=\"number\">3</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.push_back(<span class=\"string\">&#x27;.&#x27;</span>); res.push_back(c); state = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// go back</span></span><br><span class=\"line\">                    res.pop_back(); <span class=\"comment\">// pop &#x27;/&#x27;</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(res.size() != <span class=\"number\">0</span> &amp;&amp; *res.rbegin() != <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">                        res.pop_back(); <span class=\"comment\">// pop anthing until &#x27;/&#x27;</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (res.size() == <span class=\"number\">0</span>) res.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">                    state = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.push_back(<span class=\"string\">&#x27;.&#x27;</span>); </span><br><span class=\"line\">                    res.push_back(<span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">                    res.push_back(c);</span><br><span class=\"line\">                    state = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; state &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; res &lt;&lt;  endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((state == <span class=\"number\">1</span> &amp;&amp; res.size() != <span class=\"number\">1</span>)) res.pop_back();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>update at 2020-03-23</p>\n</blockquote>\n<p>状态转移图：</p>\n<p><img src=\"https://g.gravizo.com/svg?%20digraph%20G%20%7B%20State0%20%5Bshape%20=%20circle%5D%20State1%20%5Bshape%20=%20circle%5D%20State2%20%5Bshape%20=%20circle%5D%20State3%20%5Bshape%20=%20circle%5D%20State0%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20State0%20-%3E%20State0%20%5Blabel%20=%20%22char%22%5D;%20State0%20-%3E%20State2%20%5Blabel%20=%20%22point%22%5D;%20State1%20-%3E%20State0%20%5Blabel%20=%20%22char%22%5D;%20State1%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20State1%20-%3E%20State2%20%5Blabel%20=%20%22point%22%5D;%20State2%20-%3E%20State3%20%5Blabel%20=%20%22point%22%5D;%20State2%20-%3E%20State0%20%5Blabel%20=%20%22char%22%5D;%20State2%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20State3%20-%3E%20State0%20%5Blabel%20=%20%22char%20and%20point%22%5D;%20State3%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20%7D\" alt=\"FSM\"></p>\n<p>这道题其实用栈会更简单一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    path.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, sz = path.size(); i &lt; sz; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path[i] == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> s = path.substr(beg, i-beg);</span><br><span class=\"line\">            beg = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s == <span class=\"string\">&quot;.&quot;</span> || s.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s == <span class=\"string\">&quot;..&quot;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (st.size() != <span class=\"number\">0</span>) st.pop_back(); <span class=\"comment\">// make sure &#x27;/../&#x27; is ok</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> st.push_back(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;s: st) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class=\"line\">        res.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        res += s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.size() == <span class=\"number\">0</span>) res.push_back(<span class=\"string\">&#x27;/&#x27;</span>); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>stringstream</code>和<code>getline</code>来进行字符串分割：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> buf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">istringstream</span> <span class=\"title\">ss</span><span class=\"params\">(path)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(getline(ss, buf, <span class=\"string\">&#x27;/&#x27;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buf == <span class=\"string\">&quot;.&quot;</span> || buf.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (buf == <span class=\"string\">&quot;..&quot;</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (st.size() != <span class=\"number\">0</span>) st.pop_back();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st.push_back(buf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;s: st) &#123;</span><br><span class=\"line\">        res.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        res += s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.size() == <span class=\"number\">0</span>) res.push_back(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Single Number III","date":"2017-11-27T04:23:09.000Z","_content":"\n第61天。\n\n今天的题目是[Single Number III](https://leetcode.com/problems/single-number-iii/description/):\n\n> Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\n>\n> For example:\n>\n> Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].\n>\n> Note:\n> The order of the result is not important. So in the above example, [5, 3] is also correct.\n> Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?\n\n在求解这个问题之前，我们先考虑一下简化后的问题，如果只有一个Single Number的话，我们要怎么求解。\n\n如果熟悉异或运算的话，就很快的想出解决办法，这里用到了三个性质：\n\n* 0^a = a\n* a^a = 0\n* a^b^a = b\n\n假设现在序列有个数，分别为`n1,n2,n2...nk`,我们将它们异或起来：\n`t = n1^n2^n3^...^nk`,因为中间只有一个`single number`,所以t中只有一个数不能因为`a^a = 0`而消除掉。因此`t`就是这个序列中的`single number`.\n\n这是只有一个`single number`的情况，如果我们用类似的方法去做这道题的话，我们会得到`t = a1^a2`,但是显然我们无法快速的将a1和a2分解出来，除非我们知道其中一个数。\n\n那我们能不能把序列分成两部分来做，每部分都包含一个`single number`且其余的数都包含两个，我们可以从`bit`的角度来考虑，如果某个位（比如说最低位）为`1`,那我们就将它分到第一部分，否则我们就将它分到第二部分，这样的方法可以很好的区分除了`single number`之外的数（因为两个`single number`可能分到相同的部分）。现在的问题就是我们要怎么将两个`single number`分到不同部分。\n\n现在我们已经有了`t = a1^a2`,异或的定义是不同的bit为`1`,相同的bit为`0`,所以说t中为`1`的bit位（总是可以找到）可以作为我们上面那个算法的区分点了。\n\n然后现在就是找出`t`中一个为`1`的`bit`了，简单的可以遍历去做，比较只有32位，所以时间复杂度是`O(1)`的，但是我们有一个更快的方法：\n`t & (t-1)`可以将第一个为`1`的bit位清0,然后我们再异或上原来的t,我们就可以得到对应的`mask`了。\n\n```c++\nvector<int> singleNumber(vector<int>& nums) {\n    int t = 0;\n    for(auto i:nums) t ^= i;\n    int lastBit = (t & (t-1)) ^ t;\n    int a = 0;\n    for(auto i:nums) if (i&lastBit) a^=i;\n    return {a,a^t};\n}\n```\n","source":"_posts/Single-Number-III.md","raw":"---\ntitle: Single Number III\ndate: 2017-11-27T12:23:09.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Bit-Manipulation\n---\n\n第61天。\n\n今天的题目是[Single Number III](https://leetcode.com/problems/single-number-iii/description/):\n\n> Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\n>\n> For example:\n>\n> Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].\n>\n> Note:\n> The order of the result is not important. So in the above example, [5, 3] is also correct.\n> Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?\n\n在求解这个问题之前，我们先考虑一下简化后的问题，如果只有一个Single Number的话，我们要怎么求解。\n\n如果熟悉异或运算的话，就很快的想出解决办法，这里用到了三个性质：\n\n* 0^a = a\n* a^a = 0\n* a^b^a = b\n\n假设现在序列有个数，分别为`n1,n2,n2...nk`,我们将它们异或起来：\n`t = n1^n2^n3^...^nk`,因为中间只有一个`single number`,所以t中只有一个数不能因为`a^a = 0`而消除掉。因此`t`就是这个序列中的`single number`.\n\n这是只有一个`single number`的情况，如果我们用类似的方法去做这道题的话，我们会得到`t = a1^a2`,但是显然我们无法快速的将a1和a2分解出来，除非我们知道其中一个数。\n\n那我们能不能把序列分成两部分来做，每部分都包含一个`single number`且其余的数都包含两个，我们可以从`bit`的角度来考虑，如果某个位（比如说最低位）为`1`,那我们就将它分到第一部分，否则我们就将它分到第二部分，这样的方法可以很好的区分除了`single number`之外的数（因为两个`single number`可能分到相同的部分）。现在的问题就是我们要怎么将两个`single number`分到不同部分。\n\n现在我们已经有了`t = a1^a2`,异或的定义是不同的bit为`1`,相同的bit为`0`,所以说t中为`1`的bit位（总是可以找到）可以作为我们上面那个算法的区分点了。\n\n然后现在就是找出`t`中一个为`1`的`bit`了，简单的可以遍历去做，比较只有32位，所以时间复杂度是`O(1)`的，但是我们有一个更快的方法：\n`t & (t-1)`可以将第一个为`1`的bit位清0,然后我们再异或上原来的t,我们就可以得到对应的`mask`了。\n\n```c++\nvector<int> singleNumber(vector<int>& nums) {\n    int t = 0;\n    for(auto i:nums) t ^= i;\n    int lastBit = (t & (t-1)) ^ t;\n    int a = 0;\n    for(auto i:nums) if (i&lastBit) a^=i;\n    return {a,a^t};\n}\n```\n","slug":"Single-Number-III","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ps00dsqmcmg70ia38i","content":"<p>第61天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/single-number-iii/description/\">Single Number III</a>:</p>\n<blockquote>\n<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>\n<p>For example:</p>\n<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>\n<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>\n</blockquote>\n<p>在求解这个问题之前，我们先考虑一下简化后的问题，如果只有一个Single Number的话，我们要怎么求解。</p>\n<p>如果熟悉异或运算的话，就很快的想出解决办法，这里用到了三个性质：</p>\n<ul>\n<li>0^a = a</li>\n<li>a^a = 0</li>\n<li>a^b^a = b</li>\n</ul>\n<p>假设现在序列有个数，分别为<code>n1,n2,n2...nk</code>,我们将它们异或起来：<br><code>t = n1^n2^n3^...^nk</code>,因为中间只有一个<code>single number</code>,所以t中只有一个数不能因为<code>a^a = 0</code>而消除掉。因此<code>t</code>就是这个序列中的<code>single number</code>.</p>\n<p>这是只有一个<code>single number</code>的情况，如果我们用类似的方法去做这道题的话，我们会得到<code>t = a1^a2</code>,但是显然我们无法快速的将a1和a2分解出来，除非我们知道其中一个数。</p>\n<p>那我们能不能把序列分成两部分来做，每部分都包含一个<code>single number</code>且其余的数都包含两个，我们可以从<code>bit</code>的角度来考虑，如果某个位（比如说最低位）为<code>1</code>,那我们就将它分到第一部分，否则我们就将它分到第二部分，这样的方法可以很好的区分除了<code>single number</code>之外的数（因为两个<code>single number</code>可能分到相同的部分）。现在的问题就是我们要怎么将两个<code>single number</code>分到不同部分。</p>\n<p>现在我们已经有了<code>t = a1^a2</code>,异或的定义是不同的bit为<code>1</code>,相同的bit为<code>0</code>,所以说t中为<code>1</code>的bit位（总是可以找到）可以作为我们上面那个算法的区分点了。</p>\n<p>然后现在就是找出<code>t</code>中一个为<code>1</code>的<code>bit</code>了，简单的可以遍历去做，比较只有32位，所以时间复杂度是<code>O(1)</code>的，但是我们有一个更快的方法：<br><code>t &amp; (t-1)</code>可以将第一个为<code>1</code>的bit位清0,然后我们再异或上原来的t,我们就可以得到对应的<code>mask</code>了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) t ^= i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastBit = (t &amp; (t<span class=\"number\">-1</span>)) ^ t;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) <span class=\"keyword\">if</span> (i&amp;lastBit) a^=i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;a,a^t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第61天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/single-number-iii/description/\">Single Number III</a>:</p>\n<blockquote>\n<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>\n<p>For example:</p>\n<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>\n<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>\n</blockquote>\n<p>在求解这个问题之前，我们先考虑一下简化后的问题，如果只有一个Single Number的话，我们要怎么求解。</p>\n<p>如果熟悉异或运算的话，就很快的想出解决办法，这里用到了三个性质：</p>\n<ul>\n<li>0^a = a</li>\n<li>a^a = 0</li>\n<li>a^b^a = b</li>\n</ul>\n<p>假设现在序列有个数，分别为<code>n1,n2,n2...nk</code>,我们将它们异或起来：<br><code>t = n1^n2^n3^...^nk</code>,因为中间只有一个<code>single number</code>,所以t中只有一个数不能因为<code>a^a = 0</code>而消除掉。因此<code>t</code>就是这个序列中的<code>single number</code>.</p>\n<p>这是只有一个<code>single number</code>的情况，如果我们用类似的方法去做这道题的话，我们会得到<code>t = a1^a2</code>,但是显然我们无法快速的将a1和a2分解出来，除非我们知道其中一个数。</p>\n<p>那我们能不能把序列分成两部分来做，每部分都包含一个<code>single number</code>且其余的数都包含两个，我们可以从<code>bit</code>的角度来考虑，如果某个位（比如说最低位）为<code>1</code>,那我们就将它分到第一部分，否则我们就将它分到第二部分，这样的方法可以很好的区分除了<code>single number</code>之外的数（因为两个<code>single number</code>可能分到相同的部分）。现在的问题就是我们要怎么将两个<code>single number</code>分到不同部分。</p>\n<p>现在我们已经有了<code>t = a1^a2</code>,异或的定义是不同的bit为<code>1</code>,相同的bit为<code>0</code>,所以说t中为<code>1</code>的bit位（总是可以找到）可以作为我们上面那个算法的区分点了。</p>\n<p>然后现在就是找出<code>t</code>中一个为<code>1</code>的<code>bit</code>了，简单的可以遍历去做，比较只有32位，所以时间复杂度是<code>O(1)</code>的，但是我们有一个更快的方法：<br><code>t &amp; (t-1)</code>可以将第一个为<code>1</code>的bit位清0,然后我们再异或上原来的t,我们就可以得到对应的<code>mask</code>了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) t ^= i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastBit = (t &amp; (t<span class=\"number\">-1</span>)) ^ t;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums) <span class=\"keyword\">if</span> (i&amp;lastBit) a^=i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;a,a^t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Sort Characters By Frequency","date":"2019-11-11T04:23:34.000Z","_content":"\n\n> 第7天了\n\n今天的题目是[ Sort Characters By Frequency ]( https://leetcode.com/problems/sort-characters-by-frequency/ ):\n\n---\n\nGiven a string, sort it in decreasing order based on the frequency of characters.\n\n**Example 1:**\n\n```\nInput:\n\"tree\"\n\nOutput:\n\"eert\"\n\nExplanation:\n'e' appears twice while 'r' and 't' both appear once.\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\n```\n\n\n\n**Example 2:**\n\n```\nInput:\n\"cccaaa\"\n\nOutput:\n\"cccaaa\"\n\nExplanation:\nBoth 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer.\nNote that \"cacaca\" is incorrect, as the same characters must be together.\n```\n\n\n\n**Example 3:**\n\n```\nInput:\n\"Aabb\"\n\nOutput:\n\"bbAa\"\n\nExplanation:\n\"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\nNote that 'A' and 'a' are treated as two different characters.\n```\n\n---\n\n比较简单的一道题，具体解法如下：\n\n1. 计数算频率，用`unordered_map`就搞定了\n2. 按频率排序，先把`unoredred_map`转成`vector`，然后再`sort`\n3. 生成字符串。\n\n具体代码如下：\n\n```c++\nstring frequencySort(string s) {\n    unordered_map<char, int> cmap;\n    for(int i = 0;i < s.size(); i++) cmap[s[i]]++;\n    vector<pair<char, int>> pvec(cmap.begin(), cmap.end());\n    sort(pvec.begin(), pvec.end(), [](const pair<char, int> &p1, const pair<char, int> &p2) {\n        return p1.second > p2.second; \n    });\n\n    string res;\n    for(auto it = pvec.begin(); it != pvec.end(); ++it) {\n        res += string(it->second, it->first);\n    }\n    return res;\n}\n```\n\n因为中途需要把`unordered_map`转成`vector`，所以使用的空间就有点多了（统计数据存了两份），所以我们尝试直接使用`vector`来统计。之所以能直接用`vector`来统计，是因为char类型总共就256个字符而已，所以我们用一个长度为`256`的`vector`即可完成，具体代码如下：\n\n```c++\nstring frequencySort(string s) {\n    vector<pair<char, int> > pvec(256);\n    for(int i = 0;i < 256; i++) pvec[i] = make_pair(i, 0);\n    for(int i = 0;i < s.size(); i++) {\n        pvec[s[i]].second++;\n    }\n\n    string res;\n    for(auto it = pvec.begin(); it != pvec.end() && it->second; ++it) {\n        res += string(it->second, it->first);\n    }\n    return res;\n}\n```\n\n","source":"_posts/Sort-Characters-By-Frequency.md","raw":"---\ntitle: Sort Characters By Frequency\ndate: 2019-11-11T12:23:34.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n\n> 第7天了\n\n今天的题目是[ Sort Characters By Frequency ]( https://leetcode.com/problems/sort-characters-by-frequency/ ):\n\n---\n\nGiven a string, sort it in decreasing order based on the frequency of characters.\n\n**Example 1:**\n\n```\nInput:\n\"tree\"\n\nOutput:\n\"eert\"\n\nExplanation:\n'e' appears twice while 'r' and 't' both appear once.\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\n```\n\n\n\n**Example 2:**\n\n```\nInput:\n\"cccaaa\"\n\nOutput:\n\"cccaaa\"\n\nExplanation:\nBoth 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer.\nNote that \"cacaca\" is incorrect, as the same characters must be together.\n```\n\n\n\n**Example 3:**\n\n```\nInput:\n\"Aabb\"\n\nOutput:\n\"bbAa\"\n\nExplanation:\n\"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\nNote that 'A' and 'a' are treated as two different characters.\n```\n\n---\n\n比较简单的一道题，具体解法如下：\n\n1. 计数算频率，用`unordered_map`就搞定了\n2. 按频率排序，先把`unoredred_map`转成`vector`，然后再`sort`\n3. 生成字符串。\n\n具体代码如下：\n\n```c++\nstring frequencySort(string s) {\n    unordered_map<char, int> cmap;\n    for(int i = 0;i < s.size(); i++) cmap[s[i]]++;\n    vector<pair<char, int>> pvec(cmap.begin(), cmap.end());\n    sort(pvec.begin(), pvec.end(), [](const pair<char, int> &p1, const pair<char, int> &p2) {\n        return p1.second > p2.second; \n    });\n\n    string res;\n    for(auto it = pvec.begin(); it != pvec.end(); ++it) {\n        res += string(it->second, it->first);\n    }\n    return res;\n}\n```\n\n因为中途需要把`unordered_map`转成`vector`，所以使用的空间就有点多了（统计数据存了两份），所以我们尝试直接使用`vector`来统计。之所以能直接用`vector`来统计，是因为char类型总共就256个字符而已，所以我们用一个长度为`256`的`vector`即可完成，具体代码如下：\n\n```c++\nstring frequencySort(string s) {\n    vector<pair<char, int> > pvec(256);\n    for(int i = 0;i < 256; i++) pvec[i] = make_pair(i, 0);\n    for(int i = 0;i < s.size(); i++) {\n        pvec[s[i]].second++;\n    }\n\n    string res;\n    for(auto it = pvec.begin(); it != pvec.end() && it->second; ++it) {\n        res += string(it->second, it->first);\n    }\n    return res;\n}\n```\n\n","slug":"Sort-Characters-By-Frequency","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pt00dwqmcmcexy5oxt","content":"<blockquote>\n<p>第7天了</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/sort-characters-by-frequency/\"> Sort Characters By Frequency </a>:</p>\n<hr>\n<p>Given a string, sort it in decreasing order based on the frequency of characters.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">&quot;tree&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">&quot;eert&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.</span><br><span class=\"line\">So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">&quot;cccaaa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">&quot;cccaaa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Both &#39;c&#39; and &#39;a&#39; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class=\"line\">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">&quot;Aabb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">&quot;bbAa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class=\"line\">Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>比较简单的一道题，具体解法如下：</p>\n<ol>\n<li>计数算频率，用<code>unordered_map</code>就搞定了</li>\n<li>按频率排序，先把<code>unoredred_map</code>转成<code>vector</code>，然后再<code>sort</code></li>\n<li>生成字符串。</li>\n</ol>\n<p>具体代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">frequencySort</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; cmap;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.size(); i++) cmap[s[i]]++;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt;&gt; pvec(cmap.begin(), cmap.end());</span><br><span class=\"line\">    sort(pvec.begin(), pvec.end(), [](<span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; &amp;p1, <span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; &amp;p2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p1.second &gt; p2.second; </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = pvec.begin(); it != pvec.end(); ++it) &#123;</span><br><span class=\"line\">        res += <span class=\"built_in\">string</span>(it-&gt;second, it-&gt;first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为中途需要把<code>unordered_map</code>转成<code>vector</code>，所以使用的空间就有点多了（统计数据存了两份），所以我们尝试直接使用<code>vector</code>来统计。之所以能直接用<code>vector</code>来统计，是因为char类型总共就256个字符而已，所以我们用一个长度为<code>256</code>的<code>vector</code>即可完成，具体代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">frequencySort</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; &gt; pvec(<span class=\"number\">256</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">256</span>; i++) pvec[i] = <span class=\"built_in\">make_pair</span>(i, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.size(); i++) &#123;</span><br><span class=\"line\">        pvec[s[i]].second++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = pvec.begin(); it != pvec.end() &amp;&amp; it-&gt;second; ++it) &#123;</span><br><span class=\"line\">        res += <span class=\"built_in\">string</span>(it-&gt;second, it-&gt;first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第7天了</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/sort-characters-by-frequency/\"> Sort Characters By Frequency </a>:</p>\n<hr>\n<p>Given a string, sort it in decreasing order based on the frequency of characters.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">&quot;tree&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">&quot;eert&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.</span><br><span class=\"line\">So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">&quot;cccaaa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">&quot;cccaaa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Both &#39;c&#39; and &#39;a&#39; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class=\"line\">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">&quot;Aabb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">&quot;bbAa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class=\"line\">Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>比较简单的一道题，具体解法如下：</p>\n<ol>\n<li>计数算频率，用<code>unordered_map</code>就搞定了</li>\n<li>按频率排序，先把<code>unoredred_map</code>转成<code>vector</code>，然后再<code>sort</code></li>\n<li>生成字符串。</li>\n</ol>\n<p>具体代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">frequencySort</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; cmap;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.size(); i++) cmap[s[i]]++;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt;&gt; pvec(cmap.begin(), cmap.end());</span><br><span class=\"line\">    sort(pvec.begin(), pvec.end(), [](<span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; &amp;p1, <span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; &amp;p2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p1.second &gt; p2.second; </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = pvec.begin(); it != pvec.end(); ++it) &#123;</span><br><span class=\"line\">        res += <span class=\"built_in\">string</span>(it-&gt;second, it-&gt;first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为中途需要把<code>unordered_map</code>转成<code>vector</code>，所以使用的空间就有点多了（统计数据存了两份），所以我们尝试直接使用<code>vector</code>来统计。之所以能直接用<code>vector</code>来统计，是因为char类型总共就256个字符而已，所以我们用一个长度为<code>256</code>的<code>vector</code>即可完成，具体代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">frequencySort</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; &gt; pvec(<span class=\"number\">256</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">256</span>; i++) pvec[i] = <span class=\"built_in\">make_pair</span>(i, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.size(); i++) &#123;</span><br><span class=\"line\">        pvec[s[i]].second++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = pvec.begin(); it != pvec.end() &amp;&amp; it-&gt;second; ++it) &#123;</span><br><span class=\"line\">        res += <span class=\"built_in\">string</span>(it-&gt;second, it-&gt;first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Sort Colors","date":"2017-10-19T04:28:34.000Z","_content":"\n第26天。\n\n今天的题目是个排序问题，经过算法的实验一后，这个问题其实就比较简单啦。\n\n> Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n>\n> Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n>\n> Note:\n> You are not suppose to use the library's sort function for this problem.\n\n题目的意思是他会给你一个只包含`0,1,2`三个数字的数组，你要对他进行排序。\n\n因为里面的值只有三种可能，所以显然要用**计数排序**,他的时间复杂度是`O(n)`.\n\n用这个例子大概的说明一下计数排序的原理：\n\n现在待排数组里的值只能是`0,1,2`，所以我们通过一个长度为3的数组来记录`0,1,2`在待排序列中出现的次数（所以这个排序才叫计数排序），计算各个元素出现的次数我们只需要简单的遍历一遍序列即可，这里的时间复杂度是`O(n)`。\n\n假如对于一个长度为10的序列，`0`出现了3次，`1`出现了4次，`2`出现了3次，我们又知道`0<1<2`，所以排完序之后序列的前3个元素一定是0,紧接着的四个元素一定是`1`，最后三个元素一定是`2`.\n\n所以计数排序就两个步骤：\n\n* 遍历待排数组，记录元素出现的次数\n* 通过元素出现的次数，修改待排数组\n\n```c++\nvoid sortColors(vector<int>& nums) {\n    vector<int> count(3,0);\n\n    for(auto i:nums)\n        count[i]++;\n\n    int i = 0,k = 0;\n    while(k < nums.size()) {\n        while (count[i] == 0) i++;\n        nums[k] = i;\n        k++;\n        count[i]--;\n    }\n}\n```\n\n然后是在`dicuss`中看到的，模仿了快排的`patition`的方法：\n\n```c++\nvoid sortColors(int A[], int n) {\n    int second=n-1, zero=0;\n    for (int i=0; i<=second; i++) {\n        while (A[i]==2 && i<second) swap(A[i], A[second--]);\n        while (A[i]==0 && i>zero) swap(A[i], A[zero++]);\n    }\n}\n```\n","source":"_posts/Sort-Colors.md","raw":"---\ntitle: Sort Colors\ndate: 2017-10-19T12:28:34.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - sort\n---\n\n第26天。\n\n今天的题目是个排序问题，经过算法的实验一后，这个问题其实就比较简单啦。\n\n> Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n>\n> Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n>\n> Note:\n> You are not suppose to use the library's sort function for this problem.\n\n题目的意思是他会给你一个只包含`0,1,2`三个数字的数组，你要对他进行排序。\n\n因为里面的值只有三种可能，所以显然要用**计数排序**,他的时间复杂度是`O(n)`.\n\n用这个例子大概的说明一下计数排序的原理：\n\n现在待排数组里的值只能是`0,1,2`，所以我们通过一个长度为3的数组来记录`0,1,2`在待排序列中出现的次数（所以这个排序才叫计数排序），计算各个元素出现的次数我们只需要简单的遍历一遍序列即可，这里的时间复杂度是`O(n)`。\n\n假如对于一个长度为10的序列，`0`出现了3次，`1`出现了4次，`2`出现了3次，我们又知道`0<1<2`，所以排完序之后序列的前3个元素一定是0,紧接着的四个元素一定是`1`，最后三个元素一定是`2`.\n\n所以计数排序就两个步骤：\n\n* 遍历待排数组，记录元素出现的次数\n* 通过元素出现的次数，修改待排数组\n\n```c++\nvoid sortColors(vector<int>& nums) {\n    vector<int> count(3,0);\n\n    for(auto i:nums)\n        count[i]++;\n\n    int i = 0,k = 0;\n    while(k < nums.size()) {\n        while (count[i] == 0) i++;\n        nums[k] = i;\n        k++;\n        count[i]--;\n    }\n}\n```\n\n然后是在`dicuss`中看到的，模仿了快排的`patition`的方法：\n\n```c++\nvoid sortColors(int A[], int n) {\n    int second=n-1, zero=0;\n    for (int i=0; i<=second; i++) {\n        while (A[i]==2 && i<second) swap(A[i], A[second--]);\n        while (A[i]==0 && i>zero) swap(A[i], A[zero++]);\n    }\n}\n```\n","slug":"Sort-Colors","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pt00dzqmcm4iro4qih","content":"<p>第26天。</p>\n<p>今天的题目是个排序问题，经过算法的实验一后，这个问题其实就比较简单啦。</p>\n<blockquote>\n<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>\n<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>\n<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>\n</blockquote>\n<p>题目的意思是他会给你一个只包含<code>0,1,2</code>三个数字的数组，你要对他进行排序。</p>\n<p>因为里面的值只有三种可能，所以显然要用<strong>计数排序</strong>,他的时间复杂度是<code>O(n)</code>.</p>\n<p>用这个例子大概的说明一下计数排序的原理：</p>\n<p>现在待排数组里的值只能是<code>0,1,2</code>，所以我们通过一个长度为3的数组来记录<code>0,1,2</code>在待排序列中出现的次数（所以这个排序才叫计数排序），计算各个元素出现的次数我们只需要简单的遍历一遍序列即可，这里的时间复杂度是<code>O(n)</code>。</p>\n<p>假如对于一个长度为10的序列，<code>0</code>出现了3次，<code>1</code>出现了4次，<code>2</code>出现了3次，我们又知道<code>0&lt;1&lt;2</code>，所以排完序之后序列的前3个元素一定是0,紧接着的四个元素一定是<code>1</code>，最后三个元素一定是<code>2</code>.</p>\n<p>所以计数排序就两个步骤：</p>\n<ul>\n<li>遍历待排数组，记录元素出现的次数</li>\n<li>通过元素出现的次数，修改待排数组</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">count</span><span class=\"params\">(<span class=\"number\">3</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums)</span><br><span class=\"line\">        count[i]++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k &lt; nums.size()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count[i] == <span class=\"number\">0</span>) i++;</span><br><span class=\"line\">        nums[k] = i;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">        count[i]--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的，模仿了快排的<code>patition</code>的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> second=n<span class=\"number\">-1</span>, zero=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=second; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (A[i]==<span class=\"number\">2</span> &amp;&amp; i&lt;second) swap(A[i], A[second--]);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (A[i]==<span class=\"number\">0</span> &amp;&amp; i&gt;zero) swap(A[i], A[zero++]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第26天。</p>\n<p>今天的题目是个排序问题，经过算法的实验一后，这个问题其实就比较简单啦。</p>\n<blockquote>\n<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>\n<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>\n<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>\n</blockquote>\n<p>题目的意思是他会给你一个只包含<code>0,1,2</code>三个数字的数组，你要对他进行排序。</p>\n<p>因为里面的值只有三种可能，所以显然要用<strong>计数排序</strong>,他的时间复杂度是<code>O(n)</code>.</p>\n<p>用这个例子大概的说明一下计数排序的原理：</p>\n<p>现在待排数组里的值只能是<code>0,1,2</code>，所以我们通过一个长度为3的数组来记录<code>0,1,2</code>在待排序列中出现的次数（所以这个排序才叫计数排序），计算各个元素出现的次数我们只需要简单的遍历一遍序列即可，这里的时间复杂度是<code>O(n)</code>。</p>\n<p>假如对于一个长度为10的序列，<code>0</code>出现了3次，<code>1</code>出现了4次，<code>2</code>出现了3次，我们又知道<code>0&lt;1&lt;2</code>，所以排完序之后序列的前3个元素一定是0,紧接着的四个元素一定是<code>1</code>，最后三个元素一定是<code>2</code>.</p>\n<p>所以计数排序就两个步骤：</p>\n<ul>\n<li>遍历待排数组，记录元素出现的次数</li>\n<li>通过元素出现的次数，修改待排数组</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">count</span><span class=\"params\">(<span class=\"number\">3</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:nums)</span><br><span class=\"line\">        count[i]++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k &lt; nums.size()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count[i] == <span class=\"number\">0</span>) i++;</span><br><span class=\"line\">        nums[k] = i;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">        count[i]--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的，模仿了快排的<code>patition</code>的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> second=n<span class=\"number\">-1</span>, zero=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=second; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (A[i]==<span class=\"number\">2</span> &amp;&amp; i&lt;second) swap(A[i], A[second--]);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (A[i]==<span class=\"number\">0</span> &amp;&amp; i&gt;zero) swap(A[i], A[zero++]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Sort List","date":"2017-10-31T02:35:28.000Z","_content":"\n第36天。\n\n今天的题目好像是之前就做过的了，[Sort List](https://leetcode.com/problems/sort-list/description/):\n\n> Sort a linked list in O(n log n) time using constant space complexity.\n\n要`O(nlogn)`的算法，显然就是要用归并或快排啦，但是因为他是链表，所以只能是归并排序。\n\n归并排序首先要解决的问题就是，如何分成两半，这里用的方法是快慢指针：\n\n```c++\n    ListNode* sortList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr ) return head;\n\n        ListNode *slow = head;\n        ListNode *fast = head;\n        ListNode *pre = head;\n\n        while(fast && fast->next) {\n            pre = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        pre->next = nullptr;\n        head = sortList(head);\n        slow = sortList(slow);\n\n        return mergeList(head,slow);\n    }\n    ListNode *mergeList(ListNode *p1,ListNode *p2) {\n        ListNode ret(0);\n        ListNode *p = &ret;\n        while(p1&&p2) {\n            if (p1->val > p2->val) { p->next = p2; p2 = p2->next; }\n            else {p->next = p1; p1 = p1->next; }\n            p = p->next;\n        }\n        if (p1) p->next = p1;\n        if (p2) p->next = p2;\n        return ret.next;\n    }\n```\n\n因为是之前做过的，而且好像还写过`Blog`,所以就不详细写了。\n","source":"_posts/Sort-List.md","raw":"---\ntitle: Sort List\ndate: 2017-10-31T10:35:28.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - List\n---\n\n第36天。\n\n今天的题目好像是之前就做过的了，[Sort List](https://leetcode.com/problems/sort-list/description/):\n\n> Sort a linked list in O(n log n) time using constant space complexity.\n\n要`O(nlogn)`的算法，显然就是要用归并或快排啦，但是因为他是链表，所以只能是归并排序。\n\n归并排序首先要解决的问题就是，如何分成两半，这里用的方法是快慢指针：\n\n```c++\n    ListNode* sortList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr ) return head;\n\n        ListNode *slow = head;\n        ListNode *fast = head;\n        ListNode *pre = head;\n\n        while(fast && fast->next) {\n            pre = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        pre->next = nullptr;\n        head = sortList(head);\n        slow = sortList(slow);\n\n        return mergeList(head,slow);\n    }\n    ListNode *mergeList(ListNode *p1,ListNode *p2) {\n        ListNode ret(0);\n        ListNode *p = &ret;\n        while(p1&&p2) {\n            if (p1->val > p2->val) { p->next = p2; p2 = p2->next; }\n            else {p->next = p1; p1 = p1->next; }\n            p = p->next;\n        }\n        if (p1) p->next = p1;\n        if (p2) p->next = p2;\n        return ret.next;\n    }\n```\n\n因为是之前做过的，而且好像还写过`Blog`,所以就不详细写了。\n","slug":"Sort-List","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pu00e3qmcmcyb966vo","content":"<p>第36天。</p>\n<p>今天的题目好像是之前就做过的了，<a href=\"https://leetcode.com/problems/sort-list/description/\">Sort List</a>:</p>\n<blockquote>\n<p>Sort a linked list in O(n log n) time using constant space complexity.</p>\n</blockquote>\n<p>要<code>O(nlogn)</code>的算法，显然就是要用归并或快排啦，但是因为他是链表，所以只能是归并排序。</p>\n<p>归并排序首先要解决的问题就是，如何分成两半，这里用的方法是快慢指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">sortList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span> ) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *slow = head;</span><br><span class=\"line\">    ListNode *fast = head;</span><br><span class=\"line\">    ListNode *pre = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        pre = slow;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pre-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    head = sortList(head);</span><br><span class=\"line\">    slow = sortList(slow);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mergeList(head,slow);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">mergeList</span><span class=\"params\">(ListNode *p1,ListNode *p2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    ListNode *p = &amp;ret;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p1&amp;&amp;p2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p1-&gt;val &gt; p2-&gt;val) &#123; p-&gt;next = p2; p2 = p2-&gt;next; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;p-&gt;next = p1; p1 = p1-&gt;next; &#125;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1) p-&gt;next = p1;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p2) p-&gt;next = p2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为是之前做过的，而且好像还写过<code>Blog</code>,所以就不详细写了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第36天。</p>\n<p>今天的题目好像是之前就做过的了，<a href=\"https://leetcode.com/problems/sort-list/description/\">Sort List</a>:</p>\n<blockquote>\n<p>Sort a linked list in O(n log n) time using constant space complexity.</p>\n</blockquote>\n<p>要<code>O(nlogn)</code>的算法，显然就是要用归并或快排啦，但是因为他是链表，所以只能是归并排序。</p>\n<p>归并排序首先要解决的问题就是，如何分成两半，这里用的方法是快慢指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">sortList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span> ) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *slow = head;</span><br><span class=\"line\">    ListNode *fast = head;</span><br><span class=\"line\">    ListNode *pre = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        pre = slow;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pre-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    head = sortList(head);</span><br><span class=\"line\">    slow = sortList(slow);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mergeList(head,slow);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">mergeList</span><span class=\"params\">(ListNode *p1,ListNode *p2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    ListNode *p = &amp;ret;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p1&amp;&amp;p2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p1-&gt;val &gt; p2-&gt;val) &#123; p-&gt;next = p2; p2 = p2-&gt;next; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;p-&gt;next = p1; p1 = p1-&gt;next; &#125;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1) p-&gt;next = p1;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p2) p-&gt;next = p2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为是之前做过的，而且好像还写过<code>Blog</code>,所以就不详细写了。</p>\n"},{"title":"Spiral Matrix","date":"2019-03-03T03:22:31.000Z","_content":"\n> 第四天，这又是一道之前没AC掉的题目。\n\n今天的题目是[54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)\n\n题意比较好理解，写的时候注意一下下标变换即可，最好现在纸上把给出的测例手动跑一下。\n\n个人觉得，最大的坑点在第二个测例中已经给出来了，如果遇到`[[1], [2]]`或`[[1, 2]]`这种长条的要怎么做。\n\n其实我们把他当成特殊例子即可，当所给出的矩阵的行列长度不一样时，最后一定会遇到上面的情况，这样我们可以先把正常的搞定，然后在最后面处理这两种情况即可。\n\n这道题的主要思路是，我们模拟螺旋式的走法移动下标，然后一圈一圈的去游走即可，这里的代码不难，想清楚下标变换即可，最后一圈需要处理，因为最后一圈可能是三种情况：\n\n- 只有一个元素\n- 多个元素排成一列\n- 多个元素排成一行\n\n对于上面的三种情况，如果用之前模拟螺旋的方法，很容易走多了几步，其实只要简单的用两重循环即可。\n\n代码如下：\n\n```c++\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<int> res;\n        \n        int istart = 0, iend = matrix.size()-1;\n        if (iend == -1) return res;\n        int jstart = 0, jend = matrix[0].size()-1;\n        \n        // printf(\"%d %d %d %d\\n\", istart, iend, jstart, jend);\n        \n        while(istart < iend && jstart < jend) {\n            int i = istart, j = jstart;\n            // ->\n            for(;j <= jend; j++)\n                res.push_back(matrix[i][j]);\n            j--; i++;\n            // |\n            // V\n            for(;i <= iend; i++)\n                res.push_back(matrix[i][j]);\n            i--; j--;;\n            \n            // <-\n            for(;j >= jstart; j--)\n                res.push_back(matrix[i][j]);\n            j++; i--;\n            // ^\n            // |\n            for(;i > istart; i--)\n                res.push_back(matrix[i][j]);\n            \n            istart++; iend--;\n            jstart++; jend--;\n            // for(auto i: res) cout << i << \" \";\n            // cout << endl;\n        }\n        /// cout << \"----\" << endl;\n        for(int i = istart; i <= iend;i++)\n            for(int j = jstart; j <= jend; j++)\n                res.push_back(matrix[i][j]);\n        \n        return res;\n    }\n};\n```\n","source":"_posts/Spiral-Matrix.md","raw":"---\ntitle: Spiral Matrix\ndate: 2019-03-03T11:22:31.000Z\ntags:\n  - LeetCode\n  - Array\ncategories:\n  - LeetCode\n---\n\n> 第四天，这又是一道之前没AC掉的题目。\n\n今天的题目是[54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)\n\n题意比较好理解，写的时候注意一下下标变换即可，最好现在纸上把给出的测例手动跑一下。\n\n个人觉得，最大的坑点在第二个测例中已经给出来了，如果遇到`[[1], [2]]`或`[[1, 2]]`这种长条的要怎么做。\n\n其实我们把他当成特殊例子即可，当所给出的矩阵的行列长度不一样时，最后一定会遇到上面的情况，这样我们可以先把正常的搞定，然后在最后面处理这两种情况即可。\n\n这道题的主要思路是，我们模拟螺旋式的走法移动下标，然后一圈一圈的去游走即可，这里的代码不难，想清楚下标变换即可，最后一圈需要处理，因为最后一圈可能是三种情况：\n\n- 只有一个元素\n- 多个元素排成一列\n- 多个元素排成一行\n\n对于上面的三种情况，如果用之前模拟螺旋的方法，很容易走多了几步，其实只要简单的用两重循环即可。\n\n代码如下：\n\n```c++\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<int> res;\n        \n        int istart = 0, iend = matrix.size()-1;\n        if (iend == -1) return res;\n        int jstart = 0, jend = matrix[0].size()-1;\n        \n        // printf(\"%d %d %d %d\\n\", istart, iend, jstart, jend);\n        \n        while(istart < iend && jstart < jend) {\n            int i = istart, j = jstart;\n            // ->\n            for(;j <= jend; j++)\n                res.push_back(matrix[i][j]);\n            j--; i++;\n            // |\n            // V\n            for(;i <= iend; i++)\n                res.push_back(matrix[i][j]);\n            i--; j--;;\n            \n            // <-\n            for(;j >= jstart; j--)\n                res.push_back(matrix[i][j]);\n            j++; i--;\n            // ^\n            // |\n            for(;i > istart; i--)\n                res.push_back(matrix[i][j]);\n            \n            istart++; iend--;\n            jstart++; jend--;\n            // for(auto i: res) cout << i << \" \";\n            // cout << endl;\n        }\n        /// cout << \"----\" << endl;\n        for(int i = istart; i <= iend;i++)\n            for(int j = jstart; j <= jend; j++)\n                res.push_back(matrix[i][j]);\n        \n        return res;\n    }\n};\n```\n","slug":"Spiral-Matrix","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pv00e6qmcm14hpdysh","content":"<blockquote>\n<p>第四天，这又是一道之前没AC掉的题目。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/spiral-matrix/\">54. Spiral Matrix</a></p>\n<p>题意比较好理解，写的时候注意一下下标变换即可，最好现在纸上把给出的测例手动跑一下。</p>\n<p>个人觉得，最大的坑点在第二个测例中已经给出来了，如果遇到<code>[[1], [2]]</code>或<code>[[1, 2]]</code>这种长条的要怎么做。</p>\n<p>其实我们把他当成特殊例子即可，当所给出的矩阵的行列长度不一样时，最后一定会遇到上面的情况，这样我们可以先把正常的搞定，然后在最后面处理这两种情况即可。</p>\n<p>这道题的主要思路是，我们模拟螺旋式的走法移动下标，然后一圈一圈的去游走即可，这里的代码不难，想清楚下标变换即可，最后一圈需要处理，因为最后一圈可能是三种情况：</p>\n<ul>\n<li>只有一个元素</li>\n<li>多个元素排成一列</li>\n<li>多个元素排成一行</li>\n</ul>\n<p>对于上面的三种情况，如果用之前模拟螺旋的方法，很容易走多了几步，其实只要简单的用两重循环即可。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">spiralOrder</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> istart = <span class=\"number\">0</span>, iend = matrix.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iend == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> jstart = <span class=\"number\">0</span>, jend = matrix[<span class=\"number\">0</span>].size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// printf(&quot;%d %d %d %d\\n&quot;, istart, iend, jstart, jend);</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(istart &lt; iend &amp;&amp; jstart &lt; jend) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = istart, j = jstart;</span><br><span class=\"line\">            <span class=\"comment\">// -&gt;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(;j &lt;= jend; j++)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">            j--; i++;</span><br><span class=\"line\">            <span class=\"comment\">// |</span></span><br><span class=\"line\">            <span class=\"comment\">// V</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(;i &lt;= iend; i++)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">            i--; j--;;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// &lt;-</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(;j &gt;= jstart; j--)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">            j++; i--;</span><br><span class=\"line\">            <span class=\"comment\">// ^</span></span><br><span class=\"line\">            <span class=\"comment\">// |</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(;i &gt; istart; i--)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">            </span><br><span class=\"line\">            istart++; iend--;</span><br><span class=\"line\">            jstart++; jend--;</span><br><span class=\"line\">            <span class=\"comment\">// for(auto i: res) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/// cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = istart; i &lt;= iend;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = jstart; j &lt;= jend; j++)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第四天，这又是一道之前没AC掉的题目。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/spiral-matrix/\">54. Spiral Matrix</a></p>\n<p>题意比较好理解，写的时候注意一下下标变换即可，最好现在纸上把给出的测例手动跑一下。</p>\n<p>个人觉得，最大的坑点在第二个测例中已经给出来了，如果遇到<code>[[1], [2]]</code>或<code>[[1, 2]]</code>这种长条的要怎么做。</p>\n<p>其实我们把他当成特殊例子即可，当所给出的矩阵的行列长度不一样时，最后一定会遇到上面的情况，这样我们可以先把正常的搞定，然后在最后面处理这两种情况即可。</p>\n<p>这道题的主要思路是，我们模拟螺旋式的走法移动下标，然后一圈一圈的去游走即可，这里的代码不难，想清楚下标变换即可，最后一圈需要处理，因为最后一圈可能是三种情况：</p>\n<ul>\n<li>只有一个元素</li>\n<li>多个元素排成一列</li>\n<li>多个元素排成一行</li>\n</ul>\n<p>对于上面的三种情况，如果用之前模拟螺旋的方法，很容易走多了几步，其实只要简单的用两重循环即可。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">spiralOrder</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> istart = <span class=\"number\">0</span>, iend = matrix.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iend == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> jstart = <span class=\"number\">0</span>, jend = matrix[<span class=\"number\">0</span>].size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// printf(&quot;%d %d %d %d\\n&quot;, istart, iend, jstart, jend);</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(istart &lt; iend &amp;&amp; jstart &lt; jend) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = istart, j = jstart;</span><br><span class=\"line\">            <span class=\"comment\">// -&gt;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(;j &lt;= jend; j++)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">            j--; i++;</span><br><span class=\"line\">            <span class=\"comment\">// |</span></span><br><span class=\"line\">            <span class=\"comment\">// V</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(;i &lt;= iend; i++)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">            i--; j--;;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// &lt;-</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(;j &gt;= jstart; j--)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">            j++; i--;</span><br><span class=\"line\">            <span class=\"comment\">// ^</span></span><br><span class=\"line\">            <span class=\"comment\">// |</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(;i &gt; istart; i--)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">            </span><br><span class=\"line\">            istart++; iend--;</span><br><span class=\"line\">            jstart++; jend--;</span><br><span class=\"line\">            <span class=\"comment\">// for(auto i: res) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/// cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = istart; i &lt;= iend;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = jstart; j &lt;= jend; j++)</span><br><span class=\"line\">                res.push_back(matrix[i][j]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Split-Linked-List-in-Parts","date":"2018-01-19T03:34:09.000Z","_content":"\n第88天。\n\n今天的题目是[Split Linked List in Parts](https://leetcode.com/problems/split-linked-list-in-parts/description/):\n\n> Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list \"parts\".\n>\n> The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.\n>\n> The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\n>\n> Return a List of ListNode's representing the linked list parts that are formed.\n>\n> Examples 1->2->3->4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]\n> Example 1:\n> Input: \n> root = [1, 2, 3], k = 5\n> Output: [[1],[2],[3],[],[]]\n> Explanation:\n> The input and each element of the output are ListNodes, not arrays.\n> For example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.\n> The first element output[0] has output[0].val = 1, output[0].next = null.\n> The last element output[4] is null, but it's string representation as a ListNode is [].\n> Example 2:\n> Input: \n> root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3\n> Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\n> Explanation:\n> The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n> Note:\n>\n> The length of root will be in the range [0, 1000].\n> Each value of a node in the input will be an integer in the range [0, 999].\n> k will be an integer in the range [1, 50].\n\n虽然不难，但是自己还是做了一个早上，现在的效率真的是低的可以。\n\n首先要知道每个块要有多少个节点就必须先知道总共有多少个节点，所以第一遍扫描算节点数肯定是少不了的，然后就可以开始算每个块的个数了。\n\n* `k>=n`时，显然前n块只需要放一个就好了，后面的不用管。\n* `k<n`时，可以分成两部分，前面的一部分比后面的一部分多放一个块，穷举几次可以知道，后面的部分每个快放`n/k`个节点，前面的部分有`n%k`个块。\n\n其实到这里就可以发现其实并不需要分情况,第二种已经包括了第一种了。\n\n```c++\nvector<ListNode*> splitListToParts(ListNode* root, int k) {\n    int size = 0;\n    for(ListNode *p = root;p != nullptr;p=p->next) size++;\n \n    vector<ListNode *> ret(k,nullptr);\n    int a = size/k;\n    int b = size%k;\n\n    ListNode *pre = nullptr;\n    ListNode *p = root;\n    for(int i = 0;i < k && p;i++) {\n        ret[i] = p;\n        for(int j = 0;j < a + (b>0);j++) {\n            pre = p;\n            p = p->next;\n        }\n        b--;\n        pre->next = nullptr;\n    }\n\n    return ret;\n}\n```\n","source":"_posts/Split-Linked-List-in-Parts.md","raw":"---\ntitle: Split-Linked-List-in-Parts\ndate: 2018-01-19T11:34:09.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第88天。\n\n今天的题目是[Split Linked List in Parts](https://leetcode.com/problems/split-linked-list-in-parts/description/):\n\n> Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list \"parts\".\n>\n> The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.\n>\n> The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\n>\n> Return a List of ListNode's representing the linked list parts that are formed.\n>\n> Examples 1->2->3->4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]\n> Example 1:\n> Input: \n> root = [1, 2, 3], k = 5\n> Output: [[1],[2],[3],[],[]]\n> Explanation:\n> The input and each element of the output are ListNodes, not arrays.\n> For example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.\n> The first element output[0] has output[0].val = 1, output[0].next = null.\n> The last element output[4] is null, but it's string representation as a ListNode is [].\n> Example 2:\n> Input: \n> root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3\n> Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\n> Explanation:\n> The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n> Note:\n>\n> The length of root will be in the range [0, 1000].\n> Each value of a node in the input will be an integer in the range [0, 999].\n> k will be an integer in the range [1, 50].\n\n虽然不难，但是自己还是做了一个早上，现在的效率真的是低的可以。\n\n首先要知道每个块要有多少个节点就必须先知道总共有多少个节点，所以第一遍扫描算节点数肯定是少不了的，然后就可以开始算每个块的个数了。\n\n* `k>=n`时，显然前n块只需要放一个就好了，后面的不用管。\n* `k<n`时，可以分成两部分，前面的一部分比后面的一部分多放一个块，穷举几次可以知道，后面的部分每个快放`n/k`个节点，前面的部分有`n%k`个块。\n\n其实到这里就可以发现其实并不需要分情况,第二种已经包括了第一种了。\n\n```c++\nvector<ListNode*> splitListToParts(ListNode* root, int k) {\n    int size = 0;\n    for(ListNode *p = root;p != nullptr;p=p->next) size++;\n \n    vector<ListNode *> ret(k,nullptr);\n    int a = size/k;\n    int b = size%k;\n\n    ListNode *pre = nullptr;\n    ListNode *p = root;\n    for(int i = 0;i < k && p;i++) {\n        ret[i] = p;\n        for(int j = 0;j < a + (b>0);j++) {\n            pre = p;\n            p = p->next;\n        }\n        b--;\n        pre->next = nullptr;\n    }\n\n    return ret;\n}\n```\n","slug":"Split-Linked-List-in-Parts","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pv00eaqmcm0ijv9zzg","content":"<p>第88天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/split-linked-list-in-parts/description/\">Split Linked List in Parts</a>:</p>\n<blockquote>\n<p>Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list “parts”.</p>\n<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>\n<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>\n<p>Return a List of ListNode’s representing the linked list parts that are formed.</p>\n<p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]<br>Example 1:<br>Input:<br>root = [1, 2, 3], k = 5<br>Output: [[1],[2],[3],[],[]]<br>Explanation:<br>The input and each element of the output are ListNodes, not arrays.<br>For example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.<br>The first element output[0] has output[0].val = 1, output[0].next = null.<br>The last element output[4] is null, but it’s string representation as a ListNode is [].<br>Example 2:<br>Input:<br>root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br>Explanation:<br>The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.<br>Note:</p>\n<p>The length of root will be in the range [0, 1000].<br>Each value of a node in the input will be an integer in the range [0, 999].<br>k will be an integer in the range [1, 50].</p>\n</blockquote>\n<p>虽然不难，但是自己还是做了一个早上，现在的效率真的是低的可以。</p>\n<p>首先要知道每个块要有多少个节点就必须先知道总共有多少个节点，所以第一遍扫描算节点数肯定是少不了的，然后就可以开始算每个块的个数了。</p>\n<ul>\n<li><code>k&gt;=n</code>时，显然前n块只需要放一个就好了，后面的不用管。</li>\n<li><code>k&lt;n</code>时，可以分成两部分，前面的一部分比后面的一部分多放一个块，穷举几次可以知道，后面的部分每个快放<code>n/k</code>个节点，前面的部分有<code>n%k</code>个块。</li>\n</ul>\n<p>其实到这里就可以发现其实并不需要分情况,第二种已经包括了第一种了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;ListNode*&gt; <span class=\"title\">splitListToParts</span><span class=\"params\">(ListNode* root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ListNode *p = root;p != <span class=\"literal\">nullptr</span>;p=p-&gt;next) size++;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;ListNode *&gt; <span class=\"title\">ret</span><span class=\"params\">(k,<span class=\"literal\">nullptr</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = size/k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = size%k;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    ListNode *p = root;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; k &amp;&amp; p;i++) &#123;</span><br><span class=\"line\">        ret[i] = p;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; a + (b&gt;<span class=\"number\">0</span>);j++) &#123;</span><br><span class=\"line\">            pre = p;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        b--;</span><br><span class=\"line\">        pre-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第88天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/split-linked-list-in-parts/description/\">Split Linked List in Parts</a>:</p>\n<blockquote>\n<p>Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list “parts”.</p>\n<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>\n<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>\n<p>Return a List of ListNode’s representing the linked list parts that are formed.</p>\n<p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]<br>Example 1:<br>Input:<br>root = [1, 2, 3], k = 5<br>Output: [[1],[2],[3],[],[]]<br>Explanation:<br>The input and each element of the output are ListNodes, not arrays.<br>For example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.<br>The first element output[0] has output[0].val = 1, output[0].next = null.<br>The last element output[4] is null, but it’s string representation as a ListNode is [].<br>Example 2:<br>Input:<br>root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br>Explanation:<br>The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.<br>Note:</p>\n<p>The length of root will be in the range [0, 1000].<br>Each value of a node in the input will be an integer in the range [0, 999].<br>k will be an integer in the range [1, 50].</p>\n</blockquote>\n<p>虽然不难，但是自己还是做了一个早上，现在的效率真的是低的可以。</p>\n<p>首先要知道每个块要有多少个节点就必须先知道总共有多少个节点，所以第一遍扫描算节点数肯定是少不了的，然后就可以开始算每个块的个数了。</p>\n<ul>\n<li><code>k&gt;=n</code>时，显然前n块只需要放一个就好了，后面的不用管。</li>\n<li><code>k&lt;n</code>时，可以分成两部分，前面的一部分比后面的一部分多放一个块，穷举几次可以知道，后面的部分每个快放<code>n/k</code>个节点，前面的部分有<code>n%k</code>个块。</li>\n</ul>\n<p>其实到这里就可以发现其实并不需要分情况,第二种已经包括了第一种了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;ListNode*&gt; <span class=\"title\">splitListToParts</span><span class=\"params\">(ListNode* root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ListNode *p = root;p != <span class=\"literal\">nullptr</span>;p=p-&gt;next) size++;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;ListNode *&gt; <span class=\"title\">ret</span><span class=\"params\">(k,<span class=\"literal\">nullptr</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = size/k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = size%k;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode *pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    ListNode *p = root;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; k &amp;&amp; p;i++) &#123;</span><br><span class=\"line\">        ret[i] = p;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; a + (b&gt;<span class=\"number\">0</span>);j++) &#123;</span><br><span class=\"line\">            pre = p;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        b--;</span><br><span class=\"line\">        pre-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Stone Game","date":"2019-03-13T01:38:05.000Z","_content":"\n> 第13天，今天的题目有点有趣，也有点快。\n\n今天的题目是[Stone Game](https://leetcode.com/problems/stone-game/)。\n\n恩，这道题的答案是：\n\n```c++\nclass Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        return true;\n    }\n};\n```\n\n解释如下：\n\n假设有`2n`个石头。\n\n因为`Alex`先选，那么`Alex`可以选第`1`或者`2n`个石头，如果选了`1`，那么`Lee`就只能选择`2`或者`2n`,`Lee`不管选哪个，`Alex`都可以选择一个奇数位的石头，如`3`或`2n-1`,即如果`Alex`先选了`1`,那么他可以让`Lee`一直选到的是偶数位的石头，反之亦然。因此`Alex`只要在开始选择的时候，计算所有石头奇数位之和以及偶数位之和，判断谁大就可以知道怎么选才能胜利了，因此，直接`return true`就好了。\n","source":"_posts/Stone-Game.md","raw":"---\ntitle: Stone Game\ndate: 2019-03-13T09:38:05.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第13天，今天的题目有点有趣，也有点快。\n\n今天的题目是[Stone Game](https://leetcode.com/problems/stone-game/)。\n\n恩，这道题的答案是：\n\n```c++\nclass Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        return true;\n    }\n};\n```\n\n解释如下：\n\n假设有`2n`个石头。\n\n因为`Alex`先选，那么`Alex`可以选第`1`或者`2n`个石头，如果选了`1`，那么`Lee`就只能选择`2`或者`2n`,`Lee`不管选哪个，`Alex`都可以选择一个奇数位的石头，如`3`或`2n-1`,即如果`Alex`先选了`1`,那么他可以让`Lee`一直选到的是偶数位的石头，反之亦然。因此`Alex`只要在开始选择的时候，计算所有石头奇数位之和以及偶数位之和，判断谁大就可以知道怎么选才能胜利了，因此，直接`return true`就好了。\n","slug":"Stone-Game","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pw00edqmcm4zmd0xih","content":"<blockquote>\n<p>第13天，今天的题目有点有趣，也有点快。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/stone-game/\">Stone Game</a>。</p>\n<p>恩，这道题的答案是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">stoneGame</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>解释如下：</p>\n<p>假设有<code>2n</code>个石头。</p>\n<p>因为<code>Alex</code>先选，那么<code>Alex</code>可以选第<code>1</code>或者<code>2n</code>个石头，如果选了<code>1</code>，那么<code>Lee</code>就只能选择<code>2</code>或者<code>2n</code>,<code>Lee</code>不管选哪个，<code>Alex</code>都可以选择一个奇数位的石头，如<code>3</code>或<code>2n-1</code>,即如果<code>Alex</code>先选了<code>1</code>,那么他可以让<code>Lee</code>一直选到的是偶数位的石头，反之亦然。因此<code>Alex</code>只要在开始选择的时候，计算所有石头奇数位之和以及偶数位之和，判断谁大就可以知道怎么选才能胜利了，因此，直接<code>return true</code>就好了。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第13天，今天的题目有点有趣，也有点快。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/stone-game/\">Stone Game</a>。</p>\n<p>恩，这道题的答案是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">stoneGame</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>解释如下：</p>\n<p>假设有<code>2n</code>个石头。</p>\n<p>因为<code>Alex</code>先选，那么<code>Alex</code>可以选第<code>1</code>或者<code>2n</code>个石头，如果选了<code>1</code>，那么<code>Lee</code>就只能选择<code>2</code>或者<code>2n</code>,<code>Lee</code>不管选哪个，<code>Alex</code>都可以选择一个奇数位的石头，如<code>3</code>或<code>2n-1</code>,即如果<code>Alex</code>先选了<code>1</code>,那么他可以让<code>Lee</code>一直选到的是偶数位的石头，反之亦然。因此<code>Alex</code>只要在开始选择的时候，计算所有石头奇数位之和以及偶数位之和，判断谁大就可以知道怎么选才能胜利了，因此，直接<code>return true</code>就好了。</p>\n"},{"title":"String-to-Integer(atoi)","date":"2019-02-14T13:39:48.000Z","_content":"\n> hhh, 开始一天一道LeetCode吧, 恩, 忘记了之前算到第几天了, 那么从头开始吧, 今天是第一天.\n\n今天的题目是(8. String to Integer (atoi))[https://leetcode.com/problems/string-to-integer-atoi/]\n\n题目描述:\n\nImplement atoi which converts a string to an integer.\n\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\n\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\n\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\n\nIf no valid conversion could be performed, a zero value is returned.\n\nNote:\n\n- Only the space character ' ' is considered as whitespace character.\n- Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.\n\nExample 1:\n\n> Input: \"42\"\n> Output: 42\n\nExample 2:\n\n> Input: \"   -42\"\n> Output: -42\n> Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42.\n\nExample 3:\n\n> Input: \"4193 with words\"\n> Output: 4193\n> Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.\n\nExample 4:\n\n> Input: \"words and 987\"\n> Output: 0\n> Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.\n\nExample 5:\n\n> Input: \"-91283472332\"\n> Output: -2147483648\n> Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.\n\n怎么说呢， 这是一道编程題， 而不是算法题， 事实上没用到什么算法， 把逻辑理清楚， 然后注意一下坑就好了。\n\n我们现在来理一理`atoi()`的逻辑：\n\n- 我们要跳过字符串开头的所有空格。\n- 第一个非空格字符，只能是`+`, `-`以及`0`到`9`的所以数字。\n- 如果第一个非空格字符是`-`， 我们就要返回一个负数。\n- 解析字符串中的数字， 直到遇到第一个非数字就结束（或者遍历晚字符串）\n- 然后如果在解析数字的时候发现， 如果溢出了， 就直接返回`INT_MAX`或`INT_MIN`(看前面是否有符号)\n\n感觉整个逻辑还是比较好写的， 就只有一个麻烦点：`怎么判断是否溢出了？`\n\n有两个方法：\n\n- 方法一：\n\n    因为`atoi()`只解析32位的有符号整数， 所以我们可以直接用64位的整数来计算结果，这样就可以直接判断是否超出32位的范围了，也就是用`long long`, 但是这样要计算64位的乘法和加法，会比较耗时。\n\n- 方法二：\n\n    直接用32位的整数来计算结果， 在解释这个方法前，我们先看下是如何解析数字的, 解析数字主要就是把单个字符转成数字， 然后通过以下等式来迭代计算结果`res = res * 10 + i;`。可以看到这里有一个乘10的计算，所以我们可以在计算这个等式之前， 用`INT_MAX/10`来判断是否溢出。\n\n\n\n```cpp\nint myAtoi(string str) {\n    int res = 0;\n    \n    // clear space\n    int beg = 0;\n    while(beg < str.size()) {\n        char c = str[beg];\n        if (c == ' ') beg++;\n        else if (c == '-' || c == '+'||(c <= '9' && c >= '0')) break;\n        else return res;\n    }\n    \n    int sign = 1;\n    int max_num = INT_MAX;\n    // if we have '+' or '-'\n    if (str[beg] == '+') {\n        beg++;\n    } else if (str[beg] == '-') {\n        beg++;\n        sign = -1; max_num = INT_MIN;\n    }\n    \n    const int c = INT_MAX/10;\n    \n    for(;beg < str.size() && str[beg] >= '0' && str[beg] <= '9'; beg++) {\n        int i = str[beg]-'0';\n        if (res > c || (res == c && i > 7)) return max_num;\n        res = res * 10 + i;\n    }\n    \n    return sign*res;\n}\n```\n","source":"_posts/String-to-Integer-atoi.md","raw":"---\ntitle: String-to-Integer(atoi)\ndate: 2019-02-14T21:39:48.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> hhh, 开始一天一道LeetCode吧, 恩, 忘记了之前算到第几天了, 那么从头开始吧, 今天是第一天.\n\n今天的题目是(8. String to Integer (atoi))[https://leetcode.com/problems/string-to-integer-atoi/]\n\n题目描述:\n\nImplement atoi which converts a string to an integer.\n\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\n\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\n\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\n\nIf no valid conversion could be performed, a zero value is returned.\n\nNote:\n\n- Only the space character ' ' is considered as whitespace character.\n- Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.\n\nExample 1:\n\n> Input: \"42\"\n> Output: 42\n\nExample 2:\n\n> Input: \"   -42\"\n> Output: -42\n> Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42.\n\nExample 3:\n\n> Input: \"4193 with words\"\n> Output: 4193\n> Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.\n\nExample 4:\n\n> Input: \"words and 987\"\n> Output: 0\n> Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.\n\nExample 5:\n\n> Input: \"-91283472332\"\n> Output: -2147483648\n> Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.\n\n怎么说呢， 这是一道编程題， 而不是算法题， 事实上没用到什么算法， 把逻辑理清楚， 然后注意一下坑就好了。\n\n我们现在来理一理`atoi()`的逻辑：\n\n- 我们要跳过字符串开头的所有空格。\n- 第一个非空格字符，只能是`+`, `-`以及`0`到`9`的所以数字。\n- 如果第一个非空格字符是`-`， 我们就要返回一个负数。\n- 解析字符串中的数字， 直到遇到第一个非数字就结束（或者遍历晚字符串）\n- 然后如果在解析数字的时候发现， 如果溢出了， 就直接返回`INT_MAX`或`INT_MIN`(看前面是否有符号)\n\n感觉整个逻辑还是比较好写的， 就只有一个麻烦点：`怎么判断是否溢出了？`\n\n有两个方法：\n\n- 方法一：\n\n    因为`atoi()`只解析32位的有符号整数， 所以我们可以直接用64位的整数来计算结果，这样就可以直接判断是否超出32位的范围了，也就是用`long long`, 但是这样要计算64位的乘法和加法，会比较耗时。\n\n- 方法二：\n\n    直接用32位的整数来计算结果， 在解释这个方法前，我们先看下是如何解析数字的, 解析数字主要就是把单个字符转成数字， 然后通过以下等式来迭代计算结果`res = res * 10 + i;`。可以看到这里有一个乘10的计算，所以我们可以在计算这个等式之前， 用`INT_MAX/10`来判断是否溢出。\n\n\n\n```cpp\nint myAtoi(string str) {\n    int res = 0;\n    \n    // clear space\n    int beg = 0;\n    while(beg < str.size()) {\n        char c = str[beg];\n        if (c == ' ') beg++;\n        else if (c == '-' || c == '+'||(c <= '9' && c >= '0')) break;\n        else return res;\n    }\n    \n    int sign = 1;\n    int max_num = INT_MAX;\n    // if we have '+' or '-'\n    if (str[beg] == '+') {\n        beg++;\n    } else if (str[beg] == '-') {\n        beg++;\n        sign = -1; max_num = INT_MIN;\n    }\n    \n    const int c = INT_MAX/10;\n    \n    for(;beg < str.size() && str[beg] >= '0' && str[beg] <= '9'; beg++) {\n        int i = str[beg]-'0';\n        if (res > c || (res == c && i > 7)) return max_num;\n        res = res * 10 + i;\n    }\n    \n    return sign*res;\n}\n```\n","slug":"String-to-Integer-atoi","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69px00ehqmcm9snq1e9f","content":"<blockquote>\n<p>hhh, 开始一天一道LeetCode吧, 恩, 忘记了之前算到第几天了, 那么从头开始吧, 今天是第一天.</p>\n</blockquote>\n<p>今天的题目是(8. String to Integer (atoi))[<a href=\"https://leetcode.com/problems/string-to-integer-atoi/]\">https://leetcode.com/problems/string-to-integer-atoi/]</a></p>\n<p>题目描述:</p>\n<p>Implement atoi which converts a string to an integer.</p>\n<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>\n<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>\n<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>\n<p>If no valid conversion could be performed, a zero value is returned.</p>\n<p>Note:</p>\n<ul>\n<li>Only the space character ‘ ‘ is considered as whitespace character.</li>\n<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.</li>\n</ul>\n<p>Example 1:</p>\n<blockquote>\n<p>Input: “42”<br>Output: 42</p>\n</blockquote>\n<p>Example 2:</p>\n<blockquote>\n<p>Input: “   -42”<br>Output: -42<br>Explanation: The first non-whitespace character is ‘-‘, which is the minus sign. Then take as many numerical digits as possible, which gets 42.</p>\n</blockquote>\n<p>Example 3:</p>\n<blockquote>\n<p>Input: “4193 with words”<br>Output: 4193<br>Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p>\n</blockquote>\n<p>Example 4:</p>\n<blockquote>\n<p>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p>\n</blockquote>\n<p>Example 5:</p>\n<blockquote>\n<p>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.</p>\n</blockquote>\n<p>怎么说呢， 这是一道编程題， 而不是算法题， 事实上没用到什么算法， 把逻辑理清楚， 然后注意一下坑就好了。</p>\n<p>我们现在来理一理<code>atoi()</code>的逻辑：</p>\n<ul>\n<li>我们要跳过字符串开头的所有空格。</li>\n<li>第一个非空格字符，只能是<code>+</code>, <code>-</code>以及<code>0</code>到<code>9</code>的所以数字。</li>\n<li>如果第一个非空格字符是<code>-</code>， 我们就要返回一个负数。</li>\n<li>解析字符串中的数字， 直到遇到第一个非数字就结束（或者遍历晚字符串）</li>\n<li>然后如果在解析数字的时候发现， 如果溢出了， 就直接返回<code>INT_MAX</code>或<code>INT_MIN</code>(看前面是否有符号)</li>\n</ul>\n<p>感觉整个逻辑还是比较好写的， 就只有一个麻烦点：<code>怎么判断是否溢出了？</code></p>\n<p>有两个方法：</p>\n<ul>\n<li><p>方法一：</p>\n<p>  因为<code>atoi()</code>只解析32位的有符号整数， 所以我们可以直接用64位的整数来计算结果，这样就可以直接判断是否超出32位的范围了，也就是用<code>long long</code>, 但是这样要计算64位的乘法和加法，会比较耗时。</p>\n</li>\n<li><p>方法二：</p>\n<p>  直接用32位的整数来计算结果， 在解释这个方法前，我们先看下是如何解析数字的, 解析数字主要就是把单个字符转成数字， 然后通过以下等式来迭代计算结果<code>res = res * 10 + i;</code>。可以看到这里有一个乘10的计算，所以我们可以在计算这个等式之前， 用<code>INT_MAX/10</code>来判断是否溢出。</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">myAtoi</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// clear space</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg &lt; str.size()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = str[beg];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27; &#x27;</span>) beg++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;-&#x27;</span> || c == <span class=\"string\">&#x27;+&#x27;</span>||(c &lt;= <span class=\"string\">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class=\"string\">&#x27;0&#x27;</span>)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> sign = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_num = INT_MAX;</span><br><span class=\"line\">    <span class=\"comment\">// if we have &#x27;+&#x27; or &#x27;-&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str[beg] == <span class=\"string\">&#x27;+&#x27;</span>) &#123;</span><br><span class=\"line\">        beg++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (str[beg] == <span class=\"string\">&#x27;-&#x27;</span>) &#123;</span><br><span class=\"line\">        beg++;</span><br><span class=\"line\">        sign = <span class=\"number\">-1</span>; max_num = INT_MIN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> c = INT_MAX/<span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;beg &lt; str.size() &amp;&amp; str[beg] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; str[beg] &lt;= <span class=\"string\">&#x27;9&#x27;</span>; beg++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = str[beg]-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res &gt; c || (res == c &amp;&amp; i &gt; <span class=\"number\">7</span>)) <span class=\"keyword\">return</span> max_num;</span><br><span class=\"line\">        res = res * <span class=\"number\">10</span> + i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sign*res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>hhh, 开始一天一道LeetCode吧, 恩, 忘记了之前算到第几天了, 那么从头开始吧, 今天是第一天.</p>\n</blockquote>\n<p>今天的题目是(8. String to Integer (atoi))[<a href=\"https://leetcode.com/problems/string-to-integer-atoi/]\">https://leetcode.com/problems/string-to-integer-atoi/]</a></p>\n<p>题目描述:</p>\n<p>Implement atoi which converts a string to an integer.</p>\n<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>\n<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>\n<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>\n<p>If no valid conversion could be performed, a zero value is returned.</p>\n<p>Note:</p>\n<ul>\n<li>Only the space character ‘ ‘ is considered as whitespace character.</li>\n<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.</li>\n</ul>\n<p>Example 1:</p>\n<blockquote>\n<p>Input: “42”<br>Output: 42</p>\n</blockquote>\n<p>Example 2:</p>\n<blockquote>\n<p>Input: “   -42”<br>Output: -42<br>Explanation: The first non-whitespace character is ‘-‘, which is the minus sign. Then take as many numerical digits as possible, which gets 42.</p>\n</blockquote>\n<p>Example 3:</p>\n<blockquote>\n<p>Input: “4193 with words”<br>Output: 4193<br>Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p>\n</blockquote>\n<p>Example 4:</p>\n<blockquote>\n<p>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p>\n</blockquote>\n<p>Example 5:</p>\n<blockquote>\n<p>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.</p>\n</blockquote>\n<p>怎么说呢， 这是一道编程題， 而不是算法题， 事实上没用到什么算法， 把逻辑理清楚， 然后注意一下坑就好了。</p>\n<p>我们现在来理一理<code>atoi()</code>的逻辑：</p>\n<ul>\n<li>我们要跳过字符串开头的所有空格。</li>\n<li>第一个非空格字符，只能是<code>+</code>, <code>-</code>以及<code>0</code>到<code>9</code>的所以数字。</li>\n<li>如果第一个非空格字符是<code>-</code>， 我们就要返回一个负数。</li>\n<li>解析字符串中的数字， 直到遇到第一个非数字就结束（或者遍历晚字符串）</li>\n<li>然后如果在解析数字的时候发现， 如果溢出了， 就直接返回<code>INT_MAX</code>或<code>INT_MIN</code>(看前面是否有符号)</li>\n</ul>\n<p>感觉整个逻辑还是比较好写的， 就只有一个麻烦点：<code>怎么判断是否溢出了？</code></p>\n<p>有两个方法：</p>\n<ul>\n<li><p>方法一：</p>\n<p>  因为<code>atoi()</code>只解析32位的有符号整数， 所以我们可以直接用64位的整数来计算结果，这样就可以直接判断是否超出32位的范围了，也就是用<code>long long</code>, 但是这样要计算64位的乘法和加法，会比较耗时。</p>\n</li>\n<li><p>方法二：</p>\n<p>  直接用32位的整数来计算结果， 在解释这个方法前，我们先看下是如何解析数字的, 解析数字主要就是把单个字符转成数字， 然后通过以下等式来迭代计算结果<code>res = res * 10 + i;</code>。可以看到这里有一个乘10的计算，所以我们可以在计算这个等式之前， 用<code>INT_MAX/10</code>来判断是否溢出。</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">myAtoi</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// clear space</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg &lt; str.size()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = str[beg];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27; &#x27;</span>) beg++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;-&#x27;</span> || c == <span class=\"string\">&#x27;+&#x27;</span>||(c &lt;= <span class=\"string\">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class=\"string\">&#x27;0&#x27;</span>)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> sign = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_num = INT_MAX;</span><br><span class=\"line\">    <span class=\"comment\">// if we have &#x27;+&#x27; or &#x27;-&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str[beg] == <span class=\"string\">&#x27;+&#x27;</span>) &#123;</span><br><span class=\"line\">        beg++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (str[beg] == <span class=\"string\">&#x27;-&#x27;</span>) &#123;</span><br><span class=\"line\">        beg++;</span><br><span class=\"line\">        sign = <span class=\"number\">-1</span>; max_num = INT_MIN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> c = INT_MAX/<span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;beg &lt; str.size() &amp;&amp; str[beg] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; str[beg] &lt;= <span class=\"string\">&#x27;9&#x27;</span>; beg++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = str[beg]-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res &gt; c || (res == c &amp;&amp; i &gt; <span class=\"number\">7</span>)) <span class=\"keyword\">return</span> max_num;</span><br><span class=\"line\">        res = res * <span class=\"number\">10</span> + i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sign*res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Subsets","date":"2017-10-20T01:28:46.000Z","_content":"\n第27天\n\n今天的题目是[Subsets](https://leetcode.com/problems/subsets/description/):\n\n> Given a set of distinct integers, nums, return all possible subsets.\n>\n> Note: The solution set must not contain duplicate subsets.\n>\n> For example,\n> If nums = [1,2,3], a solution is:\n\n```python\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n我的做法是用递归的方法去做:\n\n```c++\nvector<vector<int>> subsets(vector<int>& nums) {\n    vector< vector<int> > ret;\n    vector<int> vec;\n    ret.push_back(vec);\n    subsetsIter(ret,nums,vec,0);\n    return ret;\n}\n\nvoid subsetsIter(vector< vector<int> > &ret,vector<int> &nums,vector<int> now,int beg) {\n    //if (now.size() == nums.size()) return ;\n    now.push_back(-1);\n    auto rbeg = now.rbegin();\n    for(int i = beg;i < nums.size();i++) {\n        *rbeg = nums[i];\n        ret.push_back(now);\n        subsetsIter(ret,nums,now,i+1);\n    }\n    now.pop_back();\n}\n```\n\n\n然后是在`dicuss`中看到的迭代的方法和利用二进制的方法：\n\n```c++\nvector<vector<int>> subsets(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    vector<vector<int>> subs(1, vector<int>());\n    for (int i = 0; i < nums.size(); i++) {\n        int n = subs.size();\n        for (int j = 0; j < n; j++) {\n            subs.push_back(subs[j]); \n            subs.back().push_back(nums[i]);\n        }\n    }\n    return subs;\n}\n```\n\n```c++\nvector<vector<int>> subsets(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int num_subset = pow(2, nums.size()); \n    vector<vector<int> > res(num_subset, vector<int>());\n    for (int i = 0; i < nums.size(); i++)\n        for (int j = 0; j < num_subset; j++)\n            if ((j >> i) & 1)\n                res[j].push_back(nums[i]);\n    return res;  \n}\n```\n","source":"_posts/Subsets.md","raw":"---\ntitle: Subsets\ndate: 2017-10-20T09:28:46.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第27天\n\n今天的题目是[Subsets](https://leetcode.com/problems/subsets/description/):\n\n> Given a set of distinct integers, nums, return all possible subsets.\n>\n> Note: The solution set must not contain duplicate subsets.\n>\n> For example,\n> If nums = [1,2,3], a solution is:\n\n```python\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n我的做法是用递归的方法去做:\n\n```c++\nvector<vector<int>> subsets(vector<int>& nums) {\n    vector< vector<int> > ret;\n    vector<int> vec;\n    ret.push_back(vec);\n    subsetsIter(ret,nums,vec,0);\n    return ret;\n}\n\nvoid subsetsIter(vector< vector<int> > &ret,vector<int> &nums,vector<int> now,int beg) {\n    //if (now.size() == nums.size()) return ;\n    now.push_back(-1);\n    auto rbeg = now.rbegin();\n    for(int i = beg;i < nums.size();i++) {\n        *rbeg = nums[i];\n        ret.push_back(now);\n        subsetsIter(ret,nums,now,i+1);\n    }\n    now.pop_back();\n}\n```\n\n\n然后是在`dicuss`中看到的迭代的方法和利用二进制的方法：\n\n```c++\nvector<vector<int>> subsets(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    vector<vector<int>> subs(1, vector<int>());\n    for (int i = 0; i < nums.size(); i++) {\n        int n = subs.size();\n        for (int j = 0; j < n; j++) {\n            subs.push_back(subs[j]); \n            subs.back().push_back(nums[i]);\n        }\n    }\n    return subs;\n}\n```\n\n```c++\nvector<vector<int>> subsets(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int num_subset = pow(2, nums.size()); \n    vector<vector<int> > res(num_subset, vector<int>());\n    for (int i = 0; i < nums.size(); i++)\n        for (int j = 0; j < num_subset; j++)\n            if ((j >> i) & 1)\n                res[j].push_back(nums[i]);\n    return res;  \n}\n```\n","slug":"Subsets","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69px00ekqmcm40brgumj","content":"<p>第27天</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/subsets/description/\">Subsets</a>:</p>\n<blockquote>\n<p>Given a set of distinct integers, nums, return all possible subsets.</p>\n<p>Note: The solution set must not contain duplicate subsets.</p>\n<p>For example,<br>If nums = [1,2,3], a solution is:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  []</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>我的做法是用递归的方法去做:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; subsets(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt; <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    ret.push_back(vec);</span><br><span class=\"line\">    subsetsIter(ret,nums,vec,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">subsetsIter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt; <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;ret,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; now,<span class=\"keyword\">int</span> beg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if (now.size() == nums.size()) return ;</span></span><br><span class=\"line\">    now.push_back(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> rbeg = now.rbegin();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        *rbeg = nums[i];</span><br><span class=\"line\">        ret.push_back(now);</span><br><span class=\"line\">        subsetsIter(ret,nums,now,i+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    now.pop_back();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>然后是在<code>dicuss</code>中看到的迭代的方法和利用二进制的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; subsets(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">    sort(nums.begin(), nums.end());</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; subs(<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = subs.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            subs.push_back(subs[j]); </span><br><span class=\"line\">            subs.back().push_back(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> subs;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; subsets(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">    sort(nums.begin(), nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num_subset = <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, nums.size()); </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res(num_subset, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; num_subset; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((j &gt;&gt; i) &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">                res[j].push_back(nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第27天</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/subsets/description/\">Subsets</a>:</p>\n<blockquote>\n<p>Given a set of distinct integers, nums, return all possible subsets.</p>\n<p>Note: The solution set must not contain duplicate subsets.</p>\n<p>For example,<br>If nums = [1,2,3], a solution is:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  []</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>我的做法是用递归的方法去做:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; subsets(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt; <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; ret;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    ret.push_back(vec);</span><br><span class=\"line\">    subsetsIter(ret,nums,vec,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">subsetsIter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt; <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; &amp;ret,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; now,<span class=\"keyword\">int</span> beg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if (now.size() == nums.size()) return ;</span></span><br><span class=\"line\">    now.push_back(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> rbeg = now.rbegin();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = beg;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        *rbeg = nums[i];</span><br><span class=\"line\">        ret.push_back(now);</span><br><span class=\"line\">        subsetsIter(ret,nums,now,i+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    now.pop_back();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>然后是在<code>dicuss</code>中看到的迭代的方法和利用二进制的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; subsets(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">    sort(nums.begin(), nums.end());</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; subs(<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = subs.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            subs.push_back(subs[j]); </span><br><span class=\"line\">            subs.back().push_back(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> subs;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; subsets(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">    sort(nums.begin(), nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num_subset = <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, nums.size()); </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res(num_subset, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; num_subset; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((j &gt;&gt; i) &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">                res[j].push_back(nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Sum Root to Leaf Numbers","date":"2019-03-06T00:43:17.000Z","_content":"\n> 第7天，为什么今天随机到了一道水题。。。\n\n今天的题目是[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\n\n恩，这是一道打卡水题，明明是道`Easy`的题目，却混进了`Medium`中：\n\n这道题有个比较容易想错的方法就是，用后序遍历做：\n\n```c++\nint sumNumbers(TreeNode* root) {\n    if (root == nullptr) return 0;\n    return sumNumbers(root->left) + sumNumbers(root->right) + 20 * root->val;\n}\n```\n\n这个方法对满二叉树是没问题的，但是对于普通的二叉树就会有问题，如：\n\n```\n    1\n  /  \n 2 \n```\n\n也就是说，在两边高度不一样时，是会出问题的，为了解决这个问题，我们要把思路换过来，把`root`到当前节点的值计算出来，并传给子节点去计算：\n\n```c++\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return sumNumbers(root, 0);\n    }\n    int sumNumbers(TreeNode* root, int v) {\n        if (root == nullptr) return 0;\n        \n        v = v*10 + root->val;\n        if (root->right == nullptr && root->left == nullptr) return v;\n        \n        return sumNumbers(root->left, v) + sumNumbers(root->right, v);\n    }\n};\n```\n","source":"_posts/Sum-Root-to-Leaf-Numbers.md","raw":"---\ntitle: Sum Root to Leaf Numbers\ndate: 2019-03-06T08:43:17.000Z\ntags:\n  - LeetCode\n  - Tree\ncategories:\n  - LeetCode\n---\n\n> 第7天，为什么今天随机到了一道水题。。。\n\n今天的题目是[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\n\n恩，这是一道打卡水题，明明是道`Easy`的题目，却混进了`Medium`中：\n\n这道题有个比较容易想错的方法就是，用后序遍历做：\n\n```c++\nint sumNumbers(TreeNode* root) {\n    if (root == nullptr) return 0;\n    return sumNumbers(root->left) + sumNumbers(root->right) + 20 * root->val;\n}\n```\n\n这个方法对满二叉树是没问题的，但是对于普通的二叉树就会有问题，如：\n\n```\n    1\n  /  \n 2 \n```\n\n也就是说，在两边高度不一样时，是会出问题的，为了解决这个问题，我们要把思路换过来，把`root`到当前节点的值计算出来，并传给子节点去计算：\n\n```c++\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return sumNumbers(root, 0);\n    }\n    int sumNumbers(TreeNode* root, int v) {\n        if (root == nullptr) return 0;\n        \n        v = v*10 + root->val;\n        if (root->right == nullptr && root->left == nullptr) return v;\n        \n        return sumNumbers(root->left, v) + sumNumbers(root->right, v);\n    }\n};\n```\n","slug":"Sum-Root-to-Leaf-Numbers","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69py00enqmcmcmc1hyqx","content":"<blockquote>\n<p>第7天，为什么今天随机到了一道水题。。。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/sum-root-to-leaf-numbers/\">129. Sum Root to Leaf Numbers</a></p>\n<p>恩，这是一道打卡水题，明明是道<code>Easy</code>的题目，却混进了<code>Medium</code>中：</p>\n<p>这道题有个比较容易想错的方法就是，用后序遍历做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumNumbers</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sumNumbers(root-&gt;left) + sumNumbers(root-&gt;right) + <span class=\"number\">20</span> * root-&gt;val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法对满二叉树是没问题的，但是对于普通的二叉树就会有问题，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   1</span><br><span class=\"line\"> &#x2F;  </span><br><span class=\"line\">2 </span><br></pre></td></tr></table></figure>\n\n<p>也就是说，在两边高度不一样时，是会出问题的，为了解决这个问题，我们要把思路换过来，把<code>root</code>到当前节点的值计算出来，并传给子节点去计算：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumNumbers</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sumNumbers(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumNumbers</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        v = v*<span class=\"number\">10</span> + root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;left == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> sumNumbers(root-&gt;left, v) + sumNumbers(root-&gt;right, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第7天，为什么今天随机到了一道水题。。。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/sum-root-to-leaf-numbers/\">129. Sum Root to Leaf Numbers</a></p>\n<p>恩，这是一道打卡水题，明明是道<code>Easy</code>的题目，却混进了<code>Medium</code>中：</p>\n<p>这道题有个比较容易想错的方法就是，用后序遍历做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumNumbers</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sumNumbers(root-&gt;left) + sumNumbers(root-&gt;right) + <span class=\"number\">20</span> * root-&gt;val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法对满二叉树是没问题的，但是对于普通的二叉树就会有问题，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   1</span><br><span class=\"line\"> &#x2F;  </span><br><span class=\"line\">2 </span><br></pre></td></tr></table></figure>\n\n<p>也就是说，在两边高度不一样时，是会出问题的，为了解决这个问题，我们要把思路换过来，把<code>root</code>到当前节点的值计算出来，并传给子节点去计算：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumNumbers</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sumNumbers(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumNumbers</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        v = v*<span class=\"number\">10</span> + root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;left == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> sumNumbers(root-&gt;left, v) + sumNumbers(root-&gt;right, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Swaps-Nodes-in-Pairs","date":"2017-12-01T05:24:36.000Z","_content":"\n第65天。\n\n今天的题目是[Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/description/):\n\n> Given a linked list, swap every two adjacent nodes and return its head.\n>\n> For example,\n> Given 1->2->3->4, you should return the list as 2->1->4->3.\n>\n> Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.\n\n和之前做的链表翻转有点像，可以用指针的指针来做：\n\n```c++\nbool swap(ListNode **head) {\n    if (*head == nullptr || ( *head)->next == nullptr) return false;\n    ListNode *p = *head;\n    ListNode *next = p->next;\n    p->next = next->next;\n    next->next = p;\n    *head = next;\n    return true;\n}\nListNode* swapPairs(ListNode* head) {\n    ListNode **p = &head;\n    while(swap(p))\n        p=&((*p)->next->next);\n    return head;\n}\n```\n","source":"_posts/Swaps-Nodes-in-Pairs.md","raw":"---\ntitle: Swaps-Nodes-in-Pairs\ndate: 2017-12-01T13:24:36.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - ListNode\n---\n\n第65天。\n\n今天的题目是[Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/description/):\n\n> Given a linked list, swap every two adjacent nodes and return its head.\n>\n> For example,\n> Given 1->2->3->4, you should return the list as 2->1->4->3.\n>\n> Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.\n\n和之前做的链表翻转有点像，可以用指针的指针来做：\n\n```c++\nbool swap(ListNode **head) {\n    if (*head == nullptr || ( *head)->next == nullptr) return false;\n    ListNode *p = *head;\n    ListNode *next = p->next;\n    p->next = next->next;\n    next->next = p;\n    *head = next;\n    return true;\n}\nListNode* swapPairs(ListNode* head) {\n    ListNode **p = &head;\n    while(swap(p))\n        p=&((*p)->next->next);\n    return head;\n}\n```\n","slug":"Swaps-Nodes-in-Pairs","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69pz00erqmcmhwgw30m0","content":"<p>第65天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/description/\">Swap Nodes in Pairs</a>:</p>\n<blockquote>\n<p>Given a linked list, swap every two adjacent nodes and return its head.</p>\n<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>\n<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>\n</blockquote>\n<p>和之前做的链表翻转有点像，可以用指针的指针来做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">swap</span><span class=\"params\">(ListNode **head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*head == <span class=\"literal\">nullptr</span> || ( *head)-&gt;next == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    ListNode *p = *head;</span><br><span class=\"line\">    ListNode *next = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = next-&gt;next;</span><br><span class=\"line\">    next-&gt;next = p;</span><br><span class=\"line\">    *head = next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    ListNode **p = &amp;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(swap(p))</span><br><span class=\"line\">        p=&amp;((*p)-&gt;next-&gt;next);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第65天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/description/\">Swap Nodes in Pairs</a>:</p>\n<blockquote>\n<p>Given a linked list, swap every two adjacent nodes and return its head.</p>\n<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>\n<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>\n</blockquote>\n<p>和之前做的链表翻转有点像，可以用指针的指针来做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">swap</span><span class=\"params\">(ListNode **head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*head == <span class=\"literal\">nullptr</span> || ( *head)-&gt;next == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    ListNode *p = *head;</span><br><span class=\"line\">    ListNode *next = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = next-&gt;next;</span><br><span class=\"line\">    next-&gt;next = p;</span><br><span class=\"line\">    *head = next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    ListNode **p = &amp;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(swap(p))</span><br><span class=\"line\">        p=&amp;((*p)-&gt;next-&gt;next);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Symmetric Tree","date":"2017-11-14T02:49:31.000Z","_content":"\n第48天。\n\n今天的题目是[Symmetric Tree](https://leetcode.com/problems/symmetric-tree/description/):\n\n> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n>\n> For example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n```python\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n\n> But the following [1,2,2,null,3,null,3] is not:\n\n```python\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n```\n\n刚看的时候还有点懵，要怎么递归的去求解这种问题呢，要比较的两个节点隔得有点远啊。后来是上课时突然想到对称其实和根节点的左子树和右子树有关，我们把他当成两个树来求解就好了，递归时需要两个`TreeNode`:\n\n```python\ndef isSymmetric1(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return True\n    else:\n        return self.isSymmetricRec(root.left,root.right)\n\ndef isSymmetricRec(self,left,right):\n    \"\"\"\n    :type left: TreeNode\n    :type right: TreeNode\n    :rtype: bool\n    \"\"\"\n    if left is None and right is None:\n        return True\n    elif left is not None and right is not None:\n        return left.val == right.val \\\n                and self.isSymmetricRec(left.left,right.right) \\\n                and self.isSymmetricRec(left.right,right.left)\n    else:\n        return False\n```\n\n然后是迭代解，这里是用层次遍历去做的：\n\n```python\ndef isSymmetricBFS(self,root):\n    \"\"\"\n    :type root:TreeNode\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return True\n\n    leftqueue = Queue()\n    rightqueue = Queue()\n\n    leftqueue.put(root.left)\n    rightqueue.put(root.right)\n\n    while not leftqueue.empty():\n        left = leftqueue.get()\n        right = rightqueue.get()\n        if left is None and right is None:\n            continue\n        elif left is not None and right is not None:\n            if left.val != right.val:\n                return False\n            leftqueue.put(left.left)\n            leftqueue.put(left.right)\n            rightqueue.put(right.right)\n            rightqueue.put(right.left)\n        else:\n            return False\n    return True\n```\n\n然后是在`dicuss`中看到的`c++`解法，思路其实是一样的：\n\n```c++\nbool isSymmetric(TreeNode *root) {\n    if (!root) return true;\n    return helper(root->left, root->right);\n}\n\nbool helper(TreeNode* p, TreeNode* q) {\n    if (!p && !q) {\n        return true;\n    } else if (!p || !q) {\n        return false;\n    }\n\n    if (p->val != q->val) {\n        return false;\n    }\n\n    return helper(p->left,q->right) && helper(p->right, q->left); \n}\n```\n\n```c++\nbool isSymmetric(TreeNode *root) {\n    TreeNode *left, *right;\n    if (!root)\n        return true;\n\n    queue<TreeNode*> q1, q2;\n    q1.push(root->left);\n    q2.push(root->right);\n    while (!q1.empty() && !q2.empty()){\n        left = q1.front();\n        q1.pop();\n        right = q2.front();\n        q2.pop();\n        if (NULL == left && NULL == right)\n            continue;\n        if (NULL == left || NULL == right)\n            return false;\n        if (left->val != right->val)\n            return false;\n        q1.push(left->left);\n        q1.push(left->right);\n        q2.push(right->right);\n        q2.push(right->left);\n    }\n    return true;\n}\n```\n","source":"_posts/Symmetric-Tree.md","raw":"---\ntitle: Symmetric Tree\ndate: 2017-11-14T10:49:31.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - Tree\n---\n\n第48天。\n\n今天的题目是[Symmetric Tree](https://leetcode.com/problems/symmetric-tree/description/):\n\n> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n>\n> For example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n```python\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n\n> But the following [1,2,2,null,3,null,3] is not:\n\n```python\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n```\n\n刚看的时候还有点懵，要怎么递归的去求解这种问题呢，要比较的两个节点隔得有点远啊。后来是上课时突然想到对称其实和根节点的左子树和右子树有关，我们把他当成两个树来求解就好了，递归时需要两个`TreeNode`:\n\n```python\ndef isSymmetric1(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return True\n    else:\n        return self.isSymmetricRec(root.left,root.right)\n\ndef isSymmetricRec(self,left,right):\n    \"\"\"\n    :type left: TreeNode\n    :type right: TreeNode\n    :rtype: bool\n    \"\"\"\n    if left is None and right is None:\n        return True\n    elif left is not None and right is not None:\n        return left.val == right.val \\\n                and self.isSymmetricRec(left.left,right.right) \\\n                and self.isSymmetricRec(left.right,right.left)\n    else:\n        return False\n```\n\n然后是迭代解，这里是用层次遍历去做的：\n\n```python\ndef isSymmetricBFS(self,root):\n    \"\"\"\n    :type root:TreeNode\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return True\n\n    leftqueue = Queue()\n    rightqueue = Queue()\n\n    leftqueue.put(root.left)\n    rightqueue.put(root.right)\n\n    while not leftqueue.empty():\n        left = leftqueue.get()\n        right = rightqueue.get()\n        if left is None and right is None:\n            continue\n        elif left is not None and right is not None:\n            if left.val != right.val:\n                return False\n            leftqueue.put(left.left)\n            leftqueue.put(left.right)\n            rightqueue.put(right.right)\n            rightqueue.put(right.left)\n        else:\n            return False\n    return True\n```\n\n然后是在`dicuss`中看到的`c++`解法，思路其实是一样的：\n\n```c++\nbool isSymmetric(TreeNode *root) {\n    if (!root) return true;\n    return helper(root->left, root->right);\n}\n\nbool helper(TreeNode* p, TreeNode* q) {\n    if (!p && !q) {\n        return true;\n    } else if (!p || !q) {\n        return false;\n    }\n\n    if (p->val != q->val) {\n        return false;\n    }\n\n    return helper(p->left,q->right) && helper(p->right, q->left); \n}\n```\n\n```c++\nbool isSymmetric(TreeNode *root) {\n    TreeNode *left, *right;\n    if (!root)\n        return true;\n\n    queue<TreeNode*> q1, q2;\n    q1.push(root->left);\n    q2.push(root->right);\n    while (!q1.empty() && !q2.empty()){\n        left = q1.front();\n        q1.pop();\n        right = q2.front();\n        q2.pop();\n        if (NULL == left && NULL == right)\n            continue;\n        if (NULL == left || NULL == right)\n            return false;\n        if (left->val != right->val)\n            return false;\n        q1.push(left->left);\n        q1.push(left->right);\n        q2.push(right->right);\n        q2.push(right->left);\n    }\n    return true;\n}\n```\n","slug":"Symmetric-Tree","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q000euqmcm4mua61v1","content":"<p>第48天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/symmetric-tree/description/\">Symmetric Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>\n<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  <span class=\"number\">2</span>   <span class=\"number\">2</span></span><br><span class=\"line\"> / \\ / \\</span><br><span class=\"line\"><span class=\"number\">3</span>  <span class=\"number\">4</span> <span class=\"number\">4</span>  <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>But the following [1,2,2,null,3,null,3] is not:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">1</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">2</span>   <span class=\"number\">2</span></span><br><span class=\"line\"> \\   \\</span><br><span class=\"line\"> <span class=\"number\">3</span>    <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>刚看的时候还有点懵，要怎么递归的去求解这种问题呢，要比较的两个节点隔得有点远啊。后来是上课时突然想到对称其实和根节点的左子树和右子树有关，我们把他当成两个树来求解就好了，递归时需要两个<code>TreeNode</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric1</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.isSymmetricRec(root.left,root.right)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetricRec</span>(<span class=\"params\">self,left,right</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type left: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :type right: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> right <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> left <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> right <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left.val == right.val \\</span><br><span class=\"line\">                <span class=\"keyword\">and</span> self.isSymmetricRec(left.left,right.right) \\</span><br><span class=\"line\">                <span class=\"keyword\">and</span> self.isSymmetricRec(left.right,right.left)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<p>然后是迭代解，这里是用层次遍历去做的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetricBFS</span>(<span class=\"params\">self,root</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type root:TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    leftqueue = Queue()</span><br><span class=\"line\">    rightqueue = Queue()</span><br><span class=\"line\"></span><br><span class=\"line\">    leftqueue.put(root.left)</span><br><span class=\"line\">    rightqueue.put(root.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> leftqueue.empty():</span><br><span class=\"line\">        left = leftqueue.get()</span><br><span class=\"line\">        right = rightqueue.get()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> right <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> left <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> right <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left.val != right.val:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            leftqueue.put(left.left)</span><br><span class=\"line\">            leftqueue.put(left.right)</span><br><span class=\"line\">            rightqueue.put(right.right)</span><br><span class=\"line\">            rightqueue.put(right.left)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的<code>c++</code>解法，思路其实是一样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(root-&gt;left, root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!p || !q) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(p-&gt;left,q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode *left, *right;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; q1, q2;</span><br><span class=\"line\">    q1.push(root-&gt;left);</span><br><span class=\"line\">    q2.push(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class=\"line\">        left = q1.front();</span><br><span class=\"line\">        q1.pop();</span><br><span class=\"line\">        right = q2.front();</span><br><span class=\"line\">        q2.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == left &amp;&amp; <span class=\"literal\">NULL</span> == right)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == left || <span class=\"literal\">NULL</span> == right)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left-&gt;val != right-&gt;val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        q1.push(left-&gt;left);</span><br><span class=\"line\">        q1.push(left-&gt;right);</span><br><span class=\"line\">        q2.push(right-&gt;right);</span><br><span class=\"line\">        q2.push(right-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第48天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/symmetric-tree/description/\">Symmetric Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>\n<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  <span class=\"number\">2</span>   <span class=\"number\">2</span></span><br><span class=\"line\"> / \\ / \\</span><br><span class=\"line\"><span class=\"number\">3</span>  <span class=\"number\">4</span> <span class=\"number\">4</span>  <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>But the following [1,2,2,null,3,null,3] is not:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">1</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">2</span>   <span class=\"number\">2</span></span><br><span class=\"line\"> \\   \\</span><br><span class=\"line\"> <span class=\"number\">3</span>    <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>刚看的时候还有点懵，要怎么递归的去求解这种问题呢，要比较的两个节点隔得有点远啊。后来是上课时突然想到对称其实和根节点的左子树和右子树有关，我们把他当成两个树来求解就好了，递归时需要两个<code>TreeNode</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric1</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.isSymmetricRec(root.left,root.right)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetricRec</span>(<span class=\"params\">self,left,right</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type left: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :type right: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> right <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> left <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> right <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left.val == right.val \\</span><br><span class=\"line\">                <span class=\"keyword\">and</span> self.isSymmetricRec(left.left,right.right) \\</span><br><span class=\"line\">                <span class=\"keyword\">and</span> self.isSymmetricRec(left.right,right.left)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<p>然后是迭代解，这里是用层次遍历去做的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetricBFS</span>(<span class=\"params\">self,root</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :type root:TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    leftqueue = Queue()</span><br><span class=\"line\">    rightqueue = Queue()</span><br><span class=\"line\"></span><br><span class=\"line\">    leftqueue.put(root.left)</span><br><span class=\"line\">    rightqueue.put(root.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> leftqueue.empty():</span><br><span class=\"line\">        left = leftqueue.get()</span><br><span class=\"line\">        right = rightqueue.get()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> right <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> left <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> right <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left.val != right.val:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            leftqueue.put(left.left)</span><br><span class=\"line\">            leftqueue.put(left.right)</span><br><span class=\"line\">            rightqueue.put(right.right)</span><br><span class=\"line\">            rightqueue.put(right.left)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<p>然后是在<code>dicuss</code>中看到的<code>c++</code>解法，思路其实是一样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(root-&gt;left, root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!p || !q) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(p-&gt;left,q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode *left, *right;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; q1, q2;</span><br><span class=\"line\">    q1.push(root-&gt;left);</span><br><span class=\"line\">    q2.push(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class=\"line\">        left = q1.front();</span><br><span class=\"line\">        q1.pop();</span><br><span class=\"line\">        right = q2.front();</span><br><span class=\"line\">        q2.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == left &amp;&amp; <span class=\"literal\">NULL</span> == right)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == left || <span class=\"literal\">NULL</span> == right)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left-&gt;val != right-&gt;val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        q1.push(left-&gt;left);</span><br><span class=\"line\">        q1.push(left-&gt;right);</span><br><span class=\"line\">        q2.push(right-&gt;right);</span><br><span class=\"line\">        q2.push(right-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Top K Frequent Elements","date":"2020-01-27T13:58:53.000Z","_content":"\n> 第60天。hhh，一回家就没做了。在家无聊到开始找活干了。\n\n今天的题目是[347. Top K Frequent Elements\n](https://leetcode.com/problems/top-k-frequent-elements/):\n\n挺简单的题目，先统计元素出现的次数，然后根据元素出现的次数来进行排序，然后取出现次数最多的前K个即可。\n\n```c++\nvector<int> topKFrequent1(vector<int>& nums, int k) {\n\tvector<int> res(k);\n\tunordered_map<int, int> imap;\n\tfor(int i = 0, n = nums.size(); i < n; i++) {\n\t\timap[nums[i]]++;\n\t}\n\t\n\tvector<pair<int, int>> temp(imap.begin(), imap.end());\n\tauto f = [](const pair<int, int> &p1, const pair<int, int> &p2) {\n\t\treturn p1.second > p2.second;  \n\t};\n\tsort(temp.begin(), temp.end(), f);\n\tfor(int i = 0;i < k; i++) {\n\t\tres[i] = temp[i].first;\n\t}\n\treturn res;    \n}\n```\n","source":"_posts/Top-K-Frequent-Elements.md","raw":"---\ntitle: Top K Frequent Elements\ndate: 2020-01-27T21:58:53.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第60天。hhh，一回家就没做了。在家无聊到开始找活干了。\n\n今天的题目是[347. Top K Frequent Elements\n](https://leetcode.com/problems/top-k-frequent-elements/):\n\n挺简单的题目，先统计元素出现的次数，然后根据元素出现的次数来进行排序，然后取出现次数最多的前K个即可。\n\n```c++\nvector<int> topKFrequent1(vector<int>& nums, int k) {\n\tvector<int> res(k);\n\tunordered_map<int, int> imap;\n\tfor(int i = 0, n = nums.size(); i < n; i++) {\n\t\timap[nums[i]]++;\n\t}\n\t\n\tvector<pair<int, int>> temp(imap.begin(), imap.end());\n\tauto f = [](const pair<int, int> &p1, const pair<int, int> &p2) {\n\t\treturn p1.second > p2.second;  \n\t};\n\tsort(temp.begin(), temp.end(), f);\n\tfor(int i = 0;i < k; i++) {\n\t\tres[i] = temp[i].first;\n\t}\n\treturn res;    \n}\n```\n","slug":"Top-K-Frequent-Elements","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q100eyqmcm6wpv1x1l","content":"<blockquote>\n<p>第60天。hhh，一回家就没做了。在家无聊到开始找活干了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/top-k-frequent-elements/\">347. Top K Frequent Elements\n</a>:</p>\n<p>挺简单的题目，先统计元素出现的次数，然后根据元素出现的次数来进行排序，然后取出现次数最多的前K个即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">topKFrequent1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(k)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; imap;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = nums.size(); i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\timap[nums[i]]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; temp(imap.begin(), imap.end());</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> f = [](<span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &amp;p1, <span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &amp;p2) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p1.second &gt; p2.second;  </span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tsort(temp.begin(), temp.end(), f);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; k; i++) &#123;</span><br><span class=\"line\">\t\tres[i] = temp[i].first;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第60天。hhh，一回家就没做了。在家无聊到开始找活干了。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/top-k-frequent-elements/\">347. Top K Frequent Elements\n</a>:</p>\n<p>挺简单的题目，先统计元素出现的次数，然后根据元素出现的次数来进行排序，然后取出现次数最多的前K个即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">topKFrequent1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(k)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; imap;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = nums.size(); i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\timap[nums[i]]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; temp(imap.begin(), imap.end());</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> f = [](<span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &amp;p1, <span class=\"keyword\">const</span> <span class=\"built_in\">pair</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &amp;p2) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p1.second &gt; p2.second;  </span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tsort(temp.begin(), temp.end(), f);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; k; i++) &#123;</span><br><span class=\"line\">\t\tres[i] = temp[i].first;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Triangle","date":"2019-11-20T04:15:06.000Z","_content":"\n> 第16天。\n\n今天的题目是[ Triangle ]( https://leetcode.com/problems/triangle/ )：\n\n---\n\nGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\n\nFor example, given the following triangle\n\n```\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n```\n\nThe minimum path sum from top to bottom is `11` (i.e., **2** + **3** + **5** + **1** = 11).\n\n**Note:**\n\nBonus point if you are able to do this using only *O*(*n*) extra space, where *n* is the total number of rows in the triangle.\n\n---\n\n一道很常规的动态规划问题。\n\n虽然例子中画出来的数组看起来很难确定路径，但是如果把它规整一下就可以得到：\n\n```\n2\n3 4\n6 5 7\n4 1 8 3\n```\n\n因此对于位置`(i,j)`来说，到达它的路径一定经过上一层的`(i-1, j)`和`(i-1,j-1)`（注意其实triangle中必须保证`0<=j<=i`，那个位置才会有值)。\n\n所以我们可以写出动态规划方程：\n\n$$\ndp[i, j]=min\\{dp[i-1, j], dp[i-1, j-1] \\} + triangle[i][j]\n$$\n\n其中`dp[i,j]`表示从顶端出发到达第`i`层第`j`个位置的最短路径的距离。其中`dp[0,0]=triangle[0]`以及`dp[i,j]=INT_MAX,i<j`，根据动态规划方程我们可以很容易的写出代码，同时为了使得空间复杂度为`O(n)`，我们可以只使用一个长度为`n`的数组来保存，之所以能做到是因为`d[i, *]`只依赖于`d[i-1, *]`，进一步的说，它只依赖于`d[i-1, *-1]`和`d[i-1, *]`，所以可以很容易改成一个用一个一维数组实现：\n\n```c++\nint minimumTotal(vector<vector<int>>& triangle) {\n    int n = triangle.size();\n    if (n == 0) return 0;\n    vector<int> dp(n, INT_MAX);\n    dp[0] = triangle[0][0];\n    for(int i = 1;i < n;i++) {\n        for(int j = i;j >= 0;j--) {\n            dp[j] = min(dp[j], j>0?dp[j-1]:INT_MAX) + triangle[i][j];\n            // cout << dp[j] << \" \";\n        }\n        // cout << endl;\n    }\n\n    int res = INT_MAX;\n    for(int i = 0;i < n;i++) res = min(res, dp[i]);\n    return res;\n}\n```\n\n","source":"_posts/Triangle.md","raw":"---\ntitle: Triangle\ndate: 2019-11-20T12:15:06.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第16天。\n\n今天的题目是[ Triangle ]( https://leetcode.com/problems/triangle/ )：\n\n---\n\nGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\n\nFor example, given the following triangle\n\n```\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n```\n\nThe minimum path sum from top to bottom is `11` (i.e., **2** + **3** + **5** + **1** = 11).\n\n**Note:**\n\nBonus point if you are able to do this using only *O*(*n*) extra space, where *n* is the total number of rows in the triangle.\n\n---\n\n一道很常规的动态规划问题。\n\n虽然例子中画出来的数组看起来很难确定路径，但是如果把它规整一下就可以得到：\n\n```\n2\n3 4\n6 5 7\n4 1 8 3\n```\n\n因此对于位置`(i,j)`来说，到达它的路径一定经过上一层的`(i-1, j)`和`(i-1,j-1)`（注意其实triangle中必须保证`0<=j<=i`，那个位置才会有值)。\n\n所以我们可以写出动态规划方程：\n\n$$\ndp[i, j]=min\\{dp[i-1, j], dp[i-1, j-1] \\} + triangle[i][j]\n$$\n\n其中`dp[i,j]`表示从顶端出发到达第`i`层第`j`个位置的最短路径的距离。其中`dp[0,0]=triangle[0]`以及`dp[i,j]=INT_MAX,i<j`，根据动态规划方程我们可以很容易的写出代码，同时为了使得空间复杂度为`O(n)`，我们可以只使用一个长度为`n`的数组来保存，之所以能做到是因为`d[i, *]`只依赖于`d[i-1, *]`，进一步的说，它只依赖于`d[i-1, *-1]`和`d[i-1, *]`，所以可以很容易改成一个用一个一维数组实现：\n\n```c++\nint minimumTotal(vector<vector<int>>& triangle) {\n    int n = triangle.size();\n    if (n == 0) return 0;\n    vector<int> dp(n, INT_MAX);\n    dp[0] = triangle[0][0];\n    for(int i = 1;i < n;i++) {\n        for(int j = i;j >= 0;j--) {\n            dp[j] = min(dp[j], j>0?dp[j-1]:INT_MAX) + triangle[i][j];\n            // cout << dp[j] << \" \";\n        }\n        // cout << endl;\n    }\n\n    int res = INT_MAX;\n    for(int i = 0;i < n;i++) res = min(res, dp[i]);\n    return res;\n}\n```\n\n","slug":"Triangle","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q100f1qmcm73qbcn7n","content":"<blockquote>\n<p>第16天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/triangle/\"> Triangle </a>：</p>\n<hr>\n<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>\n<p>For example, given the following triangle</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">     [2],</span><br><span class=\"line\">    [3,4],</span><br><span class=\"line\">   [6,5,7],</span><br><span class=\"line\">  [4,1,8,3]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p>\n<p><strong>Note:</strong></p>\n<p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p>\n<hr>\n<p>一道很常规的动态规划问题。</p>\n<p>虽然例子中画出来的数组看起来很难确定路径，但是如果把它规整一下就可以得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3 4</span><br><span class=\"line\">6 5 7</span><br><span class=\"line\">4 1 8 3</span><br></pre></td></tr></table></figure>\n\n<p>因此对于位置<code>(i,j)</code>来说，到达它的路径一定经过上一层的<code>(i-1, j)</code>和<code>(i-1,j-1)</code>（注意其实triangle中必须保证<code>0&lt;=j&lt;=i</code>，那个位置才会有值)。</p>\n<p>所以我们可以写出动态规划方程：</p>\n<p>$$<br>dp[i, j]=min{dp[i-1, j], dp[i-1, j-1] } + triangle[i][j]<br>$$</p>\n<p>其中<code>dp[i,j]</code>表示从顶端出发到达第<code>i</code>层第<code>j</code>个位置的最短路径的距离。其中<code>dp[0,0]=triangle[0]</code>以及<code>dp[i,j]=INT_MAX,i&lt;j</code>，根据动态规划方程我们可以很容易的写出代码，同时为了使得空间复杂度为<code>O(n)</code>，我们可以只使用一个长度为<code>n</code>的数组来保存，之所以能做到是因为<code>d[i, *]</code>只依赖于<code>d[i-1, *]</code>，进一步的说，它只依赖于<code>d[i-1, *-1]</code>和<code>d[i-1, *]</code>，所以可以很容易改成一个用一个一维数组实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = triangle.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = triangle[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i;j &gt;= <span class=\"number\">0</span>;j--) &#123;</span><br><span class=\"line\">            dp[j] = min(dp[j], j&gt;<span class=\"number\">0</span>?dp[j<span class=\"number\">-1</span>]:INT_MAX) + triangle[i][j];</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; dp[j] &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; endl;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++) res = min(res, dp[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第16天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/triangle/\"> Triangle </a>：</p>\n<hr>\n<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>\n<p>For example, given the following triangle</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">     [2],</span><br><span class=\"line\">    [3,4],</span><br><span class=\"line\">   [6,5,7],</span><br><span class=\"line\">  [4,1,8,3]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p>\n<p><strong>Note:</strong></p>\n<p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p>\n<hr>\n<p>一道很常规的动态规划问题。</p>\n<p>虽然例子中画出来的数组看起来很难确定路径，但是如果把它规整一下就可以得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3 4</span><br><span class=\"line\">6 5 7</span><br><span class=\"line\">4 1 8 3</span><br></pre></td></tr></table></figure>\n\n<p>因此对于位置<code>(i,j)</code>来说，到达它的路径一定经过上一层的<code>(i-1, j)</code>和<code>(i-1,j-1)</code>（注意其实triangle中必须保证<code>0&lt;=j&lt;=i</code>，那个位置才会有值)。</p>\n<p>所以我们可以写出动态规划方程：</p>\n<p>$$<br>dp[i, j]=min{dp[i-1, j], dp[i-1, j-1] } + triangle[i][j]<br>$$</p>\n<p>其中<code>dp[i,j]</code>表示从顶端出发到达第<code>i</code>层第<code>j</code>个位置的最短路径的距离。其中<code>dp[0,0]=triangle[0]</code>以及<code>dp[i,j]=INT_MAX,i&lt;j</code>，根据动态规划方程我们可以很容易的写出代码，同时为了使得空间复杂度为<code>O(n)</code>，我们可以只使用一个长度为<code>n</code>的数组来保存，之所以能做到是因为<code>d[i, *]</code>只依赖于<code>d[i-1, *]</code>，进一步的说，它只依赖于<code>d[i-1, *-1]</code>和<code>d[i-1, *]</code>，所以可以很容易改成一个用一个一维数组实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = triangle.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = triangle[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i;j &gt;= <span class=\"number\">0</span>;j--) &#123;</span><br><span class=\"line\">            dp[j] = min(dp[j], j&gt;<span class=\"number\">0</span>?dp[j<span class=\"number\">-1</span>]:INT_MAX) + triangle[i][j];</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; dp[j] &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; endl;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++) res = min(res, dp[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Trim-a-Binary-Search-Tree","date":"2017-12-05T03:06:42.000Z","_content":"\n第69天。\n\n今天的题目是[Trim a Binary Search Tree](https://leetcode.com/problems/trim-a-binary-search-tree/description/):\n\n> Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.\n>\n> Example 1:\n> Input:\n\n    1\n   / \\\n  0   2\n\n  L = 1\n  R = 2\n\n> Output:\n\n    1\n      \\\n       2\n\n> Example 2:\n> Input:\n\n    3\n   / \\\n  0   4\n   \\\n    2\n   /\n  1\n\n  L = 1\n  R = 3\n\n> Output:\n\n      3\n     /\n   2\n  /\n 1\n\n一开始没看到时二叉排序树，然后写的就有点复杂了：\n\n```c++\nTreeNode* trimBST(TreeNode* root, int L, int R) {\n    if (!root) return nullptr;\n    root->left = trimBST(root->left,L,R);\n    root->right = trimBST(root->right,L,R);\n    if (root->val >= L && root->val <= R) return root;\n    else if (root->left != nullptr && root->right != nullptr) {\n        auto p = root->left;\n        while(p->left) p = p->left;\n        p->left = root->right;\n        return root->left;\n    }\n    return (root->left)?root->left:root->right;\n}\n```\n\n```c++\nTreeNode* trimBST(TreeNode* root, int L, int R) {\n    if (root == nullptr) return nullptr;\n    if (root->val < L) return trimBST(root->right,L,R);\n    if (root->val > R) return trimBST(root->left,L,R);\n    root->left = trimBST(root->left,L,R);\n    root->right = trimBST(root->right,L,R);\n    return root;\n}\n```\n","source":"_posts/Trim-a-Binary-Search-Tree.md","raw":"---\ntitle: Trim-a-Binary-Search-Tree\ndate: 2017-12-05T11:06:42.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第69天。\n\n今天的题目是[Trim a Binary Search Tree](https://leetcode.com/problems/trim-a-binary-search-tree/description/):\n\n> Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.\n>\n> Example 1:\n> Input:\n\n    1\n   / \\\n  0   2\n\n  L = 1\n  R = 2\n\n> Output:\n\n    1\n      \\\n       2\n\n> Example 2:\n> Input:\n\n    3\n   / \\\n  0   4\n   \\\n    2\n   /\n  1\n\n  L = 1\n  R = 3\n\n> Output:\n\n      3\n     /\n   2\n  /\n 1\n\n一开始没看到时二叉排序树，然后写的就有点复杂了：\n\n```c++\nTreeNode* trimBST(TreeNode* root, int L, int R) {\n    if (!root) return nullptr;\n    root->left = trimBST(root->left,L,R);\n    root->right = trimBST(root->right,L,R);\n    if (root->val >= L && root->val <= R) return root;\n    else if (root->left != nullptr && root->right != nullptr) {\n        auto p = root->left;\n        while(p->left) p = p->left;\n        p->left = root->right;\n        return root->left;\n    }\n    return (root->left)?root->left:root->right;\n}\n```\n\n```c++\nTreeNode* trimBST(TreeNode* root, int L, int R) {\n    if (root == nullptr) return nullptr;\n    if (root->val < L) return trimBST(root->right,L,R);\n    if (root->val > R) return trimBST(root->left,L,R);\n    root->left = trimBST(root->left,L,R);\n    root->right = trimBST(root->right,L,R);\n    return root;\n}\n```\n","slug":"Trim-a-Binary-Search-Tree","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q200f5qmcmarx0c1o8","content":"<p>第69天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/trim-a-binary-search-tree/description/\">Trim a Binary Search Tree</a>:</p>\n<blockquote>\n<p>Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p>\n<p>Example 1:<br>Input:</p>\n</blockquote>\n<pre><code>1\n</code></pre>\n<p>   / <br>  0   2</p>\n<p>  L = 1<br>  R = 2</p>\n<blockquote>\n<p>Output:</p>\n</blockquote>\n<pre><code>1\n  \\\n   2\n</code></pre>\n<blockquote>\n<p>Example 2:<br>Input:</p>\n</blockquote>\n<pre><code>3\n</code></pre>\n<p>   / <br>  0   4<br>   <br>    2<br>   /<br>  1</p>\n<p>  L = 1<br>  R = 3</p>\n<blockquote>\n<p>Output:</p>\n</blockquote>\n<pre><code>  3\n /\n</code></pre>\n<p>   2<br>  /<br> 1</p>\n<p>一开始没看到时二叉排序树，然后写的就有点复杂了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    root-&gt;left = trimBST(root-&gt;left,L,R);</span><br><span class=\"line\">    root-&gt;right = trimBST(root-&gt;right,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &gt;= L &amp;&amp; root-&gt;val &lt;= R) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> p = root-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;left) p = p-&gt;left;</span><br><span class=\"line\">        p-&gt;left = root-&gt;right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (root-&gt;left)?root-&gt;left:root-&gt;right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &lt; L) <span class=\"keyword\">return</span> trimBST(root-&gt;right,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &gt; R) <span class=\"keyword\">return</span> trimBST(root-&gt;left,L,R);</span><br><span class=\"line\">    root-&gt;left = trimBST(root-&gt;left,L,R);</span><br><span class=\"line\">    root-&gt;right = trimBST(root-&gt;right,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第69天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/trim-a-binary-search-tree/description/\">Trim a Binary Search Tree</a>:</p>\n<blockquote>\n<p>Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p>\n<p>Example 1:<br>Input:</p>\n</blockquote>\n<pre><code>1\n</code></pre>\n<p>   / <br>  0   2</p>\n<p>  L = 1<br>  R = 2</p>\n<blockquote>\n<p>Output:</p>\n</blockquote>\n<pre><code>1\n  \\\n   2\n</code></pre>\n<blockquote>\n<p>Example 2:<br>Input:</p>\n</blockquote>\n<pre><code>3\n</code></pre>\n<p>   / <br>  0   4<br>   <br>    2<br>   /<br>  1</p>\n<p>  L = 1<br>  R = 3</p>\n<blockquote>\n<p>Output:</p>\n</blockquote>\n<pre><code>  3\n /\n</code></pre>\n<p>   2<br>  /<br> 1</p>\n<p>一开始没看到时二叉排序树，然后写的就有点复杂了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    root-&gt;left = trimBST(root-&gt;left,L,R);</span><br><span class=\"line\">    root-&gt;right = trimBST(root-&gt;right,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &gt;= L &amp;&amp; root-&gt;val &lt;= R) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> p = root-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;left) p = p-&gt;left;</span><br><span class=\"line\">        p-&gt;left = root-&gt;right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (root-&gt;left)?root-&gt;left:root-&gt;right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &lt; L) <span class=\"keyword\">return</span> trimBST(root-&gt;right,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &gt; R) <span class=\"keyword\">return</span> trimBST(root-&gt;left,L,R);</span><br><span class=\"line\">    root-&gt;left = trimBST(root-&gt;left,L,R);</span><br><span class=\"line\">    root-&gt;right = trimBST(root-&gt;right,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Unique Binary Search Tree","date":"2017-10-22T00:48:53.000Z","_content":"\n第29天。\n\n今天的题目是[Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/description/):\n\n> Given n, how many structurally unique BST's (binary search trees) that store values 1...n?\n>\n> For example,\n> Given n = 3, there are a total of 5 unique BST's.\n>\n>     1         3     3      2      1\n>     \\       /     /      / \\      \\\n>     3     2     1      1   3      2\n>     /     /       \\                 \\\n>     2     1         2                 3\n\n对于这种问题一般都可以用递归去做的，我们尝试的找一下递归式。\n\n`n=1` -> `1`\n`n=2` -> `2`\n`n=3` -> `5`\n\n我们考虑`n=3`时的情况,这时这棵树种包含三个值`1,2,3`,这说明树根的可能是`1,2,3`中的一个值：\n\n* 当`root=1`时，`2,3`只能放在右子树。现在只考虑`2,3`两个值，由于`BST`的性质,右子树也必须是`BST`，则此时问题转换成求`numsTrees(2)`.\n* 当`root=2`时，左边必定是`1`,右边必定是`3`.\n* 当`root=3`时，左边必定是`1,2`，同样转换成`numsTrees(2)`.\n\n我们再考虑一下`n=5`时的情况：\n\n* `root=3`，左子树必定是是包含`1,2`的BST，右子树必定是包含`4,5`的BST，此时种类为`numsTree(5-3)*numsTrees(3-1)`。\n\n所以我们可以找到递推式：\n\n* `n < 2` -> `numsTrees(n) = 1`\n* `n >= 2` -> `numsTrees(n) = numsTrees(1)*numsTrees(n-1) + numsTrees(2)*numTree(n-2) + ... + numsTree(n-1)*numsTrees(1)`;\n\n所以我们写出一个递归的解决方案:\n\n```c++\nint numTrees(int n) {\n    if (n <= 1) return 1;\n\n    int ret = 0;\n    for(int i = 1;i <= n;i++) {\n        int left = i-1;\n        int right = n-i;\n        ret += numTrees(left)*numTrees(right);\n    }\n    return ret;\n}\n```\n\n但是这里会超时，很明显这里可以用动态规划来优化:\n\n```c++\nint numTrees(int n) {\n    vector<int> ret(n+1);\n    ret[0] = 1;\n    ret[1] = 1;\n    for(int i = 2;i <= n;i++) {\n        for(int j = 1;j <= i;j++)\n            ret[i] += ret[j-1]*ret[i-j];\n    }\n    return ret[n];\n}\n```\n\n`dicuss`中基本都是和上面类似的解法，除了一个:\n\n```c++\nint numTrees(int n) {\n    //cantalan树\n    //C(2n,n)/(n+1)\n    long long ans =1;\n    for(int i=n+1;i<=2*n;i++){\n        ans = ans*i/(i-n);\n    }\n    return ans/(n+1);\n}\n```\n\nemmm,说实话，我没看懂，但是这个方法的确是最快的，只需要`O(n)`的时间，`O(1)`的空间。\n","source":"_posts/Unique-Binary-Search-Tree.md","raw":"---\ntitle: Unique Binary Search Tree\ndate: 2017-10-22T08:48:53.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 动态规划\n---\n\n第29天。\n\n今天的题目是[Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/description/):\n\n> Given n, how many structurally unique BST's (binary search trees) that store values 1...n?\n>\n> For example,\n> Given n = 3, there are a total of 5 unique BST's.\n>\n>     1         3     3      2      1\n>     \\       /     /      / \\      \\\n>     3     2     1      1   3      2\n>     /     /       \\                 \\\n>     2     1         2                 3\n\n对于这种问题一般都可以用递归去做的，我们尝试的找一下递归式。\n\n`n=1` -> `1`\n`n=2` -> `2`\n`n=3` -> `5`\n\n我们考虑`n=3`时的情况,这时这棵树种包含三个值`1,2,3`,这说明树根的可能是`1,2,3`中的一个值：\n\n* 当`root=1`时，`2,3`只能放在右子树。现在只考虑`2,3`两个值，由于`BST`的性质,右子树也必须是`BST`，则此时问题转换成求`numsTrees(2)`.\n* 当`root=2`时，左边必定是`1`,右边必定是`3`.\n* 当`root=3`时，左边必定是`1,2`，同样转换成`numsTrees(2)`.\n\n我们再考虑一下`n=5`时的情况：\n\n* `root=3`，左子树必定是是包含`1,2`的BST，右子树必定是包含`4,5`的BST，此时种类为`numsTree(5-3)*numsTrees(3-1)`。\n\n所以我们可以找到递推式：\n\n* `n < 2` -> `numsTrees(n) = 1`\n* `n >= 2` -> `numsTrees(n) = numsTrees(1)*numsTrees(n-1) + numsTrees(2)*numTree(n-2) + ... + numsTree(n-1)*numsTrees(1)`;\n\n所以我们写出一个递归的解决方案:\n\n```c++\nint numTrees(int n) {\n    if (n <= 1) return 1;\n\n    int ret = 0;\n    for(int i = 1;i <= n;i++) {\n        int left = i-1;\n        int right = n-i;\n        ret += numTrees(left)*numTrees(right);\n    }\n    return ret;\n}\n```\n\n但是这里会超时，很明显这里可以用动态规划来优化:\n\n```c++\nint numTrees(int n) {\n    vector<int> ret(n+1);\n    ret[0] = 1;\n    ret[1] = 1;\n    for(int i = 2;i <= n;i++) {\n        for(int j = 1;j <= i;j++)\n            ret[i] += ret[j-1]*ret[i-j];\n    }\n    return ret[n];\n}\n```\n\n`dicuss`中基本都是和上面类似的解法，除了一个:\n\n```c++\nint numTrees(int n) {\n    //cantalan树\n    //C(2n,n)/(n+1)\n    long long ans =1;\n    for(int i=n+1;i<=2*n;i++){\n        ans = ans*i/(i-n);\n    }\n    return ans/(n+1);\n}\n```\n\nemmm,说实话，我没看懂，但是这个方法的确是最快的，只需要`O(n)`的时间，`O(1)`的空间。\n","slug":"Unique-Binary-Search-Tree","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q400f8qmcmayih53ya","content":"<p>第29天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/unique-binary-search-trees/description/\">Unique Binary Search Trees</a>:</p>\n<blockquote>\n<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>\n<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>\n<pre><code>1         3     3      2      1\n\\       /     /      / \\      \\\n3     2     1      1   3      2\n/     /       \\                 \\\n2     1         2                 3\n</code></pre>\n</blockquote>\n<p>对于这种问题一般都可以用递归去做的，我们尝试的找一下递归式。</p>\n<p><code>n=1</code> -&gt; <code>1</code><br><code>n=2</code> -&gt; <code>2</code><br><code>n=3</code> -&gt; <code>5</code></p>\n<p>我们考虑<code>n=3</code>时的情况,这时这棵树种包含三个值<code>1,2,3</code>,这说明树根的可能是<code>1,2,3</code>中的一个值：</p>\n<ul>\n<li>当<code>root=1</code>时，<code>2,3</code>只能放在右子树。现在只考虑<code>2,3</code>两个值，由于<code>BST</code>的性质,右子树也必须是<code>BST</code>，则此时问题转换成求<code>numsTrees(2)</code>.</li>\n<li>当<code>root=2</code>时，左边必定是<code>1</code>,右边必定是<code>3</code>.</li>\n<li>当<code>root=3</code>时，左边必定是<code>1,2</code>，同样转换成<code>numsTrees(2)</code>.</li>\n</ul>\n<p>我们再考虑一下<code>n=5</code>时的情况：</p>\n<ul>\n<li><code>root=3</code>，左子树必定是是包含<code>1,2</code>的BST，右子树必定是包含<code>4,5</code>的BST，此时种类为<code>numsTree(5-3)*numsTrees(3-1)</code>。</li>\n</ul>\n<p>所以我们可以找到递推式：</p>\n<ul>\n<li><code>n &lt; 2</code> -&gt; <code>numsTrees(n) = 1</code></li>\n<li><code>n &gt;= 2</code> -&gt; <code>numsTrees(n) = numsTrees(1)*numsTrees(n-1) + numsTrees(2)*numTree(n-2) + ... + numsTree(n-1)*numsTrees(1)</code>;</li>\n</ul>\n<p>所以我们写出一个递归的解决方案:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = i<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = n-i;</span><br><span class=\"line\">        ret += numTrees(left)*numTrees(right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这里会超时，很明显这里可以用动态规划来优化:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(n+<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    ret[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt;= i;j++)</span><br><span class=\"line\">            ret[i] += ret[j<span class=\"number\">-1</span>]*ret[i-j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中基本都是和上面类似的解法，除了一个:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cantalan树</span></span><br><span class=\"line\">    <span class=\"comment\">//C(2n,n)/(n+1)</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans =<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=n+<span class=\"number\">1</span>;i&lt;=<span class=\"number\">2</span>*n;i++)&#123;</span><br><span class=\"line\">        ans = ans*i/(i-n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans/(n+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>emmm,说实话，我没看懂，但是这个方法的确是最快的，只需要<code>O(n)</code>的时间，<code>O(1)</code>的空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第29天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/unique-binary-search-trees/description/\">Unique Binary Search Trees</a>:</p>\n<blockquote>\n<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>\n<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>\n<pre><code>1         3     3      2      1\n\\       /     /      / \\      \\\n3     2     1      1   3      2\n/     /       \\                 \\\n2     1         2                 3\n</code></pre>\n</blockquote>\n<p>对于这种问题一般都可以用递归去做的，我们尝试的找一下递归式。</p>\n<p><code>n=1</code> -&gt; <code>1</code><br><code>n=2</code> -&gt; <code>2</code><br><code>n=3</code> -&gt; <code>5</code></p>\n<p>我们考虑<code>n=3</code>时的情况,这时这棵树种包含三个值<code>1,2,3</code>,这说明树根的可能是<code>1,2,3</code>中的一个值：</p>\n<ul>\n<li>当<code>root=1</code>时，<code>2,3</code>只能放在右子树。现在只考虑<code>2,3</code>两个值，由于<code>BST</code>的性质,右子树也必须是<code>BST</code>，则此时问题转换成求<code>numsTrees(2)</code>.</li>\n<li>当<code>root=2</code>时，左边必定是<code>1</code>,右边必定是<code>3</code>.</li>\n<li>当<code>root=3</code>时，左边必定是<code>1,2</code>，同样转换成<code>numsTrees(2)</code>.</li>\n</ul>\n<p>我们再考虑一下<code>n=5</code>时的情况：</p>\n<ul>\n<li><code>root=3</code>，左子树必定是是包含<code>1,2</code>的BST，右子树必定是包含<code>4,5</code>的BST，此时种类为<code>numsTree(5-3)*numsTrees(3-1)</code>。</li>\n</ul>\n<p>所以我们可以找到递推式：</p>\n<ul>\n<li><code>n &lt; 2</code> -&gt; <code>numsTrees(n) = 1</code></li>\n<li><code>n &gt;= 2</code> -&gt; <code>numsTrees(n) = numsTrees(1)*numsTrees(n-1) + numsTrees(2)*numTree(n-2) + ... + numsTree(n-1)*numsTrees(1)</code>;</li>\n</ul>\n<p>所以我们写出一个递归的解决方案:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = i<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = n-i;</span><br><span class=\"line\">        ret += numTrees(left)*numTrees(right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这里会超时，很明显这里可以用动态规划来优化:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(n+<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    ret[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt;= i;j++)</span><br><span class=\"line\">            ret[i] += ret[j<span class=\"number\">-1</span>]*ret[i-j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dicuss</code>中基本都是和上面类似的解法，除了一个:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cantalan树</span></span><br><span class=\"line\">    <span class=\"comment\">//C(2n,n)/(n+1)</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans =<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=n+<span class=\"number\">1</span>;i&lt;=<span class=\"number\">2</span>*n;i++)&#123;</span><br><span class=\"line\">        ans = ans*i/(i-n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans/(n+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>emmm,说实话，我没看懂，但是这个方法的确是最快的，只需要<code>O(n)</code>的时间，<code>O(1)</code>的空间。</p>\n"},{"title":"Unique Paths","date":"2017-10-18T02:55:35.000Z","_content":"\n第25天。\n\n感冒真难受！\n\n今天的题目是[Unique Paths](https://leetcode.com/problems/unique-paths/description/):\n\n> A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n>\n>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n>\n> How many possible unique paths are there?\n> Note: m and n will be at most 100.\n\n如果自己尝试几次去找的话，我们可以发现在`m=1`时或`n=1`时，只要一种可能，然后我们考虑我们现在位于`(m,n)`点`（m!=1,n!=1)`，现在要走向`(0,0)`,因为我们被限制到只能向下或下右走，即只能`n-1`或`m-1`，所以我们可以找到这样一个等式`uniquePaths(m,n) = uniquePaths(m-1,n) + uniquePaths(m,n-1)`，当`m!=1,n!=1`时，所以我们可以很快的写出下面的解决方案：\n\n```c++\nint uniquePaths(int m, int n) {\n    if (m == 1 || n == 1) return 1;\n    return uniquePaths(m-1,n) + uniquePaths(m,n-1);\n}\n```\n\n但是这个会时间超限，因为我们做了很多重复的计算，因为我们计算`uniquePaths(3,2)`时需要计算`uniquePaths(2,2)`,而`uniquePaths(2,1)`也需要计算一遍，这就导致了很多重复计算。\n\n我们考虑使用一个表来记录`uniquePaths`值，这样就可以减少每次计算的值了:\n\n```c++\nint uniquePaths(int m, int n) {\n    int *p = new int[m*n];\n    for(int i = 0;i < n;i++)\n        p[i] = 1;\n    for(int j = 0;j < m;j++)\n        p[n*j] = 1;\n\n    for(int i = 1;i < m;i++)\n        for(int j = 1;j < n;j++)\n            p[i*n+j] = p[ (i-1)*n +j ] + p[i*n + j - 1];\n\n    return p[m*n-1];\n    }\n```\n\n这样就不会时间超限了。\n\n然后是在`dicuss`中看到的：\n\n```c++\nint uniquePaths(int m, int n) {\n    vector<vector<int> > path(m, vector<int> (n, 1));\n    for (int i = 1; i < m; i++)\n        for (int j = 1; j < n; j++)\n            path[i][j] = path[i - 1][j] + path[i][j - 1];\n    return path[m - 1][n - 1];\n}\n```\n\n(捂脸)我一直不知道怎么用`vector`来快速的构造二维数组。\n\n上面的两个的空间复杂度都是`O(m*n)`，下面的方法可以降成`O(2*min(m,n))`，因为我们计算某一层的时候其实只需要前一行即可：\n\n```c++\nint uniquePaths(int m, int n) {\n    if (m > n) return uniquePaths(n, m); \n    vector<int> pre(m, 1);\n    vector<int> cur(m, 1);\n    for (int j = 1; j < n; j++) {\n        for (int i = 1; i < m; i++)\n            cur[i] = cur[i - 1] + pre[i];\n        swap(pre, cur);\n    }\n    return pre[m - 1];\n}\n```\n\n然后其实还可以继续降低到`O(min(m,n))`,只需要一个一维数组即可:\n\n```c++\nint uniquePaths(int m, int n) {\n    if (m > n) return uniquePaths(n, m);\n    vector<int> cur(m, 1);\n    for (int j = 1; j < n; j++)\n        for (int i = 1; i < m; i++)\n            cur[i] += cur[i - 1]; \n    return cur[m - 1];\n}\n```\n\n","source":"_posts/Unique-Paths.md","raw":"---\ntitle: Unique Paths\ndate: 2017-10-18T10:55:35.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 动态规划\n---\n\n第25天。\n\n感冒真难受！\n\n今天的题目是[Unique Paths](https://leetcode.com/problems/unique-paths/description/):\n\n> A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n>\n>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n>\n> How many possible unique paths are there?\n> Note: m and n will be at most 100.\n\n如果自己尝试几次去找的话，我们可以发现在`m=1`时或`n=1`时，只要一种可能，然后我们考虑我们现在位于`(m,n)`点`（m!=1,n!=1)`，现在要走向`(0,0)`,因为我们被限制到只能向下或下右走，即只能`n-1`或`m-1`，所以我们可以找到这样一个等式`uniquePaths(m,n) = uniquePaths(m-1,n) + uniquePaths(m,n-1)`，当`m!=1,n!=1`时，所以我们可以很快的写出下面的解决方案：\n\n```c++\nint uniquePaths(int m, int n) {\n    if (m == 1 || n == 1) return 1;\n    return uniquePaths(m-1,n) + uniquePaths(m,n-1);\n}\n```\n\n但是这个会时间超限，因为我们做了很多重复的计算，因为我们计算`uniquePaths(3,2)`时需要计算`uniquePaths(2,2)`,而`uniquePaths(2,1)`也需要计算一遍，这就导致了很多重复计算。\n\n我们考虑使用一个表来记录`uniquePaths`值，这样就可以减少每次计算的值了:\n\n```c++\nint uniquePaths(int m, int n) {\n    int *p = new int[m*n];\n    for(int i = 0;i < n;i++)\n        p[i] = 1;\n    for(int j = 0;j < m;j++)\n        p[n*j] = 1;\n\n    for(int i = 1;i < m;i++)\n        for(int j = 1;j < n;j++)\n            p[i*n+j] = p[ (i-1)*n +j ] + p[i*n + j - 1];\n\n    return p[m*n-1];\n    }\n```\n\n这样就不会时间超限了。\n\n然后是在`dicuss`中看到的：\n\n```c++\nint uniquePaths(int m, int n) {\n    vector<vector<int> > path(m, vector<int> (n, 1));\n    for (int i = 1; i < m; i++)\n        for (int j = 1; j < n; j++)\n            path[i][j] = path[i - 1][j] + path[i][j - 1];\n    return path[m - 1][n - 1];\n}\n```\n\n(捂脸)我一直不知道怎么用`vector`来快速的构造二维数组。\n\n上面的两个的空间复杂度都是`O(m*n)`，下面的方法可以降成`O(2*min(m,n))`，因为我们计算某一层的时候其实只需要前一行即可：\n\n```c++\nint uniquePaths(int m, int n) {\n    if (m > n) return uniquePaths(n, m); \n    vector<int> pre(m, 1);\n    vector<int> cur(m, 1);\n    for (int j = 1; j < n; j++) {\n        for (int i = 1; i < m; i++)\n            cur[i] = cur[i - 1] + pre[i];\n        swap(pre, cur);\n    }\n    return pre[m - 1];\n}\n```\n\n然后其实还可以继续降低到`O(min(m,n))`,只需要一个一维数组即可:\n\n```c++\nint uniquePaths(int m, int n) {\n    if (m > n) return uniquePaths(n, m);\n    vector<int> cur(m, 1);\n    for (int j = 1; j < n; j++)\n        for (int i = 1; i < m; i++)\n            cur[i] += cur[i - 1]; \n    return cur[m - 1];\n}\n```\n\n","slug":"Unique-Paths","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q500fbqmcmc8dfhs7s","content":"<p>第25天。</p>\n<p>感冒真难受！</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/unique-paths/description/\">Unique Paths</a>:</p>\n<blockquote>\n<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n<p>How many possible unique paths are there?<br>Note: m and n will be at most 100.</p>\n</blockquote>\n<p>如果自己尝试几次去找的话，我们可以发现在<code>m=1</code>时或<code>n=1</code>时，只要一种可能，然后我们考虑我们现在位于<code>(m,n)</code>点<code>（m!=1,n!=1)</code>，现在要走向<code>(0,0)</code>,因为我们被限制到只能向下或下右走，即只能<code>n-1</code>或<code>m-1</code>，所以我们可以找到这样一个等式<code>uniquePaths(m,n) = uniquePaths(m-1,n) + uniquePaths(m,n-1)</code>，当<code>m!=1,n!=1</code>时，所以我们可以很快的写出下面的解决方案：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">1</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> uniquePaths(m<span class=\"number\">-1</span>,n) + uniquePaths(m,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这个会时间超限，因为我们做了很多重复的计算，因为我们计算<code>uniquePaths(3,2)</code>时需要计算<code>uniquePaths(2,2)</code>,而<code>uniquePaths(2,1)</code>也需要计算一遍，这就导致了很多重复计算。</p>\n<p>我们考虑使用一个表来记录<code>uniquePaths</code>值，这样就可以减少每次计算的值了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m*n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)</span><br><span class=\"line\">        p[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; m;j++)</span><br><span class=\"line\">        p[n*j] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; m;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; n;j++)</span><br><span class=\"line\">            p[i*n+j] = p[ (i<span class=\"number\">-1</span>)*n +j ] + p[i*n + j - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> p[m*n<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就不会时间超限了。</p>\n<p>然后是在<code>dicuss</code>中看到的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; path(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; (n, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++)</span><br><span class=\"line\">            path[i][j] = path[i - <span class=\"number\">1</span>][j] + path[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> path[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(捂脸)我一直不知道怎么用<code>vector</code>来快速的构造二维数组。</p>\n<p>上面的两个的空间复杂度都是<code>O(m*n)</code>，下面的方法可以降成<code>O(2*min(m,n))</code>，因为我们计算某一层的时候其实只需要前一行即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m &gt; n) <span class=\"keyword\">return</span> uniquePaths(n, m); </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">pre</span><span class=\"params\">(m, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cur</span><span class=\"params\">(m, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++)</span><br><span class=\"line\">            cur[i] = cur[i - <span class=\"number\">1</span>] + pre[i];</span><br><span class=\"line\">        swap(pre, cur);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre[m - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后其实还可以继续降低到<code>O(min(m,n))</code>,只需要一个一维数组即可:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m &gt; n) <span class=\"keyword\">return</span> uniquePaths(n, m);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cur</span><span class=\"params\">(m, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++)</span><br><span class=\"line\">            cur[i] += cur[i - <span class=\"number\">1</span>]; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur[m - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>第25天。</p>\n<p>感冒真难受！</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/unique-paths/description/\">Unique Paths</a>:</p>\n<blockquote>\n<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n<p>How many possible unique paths are there?<br>Note: m and n will be at most 100.</p>\n</blockquote>\n<p>如果自己尝试几次去找的话，我们可以发现在<code>m=1</code>时或<code>n=1</code>时，只要一种可能，然后我们考虑我们现在位于<code>(m,n)</code>点<code>（m!=1,n!=1)</code>，现在要走向<code>(0,0)</code>,因为我们被限制到只能向下或下右走，即只能<code>n-1</code>或<code>m-1</code>，所以我们可以找到这样一个等式<code>uniquePaths(m,n) = uniquePaths(m-1,n) + uniquePaths(m,n-1)</code>，当<code>m!=1,n!=1</code>时，所以我们可以很快的写出下面的解决方案：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">1</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> uniquePaths(m<span class=\"number\">-1</span>,n) + uniquePaths(m,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这个会时间超限，因为我们做了很多重复的计算，因为我们计算<code>uniquePaths(3,2)</code>时需要计算<code>uniquePaths(2,2)</code>,而<code>uniquePaths(2,1)</code>也需要计算一遍，这就导致了很多重复计算。</p>\n<p>我们考虑使用一个表来记录<code>uniquePaths</code>值，这样就可以减少每次计算的值了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m*n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)</span><br><span class=\"line\">        p[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; m;j++)</span><br><span class=\"line\">        p[n*j] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; m;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j &lt; n;j++)</span><br><span class=\"line\">            p[i*n+j] = p[ (i<span class=\"number\">-1</span>)*n +j ] + p[i*n + j - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> p[m*n<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就不会时间超限了。</p>\n<p>然后是在<code>dicuss</code>中看到的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; path(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; (n, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++)</span><br><span class=\"line\">            path[i][j] = path[i - <span class=\"number\">1</span>][j] + path[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> path[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(捂脸)我一直不知道怎么用<code>vector</code>来快速的构造二维数组。</p>\n<p>上面的两个的空间复杂度都是<code>O(m*n)</code>，下面的方法可以降成<code>O(2*min(m,n))</code>，因为我们计算某一层的时候其实只需要前一行即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m &gt; n) <span class=\"keyword\">return</span> uniquePaths(n, m); </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">pre</span><span class=\"params\">(m, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cur</span><span class=\"params\">(m, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++)</span><br><span class=\"line\">            cur[i] = cur[i - <span class=\"number\">1</span>] + pre[i];</span><br><span class=\"line\">        swap(pre, cur);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre[m - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后其实还可以继续降低到<code>O(min(m,n))</code>,只需要一个一维数组即可:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m &gt; n) <span class=\"keyword\">return</span> uniquePaths(n, m);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cur</span><span class=\"params\">(m, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++)</span><br><span class=\"line\">            cur[i] += cur[i - <span class=\"number\">1</span>]; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur[m - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Unique Substrings in Wraparound String","date":"2019-12-14T02:53:43.000Z","_content":"\n> 第38天。\n\n今天的题目是[Unique Substrings in Wraparound String](https://leetcode.com/problems/unique-substrings-in-wraparound-string/):\n\n这道题麻烦的地方在于，子串需要去除重复。我们把问题转换一下，即以字符 c 结尾的子串的个数。不难发现，最长长度和子串个数是相同的。这样的话，我们可以在遍历时维护一个变量`len`来保存，以当前字符结尾的子串的长度，通过判断当前字符与上一个字符是否在`s`中相邻，来确定以当期字符结尾的子串的个数。同时，为了去除重复，我们可以用一个长度为26的字典来保存每个以字符 c 结尾的子串的最长长度。最后，我们只需要对字典进行一次求和即可。\n\n```c++\nint findSubstringInWraproundString(string p) {\n    if (p.size() == 0) return 0;\n    \n    vector<int> dict(26, 0);\n    int len = 1;\n    int prev = p[0] - 'a';\n    dict[prev] = 1;\n    \n    for(int i = 1;i < p.size();i++) {\n        int temp = p[i] - 'a';\n        if ((prev + 1) % 26 == temp) {\n            dict[temp] = max(++len, dict[temp]);\n        } else { len = 1; dict[temp] = max(dict[temp], 1); }\n        prev = temp;\n    }\n    \n    // sum\n    int res = 0;\n    for(auto i: dict) res += i;\n    return res;\n}\n```\n","source":"_posts/Unique-Substrings-in-Wraparound-String.md","raw":"---\ntitle: Unique Substrings in Wraparound String\ndate: 2019-12-14T10:53:43.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第38天。\n\n今天的题目是[Unique Substrings in Wraparound String](https://leetcode.com/problems/unique-substrings-in-wraparound-string/):\n\n这道题麻烦的地方在于，子串需要去除重复。我们把问题转换一下，即以字符 c 结尾的子串的个数。不难发现，最长长度和子串个数是相同的。这样的话，我们可以在遍历时维护一个变量`len`来保存，以当前字符结尾的子串的长度，通过判断当前字符与上一个字符是否在`s`中相邻，来确定以当期字符结尾的子串的个数。同时，为了去除重复，我们可以用一个长度为26的字典来保存每个以字符 c 结尾的子串的最长长度。最后，我们只需要对字典进行一次求和即可。\n\n```c++\nint findSubstringInWraproundString(string p) {\n    if (p.size() == 0) return 0;\n    \n    vector<int> dict(26, 0);\n    int len = 1;\n    int prev = p[0] - 'a';\n    dict[prev] = 1;\n    \n    for(int i = 1;i < p.size();i++) {\n        int temp = p[i] - 'a';\n        if ((prev + 1) % 26 == temp) {\n            dict[temp] = max(++len, dict[temp]);\n        } else { len = 1; dict[temp] = max(dict[temp], 1); }\n        prev = temp;\n    }\n    \n    // sum\n    int res = 0;\n    for(auto i: dict) res += i;\n    return res;\n}\n```\n","slug":"Unique-Substrings-in-Wraparound-String","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q500feqmcmaiip3sqt","content":"<blockquote>\n<p>第38天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/unique-substrings-in-wraparound-string/\">Unique Substrings in Wraparound String</a>:</p>\n<p>这道题麻烦的地方在于，子串需要去除重复。我们把问题转换一下，即以字符 c 结尾的子串的个数。不难发现，最长长度和子串个数是相同的。这样的话，我们可以在遍历时维护一个变量<code>len</code>来保存，以当前字符结尾的子串的长度，通过判断当前字符与上一个字符是否在<code>s</code>中相邻，来确定以当期字符结尾的子串的个数。同时，为了去除重复，我们可以用一个长度为26的字典来保存每个以字符 c 结尾的子串的最长长度。最后，我们只需要对字典进行一次求和即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findSubstringInWraproundString</span><span class=\"params\">(<span class=\"built_in\">string</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dict</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prev = p[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">    dict[prev] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; p.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = p[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((prev + <span class=\"number\">1</span>) % <span class=\"number\">26</span> == temp) &#123;</span><br><span class=\"line\">            dict[temp] = max(++len, dict[temp]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; len = <span class=\"number\">1</span>; dict[temp] = max(dict[temp], <span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">        prev = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// sum</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i: dict) res += i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第38天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/unique-substrings-in-wraparound-string/\">Unique Substrings in Wraparound String</a>:</p>\n<p>这道题麻烦的地方在于，子串需要去除重复。我们把问题转换一下，即以字符 c 结尾的子串的个数。不难发现，最长长度和子串个数是相同的。这样的话，我们可以在遍历时维护一个变量<code>len</code>来保存，以当前字符结尾的子串的长度，通过判断当前字符与上一个字符是否在<code>s</code>中相邻，来确定以当期字符结尾的子串的个数。同时，为了去除重复，我们可以用一个长度为26的字典来保存每个以字符 c 结尾的子串的最长长度。最后，我们只需要对字典进行一次求和即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findSubstringInWraproundString</span><span class=\"params\">(<span class=\"built_in\">string</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dict</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prev = p[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">    dict[prev] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; p.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = p[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((prev + <span class=\"number\">1</span>) % <span class=\"number\">26</span> == temp) &#123;</span><br><span class=\"line\">            dict[temp] = max(++len, dict[temp]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; len = <span class=\"number\">1</span>; dict[temp] = max(dict[temp], <span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">        prev = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// sum</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i: dict) res += i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Valid Parentheses","date":"2017-09-24T15:23:00.000Z","_content":"\n 恩，照常打个卡（差点忘记）。。。。\n\n由于比较晚才发现要刷个题（捂脸），所以找了个`Easy`的题目——[Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/)\n\n> Given a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n>\n> The brackets must close in the correct order, `\"()\"` and `\"()[]{}\"` are all valid but `\"(]\"` and `\"([)]\"` are not.\n\n很经典（很简单）的题目——括号匹配，显然用个栈来完成是最简单的了：\n\n```c++\n bool isValid(string str) {\n   stack<char> s;\n   for(auto c:str){\n     switch(c){\n       case '(':case '{': case '[':\n         s.push(c);\n         break;\n       case ')':\n         if (s.empty() || s.top() != '(') return false;\n         s.pop();\n         break;\n       case '}':\n         if (s.empty() || s.top() != '{') return false;\n         s.pop();\n         break;\n       case ']':\n         if (s.empty() || s.top() != '[') return false;\n         s.pop();\n         break;\n       default:\n         return false;\n     }\n   }\n   return s.empty()\n }\n```\n\n恩，好像没什么难度，多注意点细节就好了。\n\n做完之后顺手看了一下`Discuss`,看了一下别人的[实现](https://leetcode.com/problems/valid-parentheses/discuss/)，同样是c++，同样的方法，为什么别人写的看起来就很舒服呢？\n\n一起来对比一下:\n\n```c++\n bool isValid(string s) {\n   stack<char> paren;\n   for (char& c : s) {\n     switch (c) {\n       case '(': \n       case '{': \n       case '[': paren.push(c); break;\n       case ')': if (paren.empty() || paren.top()!='(') return false; else paren.pop(); break;\n       case '}': if (paren.empty() || paren.top()!='{') return false; else paren.pop(); break;\n       case ']': if (paren.empty() || paren.top()!='[') return false; else paren.pop(); break;\n       default: ; // pass\n     }\n   }\n   return paren.empty() ;\n }\n```\n\n突然很嫌弃自己的代码风格！！！\n","source":"_posts/Valid-Parentheses.md","raw":"---\ntitle: Valid Parentheses\ndate: 2017-09-24T23:23:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - Stack\n  - String\n---\n\n 恩，照常打个卡（差点忘记）。。。。\n\n由于比较晚才发现要刷个题（捂脸），所以找了个`Easy`的题目——[Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/)\n\n> Given a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n>\n> The brackets must close in the correct order, `\"()\"` and `\"()[]{}\"` are all valid but `\"(]\"` and `\"([)]\"` are not.\n\n很经典（很简单）的题目——括号匹配，显然用个栈来完成是最简单的了：\n\n```c++\n bool isValid(string str) {\n   stack<char> s;\n   for(auto c:str){\n     switch(c){\n       case '(':case '{': case '[':\n         s.push(c);\n         break;\n       case ')':\n         if (s.empty() || s.top() != '(') return false;\n         s.pop();\n         break;\n       case '}':\n         if (s.empty() || s.top() != '{') return false;\n         s.pop();\n         break;\n       case ']':\n         if (s.empty() || s.top() != '[') return false;\n         s.pop();\n         break;\n       default:\n         return false;\n     }\n   }\n   return s.empty()\n }\n```\n\n恩，好像没什么难度，多注意点细节就好了。\n\n做完之后顺手看了一下`Discuss`,看了一下别人的[实现](https://leetcode.com/problems/valid-parentheses/discuss/)，同样是c++，同样的方法，为什么别人写的看起来就很舒服呢？\n\n一起来对比一下:\n\n```c++\n bool isValid(string s) {\n   stack<char> paren;\n   for (char& c : s) {\n     switch (c) {\n       case '(': \n       case '{': \n       case '[': paren.push(c); break;\n       case ')': if (paren.empty() || paren.top()!='(') return false; else paren.pop(); break;\n       case '}': if (paren.empty() || paren.top()!='{') return false; else paren.pop(); break;\n       case ']': if (paren.empty() || paren.top()!='[') return false; else paren.pop(); break;\n       default: ; // pass\n     }\n   }\n   return paren.empty() ;\n }\n```\n\n突然很嫌弃自己的代码风格！！！\n","slug":"Valid-Parentheses","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q600fhqmcm7i1u1n80","content":"<p> 恩，照常打个卡（差点忘记）。。。。</p>\n<p>由于比较晚才发现要刷个题（捂脸），所以找了个<code>Easy</code>的题目——<a href=\"https://leetcode.com/problems/valid-parentheses/description/\">Valid Parentheses</a></p>\n<blockquote>\n<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n<p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]&#123;&#125;&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not.</p>\n</blockquote>\n<p>很经典（很简单）的题目——括号匹配，显然用个栈来完成是最简单的了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; s;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:str)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(c)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;(&#x27;</span>:<span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#123;&#x27;</span>: <span class=\"keyword\">case</span> <span class=\"string\">&#x27;[&#x27;</span>:</span><br><span class=\"line\">        s.push(c);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.empty() || s.top() != <span class=\"string\">&#x27;(&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#125;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.empty() || s.top() != <span class=\"string\">&#x27;&#123;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;]&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.empty() || s.top() != <span class=\"string\">&#x27;[&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.empty()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，好像没什么难度，多注意点细节就好了。</p>\n<p>做完之后顺手看了一下<code>Discuss</code>,看了一下别人的<a href=\"https://leetcode.com/problems/valid-parentheses/discuss/\">实现</a>，同样是c++，同样的方法，为什么别人写的看起来就很舒服呢？</p>\n<p>一起来对比一下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; paren;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span>&amp; c : s) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (c) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;(&#x27;</span>: </span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#123;&#x27;</span>: </span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;[&#x27;</span>: paren.push(c); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"keyword\">if</span> (paren.empty() || paren.top()!=<span class=\"string\">&#x27;(&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"keyword\">else</span> paren.pop(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"keyword\">if</span> (paren.empty() || paren.top()!=<span class=\"string\">&#x27;&#123;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"keyword\">else</span> paren.pop(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"keyword\">if</span> (paren.empty() || paren.top()!=<span class=\"string\">&#x27;[&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"keyword\">else</span> paren.pop(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: ; <span class=\"comment\">// pass</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paren.empty() ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>突然很嫌弃自己的代码风格！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<p> 恩，照常打个卡（差点忘记）。。。。</p>\n<p>由于比较晚才发现要刷个题（捂脸），所以找了个<code>Easy</code>的题目——<a href=\"https://leetcode.com/problems/valid-parentheses/description/\">Valid Parentheses</a></p>\n<blockquote>\n<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n<p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]&#123;&#125;&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not.</p>\n</blockquote>\n<p>很经典（很简单）的题目——括号匹配，显然用个栈来完成是最简单的了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; s;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:str)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(c)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;(&#x27;</span>:<span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#123;&#x27;</span>: <span class=\"keyword\">case</span> <span class=\"string\">&#x27;[&#x27;</span>:</span><br><span class=\"line\">        s.push(c);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.empty() || s.top() != <span class=\"string\">&#x27;(&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#125;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.empty() || s.top() != <span class=\"string\">&#x27;&#123;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;]&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.empty() || s.top() != <span class=\"string\">&#x27;[&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.empty()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>恩，好像没什么难度，多注意点细节就好了。</p>\n<p>做完之后顺手看了一下<code>Discuss</code>,看了一下别人的<a href=\"https://leetcode.com/problems/valid-parentheses/discuss/\">实现</a>，同样是c++，同样的方法，为什么别人写的看起来就很舒服呢？</p>\n<p>一起来对比一下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; paren;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span>&amp; c : s) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (c) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;(&#x27;</span>: </span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#123;&#x27;</span>: </span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;[&#x27;</span>: paren.push(c); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"keyword\">if</span> (paren.empty() || paren.top()!=<span class=\"string\">&#x27;(&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"keyword\">else</span> paren.pop(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"keyword\">if</span> (paren.empty() || paren.top()!=<span class=\"string\">&#x27;&#123;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"keyword\">else</span> paren.pop(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"keyword\">if</span> (paren.empty() || paren.top()!=<span class=\"string\">&#x27;[&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"keyword\">else</span> paren.pop(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: ; <span class=\"comment\">// pass</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paren.empty() ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>突然很嫌弃自己的代码风格！！！</p>\n"},{"title":"Valid-Triangle-Number","date":"2017-12-03T02:26:32.000Z","_content":"\n第67天。\n\n今天的题目是[Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/description/):\n\n> Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n> Example 1:\n> Input: [2,2,3,4]\n> Output: 3\n> Explanation:\n> Valid combinations are:\n> 2,3,4 (using the first 2)\n> 2,3,4 (using the second 2)\n> 2,2,3\n> Note:\n> The length of the given array won't exceed 1000.\n> The integers in the given array are in the range of [0, 1000].\n\n\n莫名其妙的用一个`O(n^3)`的解法AC了:\n\n```c++\nint triangleNumber(vector<int>& nums) {\n    sort(nums.begin(),nums.end());\n    int ret = 0;\n    for(int i = 0;i < nums.size();i++) {\n        for(int j = i + 1;j < nums.size();j++) {\n            //nums[i] + num[j] > a;\n            for(int k = j+1;k < nums.size() && nums[i] + nums[j] > nums[k];k++)\n                ret++;\n        }\n    }\n    return ret;\n}\n```\n\n然后是`dicuss`中的`O(n^2)`的解法：\n\n```java\npublic static int triangleNumber(int[] A) {\n    Arrays.sort(A);\n    int count = 0, n = A.length;\n    for (int i=n-1;i>=2;i--) {\n        int l = 0, r = i-1;\n        while (l < r) {\n            if (A[l] + A[r] > A[i]) {\n                count += r-l;\n                r--;\n            }\n            else l++;\n        }\n    }\n    return count;\n}\n```\n","source":"_posts/Valid-Triangle-Number.md","raw":"---\ntitle: Valid-Triangle-Number\ndate: 2017-12-03T10:26:32.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第67天。\n\n今天的题目是[Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/description/):\n\n> Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n> Example 1:\n> Input: [2,2,3,4]\n> Output: 3\n> Explanation:\n> Valid combinations are:\n> 2,3,4 (using the first 2)\n> 2,3,4 (using the second 2)\n> 2,2,3\n> Note:\n> The length of the given array won't exceed 1000.\n> The integers in the given array are in the range of [0, 1000].\n\n\n莫名其妙的用一个`O(n^3)`的解法AC了:\n\n```c++\nint triangleNumber(vector<int>& nums) {\n    sort(nums.begin(),nums.end());\n    int ret = 0;\n    for(int i = 0;i < nums.size();i++) {\n        for(int j = i + 1;j < nums.size();j++) {\n            //nums[i] + num[j] > a;\n            for(int k = j+1;k < nums.size() && nums[i] + nums[j] > nums[k];k++)\n                ret++;\n        }\n    }\n    return ret;\n}\n```\n\n然后是`dicuss`中的`O(n^2)`的解法：\n\n```java\npublic static int triangleNumber(int[] A) {\n    Arrays.sort(A);\n    int count = 0, n = A.length;\n    for (int i=n-1;i>=2;i--) {\n        int l = 0, r = i-1;\n        while (l < r) {\n            if (A[l] + A[r] > A[i]) {\n                count += r-l;\n                r--;\n            }\n            else l++;\n        }\n    }\n    return count;\n}\n```\n","slug":"Valid-Triangle-Number","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q700fkqmcmfe5c327t","content":"<p>第67天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/valid-triangle-number/description/\">Valid Triangle Number</a>:</p>\n<blockquote>\n<p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.<br>Example 1:<br>Input: [2,2,3,4]<br>Output: 3<br>Explanation:<br>Valid combinations are:<br>2,3,4 (using the first 2)<br>2,3,4 (using the second 2)<br>2,2,3<br>Note:<br>The length of the given array won’t exceed 1000.<br>The integers in the given array are in the range of [0, 1000].</p>\n</blockquote>\n<p>莫名其妙的用一个<code>O(n^3)</code>的解法AC了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">triangleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums.begin(),nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;j &lt; nums.size();j++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//nums[i] + num[j] &gt; a;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = j+<span class=\"number\">1</span>;k &lt; nums.size() &amp;&amp; nums[i] + nums[j] &gt; nums[k];k++)</span><br><span class=\"line\">                ret++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的<code>O(n^2)</code>的解法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">triangleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] A)</span> </span>&#123;</span><br><span class=\"line\">    Arrays.sort(A);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>, n = A.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=n-<span class=\"number\">1</span>;i&gt;=<span class=\"number\">2</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = i-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[l] + A[r] &gt; A[i]) &#123;</span><br><span class=\"line\">                count += r-l;</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第67天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/valid-triangle-number/description/\">Valid Triangle Number</a>:</p>\n<blockquote>\n<p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.<br>Example 1:<br>Input: [2,2,3,4]<br>Output: 3<br>Explanation:<br>Valid combinations are:<br>2,3,4 (using the first 2)<br>2,3,4 (using the second 2)<br>2,2,3<br>Note:<br>The length of the given array won’t exceed 1000.<br>The integers in the given array are in the range of [0, 1000].</p>\n</blockquote>\n<p>莫名其妙的用一个<code>O(n^3)</code>的解法AC了:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">triangleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    sort(nums.begin(),nums.end());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nums.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;j &lt; nums.size();j++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//nums[i] + num[j] &gt; a;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = j+<span class=\"number\">1</span>;k &lt; nums.size() &amp;&amp; nums[i] + nums[j] &gt; nums[k];k++)</span><br><span class=\"line\">                ret++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的<code>O(n^2)</code>的解法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">triangleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] A)</span> </span>&#123;</span><br><span class=\"line\">    Arrays.sort(A);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>, n = A.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=n-<span class=\"number\">1</span>;i&gt;=<span class=\"number\">2</span>;i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = i-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[l] + A[r] &gt; A[i]) &#123;</span><br><span class=\"line\">                count += r-l;</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Validate Binary Search Tree","date":"2017-10-23T00:39:55.000Z","_content":"\n第30天。\n\n恍恍惚惚就一个月了。\n\n今天的题目是[Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/description/):\n\n> Given a binary tree, determine if it is a valid binary search tree (BST).\n>\n> Assume a BST is defined as follows:\n>\n> The left subtree of a node contains only nodes with keys less than the node's key.\n> The right subtree of a node contains only nodes with keys greater than the node's key.\n> Both the left and right subtrees must also be binary search trees.\n>Example 1:\n\n```python\n    2\n   / \\\n  1   3\n```\n\n> Binary tree [2,1,3], return true.\n> Example 2:\n\n```python\n    1\n   / \\\n  2   3\n```\n\n> Binary tree [1,2,3], return false.\n\n昨天的题目也是和BST有关的，但是这里的定义和昨天有点不用，它这里要求左子树的所有节点都比根节点的值要小，右子树的所有的节点的值都比根节点的值大.\n\n我们可以发现这样定义的BST的中序遍历一定是升序的，所以我们可以用先序遍历的方式来做:\n\n```c++\n long long vmax = LLONG_MIN;\n bool isValidBST1(TreeNode* root) {\n        if (root == NULL) return true;\n        if ( !isValidBST(root->left) ) return false;\n        if (root->val <= vmax) return false;\n        vmax = root->val;\n        return isValidBST(root->right);\n    }\n```\n\n既然使用中序遍历做的，那么我们就可以用非递归版的先序遍历来加快:\n\n```c++\nlong long vmax = LLONG_MIN;\nbool isValidBST(TreeNode* root) {\n    stack<TreeNode *> st;\n    while(true) {\n        while(root){\n            st.push(root);\n            root = root->left;\n        }\n\n        if (st.empty()) break;\n        root = st.top();\n        st.pop();\n\n        if (vmax >= root->val) return false;\n        vmax = root->val;\n\n        root = root->right;\n    }\n    return true;\n}\n```\n\n上面都是用`long long`来记录最大值，这时因为如果用`INT_MIN`来做的话，`[INT_MIN,INT_MIN]`这样的测例就会出错，我是用`long long`来解决这个问题的，但是`dicuss`中有一些其他方法:\n\n```c++\nbool isValidBST(TreeNode* root) {\n    TreeNode* prev = NULL;\n    return validate(root, prev);\n}\nbool validate(TreeNode* node, TreeNode* &prev) {\n    if (node == NULL) return true;\n    if (!validate(node->left, prev)) return false;\n    if (prev != NULL && prev->val >= node->val) return false;\n    prev = node;\n    return validate(node->right, prev);\n}\n```\n\n```c++\nbool isValidBST(TreeNode* root) {\n    return isValidBST(root, NULL, NULL);\n}\n\nbool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\n    if(!root) return true;\n    if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\n        return false;\n    return isValidBST(root->left, minNode, root) && isValidBST(root->right, root, maxNode);\n}\n```\n","source":"_posts/Validate-Binary-Search-Tree.md","raw":"---\ntitle: Validate Binary Search Tree\ndate: 2017-10-23T08:39:55.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第30天。\n\n恍恍惚惚就一个月了。\n\n今天的题目是[Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/description/):\n\n> Given a binary tree, determine if it is a valid binary search tree (BST).\n>\n> Assume a BST is defined as follows:\n>\n> The left subtree of a node contains only nodes with keys less than the node's key.\n> The right subtree of a node contains only nodes with keys greater than the node's key.\n> Both the left and right subtrees must also be binary search trees.\n>Example 1:\n\n```python\n    2\n   / \\\n  1   3\n```\n\n> Binary tree [2,1,3], return true.\n> Example 2:\n\n```python\n    1\n   / \\\n  2   3\n```\n\n> Binary tree [1,2,3], return false.\n\n昨天的题目也是和BST有关的，但是这里的定义和昨天有点不用，它这里要求左子树的所有节点都比根节点的值要小，右子树的所有的节点的值都比根节点的值大.\n\n我们可以发现这样定义的BST的中序遍历一定是升序的，所以我们可以用先序遍历的方式来做:\n\n```c++\n long long vmax = LLONG_MIN;\n bool isValidBST1(TreeNode* root) {\n        if (root == NULL) return true;\n        if ( !isValidBST(root->left) ) return false;\n        if (root->val <= vmax) return false;\n        vmax = root->val;\n        return isValidBST(root->right);\n    }\n```\n\n既然使用中序遍历做的，那么我们就可以用非递归版的先序遍历来加快:\n\n```c++\nlong long vmax = LLONG_MIN;\nbool isValidBST(TreeNode* root) {\n    stack<TreeNode *> st;\n    while(true) {\n        while(root){\n            st.push(root);\n            root = root->left;\n        }\n\n        if (st.empty()) break;\n        root = st.top();\n        st.pop();\n\n        if (vmax >= root->val) return false;\n        vmax = root->val;\n\n        root = root->right;\n    }\n    return true;\n}\n```\n\n上面都是用`long long`来记录最大值，这时因为如果用`INT_MIN`来做的话，`[INT_MIN,INT_MIN]`这样的测例就会出错，我是用`long long`来解决这个问题的，但是`dicuss`中有一些其他方法:\n\n```c++\nbool isValidBST(TreeNode* root) {\n    TreeNode* prev = NULL;\n    return validate(root, prev);\n}\nbool validate(TreeNode* node, TreeNode* &prev) {\n    if (node == NULL) return true;\n    if (!validate(node->left, prev)) return false;\n    if (prev != NULL && prev->val >= node->val) return false;\n    prev = node;\n    return validate(node->right, prev);\n}\n```\n\n```c++\nbool isValidBST(TreeNode* root) {\n    return isValidBST(root, NULL, NULL);\n}\n\nbool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\n    if(!root) return true;\n    if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\n        return false;\n    return isValidBST(root->left, minNode, root) && isValidBST(root->right, root, maxNode);\n}\n```\n","slug":"Validate-Binary-Search-Tree","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q700fnqmcmh7vp0of4","content":"<p>第30天。</p>\n<p>恍恍惚惚就一个月了。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/validate-binary-search-tree/description/\">Validate Binary Search Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>\n<p>Assume a BST is defined as follows:</p>\n<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">2</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">1</span>   <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Binary tree [2,1,3], return true.<br>Example 2:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">1</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">2</span>   <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Binary tree [1,2,3], return false.</p>\n</blockquote>\n<p>昨天的题目也是和BST有关的，但是这里的定义和昨天有点不用，它这里要求左子树的所有节点都比根节点的值要小，右子树的所有的节点的值都比根节点的值大.</p>\n<p>我们可以发现这样定义的BST的中序遍历一定是升序的，所以我们可以用先序遍历的方式来做:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> vmax = LLONG_MIN;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST1</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> ( !isValidBST(root-&gt;left) ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (root-&gt;val &lt;= vmax) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       vmax = root-&gt;val;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> isValidBST(root-&gt;right);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然使用中序遍历做的，那么我们就可以用非递归版的先序遍历来加快:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> vmax = LLONG_MIN;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root)&#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st.empty()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        root = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (vmax &gt;= root-&gt;val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        vmax = root-&gt;val;</span><br><span class=\"line\"></span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面都是用<code>long long</code>来记录最大值，这时因为如果用<code>INT_MIN</code>来做的话，<code>[INT_MIN,INT_MIN]</code>这样的测例就会出错，我是用<code>long long</code>来解决这个问题的，但是<code>dicuss</code>中有一些其他方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode* prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> validate(root, prev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">validate</span><span class=\"params\">(TreeNode* node, TreeNode* &amp;prev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!validate(node-&gt;left, prev)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev != <span class=\"literal\">NULL</span> &amp;&amp; prev-&gt;val &gt;= node-&gt;val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    prev = node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> validate(node-&gt;right, prev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isValidBST(root, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root, TreeNode* minNode, TreeNode* maxNode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(minNode &amp;&amp; root-&gt;val &lt;= minNode-&gt;val || maxNode &amp;&amp; root-&gt;val &gt;= maxNode-&gt;val)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isValidBST(root-&gt;left, minNode, root) &amp;&amp; isValidBST(root-&gt;right, root, maxNode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第30天。</p>\n<p>恍恍惚惚就一个月了。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/validate-binary-search-tree/description/\">Validate Binary Search Tree</a>:</p>\n<blockquote>\n<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>\n<p>Assume a BST is defined as follows:</p>\n<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">2</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">1</span>   <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Binary tree [2,1,3], return true.<br>Example 2:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">1</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">2</span>   <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Binary tree [1,2,3], return false.</p>\n</blockquote>\n<p>昨天的题目也是和BST有关的，但是这里的定义和昨天有点不用，它这里要求左子树的所有节点都比根节点的值要小，右子树的所有的节点的值都比根节点的值大.</p>\n<p>我们可以发现这样定义的BST的中序遍历一定是升序的，所以我们可以用先序遍历的方式来做:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> vmax = LLONG_MIN;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST1</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> ( !isValidBST(root-&gt;left) ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (root-&gt;val &lt;= vmax) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       vmax = root-&gt;val;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> isValidBST(root-&gt;right);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然使用中序遍历做的，那么我们就可以用非递归版的先序遍历来加快:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> vmax = LLONG_MIN;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root)&#123;</span><br><span class=\"line\">            st.push(root);</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st.empty()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        root = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (vmax &gt;= root-&gt;val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        vmax = root-&gt;val;</span><br><span class=\"line\"></span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面都是用<code>long long</code>来记录最大值，这时因为如果用<code>INT_MIN</code>来做的话，<code>[INT_MIN,INT_MIN]</code>这样的测例就会出错，我是用<code>long long</code>来解决这个问题的，但是<code>dicuss</code>中有一些其他方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode* prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> validate(root, prev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">validate</span><span class=\"params\">(TreeNode* node, TreeNode* &amp;prev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!validate(node-&gt;left, prev)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev != <span class=\"literal\">NULL</span> &amp;&amp; prev-&gt;val &gt;= node-&gt;val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    prev = node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> validate(node-&gt;right, prev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isValidBST(root, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root, TreeNode* minNode, TreeNode* maxNode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(minNode &amp;&amp; root-&gt;val &lt;= minNode-&gt;val || maxNode &amp;&amp; root-&gt;val &gt;= maxNode-&gt;val)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isValidBST(root-&gt;left, minNode, root) &amp;&amp; isValidBST(root-&gt;right, root, maxNode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Validate Stack Sequences","date":"2019-12-17T03:52:17.000Z","_content":"\n> 第41天。\n\n今天的题目是[Validate Stack Sequences](https://leetcode.com/problems/validate-stack-sequences/):\n\n简单题，直接模拟就好了：\n\n```c++\nbool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\n    stack<int> st;\n    int i = 0;\n    for(auto &t: popped) {\n        if (!st.empty() && st.top() == t) {\n            st.pop();\n        } else {\n            while(i < pushed.size() && pushed[i] != t) {\n                st.push(pushed[i]);\n                i++;\n            }\n            if (pushed.size() == i) return false;\n            i++;\n        }\n    }\n    return true;\n}\n```\n","source":"_posts/Validate-Stack-Sequences.md","raw":"---\ntitle: Validate Stack Sequences\ndate: 2019-12-17T11:52:17.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第41天。\n\n今天的题目是[Validate Stack Sequences](https://leetcode.com/problems/validate-stack-sequences/):\n\n简单题，直接模拟就好了：\n\n```c++\nbool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\n    stack<int> st;\n    int i = 0;\n    for(auto &t: popped) {\n        if (!st.empty() && st.top() == t) {\n            st.pop();\n        } else {\n            while(i < pushed.size() && pushed[i] != t) {\n                st.push(pushed[i]);\n                i++;\n            }\n            if (pushed.size() == i) return false;\n            i++;\n        }\n    }\n    return true;\n}\n```\n","slug":"Validate-Stack-Sequences","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q800fqqmcm48374v94","content":"<blockquote>\n<p>第41天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/validate-stack-sequences/\">Validate Stack Sequences</a>:</p>\n<p>简单题，直接模拟就好了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">validateStackSequences</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; pushed, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;t: popped) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st.empty() &amp;&amp; st.top() == t) &#123;</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &lt; pushed.size() &amp;&amp; pushed[i] != t) &#123;</span><br><span class=\"line\">                st.push(pushed[i]);</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pushed.size() == i) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第41天。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/validate-stack-sequences/\">Validate Stack Sequences</a>:</p>\n<p>简单题，直接模拟就好了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">validateStackSequences</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; pushed, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;t: popped) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st.empty() &amp;&amp; st.top() == t) &#123;</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &lt; pushed.size() &amp;&amp; pushed[i] != t) &#123;</span><br><span class=\"line\">                st.push(pushed[i]);</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pushed.size() == i) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Verify-Preorder-Serialization-of-a-Binary-Tree","date":"2018-02-19T03:54:41.000Z","_content":"\n第104天。\n\n今天的题目是[331. Verify Preorder Serialization of a Binary Tree](https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description/):\n\n> One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.\n\n```\n     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\n```\n\n> For example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node.\n>\n> Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.\n>\n> Each comma separated value in the string must be either an integer or a character '#' representing null pointer.\n>\n> You may assume that the input format is always valid, for example it could never contain two consecutive commas such as \"1,,3\".\n>\n> Example 1:\n> \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n> Return true\n>\n> Example 2:\n> \"1,#\"\n> Return false\n>\n> Example 3:\n> \"9,#,#,1\"\n> Return false\n\n虽然题目很长，但是理解起来并不难，就是给你一串字符串表示一棵二叉树，用`,`分隔节点的值，用`#`表示空指针，然后问你这个字符串能不能还原出来一棵二叉树（在不建树的情况下）,其实和建树很像，都是递归的去做：\n\n```c++\nbool isValidSerialization(string preorder) {\n    int beg = 0;\n    return isValidSerialization(preorder,beg) && !next(preorder, beg);\n}\nbool isValidSerialization(string preorder, int &beg) {\n    if (beg >= preorder.size()) return false;\n    if (preorder[beg] == '#') return true;\n    return next(preorder, beg) && isValidSerialization(preorder, beg) &&\n        next(preorder, beg) && isValidSerialization(preorder, beg);\n}\nbool next(string &preorder, int &beg) {\n    while(beg < preorder.size() && preorder[beg] != ',') beg++;\n    beg++;\n    return beg < preorder.size();\n}\n```\n\n然后是`dicuss`中的迭代版本：\n\n```c++\nbool isValidSerialization(string preorder) {\n    if (preorder.empty()) return false;\n    preorder+=',';\n    int sz=preorder.size(),idx=0;\n    int capacity=1;\n    for (idx=0;idx<sz;idx++){\n        if (preorder[idx]!=',') continue;\n        capacity--;\n        if (capacity<0) return false;\n        if (preorder[idx-1]!='#') capacity+=2;\n    }\n    return capacity==0;\n}\n```\n\n> Update at 2020-04-02\n\n补充一个自己的写法：\n\n```c++\nbool isValidSerialization(string preorder) {\n    int i, c, size; \n    for(i = 0, c = 1, size = preorder.size(); i < size && c; i++){\n        if (preorder[i] == '#') c--;\n        else c++; // c--; c+=2;\n        // move next node\n        while(i < size && preorder[i]!=',') i++;\n    }\n    return c == 0 && i >= size;\n}\n```\n","source":"_posts/Verify-Preorder-Serialization-of-a-Binary-Tree.md","raw":"---\ntitle: Verify-Preorder-Serialization-of-a-Binary-Tree\ndate: 2018-02-19T11:54:41.000Z\ntags:\n  - LeetCode\n  - Stack\ncategories:\n  - LeetCode\n---\n\n第104天。\n\n今天的题目是[331. Verify Preorder Serialization of a Binary Tree](https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description/):\n\n> One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.\n\n```\n     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\n```\n\n> For example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node.\n>\n> Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.\n>\n> Each comma separated value in the string must be either an integer or a character '#' representing null pointer.\n>\n> You may assume that the input format is always valid, for example it could never contain two consecutive commas such as \"1,,3\".\n>\n> Example 1:\n> \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n> Return true\n>\n> Example 2:\n> \"1,#\"\n> Return false\n>\n> Example 3:\n> \"9,#,#,1\"\n> Return false\n\n虽然题目很长，但是理解起来并不难，就是给你一串字符串表示一棵二叉树，用`,`分隔节点的值，用`#`表示空指针，然后问你这个字符串能不能还原出来一棵二叉树（在不建树的情况下）,其实和建树很像，都是递归的去做：\n\n```c++\nbool isValidSerialization(string preorder) {\n    int beg = 0;\n    return isValidSerialization(preorder,beg) && !next(preorder, beg);\n}\nbool isValidSerialization(string preorder, int &beg) {\n    if (beg >= preorder.size()) return false;\n    if (preorder[beg] == '#') return true;\n    return next(preorder, beg) && isValidSerialization(preorder, beg) &&\n        next(preorder, beg) && isValidSerialization(preorder, beg);\n}\nbool next(string &preorder, int &beg) {\n    while(beg < preorder.size() && preorder[beg] != ',') beg++;\n    beg++;\n    return beg < preorder.size();\n}\n```\n\n然后是`dicuss`中的迭代版本：\n\n```c++\nbool isValidSerialization(string preorder) {\n    if (preorder.empty()) return false;\n    preorder+=',';\n    int sz=preorder.size(),idx=0;\n    int capacity=1;\n    for (idx=0;idx<sz;idx++){\n        if (preorder[idx]!=',') continue;\n        capacity--;\n        if (capacity<0) return false;\n        if (preorder[idx-1]!='#') capacity+=2;\n    }\n    return capacity==0;\n}\n```\n\n> Update at 2020-04-02\n\n补充一个自己的写法：\n\n```c++\nbool isValidSerialization(string preorder) {\n    int i, c, size; \n    for(i = 0, c = 1, size = preorder.size(); i < size && c; i++){\n        if (preorder[i] == '#') c--;\n        else c++; // c--; c+=2;\n        // move next node\n        while(i < size && preorder[i]!=',') i++;\n    }\n    return c == 0 && i >= size;\n}\n```\n","slug":"Verify-Preorder-Serialization-of-a-Binary-Tree","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69q900ftqmcmhbi45zov","content":"<p>第104天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description/\">331. Verify Preorder Serialization of a Binary Tree</a>:</p>\n<blockquote>\n<p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     _9_</span><br><span class=\"line\">    &#x2F;   \\</span><br><span class=\"line\">   3     2</span><br><span class=\"line\">  &#x2F; \\   &#x2F; \\</span><br><span class=\"line\"> 4   1  #  6</span><br><span class=\"line\">&#x2F; \\ &#x2F; \\   &#x2F; \\</span><br><span class=\"line\"># # # #   # #</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node.</p>\n<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>\n<p>Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>\n<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”.</p>\n<p>Example 1:<br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>Return true</p>\n<p>Example 2:<br>“1,#”<br>Return false</p>\n<p>Example 3:<br>“9,#,#,1”<br>Return false</p>\n</blockquote>\n<p>虽然题目很长，但是理解起来并不难，就是给你一串字符串表示一棵二叉树，用<code>,</code>分隔节点的值，用<code>#</code>表示空指针，然后问你这个字符串能不能还原出来一棵二叉树（在不建树的情况下）,其实和建树很像，都是递归的去做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(<span class=\"built_in\">string</span> preorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isValidSerialization(preorder,beg) &amp;&amp; !next(preorder, beg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(<span class=\"built_in\">string</span> preorder, <span class=\"keyword\">int</span> &amp;beg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beg &gt;= preorder.size()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preorder[beg] == <span class=\"string\">&#x27;#&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(preorder, beg) &amp;&amp; isValidSerialization(preorder, beg) &amp;&amp;</span><br><span class=\"line\">        next(preorder, beg) &amp;&amp; isValidSerialization(preorder, beg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;preorder, <span class=\"keyword\">int</span> &amp;beg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg &lt; preorder.size() &amp;&amp; preorder[beg] != <span class=\"string\">&#x27;,&#x27;</span>) beg++;</span><br><span class=\"line\">    beg++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beg &lt; preorder.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的迭代版本：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(<span class=\"built_in\">string</span> preorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preorder.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    preorder+=<span class=\"string\">&#x27;,&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz=preorder.size(),idx=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> capacity=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx=<span class=\"number\">0</span>;idx&lt;sz;idx++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preorder[idx]!=<span class=\"string\">&#x27;,&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        capacity--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preorder[idx<span class=\"number\">-1</span>]!=<span class=\"string\">&#x27;#&#x27;</span>) capacity+=<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> capacity==<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Update at 2020-04-02</p>\n</blockquote>\n<p>补充一个自己的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(<span class=\"built_in\">string</span> preorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, c, size; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>, c = <span class=\"number\">1</span>, size = preorder.size(); i &lt; size &amp;&amp; c; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preorder[i] == <span class=\"string\">&#x27;#&#x27;</span>) c--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> c++; <span class=\"comment\">// c--; c+=2;</span></span><br><span class=\"line\">        <span class=\"comment\">// move next node</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; size &amp;&amp; preorder[i]!=<span class=\"string\">&#x27;,&#x27;</span>) i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c == <span class=\"number\">0</span> &amp;&amp; i &gt;= size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第104天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description/\">331. Verify Preorder Serialization of a Binary Tree</a>:</p>\n<blockquote>\n<p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     _9_</span><br><span class=\"line\">    &#x2F;   \\</span><br><span class=\"line\">   3     2</span><br><span class=\"line\">  &#x2F; \\   &#x2F; \\</span><br><span class=\"line\"> 4   1  #  6</span><br><span class=\"line\">&#x2F; \\ &#x2F; \\   &#x2F; \\</span><br><span class=\"line\"># # # #   # #</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node.</p>\n<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>\n<p>Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>\n<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”.</p>\n<p>Example 1:<br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>Return true</p>\n<p>Example 2:<br>“1,#”<br>Return false</p>\n<p>Example 3:<br>“9,#,#,1”<br>Return false</p>\n</blockquote>\n<p>虽然题目很长，但是理解起来并不难，就是给你一串字符串表示一棵二叉树，用<code>,</code>分隔节点的值，用<code>#</code>表示空指针，然后问你这个字符串能不能还原出来一棵二叉树（在不建树的情况下）,其实和建树很像，都是递归的去做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(<span class=\"built_in\">string</span> preorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isValidSerialization(preorder,beg) &amp;&amp; !next(preorder, beg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(<span class=\"built_in\">string</span> preorder, <span class=\"keyword\">int</span> &amp;beg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beg &gt;= preorder.size()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preorder[beg] == <span class=\"string\">&#x27;#&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(preorder, beg) &amp;&amp; isValidSerialization(preorder, beg) &amp;&amp;</span><br><span class=\"line\">        next(preorder, beg) &amp;&amp; isValidSerialization(preorder, beg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;preorder, <span class=\"keyword\">int</span> &amp;beg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(beg &lt; preorder.size() &amp;&amp; preorder[beg] != <span class=\"string\">&#x27;,&#x27;</span>) beg++;</span><br><span class=\"line\">    beg++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beg &lt; preorder.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是<code>dicuss</code>中的迭代版本：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(<span class=\"built_in\">string</span> preorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preorder.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    preorder+=<span class=\"string\">&#x27;,&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz=preorder.size(),idx=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> capacity=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx=<span class=\"number\">0</span>;idx&lt;sz;idx++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preorder[idx]!=<span class=\"string\">&#x27;,&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        capacity--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preorder[idx<span class=\"number\">-1</span>]!=<span class=\"string\">&#x27;#&#x27;</span>) capacity+=<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> capacity==<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Update at 2020-04-02</p>\n</blockquote>\n<p>补充一个自己的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(<span class=\"built_in\">string</span> preorder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, c, size; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>, c = <span class=\"number\">1</span>, size = preorder.size(); i &lt; size &amp;&amp; c; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preorder[i] == <span class=\"string\">&#x27;#&#x27;</span>) c--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> c++; <span class=\"comment\">// c--; c+=2;</span></span><br><span class=\"line\">        <span class=\"comment\">// move next node</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; size &amp;&amp; preorder[i]!=<span class=\"string\">&#x27;,&#x27;</span>) i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c == <span class=\"number\">0</span> &amp;&amp; i &gt;= size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Word Break","date":"2017-10-27T12:27:53.000Z","_content":"\n第33天。\n\n做了超级久。。。还是没做出来，我真是菜啊，明明已经想到了要用动态规划来做了。\n\n今天的题目是:[Word Break](https://leetcode.com/problems/word-break/description/):\n\n> Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.\n>\n> For example, given\n> s = \"leetcode\",\n> dict = [\"leet\", \"code\"].\n>\n> Return true because \"leetcode\" can be segmented as \"leet code\".\n\n因为没做出来，所以只能讲别人的思路了。。。\n\n首先这里是要用动态规划去做的，我们需要一个`vector<bool> db`来记录`s.substr(0,i+1)`的子串是否能用`wordDict`进行`break`,如果我们要求`db[i]`我们是否能利用`db[0:i]`的值呢，比如，如果`0<= k < i`，且`db[k]==true`,那么我们是不是只需要在`wordDict`中查找是否有`s.substr(i,k-i)`就可了呢：\n\n```c++\n    bool wordBreak(string s,vector<string> &wordDict) {\n        if(wordDict.size() == 0) return false;\n        vector<bool> dp(s.size() + 1,false);\n        dp[0] = true;\n        for(int i = 1;i <= s.size();i++) {\n            for(int j = i-1;j >= 0;j--) {\n                if (dp[j]) {\n                    string word = s.substr(j,i-j);\n                    if (find(wordDict.begin(),wordDict.end(),word) != wordDict.end()) {\n                        dp[i] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return dp[s.size()];\n    }\n```\n\n因为是别人的思路，所以也没法复现思考的过程了，总结一下没做出来的原因吧。\n虽然说算法课上刚讲了`DP`,当时他讲的时候我还觉得挺简单的，还以为自己已经会了，因为之前已经做过好几次`DP`的题目了，现在想想上课我就记得他吐槽了`DP`的恋爱观，什么总是找局部最优解巴拉巴拉的。\n哎，这种东西还是要自己体会才行，恩，决定了，这几天刷会`DP`的题目先。\n","source":"_posts/Word-Break.md","raw":"---\ntitle: Word Break\ndate: 2017-10-27T20:27:53.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 动态规划\n---\n\n第33天。\n\n做了超级久。。。还是没做出来，我真是菜啊，明明已经想到了要用动态规划来做了。\n\n今天的题目是:[Word Break](https://leetcode.com/problems/word-break/description/):\n\n> Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.\n>\n> For example, given\n> s = \"leetcode\",\n> dict = [\"leet\", \"code\"].\n>\n> Return true because \"leetcode\" can be segmented as \"leet code\".\n\n因为没做出来，所以只能讲别人的思路了。。。\n\n首先这里是要用动态规划去做的，我们需要一个`vector<bool> db`来记录`s.substr(0,i+1)`的子串是否能用`wordDict`进行`break`,如果我们要求`db[i]`我们是否能利用`db[0:i]`的值呢，比如，如果`0<= k < i`，且`db[k]==true`,那么我们是不是只需要在`wordDict`中查找是否有`s.substr(i,k-i)`就可了呢：\n\n```c++\n    bool wordBreak(string s,vector<string> &wordDict) {\n        if(wordDict.size() == 0) return false;\n        vector<bool> dp(s.size() + 1,false);\n        dp[0] = true;\n        for(int i = 1;i <= s.size();i++) {\n            for(int j = i-1;j >= 0;j--) {\n                if (dp[j]) {\n                    string word = s.substr(j,i-j);\n                    if (find(wordDict.begin(),wordDict.end(),word) != wordDict.end()) {\n                        dp[i] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return dp[s.size()];\n    }\n```\n\n因为是别人的思路，所以也没法复现思考的过程了，总结一下没做出来的原因吧。\n虽然说算法课上刚讲了`DP`,当时他讲的时候我还觉得挺简单的，还以为自己已经会了，因为之前已经做过好几次`DP`的题目了，现在想想上课我就记得他吐槽了`DP`的恋爱观，什么总是找局部最优解巴拉巴拉的。\n哎，这种东西还是要自己体会才行，恩，决定了，这几天刷会`DP`的题目先。\n","slug":"Word-Break","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qa00fwqmcmb8g22gh0","content":"<p>第33天。</p>\n<p>做了超级久。。。还是没做出来，我真是菜啊，明明已经想到了要用动态规划来做了。</p>\n<p>今天的题目是:<a href=\"https://leetcode.com/problems/word-break/description/\">Word Break</a>:</p>\n<blockquote>\n<p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p>\n<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>\n<p>Return true because “leetcode” can be segmented as “leet code”.</p>\n</blockquote>\n<p>因为没做出来，所以只能讲别人的思路了。。。</p>\n<p>首先这里是要用动态规划去做的，我们需要一个<code>vector&lt;bool&gt; db</code>来记录<code>s.substr(0,i+1)</code>的子串是否能用<code>wordDict</code>进行<code>break</code>,如果我们要求<code>db[i]</code>我们是否能利用<code>db[0:i]</code>的值呢，比如，如果<code>0&lt;= k &lt; i</code>，且<code>db[k]==true</code>,那么我们是不是只需要在<code>wordDict</code>中查找是否有<code>s.substr(i,k-i)</code>就可了呢：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">wordBreak</span><span class=\"params\">(<span class=\"built_in\">string</span> s,<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;wordDict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(wordDict.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(s.size() + <span class=\"number\">1</span>,<span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= s.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i<span class=\"number\">-1</span>;j &gt;= <span class=\"number\">0</span>;j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dp[j]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> word = s.substr(j,i-j);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (find(wordDict.begin(),wordDict.end(),word) != wordDict.end()) &#123;</span><br><span class=\"line\">                    dp[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[s.size()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为是别人的思路，所以也没法复现思考的过程了，总结一下没做出来的原因吧。<br>虽然说算法课上刚讲了<code>DP</code>,当时他讲的时候我还觉得挺简单的，还以为自己已经会了，因为之前已经做过好几次<code>DP</code>的题目了，现在想想上课我就记得他吐槽了<code>DP</code>的恋爱观，什么总是找局部最优解巴拉巴拉的。<br>哎，这种东西还是要自己体会才行，恩，决定了，这几天刷会<code>DP</code>的题目先。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第33天。</p>\n<p>做了超级久。。。还是没做出来，我真是菜啊，明明已经想到了要用动态规划来做了。</p>\n<p>今天的题目是:<a href=\"https://leetcode.com/problems/word-break/description/\">Word Break</a>:</p>\n<blockquote>\n<p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p>\n<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>\n<p>Return true because “leetcode” can be segmented as “leet code”.</p>\n</blockquote>\n<p>因为没做出来，所以只能讲别人的思路了。。。</p>\n<p>首先这里是要用动态规划去做的，我们需要一个<code>vector&lt;bool&gt; db</code>来记录<code>s.substr(0,i+1)</code>的子串是否能用<code>wordDict</code>进行<code>break</code>,如果我们要求<code>db[i]</code>我们是否能利用<code>db[0:i]</code>的值呢，比如，如果<code>0&lt;= k &lt; i</code>，且<code>db[k]==true</code>,那么我们是不是只需要在<code>wordDict</code>中查找是否有<code>s.substr(i,k-i)</code>就可了呢：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">wordBreak</span><span class=\"params\">(<span class=\"built_in\">string</span> s,<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;wordDict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(wordDict.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(s.size() + <span class=\"number\">1</span>,<span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= s.size();i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i<span class=\"number\">-1</span>;j &gt;= <span class=\"number\">0</span>;j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dp[j]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> word = s.substr(j,i-j);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (find(wordDict.begin(),wordDict.end(),word) != wordDict.end()) &#123;</span><br><span class=\"line\">                    dp[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[s.size()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为是别人的思路，所以也没法复现思考的过程了，总结一下没做出来的原因吧。<br>虽然说算法课上刚讲了<code>DP</code>,当时他讲的时候我还觉得挺简单的，还以为自己已经会了，因为之前已经做过好几次<code>DP</code>的题目了，现在想想上课我就记得他吐槽了<code>DP</code>的恋爱观，什么总是找局部最优解巴拉巴拉的。<br>哎，这种东西还是要自己体会才行，恩，决定了，这几天刷会<code>DP</code>的题目先。</p>\n"},{"title":"Word Search","date":"2017-10-21T03:21:03.000Z","_content":"\n第28天。\n\n今天的题目是[Word Search](https://leetcode.com/problems/word-search/description/)：\n\n> Given a 2D board and a word, find if the word exists in the grid.\n>\n> The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n>\n> For example,\n> Given board =\n\n```python\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n```\n\n> word = \"ABCCED\", -> returns true,\n> word = \"SEE\", -> returns true,\n> word = \"ABCB\", -> returns false.\n\n这道题想起来不难，就是有点繁琐，有几个要点需要考虑：\n\n* 每个元素只能用一次\n* 字符只要求是临接的，即可能有四个方向需要考虑。\n\n\n因为每个元素只能用一次，所以我们需要一个方式来记录这个位置是否被使用，简单的方法就是直接用一个二维数组来记录，然后我们需要考虑是否越过边界:\n\n```c++\nbool search(vector<vector<char> > &board,vector<vector<bool> > &used,string &word,int beg,int i,int j) {\n    //找到了\n    if (beg == word.size() ) return true;\n    //边界检测\n    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() ) return false;\n    //检测是否被使用了\n    if (used[i][j]) return false;\n    //检测是否是想要的字符\n    if (word[beg] != board[i][j]) return false;\n    //假设这就是正确的路径\n    used[i][j] = true;\n    //向四个方向查找\n    if( search(board,used,word,beg+1,i-1,j) || search(board,used,word,beg+1,i+1,j)\n        || search(board,used,word,beg+1,i,j-1) || search(board,used,word,beg+1,i,j+1)\n        )\n        return true;\n    else {\n        //如果四个方法都失败了，说明了这个路径是错的，所以回溯。\n        used[i][j] =  false;\n        return false;\n    }\n}\nbool exist(vector<vector<char>>& board, string word) {\n    //保证至少有一个元素\n    if (board.size() == 0 || board[0].size() == 0) return false;\n    //创建一个二维数组来记录是否字符是否被使用\n    vector<bool> vec(board[0].size(),false);\n    vector<vector<bool> > used ( board.size(),vec );\n\n    //以每一个点为起点进行查找\n    for(int i = 0;i < board.size();i++)\n        for(int j = 0;j < board[0].size();j++) {\n            if (word[0] == board[i][j] && search(board,used,word,0,i,j))\n                return true;\n        }\n    return false;\n}\n```\n\n上面的方法使用了一个二维数组来记录元素是否被使用,其实可以直接在`board`中记录是否被使用:\n\n```c++\nint m;\nint n;\nbool exist(vector<vector<char> > &board, string word) {\n    m=board.size();\n    n=board[0].size();\n    for(int x=0;x<m;x++)\n        for(int y=0;y<n;y++)\n        {\n            if(isFound(board,word.c_str(),x,y))\n                return true;\n        }\n    return false;\n}\nbool isFound(vector<vector<char> > &board, const char* w, int x, int y)\n{\n    if(x<0||y<0||x>=m||y>=n||board[x][y]=='\\0'||*w!=board[x][y])\n        return false;\n    if(*(w+1)=='\\0')\n        return true;\n    char t=board[x][y];\n    board[x][y]='\\0';\n    if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1))\n        return true; \n    board[x][y]=t;\n    return false;\n}\n```\n","source":"_posts/Word-Search.md","raw":"---\ntitle: Word Search\ndate: 2017-10-21T11:21:03.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n第28天。\n\n今天的题目是[Word Search](https://leetcode.com/problems/word-search/description/)：\n\n> Given a 2D board and a word, find if the word exists in the grid.\n>\n> The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n>\n> For example,\n> Given board =\n\n```python\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n```\n\n> word = \"ABCCED\", -> returns true,\n> word = \"SEE\", -> returns true,\n> word = \"ABCB\", -> returns false.\n\n这道题想起来不难，就是有点繁琐，有几个要点需要考虑：\n\n* 每个元素只能用一次\n* 字符只要求是临接的，即可能有四个方向需要考虑。\n\n\n因为每个元素只能用一次，所以我们需要一个方式来记录这个位置是否被使用，简单的方法就是直接用一个二维数组来记录，然后我们需要考虑是否越过边界:\n\n```c++\nbool search(vector<vector<char> > &board,vector<vector<bool> > &used,string &word,int beg,int i,int j) {\n    //找到了\n    if (beg == word.size() ) return true;\n    //边界检测\n    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() ) return false;\n    //检测是否被使用了\n    if (used[i][j]) return false;\n    //检测是否是想要的字符\n    if (word[beg] != board[i][j]) return false;\n    //假设这就是正确的路径\n    used[i][j] = true;\n    //向四个方向查找\n    if( search(board,used,word,beg+1,i-1,j) || search(board,used,word,beg+1,i+1,j)\n        || search(board,used,word,beg+1,i,j-1) || search(board,used,word,beg+1,i,j+1)\n        )\n        return true;\n    else {\n        //如果四个方法都失败了，说明了这个路径是错的，所以回溯。\n        used[i][j] =  false;\n        return false;\n    }\n}\nbool exist(vector<vector<char>>& board, string word) {\n    //保证至少有一个元素\n    if (board.size() == 0 || board[0].size() == 0) return false;\n    //创建一个二维数组来记录是否字符是否被使用\n    vector<bool> vec(board[0].size(),false);\n    vector<vector<bool> > used ( board.size(),vec );\n\n    //以每一个点为起点进行查找\n    for(int i = 0;i < board.size();i++)\n        for(int j = 0;j < board[0].size();j++) {\n            if (word[0] == board[i][j] && search(board,used,word,0,i,j))\n                return true;\n        }\n    return false;\n}\n```\n\n上面的方法使用了一个二维数组来记录元素是否被使用,其实可以直接在`board`中记录是否被使用:\n\n```c++\nint m;\nint n;\nbool exist(vector<vector<char> > &board, string word) {\n    m=board.size();\n    n=board[0].size();\n    for(int x=0;x<m;x++)\n        for(int y=0;y<n;y++)\n        {\n            if(isFound(board,word.c_str(),x,y))\n                return true;\n        }\n    return false;\n}\nbool isFound(vector<vector<char> > &board, const char* w, int x, int y)\n{\n    if(x<0||y<0||x>=m||y>=n||board[x][y]=='\\0'||*w!=board[x][y])\n        return false;\n    if(*(w+1)=='\\0')\n        return true;\n    char t=board[x][y];\n    board[x][y]='\\0';\n    if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1))\n        return true; \n    board[x][y]=t;\n    return false;\n}\n```\n","slug":"Word-Search","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qa00fzqmcm0pjef7p5","content":"<p>第28天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/word-search/description/\">Word Search</a>：</p>\n<blockquote>\n<p>Given a 2D board and a word, find if the word exists in the grid.</p>\n<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n<p>For example,<br>Given board =</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"string\">&#x27;B&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&#x27;S&#x27;</span>,<span class=\"string\">&#x27;F&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>,<span class=\"string\">&#x27;S&#x27;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"string\">&#x27;D&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>\n</blockquote>\n<p>这道题想起来不难，就是有点繁琐，有几个要点需要考虑：</p>\n<ul>\n<li>每个元素只能用一次</li>\n<li>字符只要求是临接的，即可能有四个方向需要考虑。</li>\n</ul>\n<p>因为每个元素只能用一次，所以我们需要一个方式来记录这个位置是否被使用，简单的方法就是直接用一个二维数组来记录，然后我们需要考虑是否越过边界:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &gt; &amp;board,<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &gt; &amp;used,<span class=\"built_in\">string</span> &amp;word,<span class=\"keyword\">int</span> beg,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//找到了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beg == word.size() ) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">//边界检测</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= board.size() || j &gt;= board[<span class=\"number\">0</span>].size() ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//检测是否被使用了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (used[i][j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//检测是否是想要的字符</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (word[beg] != board[i][j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//假设这就是正确的路径</span></span><br><span class=\"line\">    used[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">//向四个方向查找</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( search(board,used,word,beg+<span class=\"number\">1</span>,i<span class=\"number\">-1</span>,j) || search(board,used,word,beg+<span class=\"number\">1</span>,i+<span class=\"number\">1</span>,j)</span><br><span class=\"line\">        || search(board,used,word,beg+<span class=\"number\">1</span>,i,j<span class=\"number\">-1</span>) || search(board,used,word,beg+<span class=\"number\">1</span>,i,j+<span class=\"number\">1</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果四个方法都失败了，说明了这个路径是错的，所以回溯。</span></span><br><span class=\"line\">        used[i][j] =  <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt;&gt;&amp; board, <span class=\"built_in\">string</span> word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//保证至少有一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (board.size() == <span class=\"number\">0</span> || board[<span class=\"number\">0</span>].size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个二维数组来记录是否字符是否被使用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(board[<span class=\"number\">0</span>].size(),<span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &gt; used ( board.size(),vec );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以每一个点为起点进行查找</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; board.size();i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; board[<span class=\"number\">0</span>].size();j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (word[<span class=\"number\">0</span>] == board[i][j] &amp;&amp; search(board,used,word,<span class=\"number\">0</span>,i,j))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的方法使用了一个二维数组来记录元素是否被使用,其实可以直接在<code>board</code>中记录是否被使用:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &gt; &amp;board, <span class=\"built_in\">string</span> word)</span> </span>&#123;</span><br><span class=\"line\">    m=board.size();</span><br><span class=\"line\">    n=board[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x=<span class=\"number\">0</span>;x&lt;m;x++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;y&lt;n;y++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isFound(board,word.c_str(),x,y))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFound</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &gt; &amp;board, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* w, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>||y&lt;<span class=\"number\">0</span>||x&gt;=m||y&gt;=n||board[x][y]==<span class=\"string\">&#x27;\\0&#x27;</span>||*w!=board[x][y])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*(w+<span class=\"number\">1</span>)==<span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> t=board[x][y];</span><br><span class=\"line\">    board[x][y]=<span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isFound(board,w+<span class=\"number\">1</span>,x<span class=\"number\">-1</span>,y)||isFound(board,w+<span class=\"number\">1</span>,x+<span class=\"number\">1</span>,y)||isFound(board,w+<span class=\"number\">1</span>,x,y<span class=\"number\">-1</span>)||isFound(board,w+<span class=\"number\">1</span>,x,y+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    board[x][y]=t;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第28天。</p>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/word-search/description/\">Word Search</a>：</p>\n<blockquote>\n<p>Given a 2D board and a word, find if the word exists in the grid.</p>\n<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n<p>For example,<br>Given board =</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"string\">&#x27;B&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&#x27;S&#x27;</span>,<span class=\"string\">&#x27;F&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>,<span class=\"string\">&#x27;S&#x27;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"string\">&#x27;D&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>\n</blockquote>\n<p>这道题想起来不难，就是有点繁琐，有几个要点需要考虑：</p>\n<ul>\n<li>每个元素只能用一次</li>\n<li>字符只要求是临接的，即可能有四个方向需要考虑。</li>\n</ul>\n<p>因为每个元素只能用一次，所以我们需要一个方式来记录这个位置是否被使用，简单的方法就是直接用一个二维数组来记录，然后我们需要考虑是否越过边界:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &gt; &amp;board,<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &gt; &amp;used,<span class=\"built_in\">string</span> &amp;word,<span class=\"keyword\">int</span> beg,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//找到了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beg == word.size() ) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">//边界检测</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= board.size() || j &gt;= board[<span class=\"number\">0</span>].size() ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//检测是否被使用了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (used[i][j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//检测是否是想要的字符</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (word[beg] != board[i][j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//假设这就是正确的路径</span></span><br><span class=\"line\">    used[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">//向四个方向查找</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( search(board,used,word,beg+<span class=\"number\">1</span>,i<span class=\"number\">-1</span>,j) || search(board,used,word,beg+<span class=\"number\">1</span>,i+<span class=\"number\">1</span>,j)</span><br><span class=\"line\">        || search(board,used,word,beg+<span class=\"number\">1</span>,i,j<span class=\"number\">-1</span>) || search(board,used,word,beg+<span class=\"number\">1</span>,i,j+<span class=\"number\">1</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果四个方法都失败了，说明了这个路径是错的，所以回溯。</span></span><br><span class=\"line\">        used[i][j] =  <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt;&gt;&amp; board, <span class=\"built_in\">string</span> word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//保证至少有一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (board.size() == <span class=\"number\">0</span> || board[<span class=\"number\">0</span>].size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个二维数组来记录是否字符是否被使用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(board[<span class=\"number\">0</span>].size(),<span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; &gt; used ( board.size(),vec );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以每一个点为起点进行查找</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; board.size();i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; board[<span class=\"number\">0</span>].size();j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (word[<span class=\"number\">0</span>] == board[i][j] &amp;&amp; search(board,used,word,<span class=\"number\">0</span>,i,j))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的方法使用了一个二维数组来记录元素是否被使用,其实可以直接在<code>board</code>中记录是否被使用:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &gt; &amp;board, <span class=\"built_in\">string</span> word)</span> </span>&#123;</span><br><span class=\"line\">    m=board.size();</span><br><span class=\"line\">    n=board[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x=<span class=\"number\">0</span>;x&lt;m;x++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;y&lt;n;y++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isFound(board,word.c_str(),x,y))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFound</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; &gt; &amp;board, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* w, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>||y&lt;<span class=\"number\">0</span>||x&gt;=m||y&gt;=n||board[x][y]==<span class=\"string\">&#x27;\\0&#x27;</span>||*w!=board[x][y])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*(w+<span class=\"number\">1</span>)==<span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> t=board[x][y];</span><br><span class=\"line\">    board[x][y]=<span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isFound(board,w+<span class=\"number\">1</span>,x<span class=\"number\">-1</span>,y)||isFound(board,w+<span class=\"number\">1</span>,x+<span class=\"number\">1</span>,y)||isFound(board,w+<span class=\"number\">1</span>,x,y<span class=\"number\">-1</span>)||isFound(board,w+<span class=\"number\">1</span>,x,y+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    board[x][y]=t;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"ZigZag Conversion","date":"2019-02-15T09:42:54.000Z","_content":"\n> 第二天。今天AC掉了一道之前没AC掉的题目。。。\n\n今天的题目是[6. ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/)\n\n题目描述：\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\n```cpp\nstring convert(string s, int numRows);\n```\n\nExample 1:\n\n```\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n```\n\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\n\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```\n\n恩，又是一道“编程题“， 并不涉及到什么算法，静下心来仔细想想还是能做出来的。做这道题的思路就是**一点一点跑例子**，找出其中的规律就好了。\n\n我们先以输入为`s = \"PAYPALISHIRING\", numRows = 3`为例子，这是题目给出的例子，正确答案已经有了。\n\n先把Z字型画出来（不难发现，题目在最开始其实已经给出了答案）：\n\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\n观察上面的例子我们可以发现：\n\n- 第一行中的元素在原来的字符串中下标相差4个。\n- 第二行中的元素在原来字符串中下标相差2个。\n\nok，看起来好像找到了一些规律，继续跑一个例子验证一下，这次的输入是`s = \"PAYPALISHIRING\", numRows = 3`，把Z字型画出来：\n\n```\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```\n\n可以看到第一行的元素在原来字符串中的下标相差6个，但是第二行却出现了一些不一样的情况：\n\n- `A`与`L`相差4个，`L`与`S`却相差2个\n- `S`与`I`相差4个，`I`与`G`却相差2个\n\n看起来`offset`是有规律的，而且好像需要分成两种情况，继续看看第3行：\n\n- `Y`与`A`相差2个，`A`与`H`相差4个\n- `H`与`R`相差4个，如果还有元素的话，下一个元素与`R`之间显然相差2个。\n\n从上面的例子来看显然是要分成两种情况的，某一行中下标之间的`offset`是不断在两个数字间不断变换的。\n\n我们尝试用两个数组来保存这些`offset`，我们把这两个数组定义为`skipDown`和`skipUp`。其中`skipDown`表示下标在z字型中经过了一个向下的剪头，如第二个例子中，第一行的`P`移动到`I`时，`P`经过了`AYPAl`组成的向下的剪头。`skipUp`同理可推。\n\n如果我们继续跑例子的话，应该是比较容易找出规律的：\n\n- 第`i`行的`skipDown`为`2*(i-1)`，而第一行和最后一行的`skipDown`都应该为`2*(numRows)`。\n- `skipDown`与`skipUp`是逆序的关系。\n\n综上，我们可以写出下面的代码：\n\n```cpp\nstring convert(string s, int numRows) {\n    if (numRows < 2) return s;\n    vector<int> skipDown(numRows);\n    vector<int> skipUp(numRows);\n    \n    skipDown[0] = 2*(numRows-1);\n    skipUp[0] = 0;\n    for(int i = 1;i < numRows; i++) {\n        skipDown[i] = skipDown[i-1] - 2;\n        skipUp[i] = skipUp[i-1] + 2;\n    }\n    \n    skipDown[numRows-1] = skipDown[0];\n    skipUp[0] = skipUp[numRows-1];\n    \n    string res(s.size(), ' ');\n    \n    int index = 0;\n    for(int i = 0;i < numRows; i++) {\n        bool flag = true;\n        for(int j = i;j < s.size();index++) {\n            res[index] = s[j];\n\n            if (flag) { j += skipDown[i]; }\n            else { j += skipUp[i]; }\n            \n            flag = !flag;\n        }\n    }\n    return res;\n}\n```\n\n当然这肯定不是最优的代码，比如其实我们可以不用两个数组，甚至不用数组来保存的`offset`，但是这样写会比较容易理解，代码会比较简单点。\n","source":"_posts/ZigZag-Conversion.md","raw":"---\ntitle: ZigZag Conversion\ndate: 2019-02-15T17:42:54.000Z\ntags:\n  - LeetCode\ncategories:\n  - LeetCode\n---\n\n> 第二天。今天AC掉了一道之前没AC掉的题目。。。\n\n今天的题目是[6. ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/)\n\n题目描述：\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\n```cpp\nstring convert(string s, int numRows);\n```\n\nExample 1:\n\n```\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n```\n\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\n\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```\n\n恩，又是一道“编程题“， 并不涉及到什么算法，静下心来仔细想想还是能做出来的。做这道题的思路就是**一点一点跑例子**，找出其中的规律就好了。\n\n我们先以输入为`s = \"PAYPALISHIRING\", numRows = 3`为例子，这是题目给出的例子，正确答案已经有了。\n\n先把Z字型画出来（不难发现，题目在最开始其实已经给出了答案）：\n\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\n观察上面的例子我们可以发现：\n\n- 第一行中的元素在原来的字符串中下标相差4个。\n- 第二行中的元素在原来字符串中下标相差2个。\n\nok，看起来好像找到了一些规律，继续跑一个例子验证一下，这次的输入是`s = \"PAYPALISHIRING\", numRows = 3`，把Z字型画出来：\n\n```\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```\n\n可以看到第一行的元素在原来字符串中的下标相差6个，但是第二行却出现了一些不一样的情况：\n\n- `A`与`L`相差4个，`L`与`S`却相差2个\n- `S`与`I`相差4个，`I`与`G`却相差2个\n\n看起来`offset`是有规律的，而且好像需要分成两种情况，继续看看第3行：\n\n- `Y`与`A`相差2个，`A`与`H`相差4个\n- `H`与`R`相差4个，如果还有元素的话，下一个元素与`R`之间显然相差2个。\n\n从上面的例子来看显然是要分成两种情况的，某一行中下标之间的`offset`是不断在两个数字间不断变换的。\n\n我们尝试用两个数组来保存这些`offset`，我们把这两个数组定义为`skipDown`和`skipUp`。其中`skipDown`表示下标在z字型中经过了一个向下的剪头，如第二个例子中，第一行的`P`移动到`I`时，`P`经过了`AYPAl`组成的向下的剪头。`skipUp`同理可推。\n\n如果我们继续跑例子的话，应该是比较容易找出规律的：\n\n- 第`i`行的`skipDown`为`2*(i-1)`，而第一行和最后一行的`skipDown`都应该为`2*(numRows)`。\n- `skipDown`与`skipUp`是逆序的关系。\n\n综上，我们可以写出下面的代码：\n\n```cpp\nstring convert(string s, int numRows) {\n    if (numRows < 2) return s;\n    vector<int> skipDown(numRows);\n    vector<int> skipUp(numRows);\n    \n    skipDown[0] = 2*(numRows-1);\n    skipUp[0] = 0;\n    for(int i = 1;i < numRows; i++) {\n        skipDown[i] = skipDown[i-1] - 2;\n        skipUp[i] = skipUp[i-1] + 2;\n    }\n    \n    skipDown[numRows-1] = skipDown[0];\n    skipUp[0] = skipUp[numRows-1];\n    \n    string res(s.size(), ' ');\n    \n    int index = 0;\n    for(int i = 0;i < numRows; i++) {\n        bool flag = true;\n        for(int j = i;j < s.size();index++) {\n            res[index] = s[j];\n\n            if (flag) { j += skipDown[i]; }\n            else { j += skipUp[i]; }\n            \n            flag = !flag;\n        }\n    }\n    return res;\n}\n```\n\n当然这肯定不是最优的代码，比如其实我们可以不用两个数组，甚至不用数组来保存的`offset`，但是这样写会比较容易理解，代码会比较简单点。\n","slug":"ZigZag-Conversion","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qb00g2qmcm12tqa6ax","content":"<blockquote>\n<p>第二天。今天AC掉了一道之前没AC掉的题目。。。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/zigzag-conversion/\">6. ZigZag Conversion</a></p>\n<p>题目描述：</p>\n<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure>\n\n<p>And then read line by line: “PAHNAPLSIIGYIR”</p>\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>Example 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class=\"line\">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class=\"line\">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\"></span><br><span class=\"line\">P     I    N</span><br><span class=\"line\">A   L S  I G</span><br><span class=\"line\">Y A   H R</span><br><span class=\"line\">P     I</span><br></pre></td></tr></table></figure>\n\n<p>恩，又是一道“编程题“， 并不涉及到什么算法，静下心来仔细想想还是能做出来的。做这道题的思路就是<strong>一点一点跑例子</strong>，找出其中的规律就好了。</p>\n<p>我们先以输入为<code>s = &quot;PAYPALISHIRING&quot;, numRows = 3</code>为例子，这是题目给出的例子，正确答案已经有了。</p>\n<p>先把Z字型画出来（不难发现，题目在最开始其实已经给出了答案）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure>\n\n<p>观察上面的例子我们可以发现：</p>\n<ul>\n<li>第一行中的元素在原来的字符串中下标相差4个。</li>\n<li>第二行中的元素在原来字符串中下标相差2个。</li>\n</ul>\n<p>ok，看起来好像找到了一些规律，继续跑一个例子验证一下，这次的输入是<code>s = &quot;PAYPALISHIRING&quot;, numRows = 3</code>，把Z字型画出来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P     I    N</span><br><span class=\"line\">A   L S  I G</span><br><span class=\"line\">Y A   H R</span><br><span class=\"line\">P     I</span><br></pre></td></tr></table></figure>\n\n<p>可以看到第一行的元素在原来字符串中的下标相差6个，但是第二行却出现了一些不一样的情况：</p>\n<ul>\n<li><code>A</code>与<code>L</code>相差4个，<code>L</code>与<code>S</code>却相差2个</li>\n<li><code>S</code>与<code>I</code>相差4个，<code>I</code>与<code>G</code>却相差2个</li>\n</ul>\n<p>看起来<code>offset</code>是有规律的，而且好像需要分成两种情况，继续看看第3行：</p>\n<ul>\n<li><code>Y</code>与<code>A</code>相差2个，<code>A</code>与<code>H</code>相差4个</li>\n<li><code>H</code>与<code>R</code>相差4个，如果还有元素的话，下一个元素与<code>R</code>之间显然相差2个。</li>\n</ul>\n<p>从上面的例子来看显然是要分成两种情况的，某一行中下标之间的<code>offset</code>是不断在两个数字间不断变换的。</p>\n<p>我们尝试用两个数组来保存这些<code>offset</code>，我们把这两个数组定义为<code>skipDown</code>和<code>skipUp</code>。其中<code>skipDown</code>表示下标在z字型中经过了一个向下的剪头，如第二个例子中，第一行的<code>P</code>移动到<code>I</code>时，<code>P</code>经过了<code>AYPAl</code>组成的向下的剪头。<code>skipUp</code>同理可推。</p>\n<p>如果我们继续跑例子的话，应该是比较容易找出规律的：</p>\n<ul>\n<li>第<code>i</code>行的<code>skipDown</code>为<code>2*(i-1)</code>，而第一行和最后一行的<code>skipDown</code>都应该为<code>2*(numRows)</code>。</li>\n<li><code>skipDown</code>与<code>skipUp</code>是逆序的关系。</li>\n</ul>\n<p>综上，我们可以写出下面的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numRows &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">skipDown</span><span class=\"params\">(numRows)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">skipUp</span><span class=\"params\">(numRows)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    skipDown[<span class=\"number\">0</span>] = <span class=\"number\">2</span>*(numRows<span class=\"number\">-1</span>);</span><br><span class=\"line\">    skipUp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; numRows; i++) &#123;</span><br><span class=\"line\">        skipDown[i] = skipDown[i<span class=\"number\">-1</span>] - <span class=\"number\">2</span>;</span><br><span class=\"line\">        skipUp[i] = skipUp[i<span class=\"number\">-1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    skipDown[numRows<span class=\"number\">-1</span>] = skipDown[<span class=\"number\">0</span>];</span><br><span class=\"line\">    skipUp[<span class=\"number\">0</span>] = skipUp[numRows<span class=\"number\">-1</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">res</span><span class=\"params\">(s.size(), <span class=\"string\">&#x27; &#x27;</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; numRows; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i;j &lt; s.size();index++) &#123;</span><br><span class=\"line\">            res[index] = s[j];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) &#123; j += skipDown[i]; &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; j += skipUp[i]; &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            flag = !flag;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这肯定不是最优的代码，比如其实我们可以不用两个数组，甚至不用数组来保存的<code>offset</code>，但是这样写会比较容易理解，代码会比较简单点。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第二天。今天AC掉了一道之前没AC掉的题目。。。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/zigzag-conversion/\">6. ZigZag Conversion</a></p>\n<p>题目描述：</p>\n<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure>\n\n<p>And then read line by line: “PAHNAPLSIIGYIR”</p>\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>Example 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class=\"line\">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class=\"line\">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\"></span><br><span class=\"line\">P     I    N</span><br><span class=\"line\">A   L S  I G</span><br><span class=\"line\">Y A   H R</span><br><span class=\"line\">P     I</span><br></pre></td></tr></table></figure>\n\n<p>恩，又是一道“编程题“， 并不涉及到什么算法，静下心来仔细想想还是能做出来的。做这道题的思路就是<strong>一点一点跑例子</strong>，找出其中的规律就好了。</p>\n<p>我们先以输入为<code>s = &quot;PAYPALISHIRING&quot;, numRows = 3</code>为例子，这是题目给出的例子，正确答案已经有了。</p>\n<p>先把Z字型画出来（不难发现，题目在最开始其实已经给出了答案）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br></pre></td></tr></table></figure>\n\n<p>观察上面的例子我们可以发现：</p>\n<ul>\n<li>第一行中的元素在原来的字符串中下标相差4个。</li>\n<li>第二行中的元素在原来字符串中下标相差2个。</li>\n</ul>\n<p>ok，看起来好像找到了一些规律，继续跑一个例子验证一下，这次的输入是<code>s = &quot;PAYPALISHIRING&quot;, numRows = 3</code>，把Z字型画出来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P     I    N</span><br><span class=\"line\">A   L S  I G</span><br><span class=\"line\">Y A   H R</span><br><span class=\"line\">P     I</span><br></pre></td></tr></table></figure>\n\n<p>可以看到第一行的元素在原来字符串中的下标相差6个，但是第二行却出现了一些不一样的情况：</p>\n<ul>\n<li><code>A</code>与<code>L</code>相差4个，<code>L</code>与<code>S</code>却相差2个</li>\n<li><code>S</code>与<code>I</code>相差4个，<code>I</code>与<code>G</code>却相差2个</li>\n</ul>\n<p>看起来<code>offset</code>是有规律的，而且好像需要分成两种情况，继续看看第3行：</p>\n<ul>\n<li><code>Y</code>与<code>A</code>相差2个，<code>A</code>与<code>H</code>相差4个</li>\n<li><code>H</code>与<code>R</code>相差4个，如果还有元素的话，下一个元素与<code>R</code>之间显然相差2个。</li>\n</ul>\n<p>从上面的例子来看显然是要分成两种情况的，某一行中下标之间的<code>offset</code>是不断在两个数字间不断变换的。</p>\n<p>我们尝试用两个数组来保存这些<code>offset</code>，我们把这两个数组定义为<code>skipDown</code>和<code>skipUp</code>。其中<code>skipDown</code>表示下标在z字型中经过了一个向下的剪头，如第二个例子中，第一行的<code>P</code>移动到<code>I</code>时，<code>P</code>经过了<code>AYPAl</code>组成的向下的剪头。<code>skipUp</code>同理可推。</p>\n<p>如果我们继续跑例子的话，应该是比较容易找出规律的：</p>\n<ul>\n<li>第<code>i</code>行的<code>skipDown</code>为<code>2*(i-1)</code>，而第一行和最后一行的<code>skipDown</code>都应该为<code>2*(numRows)</code>。</li>\n<li><code>skipDown</code>与<code>skipUp</code>是逆序的关系。</li>\n</ul>\n<p>综上，我们可以写出下面的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numRows &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">skipDown</span><span class=\"params\">(numRows)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">skipUp</span><span class=\"params\">(numRows)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    skipDown[<span class=\"number\">0</span>] = <span class=\"number\">2</span>*(numRows<span class=\"number\">-1</span>);</span><br><span class=\"line\">    skipUp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; numRows; i++) &#123;</span><br><span class=\"line\">        skipDown[i] = skipDown[i<span class=\"number\">-1</span>] - <span class=\"number\">2</span>;</span><br><span class=\"line\">        skipUp[i] = skipUp[i<span class=\"number\">-1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    skipDown[numRows<span class=\"number\">-1</span>] = skipDown[<span class=\"number\">0</span>];</span><br><span class=\"line\">    skipUp[<span class=\"number\">0</span>] = skipUp[numRows<span class=\"number\">-1</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">res</span><span class=\"params\">(s.size(), <span class=\"string\">&#x27; &#x27;</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; numRows; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i;j &lt; s.size();index++) &#123;</span><br><span class=\"line\">            res[index] = s[j];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) &#123; j += skipDown[i]; &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; j += skipUp[i]; &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            flag = !flag;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这肯定不是最优的代码，比如其实我们可以不用两个数组，甚至不用数组来保存的<code>offset</code>，但是这样写会比较容易理解，代码会比较简单点。</p>\n"},{"date":"2020-10-11T03:55:46.898Z","title":"1227. Airplane Seat Assignment Probability","_content":"\n今天的题目是[1227. Airplane Seat Assignment Probability](https://leetcode-cn.com/problems/airplane-seat-assignment-probability)。\n\n比较简单的题目，我的思路大概是这样的。\n\n先假设`f(n)`为有 n 个人时，第 n 个人坐到自己位置的概率。\n\n首先，第 1 个人随机选位置的时候，可能有三种情况：\n\n1. 选到了自己的位置，那么后面就不会有人发现自己座位被做了，此时第 n 个人一定会坐到自己的位置。\n2. 选到了第 n 个人的位置，这时第 n 个人就会坐到第 1 个人的位置上。\n3. 选到了第 k 个人位置，这时，第 k 个人前面的（除了第一个人）都坐到了自己的位置，直到第 k 个人时，问题转化求解`f(n-k+1)`。\n\n因此，我们可以列出下面的递推公式：\n\n$$\nf(n) = \\left\\{\n\t\\begin{aligned}\n\t\t1.0 &, & n == 1 \\\\\n\t\t\\frac 1 n (1.0 + 0 + \\sum_{k=2}^{n-1}f(n-k+1)) &, & n!=1\n\t\\end{aligned}\n\\right.\n$$\n\n对第二个公式进一步化简得到：\n\n$$\n\\begin{aligned}\nf(n) = & \\frac 1 n (1.0 + 0 + \\sum_{k=2}^{n-1}f(n-k+1)) \\\\\n     = & \\frac 1 n (f(1) + \\sum_{k=2}^{n-1}f(k)) \\\\\n     = & \\frac{1}{n} \\sum_{k=1}^{n-1}f(k)\n\\end{aligned}\n$$\n\n因此递推公式可以写成：\n\n$$\nf(n) = \\left\\{\n\t\\begin{aligned}\n\t\t1.0 &, & n == 1 \\\\\n\t\t\\frac{1}{n} \\sum_{k=1}^{n-1}f(k) &, & n!=1\n\t\\end{aligned}\n\\right.\n$$\n\n根据递推公式可以写出如下代码：\n\n```c++\ndouble nthPersonGetsNthSeat(int n) {\n\tdouble sum = 1.0;\n\tfor(int k = 2;k <= n;k++) {\n\t\tres = sum / k;\n\t\tsum += res;\n\t}\n\treturn res;\n}\n```\n\n我们将一些值代入到公式中可以发现这样一个事情：\n\n$$\n\\begin{aligned}\n\tf(2) & = \\frac{1}{2} f(1) \\\\\n\tf(3) & = \\frac{1}{3} (f(1) + f(2)) = \\frac{1}{2} f(1) \\\\\n\t... & \\\\\n\tf(n) & = \\frac{1}{n} (f(1) + f(2) + ... + f(n-1) ) \\\\\n\t\t& = \\frac{1}{n} (f(1) + \\frac{1}{2}f(1) + ... + \\frac{1}{2}f(1)) \\\\\n\t\t& = \\frac{1}{n} (f(1) + \\frac{n-2}{2}f(1)) \\\\\n\t\t& = \\frac{1}{2} f(1) \n\\end{aligned}\n$$\n\n因此递推公式进一步简化成：\n\n$$\nf(n) = \\left\\{\n\t\\begin{aligned}\n\t\t1.0 &, & n == 1 \\\\\n\t\t\\frac{1}{2} f(1) &, & n!=1\n\t\\end{aligned}\n\\right.\n$$\n\n因此，代码如下：\n\n```c++\ndouble nthPersonGetsNthSeat(int n) {\n\treturn n > 1 ? 0.5 : 1.0;\n}\n```","source":"_posts/airplane-seat-assignment-probability.md","raw":"---\ncategories:\n- LeetCode\ndate: '2020-10-11T11:55:46.898731'\ntags:\n- Brainteaser\n- Math\n- Dynamic Programming\n- LeetCode\ntitle: 1227. Airplane Seat Assignment Probability\n---\n\n今天的题目是[1227. Airplane Seat Assignment Probability](https://leetcode-cn.com/problems/airplane-seat-assignment-probability)。\n\n比较简单的题目，我的思路大概是这样的。\n\n先假设`f(n)`为有 n 个人时，第 n 个人坐到自己位置的概率。\n\n首先，第 1 个人随机选位置的时候，可能有三种情况：\n\n1. 选到了自己的位置，那么后面就不会有人发现自己座位被做了，此时第 n 个人一定会坐到自己的位置。\n2. 选到了第 n 个人的位置，这时第 n 个人就会坐到第 1 个人的位置上。\n3. 选到了第 k 个人位置，这时，第 k 个人前面的（除了第一个人）都坐到了自己的位置，直到第 k 个人时，问题转化求解`f(n-k+1)`。\n\n因此，我们可以列出下面的递推公式：\n\n$$\nf(n) = \\left\\{\n\t\\begin{aligned}\n\t\t1.0 &, & n == 1 \\\\\n\t\t\\frac 1 n (1.0 + 0 + \\sum_{k=2}^{n-1}f(n-k+1)) &, & n!=1\n\t\\end{aligned}\n\\right.\n$$\n\n对第二个公式进一步化简得到：\n\n$$\n\\begin{aligned}\nf(n) = & \\frac 1 n (1.0 + 0 + \\sum_{k=2}^{n-1}f(n-k+1)) \\\\\n     = & \\frac 1 n (f(1) + \\sum_{k=2}^{n-1}f(k)) \\\\\n     = & \\frac{1}{n} \\sum_{k=1}^{n-1}f(k)\n\\end{aligned}\n$$\n\n因此递推公式可以写成：\n\n$$\nf(n) = \\left\\{\n\t\\begin{aligned}\n\t\t1.0 &, & n == 1 \\\\\n\t\t\\frac{1}{n} \\sum_{k=1}^{n-1}f(k) &, & n!=1\n\t\\end{aligned}\n\\right.\n$$\n\n根据递推公式可以写出如下代码：\n\n```c++\ndouble nthPersonGetsNthSeat(int n) {\n\tdouble sum = 1.0;\n\tfor(int k = 2;k <= n;k++) {\n\t\tres = sum / k;\n\t\tsum += res;\n\t}\n\treturn res;\n}\n```\n\n我们将一些值代入到公式中可以发现这样一个事情：\n\n$$\n\\begin{aligned}\n\tf(2) & = \\frac{1}{2} f(1) \\\\\n\tf(3) & = \\frac{1}{3} (f(1) + f(2)) = \\frac{1}{2} f(1) \\\\\n\t... & \\\\\n\tf(n) & = \\frac{1}{n} (f(1) + f(2) + ... + f(n-1) ) \\\\\n\t\t& = \\frac{1}{n} (f(1) + \\frac{1}{2}f(1) + ... + \\frac{1}{2}f(1)) \\\\\n\t\t& = \\frac{1}{n} (f(1) + \\frac{n-2}{2}f(1)) \\\\\n\t\t& = \\frac{1}{2} f(1) \n\\end{aligned}\n$$\n\n因此递推公式进一步简化成：\n\n$$\nf(n) = \\left\\{\n\t\\begin{aligned}\n\t\t1.0 &, & n == 1 \\\\\n\t\t\\frac{1}{2} f(1) &, & n!=1\n\t\\end{aligned}\n\\right.\n$$\n\n因此，代码如下：\n\n```c++\ndouble nthPersonGetsNthSeat(int n) {\n\treturn n > 1 ? 0.5 : 1.0;\n}\n```","slug":"airplane-seat-assignment-probability","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qc00g5qmcmg5ih70be","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/airplane-seat-assignment-probability\">1227. Airplane Seat Assignment Probability</a>。</p>\n<p>比较简单的题目，我的思路大概是这样的。</p>\n<p>先假设<code>f(n)</code>为有 n 个人时，第 n 个人坐到自己位置的概率。</p>\n<p>首先，第 1 个人随机选位置的时候，可能有三种情况：</p>\n<ol>\n<li>选到了自己的位置，那么后面就不会有人发现自己座位被做了，此时第 n 个人一定会坐到自己的位置。</li>\n<li>选到了第 n 个人的位置，这时第 n 个人就会坐到第 1 个人的位置上。</li>\n<li>选到了第 k 个人位置，这时，第 k 个人前面的（除了第一个人）都坐到了自己的位置，直到第 k 个人时，问题转化求解<code>f(n-k+1)</code>。</li>\n</ol>\n<p>因此，我们可以列出下面的递推公式：</p>\n<p>$$<br>f(n) = \\left{<br>    \\begin{aligned}<br>        1.0 &amp;, &amp; n == 1 \\<br>        \\frac 1 n (1.0 + 0 + \\sum_{k=2}^{n-1}f(n-k+1)) &amp;, &amp; n!=1<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>对第二个公式进一步化简得到：</p>\n<p>$$<br>\\begin{aligned}<br>f(n) = &amp; \\frac 1 n (1.0 + 0 + \\sum_{k=2}^{n-1}f(n-k+1)) \\<br>     = &amp; \\frac 1 n (f(1) + \\sum_{k=2}^{n-1}f(k)) \\<br>     = &amp; \\frac{1}{n} \\sum_{k=1}^{n-1}f(k)<br>\\end{aligned}<br>$$</p>\n<p>因此递推公式可以写成：</p>\n<p>$$<br>f(n) = \\left{<br>    \\begin{aligned}<br>        1.0 &amp;, &amp; n == 1 \\<br>        \\frac{1}{n} \\sum_{k=1}^{n-1}f(k) &amp;, &amp; n!=1<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>根据递推公式可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">nthPersonGetsNthSeat</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> sum = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">2</span>;k &lt;= n;k++) &#123;</span><br><span class=\"line\">\t\tres = sum / k;</span><br><span class=\"line\">\t\tsum += res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们将一些值代入到公式中可以发现这样一个事情：</p>\n<p>$$<br>\\begin{aligned}<br>    f(2) &amp; = \\frac{1}{2} f(1) \\<br>    f(3) &amp; = \\frac{1}{3} (f(1) + f(2)) = \\frac{1}{2} f(1) \\<br>    … &amp; \\<br>    f(n) &amp; = \\frac{1}{n} (f(1) + f(2) + … + f(n-1) ) \\<br>        &amp; = \\frac{1}{n} (f(1) + \\frac{1}{2}f(1) + … + \\frac{1}{2}f(1)) \\<br>        &amp; = \\frac{1}{n} (f(1) + \\frac{n-2}{2}f(1)) \\<br>        &amp; = \\frac{1}{2} f(1)<br>\\end{aligned}<br>$$</p>\n<p>因此递推公式进一步简化成：</p>\n<p>$$<br>f(n) = \\left{<br>    \\begin{aligned}<br>        1.0 &amp;, &amp; n == 1 \\<br>        \\frac{1}{2} f(1) &amp;, &amp; n!=1<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>因此，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">nthPersonGetsNthSeat</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n &gt; <span class=\"number\">1</span> ? <span class=\"number\">0.5</span> : <span class=\"number\">1.0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/airplane-seat-assignment-probability\">1227. Airplane Seat Assignment Probability</a>。</p>\n<p>比较简单的题目，我的思路大概是这样的。</p>\n<p>先假设<code>f(n)</code>为有 n 个人时，第 n 个人坐到自己位置的概率。</p>\n<p>首先，第 1 个人随机选位置的时候，可能有三种情况：</p>\n<ol>\n<li>选到了自己的位置，那么后面就不会有人发现自己座位被做了，此时第 n 个人一定会坐到自己的位置。</li>\n<li>选到了第 n 个人的位置，这时第 n 个人就会坐到第 1 个人的位置上。</li>\n<li>选到了第 k 个人位置，这时，第 k 个人前面的（除了第一个人）都坐到了自己的位置，直到第 k 个人时，问题转化求解<code>f(n-k+1)</code>。</li>\n</ol>\n<p>因此，我们可以列出下面的递推公式：</p>\n<p>$$<br>f(n) = \\left{<br>    \\begin{aligned}<br>        1.0 &amp;, &amp; n == 1 \\<br>        \\frac 1 n (1.0 + 0 + \\sum_{k=2}^{n-1}f(n-k+1)) &amp;, &amp; n!=1<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>对第二个公式进一步化简得到：</p>\n<p>$$<br>\\begin{aligned}<br>f(n) = &amp; \\frac 1 n (1.0 + 0 + \\sum_{k=2}^{n-1}f(n-k+1)) \\<br>     = &amp; \\frac 1 n (f(1) + \\sum_{k=2}^{n-1}f(k)) \\<br>     = &amp; \\frac{1}{n} \\sum_{k=1}^{n-1}f(k)<br>\\end{aligned}<br>$$</p>\n<p>因此递推公式可以写成：</p>\n<p>$$<br>f(n) = \\left{<br>    \\begin{aligned}<br>        1.0 &amp;, &amp; n == 1 \\<br>        \\frac{1}{n} \\sum_{k=1}^{n-1}f(k) &amp;, &amp; n!=1<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>根据递推公式可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">nthPersonGetsNthSeat</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> sum = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">2</span>;k &lt;= n;k++) &#123;</span><br><span class=\"line\">\t\tres = sum / k;</span><br><span class=\"line\">\t\tsum += res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们将一些值代入到公式中可以发现这样一个事情：</p>\n<p>$$<br>\\begin{aligned}<br>    f(2) &amp; = \\frac{1}{2} f(1) \\<br>    f(3) &amp; = \\frac{1}{3} (f(1) + f(2)) = \\frac{1}{2} f(1) \\<br>    … &amp; \\<br>    f(n) &amp; = \\frac{1}{n} (f(1) + f(2) + … + f(n-1) ) \\<br>        &amp; = \\frac{1}{n} (f(1) + \\frac{1}{2}f(1) + … + \\frac{1}{2}f(1)) \\<br>        &amp; = \\frac{1}{n} (f(1) + \\frac{n-2}{2}f(1)) \\<br>        &amp; = \\frac{1}{2} f(1)<br>\\end{aligned}<br>$$</p>\n<p>因此递推公式进一步简化成：</p>\n<p>$$<br>f(n) = \\left{<br>    \\begin{aligned}<br>        1.0 &amp;, &amp; n == 1 \\<br>        \\frac{1}{2} f(1) &amp;, &amp; n!=1<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>因此，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">nthPersonGetsNthSeat</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n &gt; <span class=\"number\">1</span> ? <span class=\"number\">0.5</span> : <span class=\"number\">1.0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"date":"2020-10-06T01:56:01.190Z","title":"1344. Angle Between Hands of a Clock","_content":"\n今天的题目是[1344. Angle Between Hands of a Clock](https://leetcode-cn.com/problems/angle-between-hands-of-a-clock)。\n\n思路大概是这样的，因为时针的位置会受到分针位置的影响，比如分针在30时，时针也会向前移动半格，因此解决了这个问题就好办了。由于分钟只能在 0 到 59 之间，所以我们可以把时针的一个格子分成 60 等分，那么12个格子就是 720 等分，然后分针也映射到 720 等分的格子中，就可以简单的通过减法和除法来计算夹角占整个圆的比例了，进而算出夹角的弧度制。\n\n- 时针的位置：`hour * 60 + minutes`\n- 分针的位置：`minutes * 720 / 60` or `minutes * 12`\n\n代码如下：\n\n```c++\ndouble angleClock(int hour, int minutes) {\n\thour = hour % 12;\n\tminutes = minutes % 60;\n\thour = hour * 60 + minutes;\n\tminutes = minutes * 12;\n\treturn min(720 - abs(hour - minutes), abs(hour - minutes)) / 2.0;\n}\n```","source":"_posts/angle-between-hands-of-a-clock.md","raw":"---\ncategories:\n- LeetCode\ndate: '2020-10-06T09:56:01.190170'\ntags:\n- Math\ntitle: 1344. Angle Between Hands of a Clock\n---\n\n今天的题目是[1344. Angle Between Hands of a Clock](https://leetcode-cn.com/problems/angle-between-hands-of-a-clock)。\n\n思路大概是这样的，因为时针的位置会受到分针位置的影响，比如分针在30时，时针也会向前移动半格，因此解决了这个问题就好办了。由于分钟只能在 0 到 59 之间，所以我们可以把时针的一个格子分成 60 等分，那么12个格子就是 720 等分，然后分针也映射到 720 等分的格子中，就可以简单的通过减法和除法来计算夹角占整个圆的比例了，进而算出夹角的弧度制。\n\n- 时针的位置：`hour * 60 + minutes`\n- 分针的位置：`minutes * 720 / 60` or `minutes * 12`\n\n代码如下：\n\n```c++\ndouble angleClock(int hour, int minutes) {\n\thour = hour % 12;\n\tminutes = minutes % 60;\n\thour = hour * 60 + minutes;\n\tminutes = minutes * 12;\n\treturn min(720 - abs(hour - minutes), abs(hour - minutes)) / 2.0;\n}\n```","slug":"angle-between-hands-of-a-clock","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qd00g8qmcmgnw3ag0y","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/angle-between-hands-of-a-clock\">1344. Angle Between Hands of a Clock</a>。</p>\n<p>思路大概是这样的，因为时针的位置会受到分针位置的影响，比如分针在30时，时针也会向前移动半格，因此解决了这个问题就好办了。由于分钟只能在 0 到 59 之间，所以我们可以把时针的一个格子分成 60 等分，那么12个格子就是 720 等分，然后分针也映射到 720 等分的格子中，就可以简单的通过减法和除法来计算夹角占整个圆的比例了，进而算出夹角的弧度制。</p>\n<ul>\n<li>时针的位置：<code>hour * 60 + minutes</code></li>\n<li>分针的位置：<code>minutes * 720 / 60</code> or <code>minutes * 12</code></li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">angleClock</span><span class=\"params\">(<span class=\"keyword\">int</span> hour, <span class=\"keyword\">int</span> minutes)</span> </span>&#123;</span><br><span class=\"line\">\thour = hour % <span class=\"number\">12</span>;</span><br><span class=\"line\">\tminutes = minutes % <span class=\"number\">60</span>;</span><br><span class=\"line\">\thour = hour * <span class=\"number\">60</span> + minutes;</span><br><span class=\"line\">\tminutes = minutes * <span class=\"number\">12</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> min(<span class=\"number\">720</span> - <span class=\"built_in\">abs</span>(hour - minutes), <span class=\"built_in\">abs</span>(hour - minutes)) / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/angle-between-hands-of-a-clock\">1344. Angle Between Hands of a Clock</a>。</p>\n<p>思路大概是这样的，因为时针的位置会受到分针位置的影响，比如分针在30时，时针也会向前移动半格，因此解决了这个问题就好办了。由于分钟只能在 0 到 59 之间，所以我们可以把时针的一个格子分成 60 等分，那么12个格子就是 720 等分，然后分针也映射到 720 等分的格子中，就可以简单的通过减法和除法来计算夹角占整个圆的比例了，进而算出夹角的弧度制。</p>\n<ul>\n<li>时针的位置：<code>hour * 60 + minutes</code></li>\n<li>分针的位置：<code>minutes * 720 / 60</code> or <code>minutes * 12</code></li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">angleClock</span><span class=\"params\">(<span class=\"keyword\">int</span> hour, <span class=\"keyword\">int</span> minutes)</span> </span>&#123;</span><br><span class=\"line\">\thour = hour % <span class=\"number\">12</span>;</span><br><span class=\"line\">\tminutes = minutes % <span class=\"number\">60</span>;</span><br><span class=\"line\">\thour = hour * <span class=\"number\">60</span> + minutes;</span><br><span class=\"line\">\tminutes = minutes * <span class=\"number\">12</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> min(<span class=\"number\">720</span> - <span class=\"built_in\">abs</span>(hour - minutes), <span class=\"built_in\">abs</span>(hour - minutes)) / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"date":"2020-10-08T07:23:34.599Z","title":"889. Construct Binary Tree from Preorder and Postorder Traversal","_content":"\n今天的题目是[889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal)。\n\n和前/后序+中序构造二叉树的方法差不多，毕竟这里只要求输出一个符合的解即可。\n\n首先，我们知道先序遍历和后序遍历得到的输出基本结构如下：\n\n- 先序：根节点，左子树先序，右子树先序\n- 后序：左子树后序，右子树后序，根节点。\n\n从上面我们可以知道以下两点：\n\n- 一棵树先序的第一个元素和后序的最后一个元素相等。\n- 左子树/右子树的先序与后序由相同的元素组成。\n\n进而我们可以得出以下推论：**先序的第二个元素（如果有的话）是其左子树根节点，即应该等于左子树后序的最后一个元素**，我们可以用这个推论来分割左右子树。\n知道如何分割左右子树了，那么只需要和前/后序+中序构造二叉树一样递归建树即可。\n\n代码如下：\n\n```c++\nTreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\n\treturn constructFromPrePost(pre, post, 0, pre.size() -1, 0 ,post.size() - 1);\n}\nTreeNode* constructFromPrePost(vector<int> &pre, vector<int> &post, \n\tint preFirst, int preLast, int postFirst, int postLast) {\n\n\tif (preFirst > preLast || postFirst > postLast) return nullptr;\n\t\n\tTreeNode *root = new TreeNode(pre[preFirst]);\n\tpreFirst++; postLast--;\n\tif (preFirst > preLast || postFirst > postLast) return root;\n\n\tint leftPostLast = postFirst;\n\twhile (leftPostLast <= postLast && post[leftPostLast] != pre[preFirst])\n\t{\n\t\tleftPostLast++;\n\t}\n\tint leftPreLast = leftPostLast - postFirst + preFirst;\n\n\troot->left = constructFromPrePost(pre, post, preFirst, leftPreLast, postFirst, leftPostLast);\n\troot->right = constructFromPrePost(pre, post, leftPreLast + 1, preLast, leftPostLast + 1, postLast);\n\treturn root;\n}\n```\n\n","source":"_posts/construct-binary-tree-from-preorder-and-postorder-traversal.md","raw":"---\ncategories:\n- LeetCode\ndate: '2020-10-08T15:23:34.599502'\ntags:\n- Tree\n- LeetCode\ntitle: 889. Construct Binary Tree from Preorder and Postorder Traversal\n---\n\n今天的题目是[889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal)。\n\n和前/后序+中序构造二叉树的方法差不多，毕竟这里只要求输出一个符合的解即可。\n\n首先，我们知道先序遍历和后序遍历得到的输出基本结构如下：\n\n- 先序：根节点，左子树先序，右子树先序\n- 后序：左子树后序，右子树后序，根节点。\n\n从上面我们可以知道以下两点：\n\n- 一棵树先序的第一个元素和后序的最后一个元素相等。\n- 左子树/右子树的先序与后序由相同的元素组成。\n\n进而我们可以得出以下推论：**先序的第二个元素（如果有的话）是其左子树根节点，即应该等于左子树后序的最后一个元素**，我们可以用这个推论来分割左右子树。\n知道如何分割左右子树了，那么只需要和前/后序+中序构造二叉树一样递归建树即可。\n\n代码如下：\n\n```c++\nTreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\n\treturn constructFromPrePost(pre, post, 0, pre.size() -1, 0 ,post.size() - 1);\n}\nTreeNode* constructFromPrePost(vector<int> &pre, vector<int> &post, \n\tint preFirst, int preLast, int postFirst, int postLast) {\n\n\tif (preFirst > preLast || postFirst > postLast) return nullptr;\n\t\n\tTreeNode *root = new TreeNode(pre[preFirst]);\n\tpreFirst++; postLast--;\n\tif (preFirst > preLast || postFirst > postLast) return root;\n\n\tint leftPostLast = postFirst;\n\twhile (leftPostLast <= postLast && post[leftPostLast] != pre[preFirst])\n\t{\n\t\tleftPostLast++;\n\t}\n\tint leftPreLast = leftPostLast - postFirst + preFirst;\n\n\troot->left = constructFromPrePost(pre, post, preFirst, leftPreLast, postFirst, leftPostLast);\n\troot->right = constructFromPrePost(pre, post, leftPreLast + 1, preLast, leftPostLast + 1, postLast);\n\treturn root;\n}\n```\n\n","slug":"construct-binary-tree-from-preorder-and-postorder-traversal","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qe00gcqmcm0lsq1ttm","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal\">889. Construct Binary Tree from Preorder and Postorder Traversal</a>。</p>\n<p>和前/后序+中序构造二叉树的方法差不多，毕竟这里只要求输出一个符合的解即可。</p>\n<p>首先，我们知道先序遍历和后序遍历得到的输出基本结构如下：</p>\n<ul>\n<li>先序：根节点，左子树先序，右子树先序</li>\n<li>后序：左子树后序，右子树后序，根节点。</li>\n</ul>\n<p>从上面我们可以知道以下两点：</p>\n<ul>\n<li>一棵树先序的第一个元素和后序的最后一个元素相等。</li>\n<li>左子树/右子树的先序与后序由相同的元素组成。</li>\n</ul>\n<p>进而我们可以得出以下推论：<strong>先序的第二个元素（如果有的话）是其左子树根节点，即应该等于左子树后序的最后一个元素</strong>，我们可以用这个推论来分割左右子树。<br>知道如何分割左右子树了，那么只需要和前/后序+中序构造二叉树一样递归建树即可。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">constructFromPrePost</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; pre, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> constructFromPrePost(pre, post, <span class=\"number\">0</span>, pre.size() <span class=\"number\">-1</span>, <span class=\"number\">0</span> ,post.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">constructFromPrePost</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;pre, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;post, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t<span class=\"keyword\">int</span> preFirst, <span class=\"keyword\">int</span> preLast, <span class=\"keyword\">int</span> postFirst, <span class=\"keyword\">int</span> postLast)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (preFirst &gt; preLast || postFirst &gt; postLast) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tTreeNode *root = <span class=\"keyword\">new</span> TreeNode(pre[preFirst]);</span><br><span class=\"line\">\tpreFirst++; postLast--;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (preFirst &gt; preLast || postFirst &gt; postLast) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftPostLast = postFirst;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (leftPostLast &lt;= postLast &amp;&amp; post[leftPostLast] != pre[preFirst])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tleftPostLast++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftPreLast = leftPostLast - postFirst + preFirst;</span><br><span class=\"line\"></span><br><span class=\"line\">\troot-&gt;left = constructFromPrePost(pre, post, preFirst, leftPreLast, postFirst, leftPostLast);</span><br><span class=\"line\">\troot-&gt;right = constructFromPrePost(pre, post, leftPreLast + <span class=\"number\">1</span>, preLast, leftPostLast + <span class=\"number\">1</span>, postLast);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal\">889. Construct Binary Tree from Preorder and Postorder Traversal</a>。</p>\n<p>和前/后序+中序构造二叉树的方法差不多，毕竟这里只要求输出一个符合的解即可。</p>\n<p>首先，我们知道先序遍历和后序遍历得到的输出基本结构如下：</p>\n<ul>\n<li>先序：根节点，左子树先序，右子树先序</li>\n<li>后序：左子树后序，右子树后序，根节点。</li>\n</ul>\n<p>从上面我们可以知道以下两点：</p>\n<ul>\n<li>一棵树先序的第一个元素和后序的最后一个元素相等。</li>\n<li>左子树/右子树的先序与后序由相同的元素组成。</li>\n</ul>\n<p>进而我们可以得出以下推论：<strong>先序的第二个元素（如果有的话）是其左子树根节点，即应该等于左子树后序的最后一个元素</strong>，我们可以用这个推论来分割左右子树。<br>知道如何分割左右子树了，那么只需要和前/后序+中序构造二叉树一样递归建树即可。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">constructFromPrePost</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; pre, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> constructFromPrePost(pre, post, <span class=\"number\">0</span>, pre.size() <span class=\"number\">-1</span>, <span class=\"number\">0</span> ,post.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">constructFromPrePost</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;pre, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;post, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t<span class=\"keyword\">int</span> preFirst, <span class=\"keyword\">int</span> preLast, <span class=\"keyword\">int</span> postFirst, <span class=\"keyword\">int</span> postLast)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (preFirst &gt; preLast || postFirst &gt; postLast) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tTreeNode *root = <span class=\"keyword\">new</span> TreeNode(pre[preFirst]);</span><br><span class=\"line\">\tpreFirst++; postLast--;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (preFirst &gt; preLast || postFirst &gt; postLast) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftPostLast = postFirst;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (leftPostLast &lt;= postLast &amp;&amp; post[leftPostLast] != pre[preFirst])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tleftPostLast++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftPreLast = leftPostLast - postFirst + preFirst;</span><br><span class=\"line\"></span><br><span class=\"line\">\troot-&gt;left = constructFromPrePost(pre, post, preFirst, leftPreLast, postFirst, leftPostLast);</span><br><span class=\"line\">\troot-&gt;right = constructFromPrePost(pre, post, leftPreLast + <span class=\"number\">1</span>, preLast, leftPostLast + <span class=\"number\">1</span>, postLast);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Different Ways to Add Parentheses","date":"2017-09-20T04:00:00.000Z","_content":"\n#  Different Ways to Add Parentheses \n\n> 开始每天坚持刷OJ和Paper吧。\n\n今天的题目是[ Different Ways to Add Parentheses ]( https://leetcode.com/problems/different-ways-to-add-parentheses/):\n\nGiven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are `+`, `-` and `*`.\n\n**Example 1:**\n\n```\nInput: \"2-1-1\"\nOutput: [0, 2]\nExplanation: \n((2-1)-1) = 0 \n(2-(1-1)) = 2\n```\n\n**Example 2:**\n\n```\nInput: \"2*3-4*5\"\nOutput: [-34, -14, -10, -10, 10]\nExplanation: \n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n```\n\n太久没刷过题的后果就是之前掌握的一些解题思路好像有点生疏了，但还是勉强完成了这道题，首先从两个Example开始分析，第一个太简单好像看不出什么，我们分析一下第二个，我们可以看到，`(2*(3-(4*5))) = -34`是先算第二个`*`，然后再算`-`，最后算第一个`*`。大概可以猜出来我们需要穷举所有运算顺序，但应该不是全排列，因为当运算符个数为3时，他的运算顺序只有5个，而不是6个。仔细分析一下可以发现，这是因为已下两种算法是一样的：\n\n1. 先算第一个，再算第三个，最后算第二个\n2. 先算第三个，再算第一个，最后算第二个\n\n这就有点像一个二叉树了，层数相同的情况。我们尝试把上面五种运行顺序用二叉树表示出来，首先，分别用`1`,`2`,`3`代替`*`,`-`,`*`:\n\n```\n1\n \\\n  2\n    \\\n     3\n```\n\n\n```\n    2\n  /   \\\n 1     3\n```\n\n```\n  1\n   \\\n    3\n   /\n  2\n```\n\n```\n   1\n  /\n 3\n  \\\n   2\n```\n\n```\n     3\n    /     \n   2\n  /\n 1\n```\n\n画出来后，我们很容易的发现，这个问题变成了对平衡二叉树的穷举问题，因此代码如下：\n\n```c++\nvector<int> nums;\nvector<char> ops;\nvector<int> diffWaysToCompute(string input) {\n    vector<int> res;\n\n    int num; char op;\n    stringstream ss(input);\n\n    ss >> num;\n    nums.push_back(num);\n    while(ss >> op >> num) {\n        nums.push_back(num);\n        ops.push_back(op);\n    }\n\n    helper(0, ops.size(), res);\n    return res;\n}\n\nint calc(char op, int i1, int i2) {\n    int res = 0;\n    switch(op) {\n        case '+': res = i1 + i2; break;\n        case '-': res = i1 - i2; break;\n        case '*': res = i1 * i2; break;\n    }\n    return res;\n}\n\nvoid helper(int first, int last, vector<int> &outputs) {\n    if (first == last) {\n        outputs.push_back(nums[first]);\n        return ;\n    }\n\n    vector<int> lefts;\n    vector<int> rights;\n\n    for(int i = first; i < last;i++) {\n        // select ops[i] in this layer\n        lefts.clear();\n        rights.clear();\n\n        helper(first, i, lefts);\n        helper(i+1, last, rights);\n\n        for(auto l: lefts) {\n            for(auto r: rights) {\n                outputs.push_back(calc(ops[i], l, r));\n            }\n        }\n    }\n\n}\n```\n\n由于`stringstream`的效率的确不行，所以我们可以尝试将解析字符串的那段代码改成：\n\n```c++\nint beg = 0, end = 0;\nfor(;end < input.size(); end++) {\n    if (input[end] == '+' || input[end] == '-' || input[end] == '*') {\n        nums.push_back(stoi(input.substr(beg, end - beg)));\n        ops.push_back(input[end]);\n        beg = end + 1;\n    }\n}\nnums.push_back(stoi(input.substr(beg, end - beg)));\n```\n\n","source":"_posts/different-ways-to-add-parentheses.md","raw":"---\ntitle: Different Ways to Add Parentheses\ndate: 2017-09-20T12:00:00.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n---\n\n#  Different Ways to Add Parentheses \n\n> 开始每天坚持刷OJ和Paper吧。\n\n今天的题目是[ Different Ways to Add Parentheses ]( https://leetcode.com/problems/different-ways-to-add-parentheses/):\n\nGiven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are `+`, `-` and `*`.\n\n**Example 1:**\n\n```\nInput: \"2-1-1\"\nOutput: [0, 2]\nExplanation: \n((2-1)-1) = 0 \n(2-(1-1)) = 2\n```\n\n**Example 2:**\n\n```\nInput: \"2*3-4*5\"\nOutput: [-34, -14, -10, -10, 10]\nExplanation: \n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n```\n\n太久没刷过题的后果就是之前掌握的一些解题思路好像有点生疏了，但还是勉强完成了这道题，首先从两个Example开始分析，第一个太简单好像看不出什么，我们分析一下第二个，我们可以看到，`(2*(3-(4*5))) = -34`是先算第二个`*`，然后再算`-`，最后算第一个`*`。大概可以猜出来我们需要穷举所有运算顺序，但应该不是全排列，因为当运算符个数为3时，他的运算顺序只有5个，而不是6个。仔细分析一下可以发现，这是因为已下两种算法是一样的：\n\n1. 先算第一个，再算第三个，最后算第二个\n2. 先算第三个，再算第一个，最后算第二个\n\n这就有点像一个二叉树了，层数相同的情况。我们尝试把上面五种运行顺序用二叉树表示出来，首先，分别用`1`,`2`,`3`代替`*`,`-`,`*`:\n\n```\n1\n \\\n  2\n    \\\n     3\n```\n\n\n```\n    2\n  /   \\\n 1     3\n```\n\n```\n  1\n   \\\n    3\n   /\n  2\n```\n\n```\n   1\n  /\n 3\n  \\\n   2\n```\n\n```\n     3\n    /     \n   2\n  /\n 1\n```\n\n画出来后，我们很容易的发现，这个问题变成了对平衡二叉树的穷举问题，因此代码如下：\n\n```c++\nvector<int> nums;\nvector<char> ops;\nvector<int> diffWaysToCompute(string input) {\n    vector<int> res;\n\n    int num; char op;\n    stringstream ss(input);\n\n    ss >> num;\n    nums.push_back(num);\n    while(ss >> op >> num) {\n        nums.push_back(num);\n        ops.push_back(op);\n    }\n\n    helper(0, ops.size(), res);\n    return res;\n}\n\nint calc(char op, int i1, int i2) {\n    int res = 0;\n    switch(op) {\n        case '+': res = i1 + i2; break;\n        case '-': res = i1 - i2; break;\n        case '*': res = i1 * i2; break;\n    }\n    return res;\n}\n\nvoid helper(int first, int last, vector<int> &outputs) {\n    if (first == last) {\n        outputs.push_back(nums[first]);\n        return ;\n    }\n\n    vector<int> lefts;\n    vector<int> rights;\n\n    for(int i = first; i < last;i++) {\n        // select ops[i] in this layer\n        lefts.clear();\n        rights.clear();\n\n        helper(first, i, lefts);\n        helper(i+1, last, rights);\n\n        for(auto l: lefts) {\n            for(auto r: rights) {\n                outputs.push_back(calc(ops[i], l, r));\n            }\n        }\n    }\n\n}\n```\n\n由于`stringstream`的效率的确不行，所以我们可以尝试将解析字符串的那段代码改成：\n\n```c++\nint beg = 0, end = 0;\nfor(;end < input.size(); end++) {\n    if (input[end] == '+' || input[end] == '-' || input[end] == '*') {\n        nums.push_back(stoi(input.substr(beg, end - beg)));\n        ops.push_back(input[end]);\n        beg = end + 1;\n    }\n}\nnums.push_back(stoi(input.substr(beg, end - beg)));\n```\n\n","slug":"different-ways-to-add-parentheses","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qe00gfqmcm278ca7ou","content":"<h1 id=\"Different-Ways-to-Add-Parentheses\"><a href=\"#Different-Ways-to-Add-Parentheses\" class=\"headerlink\" title=\"Different Ways to Add Parentheses\"></a>Different Ways to Add Parentheses</h1><blockquote>\n<p>开始每天坚持刷OJ和Paper吧。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/different-ways-to-add-parentheses/\"> Different Ways to Add Parentheses </a>:</p>\n<p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;2-1-1&quot;</span><br><span class=\"line\">Output: [0, 2]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">((2-1)-1) &#x3D; 0 </span><br><span class=\"line\">(2-(1-1)) &#x3D; 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;2*3-4*5&quot;</span><br><span class=\"line\">Output: [-34, -14, -10, -10, 10]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">(2*(3-(4*5))) &#x3D; -34 </span><br><span class=\"line\">((2*3)-(4*5)) &#x3D; -14 </span><br><span class=\"line\">((2*(3-4))*5) &#x3D; -10 </span><br><span class=\"line\">(2*((3-4)*5)) &#x3D; -10 </span><br><span class=\"line\">(((2*3)-4)*5) &#x3D; 10</span><br></pre></td></tr></table></figure>\n\n<p>太久没刷过题的后果就是之前掌握的一些解题思路好像有点生疏了，但还是勉强完成了这道题，首先从两个Example开始分析，第一个太简单好像看不出什么，我们分析一下第二个，我们可以看到，<code>(2*(3-(4*5))) = -34</code>是先算第二个<code>*</code>，然后再算<code>-</code>，最后算第一个<code>*</code>。大概可以猜出来我们需要穷举所有运算顺序，但应该不是全排列，因为当运算符个数为3时，他的运算顺序只有5个，而不是6个。仔细分析一下可以发现，这是因为已下两种算法是一样的：</p>\n<ol>\n<li>先算第一个，再算第三个，最后算第二个</li>\n<li>先算第三个，再算第一个，最后算第二个</li>\n</ol>\n<p>这就有点像一个二叉树了，层数相同的情况。我们尝试把上面五种运行顺序用二叉树表示出来，首先，分别用<code>1</code>,<code>2</code>,<code>3</code>代替<code>*</code>,<code>-</code>,<code>*</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  2</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     3</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   2</span><br><span class=\"line\"> &#x2F;   \\</span><br><span class=\"line\">1     3</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  3</span><br><span class=\"line\"> &#x2F;</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  1</span><br><span class=\"line\"> &#x2F;</span><br><span class=\"line\">3</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    3</span><br><span class=\"line\">   &#x2F;     </span><br><span class=\"line\">  2</span><br><span class=\"line\"> &#x2F;</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>画出来后，我们很容易的发现，这个问题变成了对平衡二叉树的穷举问题，因此代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; ops;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(<span class=\"built_in\">string</span> input)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num; <span class=\"keyword\">char</span> op;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(input)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ss &gt;&gt; num;</span><br><span class=\"line\">    nums.push_back(num);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss &gt;&gt; op &gt;&gt; num) &#123;</span><br><span class=\"line\">        nums.push_back(num);</span><br><span class=\"line\">        ops.push_back(op);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    helper(<span class=\"number\">0</span>, ops.size(), res);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">calc</span><span class=\"params\">(<span class=\"keyword\">char</span> op, <span class=\"keyword\">int</span> i1, <span class=\"keyword\">int</span> i2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(op) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: res = i1 + i2; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: res = i1 - i2; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: res = i1 * i2; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> last, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;outputs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first == last) &#123;</span><br><span class=\"line\">        outputs.push_back(nums[first]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; lefts;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rights;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = first; i &lt; last;i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// select ops[i] in this layer</span></span><br><span class=\"line\">        lefts.clear();</span><br><span class=\"line\">        rights.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        helper(first, i, lefts);</span><br><span class=\"line\">        helper(i+<span class=\"number\">1</span>, last, rights);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> l: lefts) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> r: rights) &#123;</span><br><span class=\"line\">                outputs.push_back(calc(ops[i], l, r));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>stringstream</code>的效率的确不行，所以我们可以尝试将解析字符串的那段代码改成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>, end = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(;end &lt; input.size(); end++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input[end] == <span class=\"string\">&#x27;+&#x27;</span> || input[end] == <span class=\"string\">&#x27;-&#x27;</span> || input[end] == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">        nums.push_back(stoi(input.substr(beg, end - beg)));</span><br><span class=\"line\">        ops.push_back(input[end]);</span><br><span class=\"line\">        beg = end + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nums.push_back(stoi(input.substr(beg, end - beg)));</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Different-Ways-to-Add-Parentheses\"><a href=\"#Different-Ways-to-Add-Parentheses\" class=\"headerlink\" title=\"Different Ways to Add Parentheses\"></a>Different Ways to Add Parentheses</h1><blockquote>\n<p>开始每天坚持刷OJ和Paper吧。</p>\n</blockquote>\n<p>今天的题目是<a href=\"https://leetcode.com/problems/different-ways-to-add-parentheses/\"> Different Ways to Add Parentheses </a>:</p>\n<p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;2-1-1&quot;</span><br><span class=\"line\">Output: [0, 2]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">((2-1)-1) &#x3D; 0 </span><br><span class=\"line\">(2-(1-1)) &#x3D; 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: &quot;2*3-4*5&quot;</span><br><span class=\"line\">Output: [-34, -14, -10, -10, 10]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">(2*(3-(4*5))) &#x3D; -34 </span><br><span class=\"line\">((2*3)-(4*5)) &#x3D; -14 </span><br><span class=\"line\">((2*(3-4))*5) &#x3D; -10 </span><br><span class=\"line\">(2*((3-4)*5)) &#x3D; -10 </span><br><span class=\"line\">(((2*3)-4)*5) &#x3D; 10</span><br></pre></td></tr></table></figure>\n\n<p>太久没刷过题的后果就是之前掌握的一些解题思路好像有点生疏了，但还是勉强完成了这道题，首先从两个Example开始分析，第一个太简单好像看不出什么，我们分析一下第二个，我们可以看到，<code>(2*(3-(4*5))) = -34</code>是先算第二个<code>*</code>，然后再算<code>-</code>，最后算第一个<code>*</code>。大概可以猜出来我们需要穷举所有运算顺序，但应该不是全排列，因为当运算符个数为3时，他的运算顺序只有5个，而不是6个。仔细分析一下可以发现，这是因为已下两种算法是一样的：</p>\n<ol>\n<li>先算第一个，再算第三个，最后算第二个</li>\n<li>先算第三个，再算第一个，最后算第二个</li>\n</ol>\n<p>这就有点像一个二叉树了，层数相同的情况。我们尝试把上面五种运行顺序用二叉树表示出来，首先，分别用<code>1</code>,<code>2</code>,<code>3</code>代替<code>*</code>,<code>-</code>,<code>*</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  2</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     3</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   2</span><br><span class=\"line\"> &#x2F;   \\</span><br><span class=\"line\">1     3</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  3</span><br><span class=\"line\"> &#x2F;</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  1</span><br><span class=\"line\"> &#x2F;</span><br><span class=\"line\">3</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    3</span><br><span class=\"line\">   &#x2F;     </span><br><span class=\"line\">  2</span><br><span class=\"line\"> &#x2F;</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>画出来后，我们很容易的发现，这个问题变成了对平衡二叉树的穷举问题，因此代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; ops;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(<span class=\"built_in\">string</span> input)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num; <span class=\"keyword\">char</span> op;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(input)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ss &gt;&gt; num;</span><br><span class=\"line\">    nums.push_back(num);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss &gt;&gt; op &gt;&gt; num) &#123;</span><br><span class=\"line\">        nums.push_back(num);</span><br><span class=\"line\">        ops.push_back(op);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    helper(<span class=\"number\">0</span>, ops.size(), res);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">calc</span><span class=\"params\">(<span class=\"keyword\">char</span> op, <span class=\"keyword\">int</span> i1, <span class=\"keyword\">int</span> i2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(op) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: res = i1 + i2; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: res = i1 - i2; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: res = i1 * i2; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> last, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;outputs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first == last) &#123;</span><br><span class=\"line\">        outputs.push_back(nums[first]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; lefts;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rights;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = first; i &lt; last;i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// select ops[i] in this layer</span></span><br><span class=\"line\">        lefts.clear();</span><br><span class=\"line\">        rights.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        helper(first, i, lefts);</span><br><span class=\"line\">        helper(i+<span class=\"number\">1</span>, last, rights);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> l: lefts) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> r: rights) &#123;</span><br><span class=\"line\">                outputs.push_back(calc(ops[i], l, r));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>stringstream</code>的效率的确不行，所以我们可以尝试将解析字符串的那段代码改成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> beg = <span class=\"number\">0</span>, end = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(;end &lt; input.size(); end++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input[end] == <span class=\"string\">&#x27;+&#x27;</span> || input[end] == <span class=\"string\">&#x27;-&#x27;</span> || input[end] == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">        nums.push_back(stoi(input.substr(beg, end - beg)));</span><br><span class=\"line\">        ops.push_back(input[end]);</span><br><span class=\"line\">        beg = end + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nums.push_back(stoi(input.substr(beg, end - beg)));</span><br></pre></td></tr></table></figure>\n\n"},{"date":"2020-10-09T11:48:38.911Z","title":"375. Guess Number Higher or Lower II","_content":"\n今天的题目是[375. Guess Number Higher or Lower II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii)。\n\n一道动态规划问题，一开始以为是通过二分查找的方式来计算就好了，但是后面发现这样算出来答案不是最优的。\n\n思路大概是这样的，把问题先泛化为，给定从`i`到`j`的数字，猜数字的最大代价，为了得到最大代价，我们不妨假设每次都猜错，直到只有一个元素时。\n\n第一次猜的时候，我们可以猜从`i`到`j`的任意一个数字`k`，这时代价为`k`，猜错后可能得到两种回答，比`k`大或者比`k`小，这时我们的问题转换为两个子问题：\n\n- 给定`i`到`k-1`的数字，猜数字的最大代价\n- 给定`k+1`到`j`的数字，猜数字的最大代价\n\n当`i`到`j`的数字的数目小于等于1时，代价为`0`。\n\n据此，我们可以写出以下动态规划方程：\n\n$$\ndp[i,j] = \\left\\{\n\t\\begin{aligned}\n\t\t0 & , & (j - i + 1) >= 0 \\\\\n\t\tmin_{i<=k<=j}\\{dp[i,k-1] + k + dp[k+1,j]\\} & , & others\n\t\\end{aligned}\n\\right.\n$$\n\n由于计算`dp[i,j]`需要`dp[i,k-1]`和`dp[k+1,j]`，所以我们可以直到它是沿着斜对角线计算得到`dp[1,n]`的,如下图所示:\n\n![guess-number-higher-or-lower-ii-20201009202433-2020-10-09](https://imagehosting.wuxiaobai24.fun/blogguess-number-higher-or-lower-ii-20201009202431-2020-10-09)\n\n\n因此，我们可以根据动态规划方程写出如下代码：\n\n```c++\nint getMoneyAmount(int n) {\n\tvector<vector<int>> dp(n+1, vector<int>(n+1, 0));\n\tfor (int step = 1;step < n;step++) {\n\t\tfor(int i = 1,j = 1 + step;j <= n;i++,j++) {\n\t\t\t// int j = i + step;\n\t\t\t// if (j > n) break;\n\t\t\t// dp[i][j] = INT_MAX;\n\t\t\tdp[i][j] = dp[i][j-1] + j;\n\t\t\tfor(int k = i;k < j;k++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], k + max(dp[i][k-1], dp[k+1][j]));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[1][n];\n}\n```","source":"_posts/guess-number-higher-or-lower-ii.md","raw":"---\ncategories:\n- LeetCode\ndate: '2020-10-09T19:48:38.911460'\ntags:\n- Minimax\n- Dynamic Programming\n- LeetCode\ntitle: 375. Guess Number Higher or Lower II\n---\n\n今天的题目是[375. Guess Number Higher or Lower II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii)。\n\n一道动态规划问题，一开始以为是通过二分查找的方式来计算就好了，但是后面发现这样算出来答案不是最优的。\n\n思路大概是这样的，把问题先泛化为，给定从`i`到`j`的数字，猜数字的最大代价，为了得到最大代价，我们不妨假设每次都猜错，直到只有一个元素时。\n\n第一次猜的时候，我们可以猜从`i`到`j`的任意一个数字`k`，这时代价为`k`，猜错后可能得到两种回答，比`k`大或者比`k`小，这时我们的问题转换为两个子问题：\n\n- 给定`i`到`k-1`的数字，猜数字的最大代价\n- 给定`k+1`到`j`的数字，猜数字的最大代价\n\n当`i`到`j`的数字的数目小于等于1时，代价为`0`。\n\n据此，我们可以写出以下动态规划方程：\n\n$$\ndp[i,j] = \\left\\{\n\t\\begin{aligned}\n\t\t0 & , & (j - i + 1) >= 0 \\\\\n\t\tmin_{i<=k<=j}\\{dp[i,k-1] + k + dp[k+1,j]\\} & , & others\n\t\\end{aligned}\n\\right.\n$$\n\n由于计算`dp[i,j]`需要`dp[i,k-1]`和`dp[k+1,j]`，所以我们可以直到它是沿着斜对角线计算得到`dp[1,n]`的,如下图所示:\n\n![guess-number-higher-or-lower-ii-20201009202433-2020-10-09](https://imagehosting.wuxiaobai24.fun/blogguess-number-higher-or-lower-ii-20201009202431-2020-10-09)\n\n\n因此，我们可以根据动态规划方程写出如下代码：\n\n```c++\nint getMoneyAmount(int n) {\n\tvector<vector<int>> dp(n+1, vector<int>(n+1, 0));\n\tfor (int step = 1;step < n;step++) {\n\t\tfor(int i = 1,j = 1 + step;j <= n;i++,j++) {\n\t\t\t// int j = i + step;\n\t\t\t// if (j > n) break;\n\t\t\t// dp[i][j] = INT_MAX;\n\t\t\tdp[i][j] = dp[i][j-1] + j;\n\t\t\tfor(int k = i;k < j;k++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], k + max(dp[i][k-1], dp[k+1][j]));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[1][n];\n}\n```","slug":"guess-number-higher-or-lower-ii","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qf00giqmcma9y30ats","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii\">375. Guess Number Higher or Lower II</a>。</p>\n<p>一道动态规划问题，一开始以为是通过二分查找的方式来计算就好了，但是后面发现这样算出来答案不是最优的。</p>\n<p>思路大概是这样的，把问题先泛化为，给定从<code>i</code>到<code>j</code>的数字，猜数字的最大代价，为了得到最大代价，我们不妨假设每次都猜错，直到只有一个元素时。</p>\n<p>第一次猜的时候，我们可以猜从<code>i</code>到<code>j</code>的任意一个数字<code>k</code>，这时代价为<code>k</code>，猜错后可能得到两种回答，比<code>k</code>大或者比<code>k</code>小，这时我们的问题转换为两个子问题：</p>\n<ul>\n<li>给定<code>i</code>到<code>k-1</code>的数字，猜数字的最大代价</li>\n<li>给定<code>k+1</code>到<code>j</code>的数字，猜数字的最大代价</li>\n</ul>\n<p>当<code>i</code>到<code>j</code>的数字的数目小于等于1时，代价为<code>0</code>。</p>\n<p>据此，我们可以写出以下动态规划方程：</p>\n<p>$$<br>dp[i,j] = \\left{<br>    \\begin{aligned}<br>        0 &amp; , &amp; (j - i + 1) &gt;= 0 \\<br>        min_{i&lt;=k&lt;=j}{dp[i,k-1] + k + dp[k+1,j]} &amp; , &amp; others<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>由于计算<code>dp[i,j]</code>需要<code>dp[i,k-1]</code>和<code>dp[k+1,j]</code>，所以我们可以直到它是沿着斜对角线计算得到<code>dp[1,n]</code>的,如下图所示:</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogguess-number-higher-or-lower-ii-20201009202431-2020-10-09\" alt=\"guess-number-higher-or-lower-ii-20201009202433-2020-10-09\"></p>\n<p>因此，我们可以根据动态规划方程写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMoneyAmount</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(n+<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> step = <span class=\"number\">1</span>;step &lt; n;step++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>,j = <span class=\"number\">1</span> + step;j &lt;= n;i++,j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// int j = i + step;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// if (j &gt; n) break;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// dp[i][j] = INT_MAX;</span></span><br><span class=\"line\">\t\t\tdp[i][j] = dp[i][j<span class=\"number\">-1</span>] + j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = i;k &lt; j;k++) &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i][j], k + max(dp[i][k<span class=\"number\">-1</span>], dp[k+<span class=\"number\">1</span>][j]));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[<span class=\"number\">1</span>][n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii\">375. Guess Number Higher or Lower II</a>。</p>\n<p>一道动态规划问题，一开始以为是通过二分查找的方式来计算就好了，但是后面发现这样算出来答案不是最优的。</p>\n<p>思路大概是这样的，把问题先泛化为，给定从<code>i</code>到<code>j</code>的数字，猜数字的最大代价，为了得到最大代价，我们不妨假设每次都猜错，直到只有一个元素时。</p>\n<p>第一次猜的时候，我们可以猜从<code>i</code>到<code>j</code>的任意一个数字<code>k</code>，这时代价为<code>k</code>，猜错后可能得到两种回答，比<code>k</code>大或者比<code>k</code>小，这时我们的问题转换为两个子问题：</p>\n<ul>\n<li>给定<code>i</code>到<code>k-1</code>的数字，猜数字的最大代价</li>\n<li>给定<code>k+1</code>到<code>j</code>的数字，猜数字的最大代价</li>\n</ul>\n<p>当<code>i</code>到<code>j</code>的数字的数目小于等于1时，代价为<code>0</code>。</p>\n<p>据此，我们可以写出以下动态规划方程：</p>\n<p>$$<br>dp[i,j] = \\left{<br>    \\begin{aligned}<br>        0 &amp; , &amp; (j - i + 1) &gt;= 0 \\<br>        min_{i&lt;=k&lt;=j}{dp[i,k-1] + k + dp[k+1,j]} &amp; , &amp; others<br>    \\end{aligned}<br>\\right.<br>$$</p>\n<p>由于计算<code>dp[i,j]</code>需要<code>dp[i,k-1]</code>和<code>dp[k+1,j]</code>，所以我们可以直到它是沿着斜对角线计算得到<code>dp[1,n]</code>的,如下图所示:</p>\n<p><img src=\"https://imagehosting.wuxiaobai24.fun/blogguess-number-higher-or-lower-ii-20201009202431-2020-10-09\" alt=\"guess-number-higher-or-lower-ii-20201009202433-2020-10-09\"></p>\n<p>因此，我们可以根据动态规划方程写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMoneyAmount</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp(n+<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> step = <span class=\"number\">1</span>;step &lt; n;step++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>,j = <span class=\"number\">1</span> + step;j &lt;= n;i++,j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// int j = i + step;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// if (j &gt; n) break;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// dp[i][j] = INT_MAX;</span></span><br><span class=\"line\">\t\t\tdp[i][j] = dp[i][j<span class=\"number\">-1</span>] + j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = i;k &lt; j;k++) &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i][j], k + max(dp[i][k<span class=\"number\">-1</span>], dp[k+<span class=\"number\">1</span>][j]));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[<span class=\"number\">1</span>][n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"date":"2020-10-13T01:01:05.518Z","title":"274. H-Index","_content":"\n今天的题目是[274. H-Index](https://leetcode-cn.com/problems/h-index)。\n\n这道题要求出最大的一个`h`满足总共有`h`篇文章引用了至少`h`次。给定的输入时每一篇文章引用数。\n\n这种问题，一般来说都是先排个序来做加速的。如果现在`citations`数组是有序的，我们可以从后往前搜索，找到最大的`j`使得倒数第`j`个元素的引用数（`citations[j]`）大于等于`j`。因此，代码如下：\n\n```cpp\nint hIndex(vector<int>& citations) {\n\tsort(citations.begin(), citations.end());\n\tint i, j;\n\tfor(i = citations.size() - 1, j = 1;i >= 0 && citations[i] >= j;i--,j++);\n\treturn j - 1;\n}\n```","source":"_posts/h-index.md","raw":"---\ncategories:\n- LeetCode\ndate: '2020-10-13T09:01:05.518318'\ntags:\n- Sort\n- Hash Table\n- LeetCode\ntitle: 274. H-Index\n---\n\n今天的题目是[274. H-Index](https://leetcode-cn.com/problems/h-index)。\n\n这道题要求出最大的一个`h`满足总共有`h`篇文章引用了至少`h`次。给定的输入时每一篇文章引用数。\n\n这种问题，一般来说都是先排个序来做加速的。如果现在`citations`数组是有序的，我们可以从后往前搜索，找到最大的`j`使得倒数第`j`个元素的引用数（`citations[j]`）大于等于`j`。因此，代码如下：\n\n```cpp\nint hIndex(vector<int>& citations) {\n\tsort(citations.begin(), citations.end());\n\tint i, j;\n\tfor(i = citations.size() - 1, j = 1;i >= 0 && citations[i] >= j;i--,j++);\n\treturn j - 1;\n}\n```","slug":"h-index","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qg00gmqmcm88b9gq21","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/h-index\">274. H-Index</a>。</p>\n<p>这道题要求出最大的一个<code>h</code>满足总共有<code>h</code>篇文章引用了至少<code>h</code>次。给定的输入时每一篇文章引用数。</p>\n<p>这种问题，一般来说都是先排个序来做加速的。如果现在<code>citations</code>数组是有序的，我们可以从后往前搜索，找到最大的<code>j</code>使得倒数第<code>j</code>个元素的引用数（<code>citations[j]</code>）大于等于<code>j</code>。因此，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hIndex</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class=\"line\">\tsort(citations.begin(), citations.end());</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i = citations.size() - <span class=\"number\">1</span>, j = <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span> &amp;&amp; citations[i] &gt;= j;i--,j++);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> j - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/h-index\">274. H-Index</a>。</p>\n<p>这道题要求出最大的一个<code>h</code>满足总共有<code>h</code>篇文章引用了至少<code>h</code>次。给定的输入时每一篇文章引用数。</p>\n<p>这种问题，一般来说都是先排个序来做加速的。如果现在<code>citations</code>数组是有序的，我们可以从后往前搜索，找到最大的<code>j</code>使得倒数第<code>j</code>个元素的引用数（<code>citations[j]</code>）大于等于<code>j</code>。因此，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hIndex</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class=\"line\">\tsort(citations.begin(), citations.end());</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i = citations.size() - <span class=\"number\">1</span>, j = <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span> &amp;&amp; citations[i] &gt;= j;i--,j++);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> j - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"date":"2020-10-07T03:28:36.590Z","title":"817. Linked List Components","_content":"\n今天的题目是[817. Linked List Components](https://leetcode-cn.com/problems/linked-list-components)。\n\n非常简单的一道题。。。为什么会出现在`Medium`中呢？\n\n把`G`数组转成一个`unordered_set`就可以快速的判断某个元素是否在`G`中了，用一个`flag`来标识前一个元素是否在`G`中，初始值为`false`，然后遍历链表：\n\n1. 当前元素在`G`时，`flag = true`\n2. 当前元素不在`G`时，如果`flag == true`，计数就加一，然后`flag = false`。\n\n遍历完链表后，再判断一次`flag`是否为真，如果是，则计数加一。\n\n代码如下：\n\n```c++\nint numComponents(ListNode* head, vector<int>& G) {\n\tunordered_set<int> iset(G.begin(), G.end());\n\tint c = 0;\n\tbool flag = false;\n\twhile (head)\n\t{\n\t\tif (iset.count(head->val) != 0) {\n\t\t\tflag = true;\n\t\t} else {\n\t\t\tc += flag;\n\t\t\tflag = false;\n\t\t}\n\t\t    head = head->next;\n\t}\n\tc += flag;\n\treturn c;\n}\n```\n\n- 时间复杂度为：`O(n+m)`\n- 空间复杂度为：`O(m)`\n- `n`为链表大小，`m`为`G`的大小\n\n\n当然如果不用`unordered_set`来做也是可以的，因为题目中限制了链表长度和值的范围，而`G`中元素都是链表中的元素，所以我们可以用一个长度为 10000 的数组来代替`unordered_set`。\n\n代码如下：\n\n```c++\nint numComponents(ListNode* head, vector<int>& G) {\n    // unordered_set<int> iset(G.begin(), G.end());\n    vector<bool> iset(10000, false);\n    for(int v: G) iset[v] = true;\n\n    int c = 0;\n    bool flag = false;\n    while (head)\n    {\n        if (iset[head->val]) {\n            flag = true;\n        } else {\n            c += flag;\n            flag = false;\n        }\n        head = head->next;\n    }\n    c += flag;\n    return c;\n}\n```\n\n- 时间复杂度为：`O(n+m)`\n- 空间复杂度为：`O(1)`\n- `n`为链表大小，`m`为`G`的大小\n\n","source":"_posts/linked-list-components.md","raw":"---\ncategories:\n- LeetCode\ndate: '2020-10-07T11:28:36.590921'\ntags:\n- Linked List\n- LeetCode\ntitle: 817. Linked List Components\n---\n\n今天的题目是[817. Linked List Components](https://leetcode-cn.com/problems/linked-list-components)。\n\n非常简单的一道题。。。为什么会出现在`Medium`中呢？\n\n把`G`数组转成一个`unordered_set`就可以快速的判断某个元素是否在`G`中了，用一个`flag`来标识前一个元素是否在`G`中，初始值为`false`，然后遍历链表：\n\n1. 当前元素在`G`时，`flag = true`\n2. 当前元素不在`G`时，如果`flag == true`，计数就加一，然后`flag = false`。\n\n遍历完链表后，再判断一次`flag`是否为真，如果是，则计数加一。\n\n代码如下：\n\n```c++\nint numComponents(ListNode* head, vector<int>& G) {\n\tunordered_set<int> iset(G.begin(), G.end());\n\tint c = 0;\n\tbool flag = false;\n\twhile (head)\n\t{\n\t\tif (iset.count(head->val) != 0) {\n\t\t\tflag = true;\n\t\t} else {\n\t\t\tc += flag;\n\t\t\tflag = false;\n\t\t}\n\t\t    head = head->next;\n\t}\n\tc += flag;\n\treturn c;\n}\n```\n\n- 时间复杂度为：`O(n+m)`\n- 空间复杂度为：`O(m)`\n- `n`为链表大小，`m`为`G`的大小\n\n\n当然如果不用`unordered_set`来做也是可以的，因为题目中限制了链表长度和值的范围，而`G`中元素都是链表中的元素，所以我们可以用一个长度为 10000 的数组来代替`unordered_set`。\n\n代码如下：\n\n```c++\nint numComponents(ListNode* head, vector<int>& G) {\n    // unordered_set<int> iset(G.begin(), G.end());\n    vector<bool> iset(10000, false);\n    for(int v: G) iset[v] = true;\n\n    int c = 0;\n    bool flag = false;\n    while (head)\n    {\n        if (iset[head->val]) {\n            flag = true;\n        } else {\n            c += flag;\n            flag = false;\n        }\n        head = head->next;\n    }\n    c += flag;\n    return c;\n}\n```\n\n- 时间复杂度为：`O(n+m)`\n- 空间复杂度为：`O(1)`\n- `n`为链表大小，`m`为`G`的大小\n\n","slug":"linked-list-components","published":1,"updated":"2021-03-10T13:47:05.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qg00gpqmcm0pgqcu3s","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/linked-list-components\">817. Linked List Components</a>。</p>\n<p>非常简单的一道题。。。为什么会出现在<code>Medium</code>中呢？</p>\n<p>把<code>G</code>数组转成一个<code>unordered_set</code>就可以快速的判断某个元素是否在<code>G</code>中了，用一个<code>flag</code>来标识前一个元素是否在<code>G</code>中，初始值为<code>false</code>，然后遍历链表：</p>\n<ol>\n<li>当前元素在<code>G</code>时，<code>flag = true</code></li>\n<li>当前元素不在<code>G</code>时，如果<code>flag == true</code>，计数就加一，然后<code>flag = false</code>。</li>\n</ol>\n<p>遍历完链表后，再判断一次<code>flag</code>是否为真，如果是，则计数加一。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numComponents</span><span class=\"params\">(ListNode* head, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">iset</span><span class=\"params\">(G.begin(), G.end())</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (head)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (iset.count(head-&gt;val) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tflag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tc += flag;</span><br><span class=\"line\">\t\t\tflag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t    head = head-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc += flag;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>时间复杂度为：<code>O(n+m)</code></li>\n<li>空间复杂度为：<code>O(m)</code></li>\n<li><code>n</code>为链表大小，<code>m</code>为<code>G</code>的大小</li>\n</ul>\n<p>当然如果不用<code>unordered_set</code>来做也是可以的，因为题目中限制了链表长度和值的范围，而<code>G</code>中元素都是链表中的元素，所以我们可以用一个长度为 10000 的数组来代替<code>unordered_set</code>。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numComponents</span><span class=\"params\">(ListNode* head, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// unordered_set&lt;int&gt; iset(G.begin(), G.end());</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">iset</span><span class=\"params\">(<span class=\"number\">10000</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v: G) iset[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (head)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iset[head-&gt;val]) &#123;</span><br><span class=\"line\">            flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            c += flag;</span><br><span class=\"line\">            flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c += flag;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>时间复杂度为：<code>O(n+m)</code></li>\n<li>空间复杂度为：<code>O(1)</code></li>\n<li><code>n</code>为链表大小，<code>m</code>为<code>G</code>的大小</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/linked-list-components\">817. Linked List Components</a>。</p>\n<p>非常简单的一道题。。。为什么会出现在<code>Medium</code>中呢？</p>\n<p>把<code>G</code>数组转成一个<code>unordered_set</code>就可以快速的判断某个元素是否在<code>G</code>中了，用一个<code>flag</code>来标识前一个元素是否在<code>G</code>中，初始值为<code>false</code>，然后遍历链表：</p>\n<ol>\n<li>当前元素在<code>G</code>时，<code>flag = true</code></li>\n<li>当前元素不在<code>G</code>时，如果<code>flag == true</code>，计数就加一，然后<code>flag = false</code>。</li>\n</ol>\n<p>遍历完链表后，再判断一次<code>flag</code>是否为真，如果是，则计数加一。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numComponents</span><span class=\"params\">(ListNode* head, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">iset</span><span class=\"params\">(G.begin(), G.end())</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (head)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (iset.count(head-&gt;val) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tflag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tc += flag;</span><br><span class=\"line\">\t\t\tflag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t    head = head-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc += flag;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>时间复杂度为：<code>O(n+m)</code></li>\n<li>空间复杂度为：<code>O(m)</code></li>\n<li><code>n</code>为链表大小，<code>m</code>为<code>G</code>的大小</li>\n</ul>\n<p>当然如果不用<code>unordered_set</code>来做也是可以的，因为题目中限制了链表长度和值的范围，而<code>G</code>中元素都是链表中的元素，所以我们可以用一个长度为 10000 的数组来代替<code>unordered_set</code>。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numComponents</span><span class=\"params\">(ListNode* head, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// unordered_set&lt;int&gt; iset(G.begin(), G.end());</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">iset</span><span class=\"params\">(<span class=\"number\">10000</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v: G) iset[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (head)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iset[head-&gt;val]) &#123;</span><br><span class=\"line\">            flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            c += flag;</span><br><span class=\"line\">            flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c += flag;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>时间复杂度为：<code>O(n+m)</code></li>\n<li>空间复杂度为：<code>O(1)</code></li>\n<li><code>n</code>为链表大小，<code>m</code>为<code>G</code>的大小</li>\n</ul>\n"},{"date":"2021-01-20T13:38:55.252Z","title":"687. Longest Univalue Path","_content":"\n今天的题目是[687. Longest Univalue Path](https://leetcode-cn.com/problems/longest-univalue-path)。\n\n还是比较简单的一道题目，但是太久没做题了，敲代码有点生疏。。。\n\n首先分析一下题目，有几个点需要注意一下：\n\n- 它要的路径长度，而不是节点数。当然这两个问题非常容易转换，排除掉空树后，节点数减 1 就是路径长度。\n- 这个路径不一定是向下的，也就是说，这条路径是可以从左子树沿着根节点到右子树的。\n- 这条路径可以不经过根节点\n\n应该很容易就可以发现，对于一棵树来说，最长同值路径只可能是以下几种情况：\n\n- 在左子树中\n- 在右子树中\n- 经过根节点\n\n前两个很容易解决，因为可以用递归的思想，假设当前函数已经可以求出这个长度了，然后递归调用即可。\n但是经过根节点的情况就比较复杂了。但是可能的情况也是可以穷举出来的：\n\n- 最长同值路径只包含左子树和根节点 (`root->val == root->left->val`)\n- 最长同值路径只包含右子树和根节点 (`root->val == root->right->val`)\n- 最长同值路径包含左、右子树和根节点 (`root->val == root->left->val && root->val == root->right->val`)\n\n\n看上去只需要递归求解左右子树的最长同值路径，然后通过简单的判断\n，并对所有情况的路径长度求`max`即可，但是这又涉及到另一个坑点了：\n\n```\n    4\n   /\n  4\n / \\\n4   4\n```\n\n对于上面这棵树来说，它的最长同值路径是2，而不是3。\n\n而且上面提到的做法也无法解决到最开始提到的第三个坑。\n\n这里采用的做法是在递归求解一棵树的最长同值路径的同时，求解\n它**经过根节点的**、**向下的**的最长同值路径。\n\n有了这个新的附加条件，我们就可以通过简单的判断来计算经过根节点时最长同值路径的长度。\n\n下面是实现代码（实现上，我们其实求的是路径中节点的个数，然后在最后返回时减一）：\n\n```c++\nint longestUnivaluePath(TreeNode* root) {\nif (root == nullptr) return 0;\n    auto res = helper(root);\n    return res.first - 1;\n}\npair<int, int> helper(TreeNode *root) {\n    if (!root) return make_pair(0, 0);\n    auto left = helper(root->left);\n    auto right = helper(root->right);\n    int lup = 0, rlup = 1;\n    \n    if (root->left && root->left->val == root->val) {\n        lup += left.second;\n        rlup = max(rlup, left.second + 1);\n    }\n    if (root->right && root->right->val  == root->val) {\n        lup += right.second;\n        rlup = max(rlup, right.second + 1);\n    }\n    lup += 1;\n    lup = max(lup, left.first);\n    lup = max(lup, right.first);\n    \n    return make_pair(lup, rlup);\n}\n```\n\n\n","source":"_posts/longest-univalue-path.md","raw":"---\ncategories:\n- LeetCode\ndate: '2021-01-20T21:38:55.252165'\ntags:\n- Tree\n- Recursion\n- LeetCode\ntitle: 687. Longest Univalue Path\n---\n\n今天的题目是[687. Longest Univalue Path](https://leetcode-cn.com/problems/longest-univalue-path)。\n\n还是比较简单的一道题目，但是太久没做题了，敲代码有点生疏。。。\n\n首先分析一下题目，有几个点需要注意一下：\n\n- 它要的路径长度，而不是节点数。当然这两个问题非常容易转换，排除掉空树后，节点数减 1 就是路径长度。\n- 这个路径不一定是向下的，也就是说，这条路径是可以从左子树沿着根节点到右子树的。\n- 这条路径可以不经过根节点\n\n应该很容易就可以发现，对于一棵树来说，最长同值路径只可能是以下几种情况：\n\n- 在左子树中\n- 在右子树中\n- 经过根节点\n\n前两个很容易解决，因为可以用递归的思想，假设当前函数已经可以求出这个长度了，然后递归调用即可。\n但是经过根节点的情况就比较复杂了。但是可能的情况也是可以穷举出来的：\n\n- 最长同值路径只包含左子树和根节点 (`root->val == root->left->val`)\n- 最长同值路径只包含右子树和根节点 (`root->val == root->right->val`)\n- 最长同值路径包含左、右子树和根节点 (`root->val == root->left->val && root->val == root->right->val`)\n\n\n看上去只需要递归求解左右子树的最长同值路径，然后通过简单的判断\n，并对所有情况的路径长度求`max`即可，但是这又涉及到另一个坑点了：\n\n```\n    4\n   /\n  4\n / \\\n4   4\n```\n\n对于上面这棵树来说，它的最长同值路径是2，而不是3。\n\n而且上面提到的做法也无法解决到最开始提到的第三个坑。\n\n这里采用的做法是在递归求解一棵树的最长同值路径的同时，求解\n它**经过根节点的**、**向下的**的最长同值路径。\n\n有了这个新的附加条件，我们就可以通过简单的判断来计算经过根节点时最长同值路径的长度。\n\n下面是实现代码（实现上，我们其实求的是路径中节点的个数，然后在最后返回时减一）：\n\n```c++\nint longestUnivaluePath(TreeNode* root) {\nif (root == nullptr) return 0;\n    auto res = helper(root);\n    return res.first - 1;\n}\npair<int, int> helper(TreeNode *root) {\n    if (!root) return make_pair(0, 0);\n    auto left = helper(root->left);\n    auto right = helper(root->right);\n    int lup = 0, rlup = 1;\n    \n    if (root->left && root->left->val == root->val) {\n        lup += left.second;\n        rlup = max(rlup, left.second + 1);\n    }\n    if (root->right && root->right->val  == root->val) {\n        lup += right.second;\n        rlup = max(rlup, right.second + 1);\n    }\n    lup += 1;\n    lup = max(lup, left.first);\n    lup = max(lup, right.first);\n    \n    return make_pair(lup, rlup);\n}\n```\n\n\n","slug":"longest-univalue-path","published":1,"updated":"2021-03-10T13:47:05.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qh00gtqmcmezwrf5eg","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/longest-univalue-path\">687. Longest Univalue Path</a>。</p>\n<p>还是比较简单的一道题目，但是太久没做题了，敲代码有点生疏。。。</p>\n<p>首先分析一下题目，有几个点需要注意一下：</p>\n<ul>\n<li>它要的路径长度，而不是节点数。当然这两个问题非常容易转换，排除掉空树后，节点数减 1 就是路径长度。</li>\n<li>这个路径不一定是向下的，也就是说，这条路径是可以从左子树沿着根节点到右子树的。</li>\n<li>这条路径可以不经过根节点</li>\n</ul>\n<p>应该很容易就可以发现，对于一棵树来说，最长同值路径只可能是以下几种情况：</p>\n<ul>\n<li>在左子树中</li>\n<li>在右子树中</li>\n<li>经过根节点</li>\n</ul>\n<p>前两个很容易解决，因为可以用递归的思想，假设当前函数已经可以求出这个长度了，然后递归调用即可。<br>但是经过根节点的情况就比较复杂了。但是可能的情况也是可以穷举出来的：</p>\n<ul>\n<li>最长同值路径只包含左子树和根节点 (<code>root-&gt;val == root-&gt;left-&gt;val</code>)</li>\n<li>最长同值路径只包含右子树和根节点 (<code>root-&gt;val == root-&gt;right-&gt;val</code>)</li>\n<li>最长同值路径包含左、右子树和根节点 (<code>root-&gt;val == root-&gt;left-&gt;val &amp;&amp; root-&gt;val == root-&gt;right-&gt;val</code>)</li>\n</ul>\n<p>看上去只需要递归求解左右子树的最长同值路径，然后通过简单的判断<br>，并对所有情况的路径长度求<code>max</code>即可，但是这又涉及到另一个坑点了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    4</span><br><span class=\"line\">   &#x2F;</span><br><span class=\"line\">  4</span><br><span class=\"line\"> &#x2F; \\</span><br><span class=\"line\">4   4</span><br></pre></td></tr></table></figure>\n\n<p>对于上面这棵树来说，它的最长同值路径是2，而不是3。</p>\n<p>而且上面提到的做法也无法解决到最开始提到的第三个坑。</p>\n<p>这里采用的做法是在递归求解一棵树的最长同值路径的同时，求解<br>它<strong>经过根节点的</strong>、<strong>向下的</strong>的最长同值路径。</p>\n<p>有了这个新的附加条件，我们就可以通过简单的判断来计算经过根节点时最长同值路径的长度。</p>\n<p>下面是实现代码（实现上，我们其实求的是路径中节点的个数，然后在最后返回时减一）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestUnivaluePath</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> res = helper(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.first - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pair&lt;int, int&gt; helper(TreeNode *root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = helper(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> right = helper(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lup = <span class=\"number\">0</span>, rlup = <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;left-&gt;val == root-&gt;val) &#123;</span><br><span class=\"line\">        lup += left.second;</span><br><span class=\"line\">        rlup = max(rlup, left.second + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right &amp;&amp; root-&gt;right-&gt;val  == root-&gt;val) &#123;</span><br><span class=\"line\">        lup += right.second;</span><br><span class=\"line\">        rlup = max(rlup, right.second + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lup += <span class=\"number\">1</span>;</span><br><span class=\"line\">    lup = max(lup, left.first);</span><br><span class=\"line\">    lup = max(lup, right.first);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(lup, rlup);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/longest-univalue-path\">687. Longest Univalue Path</a>。</p>\n<p>还是比较简单的一道题目，但是太久没做题了，敲代码有点生疏。。。</p>\n<p>首先分析一下题目，有几个点需要注意一下：</p>\n<ul>\n<li>它要的路径长度，而不是节点数。当然这两个问题非常容易转换，排除掉空树后，节点数减 1 就是路径长度。</li>\n<li>这个路径不一定是向下的，也就是说，这条路径是可以从左子树沿着根节点到右子树的。</li>\n<li>这条路径可以不经过根节点</li>\n</ul>\n<p>应该很容易就可以发现，对于一棵树来说，最长同值路径只可能是以下几种情况：</p>\n<ul>\n<li>在左子树中</li>\n<li>在右子树中</li>\n<li>经过根节点</li>\n</ul>\n<p>前两个很容易解决，因为可以用递归的思想，假设当前函数已经可以求出这个长度了，然后递归调用即可。<br>但是经过根节点的情况就比较复杂了。但是可能的情况也是可以穷举出来的：</p>\n<ul>\n<li>最长同值路径只包含左子树和根节点 (<code>root-&gt;val == root-&gt;left-&gt;val</code>)</li>\n<li>最长同值路径只包含右子树和根节点 (<code>root-&gt;val == root-&gt;right-&gt;val</code>)</li>\n<li>最长同值路径包含左、右子树和根节点 (<code>root-&gt;val == root-&gt;left-&gt;val &amp;&amp; root-&gt;val == root-&gt;right-&gt;val</code>)</li>\n</ul>\n<p>看上去只需要递归求解左右子树的最长同值路径，然后通过简单的判断<br>，并对所有情况的路径长度求<code>max</code>即可，但是这又涉及到另一个坑点了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    4</span><br><span class=\"line\">   &#x2F;</span><br><span class=\"line\">  4</span><br><span class=\"line\"> &#x2F; \\</span><br><span class=\"line\">4   4</span><br></pre></td></tr></table></figure>\n\n<p>对于上面这棵树来说，它的最长同值路径是2，而不是3。</p>\n<p>而且上面提到的做法也无法解决到最开始提到的第三个坑。</p>\n<p>这里采用的做法是在递归求解一棵树的最长同值路径的同时，求解<br>它<strong>经过根节点的</strong>、<strong>向下的</strong>的最长同值路径。</p>\n<p>有了这个新的附加条件，我们就可以通过简单的判断来计算经过根节点时最长同值路径的长度。</p>\n<p>下面是实现代码（实现上，我们其实求的是路径中节点的个数，然后在最后返回时减一）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestUnivaluePath</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> res = helper(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.first - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pair&lt;int, int&gt; helper(TreeNode *root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = helper(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> right = helper(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lup = <span class=\"number\">0</span>, rlup = <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;left-&gt;val == root-&gt;val) &#123;</span><br><span class=\"line\">        lup += left.second;</span><br><span class=\"line\">        rlup = max(rlup, left.second + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right &amp;&amp; root-&gt;right-&gt;val  == root-&gt;val) &#123;</span><br><span class=\"line\">        lup += right.second;</span><br><span class=\"line\">        rlup = max(rlup, right.second + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lup += <span class=\"number\">1</span>;</span><br><span class=\"line\">    lup = max(lup, left.first);</span><br><span class=\"line\">    lup = max(lup, right.first);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">make_pair</span>(lup, rlup);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"date":"2021-01-21T13:37:20.086Z","title":"318. Maximum Product of Word Lengths","_content":"\n今天的题目是[318. Maximum Product of Word Lengths](https://leetcode-cn.com/problems/maximum-product-of-word-lengths)。\n\n比较简单的一道的题目，由于 word 只由26种小写字母组成，所以我们\n可以利用一个 32 位的整数中前26位存储每个 word 中是否出现够某个字符。\n进而，可以快速的判断两个 word 是否含有公共字母。然后两两比较，找出\n不含有公共字母的单词对，并计算单词对的长度乘积，求解得到最大单词长度乘积了。\n\n```c++\nunsigned word2bits(const string &word) {\n    unsigned res = 0;\n    for(auto c: word) {\n        res |= 1 << (c-'a');\n    }\n    return res;\n}\nint maxProduct(vector<string>& words) {\n    int size = words.size();\n    if (!size) return 0;\n\n    vector<unsigned> bitmap(size);\n    for(int i = 0; i < size; i++) {\n        bitmap[i] = word2bits(words[i]);\n    }\n    int res = 0;\n    for(int i = 0;i < size; i++) {\n        for(int j = i + 1;j < size; j++) {\n            if ((bitmap[i] & bitmap[j]) == 0) {\n                res = max(res, int(words[i].size() * words[j].size()));\n            }\n                \n        }\n    }\n    return res;\n}\n```\n\nBTW，其实一开始我以为它是需要优化到`O(nlogn)`才能 AC 的。\n","source":"_posts/maximum-product-of-word-lengths.md","raw":"---\ncategories:\n- LeetCode\ndate: '2021-01-21T21:37:20.086257'\ntags:\n- Bit Manipulation\n- LeetCode\ntitle: 318. Maximum Product of Word Lengths\n---\n\n今天的题目是[318. Maximum Product of Word Lengths](https://leetcode-cn.com/problems/maximum-product-of-word-lengths)。\n\n比较简单的一道的题目，由于 word 只由26种小写字母组成，所以我们\n可以利用一个 32 位的整数中前26位存储每个 word 中是否出现够某个字符。\n进而，可以快速的判断两个 word 是否含有公共字母。然后两两比较，找出\n不含有公共字母的单词对，并计算单词对的长度乘积，求解得到最大单词长度乘积了。\n\n```c++\nunsigned word2bits(const string &word) {\n    unsigned res = 0;\n    for(auto c: word) {\n        res |= 1 << (c-'a');\n    }\n    return res;\n}\nint maxProduct(vector<string>& words) {\n    int size = words.size();\n    if (!size) return 0;\n\n    vector<unsigned> bitmap(size);\n    for(int i = 0; i < size; i++) {\n        bitmap[i] = word2bits(words[i]);\n    }\n    int res = 0;\n    for(int i = 0;i < size; i++) {\n        for(int j = i + 1;j < size; j++) {\n            if ((bitmap[i] & bitmap[j]) == 0) {\n                res = max(res, int(words[i].size() * words[j].size()));\n            }\n                \n        }\n    }\n    return res;\n}\n```\n\nBTW，其实一开始我以为它是需要优化到`O(nlogn)`才能 AC 的。\n","slug":"maximum-product-of-word-lengths","published":1,"updated":"2021-03-10T13:47:05.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qi00gwqmcm4mqvas7a","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/maximum-product-of-word-lengths\">318. Maximum Product of Word Lengths</a>。</p>\n<p>比较简单的一道的题目，由于 word 只由26种小写字母组成，所以我们<br>可以利用一个 32 位的整数中前26位存储每个 word 中是否出现够某个字符。<br>进而，可以快速的判断两个 word 是否含有公共字母。然后两两比较，找出<br>不含有公共字母的单词对，并计算单词对的长度乘积，求解得到最大单词长度乘积了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">word2bits</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c: word) &#123;</span><br><span class=\"line\">        res |= <span class=\"number\">1</span> &lt;&lt; (c-<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = words.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!size) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; <span class=\"title\">bitmap</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        bitmap[i] = word2bits(words[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;j &lt; size; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((bitmap[i] &amp; bitmap[j]) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res = max(res, <span class=\"keyword\">int</span>(words[i].size() * words[j].size()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BTW，其实一开始我以为它是需要优化到<code>O(nlogn)</code>才能 AC 的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/maximum-product-of-word-lengths\">318. Maximum Product of Word Lengths</a>。</p>\n<p>比较简单的一道的题目，由于 word 只由26种小写字母组成，所以我们<br>可以利用一个 32 位的整数中前26位存储每个 word 中是否出现够某个字符。<br>进而，可以快速的判断两个 word 是否含有公共字母。然后两两比较，找出<br>不含有公共字母的单词对，并计算单词对的长度乘积，求解得到最大单词长度乘积了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">word2bits</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c: word) &#123;</span><br><span class=\"line\">        res |= <span class=\"number\">1</span> &lt;&lt; (c-<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = words.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!size) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; <span class=\"title\">bitmap</span><span class=\"params\">(size)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        bitmap[i] = word2bits(words[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;j &lt; size; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((bitmap[i] &amp; bitmap[j]) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res = max(res, <span class=\"keyword\">int</span>(words[i].size() * words[j].size()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BTW，其实一开始我以为它是需要优化到<code>O(nlogn)</code>才能 AC 的。</p>\n"},{"date":"2020-10-10T02:42:11.306Z","title":"1019. Next Greater Node In Linked List","_content":"\n今天的题目是[1019. Next Greater Node In Linked List](https://leetcode-cn.com/problems/next-greater-node-in-linked-list)。\n\n这种求下一个更大的元素用单调栈就可以解决了。\n\n简单来讲，就是从后往前遍历，每次都将当前元素压入栈中，并且压栈前确定当前元素的下一个更大的元素。确认下一个更大的元素的方式是，检查栈顶元素是否大于当前元素，如果不大于，则弹出栈顶元素，并继续检查直到找到或者栈空。\n\n由于题目给出的是链表，而我们又需要从后往前遍历，所以先遍历一次链表得到元素数组，而且因为可以重用这个数组作为返回值，所以消耗的空间并没有增加\n\n```cpp\nvector<int> nextLargerNodes(ListNode* head) {\n\tvector<int> val;\n\twhile (head)\n\t{\n\t\tval.push_back(head->val);\n\t\thead = head->next;\n\t}\n\tstack<int> st;\n\tint temp;\n\tfor(int i = val.size() - 1;i>=0;i--) {\n\t\twhile (!st.empty() && val[i] >= st.top())\n\t\t{\n\t\t\tst.pop();\n\t\t}\n\t\ttemp = st.empty() ? 0 : st.top();\n\t\tst.push(val[i]);\n\t\tval[i] = temp;\n\t}\n\treturn val;\n}\n```\n\n上面那种方法需要两边遍历，而之所以需要两次遍历的原因是，在第二次遍历中，我们需要从后向前遍历来实现单调栈，进而需要通过第一次遍历来生成元素数组。\n而如果我们可以将从后向前改成从前向后的话，就可以将两次遍历转成一次遍历了。\n\n从前向后遍历链表时，我们可以先假设后面没有元素大于当前元素，所以先在返回值数组对应位置设置`0`，然后不断判断当前元素是否比栈顶元素要大，\n如果比它大的话，那么栈顶元素对应的下一个更大的元素就是当前元素，这时就可以将栈顶元素弹出栈，然后重新比较栈顶元素和当前元素的大小，直到栈空或者当前元素小于栈顶元素。比较完成后，我们将当前元素和其下标压入栈中。\n这时，栈中的元素都是还未确定下一个更大的元素，而已经弹出栈的元素都已经确定了下一个更大的元素，当遍历完链表时，就求解出结果了。\n\n代码如下：\n\n```c++\nvector<int> nextLargerNodes(ListNode* head) {\n\tvector<int> val;\n\twhile (head)\n\t{\n\t\tval.push_back(head->val);\n\t\thead = head->next;\n\t}\n\tstack<int> st;\n\tint temp;\n\tfor(int i = val.size() - 1;i>=0;i--) {\n\t\twhile (!st.empty() && val[i] >= st.top())\n\t\t{\n\t\t\tst.pop();\n\t\t}\n\t\ttemp = st.empty() ? 0 : st.top();\n\t\tst.push(val[i]);\n\t\tval[i] = temp;\n\t}\n\treturn val;\n}\n```\n\n以上两种方法的时间复杂度和空间复杂度都是`O(n)`，虽然说第二种方法只需要扫描一遍，但是因为它栈中需要保存元素的值和元素的下标，所以在一些情况下估计跑的还不如第一种方法。","source":"_posts/next-greater-node-in-linked-list.md","raw":"---\ncategories:\n- LeetCode\ndate: '2020-10-10T10:42:11.306505'\ntags:\n- Stack\n- Linked List\n- LeetCode\ntitle: 1019. Next Greater Node In Linked List\n---\n\n今天的题目是[1019. Next Greater Node In Linked List](https://leetcode-cn.com/problems/next-greater-node-in-linked-list)。\n\n这种求下一个更大的元素用单调栈就可以解决了。\n\n简单来讲，就是从后往前遍历，每次都将当前元素压入栈中，并且压栈前确定当前元素的下一个更大的元素。确认下一个更大的元素的方式是，检查栈顶元素是否大于当前元素，如果不大于，则弹出栈顶元素，并继续检查直到找到或者栈空。\n\n由于题目给出的是链表，而我们又需要从后往前遍历，所以先遍历一次链表得到元素数组，而且因为可以重用这个数组作为返回值，所以消耗的空间并没有增加\n\n```cpp\nvector<int> nextLargerNodes(ListNode* head) {\n\tvector<int> val;\n\twhile (head)\n\t{\n\t\tval.push_back(head->val);\n\t\thead = head->next;\n\t}\n\tstack<int> st;\n\tint temp;\n\tfor(int i = val.size() - 1;i>=0;i--) {\n\t\twhile (!st.empty() && val[i] >= st.top())\n\t\t{\n\t\t\tst.pop();\n\t\t}\n\t\ttemp = st.empty() ? 0 : st.top();\n\t\tst.push(val[i]);\n\t\tval[i] = temp;\n\t}\n\treturn val;\n}\n```\n\n上面那种方法需要两边遍历，而之所以需要两次遍历的原因是，在第二次遍历中，我们需要从后向前遍历来实现单调栈，进而需要通过第一次遍历来生成元素数组。\n而如果我们可以将从后向前改成从前向后的话，就可以将两次遍历转成一次遍历了。\n\n从前向后遍历链表时，我们可以先假设后面没有元素大于当前元素，所以先在返回值数组对应位置设置`0`，然后不断判断当前元素是否比栈顶元素要大，\n如果比它大的话，那么栈顶元素对应的下一个更大的元素就是当前元素，这时就可以将栈顶元素弹出栈，然后重新比较栈顶元素和当前元素的大小，直到栈空或者当前元素小于栈顶元素。比较完成后，我们将当前元素和其下标压入栈中。\n这时，栈中的元素都是还未确定下一个更大的元素，而已经弹出栈的元素都已经确定了下一个更大的元素，当遍历完链表时，就求解出结果了。\n\n代码如下：\n\n```c++\nvector<int> nextLargerNodes(ListNode* head) {\n\tvector<int> val;\n\twhile (head)\n\t{\n\t\tval.push_back(head->val);\n\t\thead = head->next;\n\t}\n\tstack<int> st;\n\tint temp;\n\tfor(int i = val.size() - 1;i>=0;i--) {\n\t\twhile (!st.empty() && val[i] >= st.top())\n\t\t{\n\t\t\tst.pop();\n\t\t}\n\t\ttemp = st.empty() ? 0 : st.top();\n\t\tst.push(val[i]);\n\t\tval[i] = temp;\n\t}\n\treturn val;\n}\n```\n\n以上两种方法的时间复杂度和空间复杂度都是`O(n)`，虽然说第二种方法只需要扫描一遍，但是因为它栈中需要保存元素的值和元素的下标，所以在一些情况下估计跑的还不如第一种方法。","slug":"next-greater-node-in-linked-list","published":1,"updated":"2021-03-10T13:47:05.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qj00h0qmcm662h26yv","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/next-greater-node-in-linked-list\">1019. Next Greater Node In Linked List</a>。</p>\n<p>这种求下一个更大的元素用单调栈就可以解决了。</p>\n<p>简单来讲，就是从后往前遍历，每次都将当前元素压入栈中，并且压栈前确定当前元素的下一个更大的元素。确认下一个更大的元素的方式是，检查栈顶元素是否大于当前元素，如果不大于，则弹出栈顶元素，并继续检查直到找到或者栈空。</p>\n<p>由于题目给出的是链表，而我们又需要从后往前遍历，所以先遍历一次链表得到元素数组，而且因为可以重用这个数组作为返回值，所以消耗的空间并没有增加</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nextLargerNodes</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; val;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (head)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tval.push_back(head-&gt;val);</span><br><span class=\"line\">\t\thead = head-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = val.size() - <span class=\"number\">1</span>;i&gt;=<span class=\"number\">0</span>;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!st.empty() &amp;&amp; val[i] &gt;= st.top())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tst.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp = st.empty() ? <span class=\"number\">0</span> : st.top();</span><br><span class=\"line\">\t\tst.push(val[i]);</span><br><span class=\"line\">\t\tval[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面那种方法需要两边遍历，而之所以需要两次遍历的原因是，在第二次遍历中，我们需要从后向前遍历来实现单调栈，进而需要通过第一次遍历来生成元素数组。<br>而如果我们可以将从后向前改成从前向后的话，就可以将两次遍历转成一次遍历了。</p>\n<p>从前向后遍历链表时，我们可以先假设后面没有元素大于当前元素，所以先在返回值数组对应位置设置<code>0</code>，然后不断判断当前元素是否比栈顶元素要大，<br>如果比它大的话，那么栈顶元素对应的下一个更大的元素就是当前元素，这时就可以将栈顶元素弹出栈，然后重新比较栈顶元素和当前元素的大小，直到栈空或者当前元素小于栈顶元素。比较完成后，我们将当前元素和其下标压入栈中。<br>这时，栈中的元素都是还未确定下一个更大的元素，而已经弹出栈的元素都已经确定了下一个更大的元素，当遍历完链表时，就求解出结果了。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nextLargerNodes</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; val;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (head)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tval.push_back(head-&gt;val);</span><br><span class=\"line\">\t\thead = head-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = val.size() - <span class=\"number\">1</span>;i&gt;=<span class=\"number\">0</span>;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!st.empty() &amp;&amp; val[i] &gt;= st.top())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tst.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp = st.empty() ? <span class=\"number\">0</span> : st.top();</span><br><span class=\"line\">\t\tst.push(val[i]);</span><br><span class=\"line\">\t\tval[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上两种方法的时间复杂度和空间复杂度都是<code>O(n)</code>，虽然说第二种方法只需要扫描一遍，但是因为它栈中需要保存元素的值和元素的下标，所以在一些情况下估计跑的还不如第一种方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/next-greater-node-in-linked-list\">1019. Next Greater Node In Linked List</a>。</p>\n<p>这种求下一个更大的元素用单调栈就可以解决了。</p>\n<p>简单来讲，就是从后往前遍历，每次都将当前元素压入栈中，并且压栈前确定当前元素的下一个更大的元素。确认下一个更大的元素的方式是，检查栈顶元素是否大于当前元素，如果不大于，则弹出栈顶元素，并继续检查直到找到或者栈空。</p>\n<p>由于题目给出的是链表，而我们又需要从后往前遍历，所以先遍历一次链表得到元素数组，而且因为可以重用这个数组作为返回值，所以消耗的空间并没有增加</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nextLargerNodes</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; val;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (head)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tval.push_back(head-&gt;val);</span><br><span class=\"line\">\t\thead = head-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = val.size() - <span class=\"number\">1</span>;i&gt;=<span class=\"number\">0</span>;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!st.empty() &amp;&amp; val[i] &gt;= st.top())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tst.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp = st.empty() ? <span class=\"number\">0</span> : st.top();</span><br><span class=\"line\">\t\tst.push(val[i]);</span><br><span class=\"line\">\t\tval[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面那种方法需要两边遍历，而之所以需要两次遍历的原因是，在第二次遍历中，我们需要从后向前遍历来实现单调栈，进而需要通过第一次遍历来生成元素数组。<br>而如果我们可以将从后向前改成从前向后的话，就可以将两次遍历转成一次遍历了。</p>\n<p>从前向后遍历链表时，我们可以先假设后面没有元素大于当前元素，所以先在返回值数组对应位置设置<code>0</code>，然后不断判断当前元素是否比栈顶元素要大，<br>如果比它大的话，那么栈顶元素对应的下一个更大的元素就是当前元素，这时就可以将栈顶元素弹出栈，然后重新比较栈顶元素和当前元素的大小，直到栈空或者当前元素小于栈顶元素。比较完成后，我们将当前元素和其下标压入栈中。<br>这时，栈中的元素都是还未确定下一个更大的元素，而已经弹出栈的元素都已经确定了下一个更大的元素，当遍历完链表时，就求解出结果了。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nextLargerNodes</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; val;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (head)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tval.push_back(head-&gt;val);</span><br><span class=\"line\">\t\thead = head-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = val.size() - <span class=\"number\">1</span>;i&gt;=<span class=\"number\">0</span>;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!st.empty() &amp;&amp; val[i] &gt;= st.top())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tst.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp = st.empty() ? <span class=\"number\">0</span> : st.top();</span><br><span class=\"line\">\t\tst.push(val[i]);</span><br><span class=\"line\">\t\tval[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上两种方法的时间复杂度和空间复杂度都是<code>O(n)</code>，虽然说第二种方法只需要扫描一遍，但是因为它栈中需要保存元素的值和元素的下标，所以在一些情况下估计跑的还不如第一种方法。</p>\n"},{"date":"2020-10-12T01:41:14.917Z","title":"116. Populating Next Right Pointers in Each Node","_content":"\n今天的题目是[116. Populating Next Right Pointers in Each Node](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node)。\n\n不算难的题目，因为题目中给出的树是特定的树，即所谓的完美二叉树，因此我们可以简单的用一个指针去获取左子树最右边的节点，右子树最左边的节点，然后直接对应相连。完成这一步后左子树和右子树之间已经通过`next`指针连接起来了，现在只需要递归地去连接左，右子树各自的`next`指针即可。\n\n代码如下：\n\n```cpp\nNode* connect(Node* root) {\n\tif (!root) return nullptr;\n\tNode* left = root->left;\n\tNode *right = root->right;\n\twhile (left && right)\n\t{\n\t\tleft->next = right;\n\t\tleft = left->right;\n\t\tright = right->left;\n\t}\n\tconnect(root->left);\n\tconnect(root->right);\n\treturn root;\n}\n```\n\n上面的方法需要遍历多次节点，显然效率不是最高的，我们可以尝试利用上已经连接好的`next`指针，然后减少遍历节点的次数。在遍历到节点`n`的时候，如果`n`的`next`指针已经确定了，我们就可以通过`next`指针来访问到同一层相邻的节点，进而节点`n`的右孩子的`next`指针就可以在常数时间内找到，而节点`n`左孩子的`next`指针就是节点`n`的右孩子，所以在遍历到孩子节点前，我们就可以确定它们的`next`指针。\n\n代码如下：\n\n```cpp\nNode* connect(Node* root) {\n\tif (root && root->left) {\n\t\troot->left->next = root->right;\n\t\troot->right->next = root->next ? root->next->left : nullptr;\n\t\tconnect(root->left);\n\t\tconnect(root->right);\n\t}\n\treturn root;\n}\n```\n\n上面两种方法都是递归实现的，但是利用上`next`指针，我们可以实现一个没有额外空间的层次遍历。\n\n连接的方式和第二种方法有点类似，只是遍历方式换掉了。这里是当访问到第`i`层时，该层所有节点的`next`指针都已经确定了。所以我们可以通过`next`指针来遍历这里层的所有节点，并用和第二种方法一样的方式将下一层节点的`next`指针确定下来，而移动到下一层只需要记住树最左边节点的指针即可。\n\n```cpp\nNode* connect(Node *root) {\n\tNode* nextLayer = root;\n\tNode* p;\n\twhile(nextLayer) {\n\t\tp = nextLayer;\n\t\tnextLayer = p->left;\n\t\twhile (p && nextLayer)\n\t\t{\n\t\t\tp->left->next = p->right;\n\t\t\tp->right->next = p->next ? p->next->left : nullptr;\n\t\t\tp = p->next;\n\t\t}\n\t}\n\treturn root;\n}\n```","source":"_posts/populating-next-right-pointers-in-each-node.md","raw":"---\ncategories:\n- LeetCode\ndate: '2020-10-12T09:41:14.917569'\ntags:\n- Tree\n- Depth-first Search\n- LeetCode\ntitle: 116. Populating Next Right Pointers in Each Node\n---\n\n今天的题目是[116. Populating Next Right Pointers in Each Node](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node)。\n\n不算难的题目，因为题目中给出的树是特定的树，即所谓的完美二叉树，因此我们可以简单的用一个指针去获取左子树最右边的节点，右子树最左边的节点，然后直接对应相连。完成这一步后左子树和右子树之间已经通过`next`指针连接起来了，现在只需要递归地去连接左，右子树各自的`next`指针即可。\n\n代码如下：\n\n```cpp\nNode* connect(Node* root) {\n\tif (!root) return nullptr;\n\tNode* left = root->left;\n\tNode *right = root->right;\n\twhile (left && right)\n\t{\n\t\tleft->next = right;\n\t\tleft = left->right;\n\t\tright = right->left;\n\t}\n\tconnect(root->left);\n\tconnect(root->right);\n\treturn root;\n}\n```\n\n上面的方法需要遍历多次节点，显然效率不是最高的，我们可以尝试利用上已经连接好的`next`指针，然后减少遍历节点的次数。在遍历到节点`n`的时候，如果`n`的`next`指针已经确定了，我们就可以通过`next`指针来访问到同一层相邻的节点，进而节点`n`的右孩子的`next`指针就可以在常数时间内找到，而节点`n`左孩子的`next`指针就是节点`n`的右孩子，所以在遍历到孩子节点前，我们就可以确定它们的`next`指针。\n\n代码如下：\n\n```cpp\nNode* connect(Node* root) {\n\tif (root && root->left) {\n\t\troot->left->next = root->right;\n\t\troot->right->next = root->next ? root->next->left : nullptr;\n\t\tconnect(root->left);\n\t\tconnect(root->right);\n\t}\n\treturn root;\n}\n```\n\n上面两种方法都是递归实现的，但是利用上`next`指针，我们可以实现一个没有额外空间的层次遍历。\n\n连接的方式和第二种方法有点类似，只是遍历方式换掉了。这里是当访问到第`i`层时，该层所有节点的`next`指针都已经确定了。所以我们可以通过`next`指针来遍历这里层的所有节点，并用和第二种方法一样的方式将下一层节点的`next`指针确定下来，而移动到下一层只需要记住树最左边节点的指针即可。\n\n```cpp\nNode* connect(Node *root) {\n\tNode* nextLayer = root;\n\tNode* p;\n\twhile(nextLayer) {\n\t\tp = nextLayer;\n\t\tnextLayer = p->left;\n\t\twhile (p && nextLayer)\n\t\t{\n\t\t\tp->left->next = p->right;\n\t\t\tp->right->next = p->next ? p->next->left : nullptr;\n\t\t\tp = p->next;\n\t\t}\n\t}\n\treturn root;\n}\n```","slug":"populating-next-right-pointers-in-each-node","published":1,"updated":"2021-03-10T13:47:05.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qj00h3qmcm9cea7215","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node\">116. Populating Next Right Pointers in Each Node</a>。</p>\n<p>不算难的题目，因为题目中给出的树是特定的树，即所谓的完美二叉树，因此我们可以简单的用一个指针去获取左子树最右边的节点，右子树最左边的节点，然后直接对应相连。完成这一步后左子树和右子树之间已经通过<code>next</code>指针连接起来了，现在只需要递归地去连接左，右子树各自的<code>next</code>指针即可。</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\tNode* left = root-&gt;left;</span><br><span class=\"line\">\tNode *right = root-&gt;right;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (left &amp;&amp; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tleft-&gt;next = right;</span><br><span class=\"line\">\t\tleft = left-&gt;right;</span><br><span class=\"line\">\t\tright = right-&gt;left;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconnect(root-&gt;left);</span><br><span class=\"line\">\tconnect(root-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的方法需要遍历多次节点，显然效率不是最高的，我们可以尝试利用上已经连接好的<code>next</code>指针，然后减少遍历节点的次数。在遍历到节点<code>n</code>的时候，如果<code>n</code>的<code>next</code>指针已经确定了，我们就可以通过<code>next</code>指针来访问到同一层相邻的节点，进而节点<code>n</code>的右孩子的<code>next</code>指针就可以在常数时间内找到，而节点<code>n</code>左孩子的<code>next</code>指针就是节点<code>n</code>的右孩子，所以在遍历到孩子节点前，我们就可以确定它们的<code>next</code>指针。</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root &amp;&amp; root-&gt;left) &#123;</span><br><span class=\"line\">\t\troot-&gt;left-&gt;next = root-&gt;right;</span><br><span class=\"line\">\t\troot-&gt;right-&gt;next = root-&gt;next ? root-&gt;next-&gt;left : <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\tconnect(root-&gt;left);</span><br><span class=\"line\">\t\tconnect(root-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面两种方法都是递归实现的，但是利用上<code>next</code>指针，我们可以实现一个没有额外空间的层次遍历。</p>\n<p>连接的方式和第二种方法有点类似，只是遍历方式换掉了。这里是当访问到第<code>i</code>层时，该层所有节点的<code>next</code>指针都已经确定了。所以我们可以通过<code>next</code>指针来遍历这里层的所有节点，并用和第二种方法一样的方式将下一层节点的<code>next</code>指针确定下来，而移动到下一层只需要记住树最左边节点的指针即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">\tNode* nextLayer = root;</span><br><span class=\"line\">\tNode* p;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(nextLayer) &#123;</span><br><span class=\"line\">\t\tp = nextLayer;</span><br><span class=\"line\">\t\tnextLayer = p-&gt;left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p &amp;&amp; nextLayer)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tp-&gt;left-&gt;next = p-&gt;right;</span><br><span class=\"line\">\t\t\tp-&gt;right-&gt;next = p-&gt;next ? p-&gt;next-&gt;left : <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node\">116. Populating Next Right Pointers in Each Node</a>。</p>\n<p>不算难的题目，因为题目中给出的树是特定的树，即所谓的完美二叉树，因此我们可以简单的用一个指针去获取左子树最右边的节点，右子树最左边的节点，然后直接对应相连。完成这一步后左子树和右子树之间已经通过<code>next</code>指针连接起来了，现在只需要递归地去连接左，右子树各自的<code>next</code>指针即可。</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\tNode* left = root-&gt;left;</span><br><span class=\"line\">\tNode *right = root-&gt;right;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (left &amp;&amp; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tleft-&gt;next = right;</span><br><span class=\"line\">\t\tleft = left-&gt;right;</span><br><span class=\"line\">\t\tright = right-&gt;left;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconnect(root-&gt;left);</span><br><span class=\"line\">\tconnect(root-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的方法需要遍历多次节点，显然效率不是最高的，我们可以尝试利用上已经连接好的<code>next</code>指针，然后减少遍历节点的次数。在遍历到节点<code>n</code>的时候，如果<code>n</code>的<code>next</code>指针已经确定了，我们就可以通过<code>next</code>指针来访问到同一层相邻的节点，进而节点<code>n</code>的右孩子的<code>next</code>指针就可以在常数时间内找到，而节点<code>n</code>左孩子的<code>next</code>指针就是节点<code>n</code>的右孩子，所以在遍历到孩子节点前，我们就可以确定它们的<code>next</code>指针。</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root &amp;&amp; root-&gt;left) &#123;</span><br><span class=\"line\">\t\troot-&gt;left-&gt;next = root-&gt;right;</span><br><span class=\"line\">\t\troot-&gt;right-&gt;next = root-&gt;next ? root-&gt;next-&gt;left : <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\tconnect(root-&gt;left);</span><br><span class=\"line\">\t\tconnect(root-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面两种方法都是递归实现的，但是利用上<code>next</code>指针，我们可以实现一个没有额外空间的层次遍历。</p>\n<p>连接的方式和第二种方法有点类似，只是遍历方式换掉了。这里是当访问到第<code>i</code>层时，该层所有节点的<code>next</code>指针都已经确定了。所以我们可以通过<code>next</code>指针来遍历这里层的所有节点，并用和第二种方法一样的方式将下一层节点的<code>next</code>指针确定下来，而移动到下一层只需要记住树最左边节点的指针即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">\tNode* nextLayer = root;</span><br><span class=\"line\">\tNode* p;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(nextLayer) &#123;</span><br><span class=\"line\">\t\tp = nextLayer;</span><br><span class=\"line\">\t\tnextLayer = p-&gt;left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p &amp;&amp; nextLayer)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tp-&gt;left-&gt;next = p-&gt;right;</span><br><span class=\"line\">\t\t\tp-&gt;right-&gt;next = p-&gt;next ? p-&gt;next-&gt;left : <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Search for a Range","date":"2017-10-11T04:42:31.000Z","_content":"\n第18天！！！\n\n又是一道二分查找的题目：\n\n> Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.\n>\n> Your algorithm's runtime complexity must be in the order of O(log n).\n>\n> If the target is not found in the array, return [-1, -1].\n>\n> For example,\n> Given [5, 7, 7, 8, 8, 10] and target value 8,\n> return [3, 4].\n\n时间复杂度要求为`O(logn)`,直接就暗示我们要用二分查找去做啊，但是这个又有限定条件，就是它需要求出范围，自然而然的就想到先用二分查找，然后从找到的点向两边去寻找边界。\n\n相当简单的方法，但是如果遇到`1,2,2,2,2,2,2,2,3`这样的序列，就变成了`O(n)`的时间复杂度。\n\n然后就可以自然而然的想到，做多两次二分查找,在序列`nums[0:mid]`中寻找左边界，`nums[mid:]`中寻找右边界，不然如果要是用二分查找的方法去做的话，就需要转换一下，我们找左边界的前一个元素，右边界的后一个元素，这样会方便一点。\n\n```c++\nvector<int> searchRange1(vector<int>& nums, int target) {\n    int first = 0,last = nums.size() - 1,mid;\n    vector<int> ret{-1,-1};\n    while(first <= last) {\n        mid = (first + last)/2;\n        if (nums[mid] == target){\n            break;\n        } \n        else if (nums[mid] < target) first = mid+1;\n        else last = mid - 1;\n    }\n\n    int l = mid,f = mid;\n    ret[0] = first;\n    ret[1] = last;\n\n    while(first <= l) {\n        int m = (first + l)/2;\n        if (nums[m] == nums[mid])\n            l = m - 1;\n        else if (nums[m+1] != nums[mid]) first = m + 1;\n        else {\n            ret[0] = m+1;\n            break;\n        }\n    }\n    while(f <= last) {\n        int m = (f + last)/2;\n        if (nums[m] == nums[mid]) f = m + 1;\n        else if (nums[m-1] != nums[mid]) last = m - 1;\n        else {\n            ret[1] = m - 1;\n            break;\n        }\n    }\n\n    return ret;\n}\n```\n\n这个思路很简单，也很好实现，就是代码会复杂一点，三个循环其实长得差不多，但是你不能合并起来，所以换一种思路尝试一下：\n\n我们找到一个与`target`相等的值`nums[mid]`，我们对`nums[0,mid-1]`再进行一次二分查找：\n\n* 如果查找失败， 那么说明当前mid就是左边界\n* 如果找到了，我们就更新mid，再对`nums[0:mid-1]`进行查找，直到查找失败。\n\n对右边界做同样的事，我们就得到答案了。\n\n```c++\nvector<int> searchRange(vector<int>& nums, int target) {\n    vector<int> ret{-1,-1};\n    int mid = nums.size();\n    while( (mid = searchRangeIter(nums,0,mid-1,target) ) != -1) \n        ret[0] = mid;\n    //mid = -1;\n    while( (mid = searchRangeIter(nums,mid+1,nums.size() - 1,target)) != -1)\n        ret[1] = mid;\n    return ret;\n}\nint searchRangeIter(vector<int> nums,int first,int last,int target) {\n    while(first <= last) {\n        int mid = (first + last)/2;\n        if (nums[mid] == target){\n            return mid;  \n        } \n        else if (nums[mid] < target) first = mid+1;\n        else last = mid - 1;\n    }\n    return -1;\n}\n```\n\n\n在`dicuss`中看到一个更简洁的迭代的方法：\n\n```c++\nvector<int> searchRange(int A[], int n, int target) {\n    int i = 0, j = n - 1;\n    vector<int> ret(2, -1);\n    // Search for the left one\n    while (i < j)\n    {\n        int mid = (i + j) /2;\n        if (A[mid] < target) i = mid + 1;\n        else j = mid;\n    }\n    if (A[i]!=target) return ret;\n    else ret[0] = i;\n\n    // Search for the right one\n    j = n-1;  // We don't have to set i to 0 the second time.\n    while (i < j)\n    {\n        int mid = (i + j) /2 + 1;// Make mid biased to the right\n        if (A[mid] > target) j = mid - 1;\n        else i = mid;// So that this won't make the search range stuck.\n    }\n    ret[1] = j;\n    return ret;\n}\n```\n","source":"_posts/search-for-a-range.md","raw":"---\ntitle: Search for a Range\ndate: 2017-10-11T12:42:31.000Z\ncategories:\n  - LeetCode\ntags:\n  - LeetCode\n  - 查找\n---\n\n第18天！！！\n\n又是一道二分查找的题目：\n\n> Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.\n>\n> Your algorithm's runtime complexity must be in the order of O(log n).\n>\n> If the target is not found in the array, return [-1, -1].\n>\n> For example,\n> Given [5, 7, 7, 8, 8, 10] and target value 8,\n> return [3, 4].\n\n时间复杂度要求为`O(logn)`,直接就暗示我们要用二分查找去做啊，但是这个又有限定条件，就是它需要求出范围，自然而然的就想到先用二分查找，然后从找到的点向两边去寻找边界。\n\n相当简单的方法，但是如果遇到`1,2,2,2,2,2,2,2,3`这样的序列，就变成了`O(n)`的时间复杂度。\n\n然后就可以自然而然的想到，做多两次二分查找,在序列`nums[0:mid]`中寻找左边界，`nums[mid:]`中寻找右边界，不然如果要是用二分查找的方法去做的话，就需要转换一下，我们找左边界的前一个元素，右边界的后一个元素，这样会方便一点。\n\n```c++\nvector<int> searchRange1(vector<int>& nums, int target) {\n    int first = 0,last = nums.size() - 1,mid;\n    vector<int> ret{-1,-1};\n    while(first <= last) {\n        mid = (first + last)/2;\n        if (nums[mid] == target){\n            break;\n        } \n        else if (nums[mid] < target) first = mid+1;\n        else last = mid - 1;\n    }\n\n    int l = mid,f = mid;\n    ret[0] = first;\n    ret[1] = last;\n\n    while(first <= l) {\n        int m = (first + l)/2;\n        if (nums[m] == nums[mid])\n            l = m - 1;\n        else if (nums[m+1] != nums[mid]) first = m + 1;\n        else {\n            ret[0] = m+1;\n            break;\n        }\n    }\n    while(f <= last) {\n        int m = (f + last)/2;\n        if (nums[m] == nums[mid]) f = m + 1;\n        else if (nums[m-1] != nums[mid]) last = m - 1;\n        else {\n            ret[1] = m - 1;\n            break;\n        }\n    }\n\n    return ret;\n}\n```\n\n这个思路很简单，也很好实现，就是代码会复杂一点，三个循环其实长得差不多，但是你不能合并起来，所以换一种思路尝试一下：\n\n我们找到一个与`target`相等的值`nums[mid]`，我们对`nums[0,mid-1]`再进行一次二分查找：\n\n* 如果查找失败， 那么说明当前mid就是左边界\n* 如果找到了，我们就更新mid，再对`nums[0:mid-1]`进行查找，直到查找失败。\n\n对右边界做同样的事，我们就得到答案了。\n\n```c++\nvector<int> searchRange(vector<int>& nums, int target) {\n    vector<int> ret{-1,-1};\n    int mid = nums.size();\n    while( (mid = searchRangeIter(nums,0,mid-1,target) ) != -1) \n        ret[0] = mid;\n    //mid = -1;\n    while( (mid = searchRangeIter(nums,mid+1,nums.size() - 1,target)) != -1)\n        ret[1] = mid;\n    return ret;\n}\nint searchRangeIter(vector<int> nums,int first,int last,int target) {\n    while(first <= last) {\n        int mid = (first + last)/2;\n        if (nums[mid] == target){\n            return mid;  \n        } \n        else if (nums[mid] < target) first = mid+1;\n        else last = mid - 1;\n    }\n    return -1;\n}\n```\n\n\n在`dicuss`中看到一个更简洁的迭代的方法：\n\n```c++\nvector<int> searchRange(int A[], int n, int target) {\n    int i = 0, j = n - 1;\n    vector<int> ret(2, -1);\n    // Search for the left one\n    while (i < j)\n    {\n        int mid = (i + j) /2;\n        if (A[mid] < target) i = mid + 1;\n        else j = mid;\n    }\n    if (A[i]!=target) return ret;\n    else ret[0] = i;\n\n    // Search for the right one\n    j = n-1;  // We don't have to set i to 0 the second time.\n    while (i < j)\n    {\n        int mid = (i + j) /2 + 1;// Make mid biased to the right\n        if (A[mid] > target) j = mid - 1;\n        else i = mid;// So that this won't make the search range stuck.\n    }\n    ret[1] = j;\n    return ret;\n}\n```\n","slug":"search-for-a-range","published":1,"updated":"2021-03-10T13:47:05.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69qk00h7qmcm612s52c9","content":"<p>第18天！！！</p>\n<p>又是一道二分查找的题目：</p>\n<blockquote>\n<p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>\n<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>\n<p>If the target is not found in the array, return [-1, -1].</p>\n<p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>\n</blockquote>\n<p>时间复杂度要求为<code>O(logn)</code>,直接就暗示我们要用二分查找去做啊，但是这个又有限定条件，就是它需要求出范围，自然而然的就想到先用二分查找，然后从找到的点向两边去寻找边界。</p>\n<p>相当简单的方法，但是如果遇到<code>1,2,2,2,2,2,2,2,3</code>这样的序列，就变成了<code>O(n)</code>的时间复杂度。</p>\n<p>然后就可以自然而然的想到，做多两次二分查找,在序列<code>nums[0:mid]</code>中寻找左边界，<code>nums[mid:]</code>中寻找右边界，不然如果要是用二分查找的方法去做的话，就需要转换一下，我们找左边界的前一个元素，右边界的后一个元素，这样会方便一点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">searchRange1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = <span class=\"number\">0</span>,last = nums.size() - <span class=\"number\">1</span>,mid;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret&#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last) &#123;</span><br><span class=\"line\">        mid = (first + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] == target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) first = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> last = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = mid,f = mid;</span><br><span class=\"line\">    ret[<span class=\"number\">0</span>] = first;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = last;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= l) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = (first + l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[m] == nums[mid])</span><br><span class=\"line\">            l = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[m+<span class=\"number\">1</span>] != nums[mid]) first = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ret[<span class=\"number\">0</span>] = m+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(f &lt;= last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = (f + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[m] == nums[mid]) f = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[m<span class=\"number\">-1</span>] != nums[mid]) last = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ret[<span class=\"number\">1</span>] = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个思路很简单，也很好实现，就是代码会复杂一点，三个循环其实长得差不多，但是你不能合并起来，所以换一种思路尝试一下：</p>\n<p>我们找到一个与<code>target</code>相等的值<code>nums[mid]</code>，我们对<code>nums[0,mid-1]</code>再进行一次二分查找：</p>\n<ul>\n<li>如果查找失败， 那么说明当前mid就是左边界</li>\n<li>如果找到了，我们就更新mid，再对<code>nums[0:mid-1]</code>进行查找，直到查找失败。</li>\n</ul>\n<p>对右边界做同样的事，我们就得到答案了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret&#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( (mid = searchRangeIter(nums,<span class=\"number\">0</span>,mid<span class=\"number\">-1</span>,target) ) != <span class=\"number\">-1</span>) </span><br><span class=\"line\">        ret[<span class=\"number\">0</span>] = mid;</span><br><span class=\"line\">    <span class=\"comment\">//mid = -1;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( (mid = searchRangeIter(nums,mid+<span class=\"number\">1</span>,nums.size() - <span class=\"number\">1</span>,target)) != <span class=\"number\">-1</span>)</span><br><span class=\"line\">        ret[<span class=\"number\">1</span>] = mid;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">searchRangeIter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (first + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] == target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;  </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) first = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> last = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在<code>dicuss</code>中看到一个更简洁的迭代的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Search for the left one</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (i + j) /<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[mid] &lt; target) i = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> j = mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[i]!=target) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> ret[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Search for the right one</span></span><br><span class=\"line\">    j = n<span class=\"number\">-1</span>;  <span class=\"comment\">// We don&#x27;t have to set i to 0 the second time.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (i + j) /<span class=\"number\">2</span> + <span class=\"number\">1</span>;<span class=\"comment\">// Make mid biased to the right</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[mid] &gt; target) j = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> i = mid;<span class=\"comment\">// So that this won&#x27;t make the search range stuck.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = j;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第18天！！！</p>\n<p>又是一道二分查找的题目：</p>\n<blockquote>\n<p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>\n<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>\n<p>If the target is not found in the array, return [-1, -1].</p>\n<p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>\n</blockquote>\n<p>时间复杂度要求为<code>O(logn)</code>,直接就暗示我们要用二分查找去做啊，但是这个又有限定条件，就是它需要求出范围，自然而然的就想到先用二分查找，然后从找到的点向两边去寻找边界。</p>\n<p>相当简单的方法，但是如果遇到<code>1,2,2,2,2,2,2,2,3</code>这样的序列，就变成了<code>O(n)</code>的时间复杂度。</p>\n<p>然后就可以自然而然的想到，做多两次二分查找,在序列<code>nums[0:mid]</code>中寻找左边界，<code>nums[mid:]</code>中寻找右边界，不然如果要是用二分查找的方法去做的话，就需要转换一下，我们找左边界的前一个元素，右边界的后一个元素，这样会方便一点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">searchRange1</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = <span class=\"number\">0</span>,last = nums.size() - <span class=\"number\">1</span>,mid;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret&#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last) &#123;</span><br><span class=\"line\">        mid = (first + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] == target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) first = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> last = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = mid,f = mid;</span><br><span class=\"line\">    ret[<span class=\"number\">0</span>] = first;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = last;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= l) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = (first + l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[m] == nums[mid])</span><br><span class=\"line\">            l = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[m+<span class=\"number\">1</span>] != nums[mid]) first = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ret[<span class=\"number\">0</span>] = m+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(f &lt;= last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = (f + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[m] == nums[mid]) f = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[m<span class=\"number\">-1</span>] != nums[mid]) last = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ret[<span class=\"number\">1</span>] = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个思路很简单，也很好实现，就是代码会复杂一点，三个循环其实长得差不多，但是你不能合并起来，所以换一种思路尝试一下：</p>\n<p>我们找到一个与<code>target</code>相等的值<code>nums[mid]</code>，我们对<code>nums[0,mid-1]</code>再进行一次二分查找：</p>\n<ul>\n<li>如果查找失败， 那么说明当前mid就是左边界</li>\n<li>如果找到了，我们就更新mid，再对<code>nums[0:mid-1]</code>进行查找，直到查找失败。</li>\n</ul>\n<p>对右边界做同样的事，我们就得到答案了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret&#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( (mid = searchRangeIter(nums,<span class=\"number\">0</span>,mid<span class=\"number\">-1</span>,target) ) != <span class=\"number\">-1</span>) </span><br><span class=\"line\">        ret[<span class=\"number\">0</span>] = mid;</span><br><span class=\"line\">    <span class=\"comment\">//mid = -1;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( (mid = searchRangeIter(nums,mid+<span class=\"number\">1</span>,nums.size() - <span class=\"number\">1</span>,target)) != <span class=\"number\">-1</span>)</span><br><span class=\"line\">        ret[<span class=\"number\">1</span>] = mid;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">searchRangeIter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums,<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first &lt;= last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (first + last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] == target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;  </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target) first = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> last = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在<code>dicuss</code>中看到一个更简洁的迭代的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ret</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Search for the left one</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (i + j) /<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[mid] &lt; target) i = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> j = mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[i]!=target) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> ret[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Search for the right one</span></span><br><span class=\"line\">    j = n<span class=\"number\">-1</span>;  <span class=\"comment\">// We don&#x27;t have to set i to 0 the second time.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (i + j) /<span class=\"number\">2</span> + <span class=\"number\">1</span>;<span class=\"comment\">// Make mid biased to the right</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[mid] &gt; target) j = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> i = mid;<span class=\"comment\">// So that this won&#x27;t make the search range stuck.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = j;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"date":"2020-10-14T08:46:51.646Z","title":"365. Water and Jug Problem","_content":"\n今天的题目是[365. Water and Jug Problem](https://leetcode-cn.com/problems/water-and-jug-problem)。\n\n我们可以执行的操作有三种：\n\n- 给一个杯子装满\n- 倒掉一个杯子中的所有水\n- 将一个杯子中的水转移到另一个杯子中直到没水或者另一个杯子装满\n\n三种操作会分别让两个杯子总水量产生三种：\n\n- 增加`x`或`y`\n- 减少`x`或`y`\n- 总量不变\n\n上面的说法是没有考虑向一个未空的杯子中加水或者是从一个未空的杯子中加水的情况，因为这样的操作显然是没有意义的。\n\n因此杯子中的总水量可以用`ax+by`表示，其中`a`和`b`都是整数。此时问题转换为是否存在`a`和`b`使得`ax+by=z`。根据[裴蜀定理](https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F)，我们可以用`z % gcd(x,y)`来判断。\n\n代码如下：\n\n```c++\nint gcd(int x,int y) {\n\treturn x % y == 0 ? y : gcd(x, x % y);\n}\nbool canMeasureWater(int x, int y, int z) {\n\tif (x == 0 && y == 0) return z == 0;\n\tif (x + y < z) return false;\n\tif (x > y) swap(x, y); // y >= x\n\tint d = x ? gcd(y, x) : y;\n\treturn (z % d == 0);\n}\n```","source":"_posts/water-and-jug-problem.md","raw":"---\ncategories:\n- LeetCode\ndate: '2020-10-14T16:46:51.646493'\ntags:\n- Math\n- LeetCode\ntitle: 365. Water and Jug Problem\n---\n\n今天的题目是[365. Water and Jug Problem](https://leetcode-cn.com/problems/water-and-jug-problem)。\n\n我们可以执行的操作有三种：\n\n- 给一个杯子装满\n- 倒掉一个杯子中的所有水\n- 将一个杯子中的水转移到另一个杯子中直到没水或者另一个杯子装满\n\n三种操作会分别让两个杯子总水量产生三种：\n\n- 增加`x`或`y`\n- 减少`x`或`y`\n- 总量不变\n\n上面的说法是没有考虑向一个未空的杯子中加水或者是从一个未空的杯子中加水的情况，因为这样的操作显然是没有意义的。\n\n因此杯子中的总水量可以用`ax+by`表示，其中`a`和`b`都是整数。此时问题转换为是否存在`a`和`b`使得`ax+by=z`。根据[裴蜀定理](https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F)，我们可以用`z % gcd(x,y)`来判断。\n\n代码如下：\n\n```c++\nint gcd(int x,int y) {\n\treturn x % y == 0 ? y : gcd(x, x % y);\n}\nbool canMeasureWater(int x, int y, int z) {\n\tif (x == 0 && y == 0) return z == 0;\n\tif (x + y < z) return false;\n\tif (x > y) swap(x, y); // y >= x\n\tint d = x ? gcd(y, x) : y;\n\treturn (z % d == 0);\n}\n```","slug":"water-and-jug-problem","published":1,"updated":"2021-03-10T13:47:05.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l69ql00haqmcm72ekb0do","content":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/water-and-jug-problem\">365. Water and Jug Problem</a>。</p>\n<p>我们可以执行的操作有三种：</p>\n<ul>\n<li>给一个杯子装满</li>\n<li>倒掉一个杯子中的所有水</li>\n<li>将一个杯子中的水转移到另一个杯子中直到没水或者另一个杯子装满</li>\n</ul>\n<p>三种操作会分别让两个杯子总水量产生三种：</p>\n<ul>\n<li>增加<code>x</code>或<code>y</code></li>\n<li>减少<code>x</code>或<code>y</code></li>\n<li>总量不变</li>\n</ul>\n<p>上面的说法是没有考虑向一个未空的杯子中加水或者是从一个未空的杯子中加水的情况，因为这样的操作显然是没有意义的。</p>\n<p>因此杯子中的总水量可以用<code>ax+by</code>表示，其中<code>a</code>和<code>b</code>都是整数。此时问题转换为是否存在<code>a</code>和<code>b</code>使得<code>ax+by=z</code>。根据<a href=\"https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F\">裴蜀定理</a>，我们可以用<code>z % gcd(x,y)</code>来判断。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x % y == <span class=\"number\">0</span> ? y : gcd(x, x % y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canMeasureWater</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> z)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == <span class=\"number\">0</span> &amp;&amp; y == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> z == <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x + y &lt; z) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x &gt; y) swap(x, y); <span class=\"comment\">// y &gt;= x</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> d = x ? gcd(y, x) : y;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (z % d == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>今天的题目是<a href=\"https://leetcode-cn.com/problems/water-and-jug-problem\">365. Water and Jug Problem</a>。</p>\n<p>我们可以执行的操作有三种：</p>\n<ul>\n<li>给一个杯子装满</li>\n<li>倒掉一个杯子中的所有水</li>\n<li>将一个杯子中的水转移到另一个杯子中直到没水或者另一个杯子装满</li>\n</ul>\n<p>三种操作会分别让两个杯子总水量产生三种：</p>\n<ul>\n<li>增加<code>x</code>或<code>y</code></li>\n<li>减少<code>x</code>或<code>y</code></li>\n<li>总量不变</li>\n</ul>\n<p>上面的说法是没有考虑向一个未空的杯子中加水或者是从一个未空的杯子中加水的情况，因为这样的操作显然是没有意义的。</p>\n<p>因此杯子中的总水量可以用<code>ax+by</code>表示，其中<code>a</code>和<code>b</code>都是整数。此时问题转换为是否存在<code>a</code>和<code>b</code>使得<code>ax+by=z</code>。根据<a href=\"https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F\">裴蜀定理</a>，我们可以用<code>z % gcd(x,y)</code>来判断。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x % y == <span class=\"number\">0</span> ? y : gcd(x, x % y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canMeasureWater</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> z)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == <span class=\"number\">0</span> &amp;&amp; y == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> z == <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x + y &lt; z) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x &gt; y) swap(x, y); <span class=\"comment\">// y &gt;= x</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> d = x ? gcd(y, x) : y;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (z % d == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckm3l69mf0005qmcm5uatff51","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mk000dqmcmhv5i1zv4"},{"post_id":"ckm3l69m70000qmcm3ked11e6","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ml000iqmcmguu065ps"},{"post_id":"ckm3l69mg0006qmcm8utkdbpc","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mm000lqmcmfgv129zw"},{"post_id":"ckm3l69mi000aqmcm78ksd6jd","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mn000oqmcma0uv3m1u"},{"post_id":"ckm3l69mb0001qmcm9nfgdu8q","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mo000rqmcmgcz833b8"},{"post_id":"ckm3l69mj000cqmcmeqdwa6sd","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mp000vqmcmcian1nk3"},{"post_id":"ckm3l69ml000hqmcm4n6reye5","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mq000yqmcmh1p80z93"},{"post_id":"ckm3l69me0004qmcmb3tx8g6s","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mr0012qmcmf5v03kq9"},{"post_id":"ckm3l69mm000kqmcm70qc4gxy","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ms0015qmcmg2tg7q4r"},{"post_id":"ckm3l69mn000nqmcm7ocm26vs","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ms0019qmcm34xc02gd"},{"post_id":"ckm3l69mo000qqmcmh9ul1n3i","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mt001cqmcmefxca7nx"},{"post_id":"ckm3l69mp000uqmcmfiakeob1","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mu001fqmcm2dl8787n"},{"post_id":"ckm3l69mp000xqmcmfahh9eyi","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mv001jqmcma94l076d"},{"post_id":"ckm3l69mq0011qmcmgtzqhs1b","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mw001mqmcmee3lc6g8"},{"post_id":"ckm3l69mr0014qmcmgb7a912y","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mx001qqmcm99hla44x"},{"post_id":"ckm3l69ms0018qmcmea566m5b","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69my001tqmcm4jxi02p1"},{"post_id":"ckm3l69mt001bqmcmd6069ijf","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69mz001xqmcm84zta0f5"},{"post_id":"ckm3l69mu001eqmcmeb0lhzkk","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69n00020qmcm5pjiac6u"},{"post_id":"ckm3l69mv001iqmcmalp6gnc5","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69n10024qmcm7abl4r3p"},{"post_id":"ckm3l69mv001lqmcmevat38ii","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69n10027qmcmfi5c4ywe"},{"post_id":"ckm3l69mw001pqmcm13ilgolp","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69n2002bqmcm7udbdnfz"},{"post_id":"ckm3l69mx001sqmcm8xmf0quu","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69n3002eqmcmh72ocidf"},{"post_id":"ckm3l69my001wqmcmbm137rms","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69n4002iqmcmhwfd9x9v"},{"post_id":"ckm3l69mz001zqmcm2jf6485z","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69n5002lqmcmcxashjqg"},{"post_id":"ckm3l69n00023qmcmh7b1h3jd","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69n8002pqmcmhalsao2p"},{"post_id":"ckm3l69n10026qmcmah4ae1t3","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nc002sqmcm1awyeawx"},{"post_id":"ckm3l69n2002aqmcm9pjw29f0","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nd002vqmcm71vu8zho"},{"post_id":"ckm3l69n3002dqmcmcpv225ug","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ne002zqmcm5m3t44rr"},{"post_id":"ckm3l69n4002hqmcmbdym273k","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ne0032qmcmbb1m1i19"},{"post_id":"ckm3l69n5002kqmcm3eyu3ajy","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nf0036qmcmgsf4grak"},{"post_id":"ckm3l69n6002oqmcmgvi6a3fl","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ng0039qmcmg1mq0t6m"},{"post_id":"ckm3l69nb002rqmcm54dsczbe","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nh003dqmcmfx7dgaae"},{"post_id":"ckm3l69nc002uqmcm1rrsd65z","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ni003gqmcmh8whgc55"},{"post_id":"ckm3l69nd002yqmcmby9hgaut","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nj003kqmcmfzwi2k15"},{"post_id":"ckm3l69ne0031qmcmb1ai04jo","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nk003nqmcm6mgih6qh"},{"post_id":"ckm3l69nf0035qmcm52a61azq","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nk003qqmcma31m1fzb"},{"post_id":"ckm3l69nf0038qmcm0bs0gjga","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nl003uqmcm7go99dq4"},{"post_id":"ckm3l69nh003cqmcm7s1s7216","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nm003xqmcmgj2yfan9"},{"post_id":"ckm3l69nh003fqmcm8rdt3g2u","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nm0040qmcmct9a5w6d"},{"post_id":"ckm3l69ni003jqmcm937gb8oe","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nn0043qmcmcplt4ety"},{"post_id":"ckm3l69nj003mqmcmdhfp9edi","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69no0046qmcm9w73f945"},{"post_id":"ckm3l69nk003pqmcmg6at2ijo","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69no0049qmcm00oeb4l9"},{"post_id":"ckm3l69nl003tqmcmaf6p8zmo","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69np004cqmcm5w2lffl1"},{"post_id":"ckm3l69nl003wqmcm2b7r5hmd","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nq004fqmcm0uuzds82"},{"post_id":"ckm3l69nm003zqmcmdgf8ay6s","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nr004iqmcm0jp18i0z"},{"post_id":"ckm3l69nn0042qmcm1wrx6c2p","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ns004lqmcmfd6ffde6"},{"post_id":"ckm3l69nn0045qmcmgwd3e6nx","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ns004oqmcm1iuf85a4"},{"post_id":"ckm3l69no0048qmcm5x9x214g","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nt004rqmcmg2z99g7o"},{"post_id":"ckm3l69np004bqmcm3c2y6evx","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nu004uqmcm9rcf8tg6"},{"post_id":"ckm3l69np004eqmcmblsy1adk","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nv004xqmcmh4ln8w1d"},{"post_id":"ckm3l69nq004hqmcm16q594zq","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nw0050qmcm376ice2w"},{"post_id":"ckm3l69nr004kqmcm01zzdbey","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nw0053qmcmfeor2usm"},{"post_id":"ckm3l69ns004nqmcmb6k9hs6b","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nx0056qmcmemhs26cs"},{"post_id":"ckm3l69nt004qqmcmdg4h5yx0","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ny0059qmcm4n000r62"},{"post_id":"ckm3l69nt004tqmcmedvzf1mj","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nz005cqmcmfr5a2kiy"},{"post_id":"ckm3l69nv004wqmcmc1f600e9","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69nz005fqmcm7ylm2qjm"},{"post_id":"ckm3l69nv004zqmcmgjm1687z","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o0005iqmcm8e7p9pp3"},{"post_id":"ckm3l69nw0052qmcm8dx685xu","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o1005lqmcmccpefloh"},{"post_id":"ckm3l69nx0055qmcmgo7whsso","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o1005oqmcm6b5ifo5c"},{"post_id":"ckm3l69ny0058qmcmgp9t30ks","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o2005rqmcm1wg17hu1"},{"post_id":"ckm3l69ny005bqmcmgggt7mqa","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o2005uqmcmf1nkbzig"},{"post_id":"ckm3l69nz005eqmcm0j140b16","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o3005xqmcmf4dj8uhe"},{"post_id":"ckm3l69o0005hqmcm95kb46dk","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o30060qmcmhwp68fhl"},{"post_id":"ckm3l69o0005kqmcmanpvge2q","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o40063qmcmbmuhdfj1"},{"post_id":"ckm3l69o1005nqmcmefmv5rbv","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o50066qmcmfy3v77y6"},{"post_id":"ckm3l69o1005qqmcm5r65cebs","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o50069qmcm69jdbfr6"},{"post_id":"ckm3l69o2005tqmcmdvax4y07","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o6006dqmcm4psi9p4m"},{"post_id":"ckm3l69o2005wqmcmd6pd5px3","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o6006gqmcm4c886adq"},{"post_id":"ckm3l69o3005zqmcm6s7ebs5o","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o7006jqmcmbma06tni"},{"post_id":"ckm3l69o40062qmcm2e39ezn0","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o8006mqmcm8pwj8cwp"},{"post_id":"ckm3l69o40065qmcm3smf1hve","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o8006pqmcmf1mn1etb"},{"post_id":"ckm3l69o50068qmcm7sp62cv6","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o9006sqmcmdwycd13k"},{"post_id":"ckm3l69o5006cqmcm9pd094td","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69o9006vqmcm0zk04nan"},{"post_id":"ckm3l69o6006fqmcm40fxcu3b","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oa006yqmcm30phb8fh"},{"post_id":"ckm3l69o7006iqmcmby9p2c29","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oa0071qmcm9t1z2786"},{"post_id":"ckm3l69o7006lqmcmcxul8ddw","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ob0074qmcm72ve96sv"},{"post_id":"ckm3l69o8006oqmcmh2sz0buk","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oc0077qmcm7pqw5ivp"},{"post_id":"ckm3l69o8006rqmcma9sy46m2","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oc007aqmcm6zwhboqj"},{"post_id":"ckm3l69o9006uqmcmg4ubbn4a","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69od007dqmcm9fff1vas"},{"post_id":"ckm3l69oa006xqmcm57nrgb7s","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69od007gqmcm59plg1l0"},{"post_id":"ckm3l69oa0070qmcm2anb54u1","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oe007kqmcmcbvg6e19"},{"post_id":"ckm3l69ob0073qmcmeq4b8jk0","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69of007nqmcmclg8cyfw"},{"post_id":"ckm3l69ob0076qmcmao430d0v","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69of007qqmcmaoa3dfxi"},{"post_id":"ckm3l69oc0079qmcm8drd9nwb","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69og007tqmcm36r8dnv4"},{"post_id":"ckm3l69oc007cqmcmfyw6bdhs","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oh007wqmcme6jtarsa"},{"post_id":"ckm3l69od007fqmcme2mqdjli","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oh007zqmcm2h3m0chk"},{"post_id":"ckm3l69oe007jqmcm07uc3ebu","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oi0082qmcm7gfncniv"},{"post_id":"ckm3l69oe007mqmcmagd5frlu","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oi0085qmcme97q50ha"},{"post_id":"ckm3l69of007pqmcmhb7few0u","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oj0088qmcm1ffi6ac8"},{"post_id":"ckm3l69og007sqmcmcnxy9gvd","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ok008bqmcmcgb8honw"},{"post_id":"ckm3l69og007vqmcmfb158c7v","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ol008eqmcm7osc1d68"},{"post_id":"ckm3l69oh007yqmcmd9io9wgz","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ol008hqmcm0woyfsdu"},{"post_id":"ckm3l69oh0081qmcmdpoq97rx","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69om008kqmcm9axq5e7v"},{"post_id":"ckm3l69oi0084qmcme35ncrn0","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69on008nqmcm4t2zgyxg"},{"post_id":"ckm3l69oj0087qmcm7goe3wbl","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69on008rqmcmec86gynu"},{"post_id":"ckm3l69oj008aqmcm7j0bahx6","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oo008uqmcm9aotc8iq"},{"post_id":"ckm3l69ok008dqmcmb0ns7058","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69op008xqmcmfj1ghf1o"},{"post_id":"ckm3l69ol008gqmcm2rts6hdm","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69op0090qmcman5d5gv3"},{"post_id":"ckm3l69ol008jqmcm35aqdcrs","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oq0093qmcmds5ke7kz"},{"post_id":"ckm3l69om008mqmcm81ua313r","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69or0096qmcmd6ju96oq"},{"post_id":"ckm3l69on008qqmcm554qhxia","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69or0099qmcmdi7yejgd"},{"post_id":"ckm3l69oo008tqmcmeb761vs9","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69os009cqmcm0gk5eitk"},{"post_id":"ckm3l69oo008wqmcm1tdq0yn4","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ot009fqmcmemyuh1cq"},{"post_id":"ckm3l69op008zqmcm66kuc49x","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ot009iqmcmfzwu84t3"},{"post_id":"ckm3l69oq0092qmcm6ef02x5k","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ov009lqmcmeikifjkh"},{"post_id":"ckm3l69oq0095qmcmddta92vq","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ov009oqmcmcdl3d2x1"},{"post_id":"ckm3l69or0098qmcmd25me45k","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ow009rqmcm6ne6fnq8"},{"post_id":"ckm3l69or009bqmcm3hlsdm03","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ox009uqmcmgrmmelzz"},{"post_id":"ckm3l69os009eqmcm8mnwf5kx","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ox009xqmcm3adgdd3w"},{"post_id":"ckm3l69ot009hqmcm5j15boue","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oy00a0qmcm5hd567v4"},{"post_id":"ckm3l69ou009kqmcmg1cud5nm","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oz00a3qmcm6i98eslr"},{"post_id":"ckm3l69ov009nqmcm1ryydvwz","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69oz00a6qmcm4m7u1620"},{"post_id":"ckm3l69ow009qqmcm6o377xvy","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p000a9qmcman7i0vlx"},{"post_id":"ckm3l69ow009tqmcmha2fewk8","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p100acqmcm65hjbqyy"},{"post_id":"ckm3l69ox009wqmcma3ahddzz","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p100afqmcm8hit56xp"},{"post_id":"ckm3l69oy009zqmcm3hhqghul","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p200aiqmcm00s0e3ty"},{"post_id":"ckm3l69oy00a2qmcm57hs1yda","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p300alqmcme5648zrh"},{"post_id":"ckm3l69oz00a5qmcm0du88tw7","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p300aoqmcmex068f45"},{"post_id":"ckm3l69oz00a8qmcma9t886yk","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p400arqmcmhpht6eyu"},{"post_id":"ckm3l69p000abqmcm0uvv73qr","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p500auqmcm6esv43jv"},{"post_id":"ckm3l69p100aeqmcma8vcb0ch","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p500axqmcm1tgw7r2r"},{"post_id":"ckm3l69p200ahqmcmfm0ag0x2","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p600b0qmcm3c2174ox"},{"post_id":"ckm3l69p200akqmcmclvnamje","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p700b4qmcm7eybba0r"},{"post_id":"ckm3l69p300anqmcm89pmfesc","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p700b7qmcmatnoec54"},{"post_id":"ckm3l69p400aqqmcm0zwz1r02","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p800bbqmcm60o387ku"},{"post_id":"ckm3l69p400atqmcmaotp763x","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69p900beqmcmdllcbp2s"},{"post_id":"ckm3l69p500awqmcm6pxl1se4","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pa00bhqmcm48hm0jw4"},{"post_id":"ckm3l69p600azqmcm58cl1hpr","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pb00bkqmcmedof4one"},{"post_id":"ckm3l69p600b3qmcm58nc6zps","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pb00bnqmcm6ftu9r9i"},{"post_id":"ckm3l69p700b6qmcmffrqfhli","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pc00bqqmcme83y7gyc"},{"post_id":"ckm3l69p800b9qmcmgslx9zdo","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pd00btqmcmdp9x01ro"},{"post_id":"ckm3l69p800bdqmcm8pow5n9q","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pe00bwqmcmbh0b3cip"},{"post_id":"ckm3l69p900bgqmcm06846ewm","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pf00bzqmcmhk2a7vww"},{"post_id":"ckm3l69pa00bjqmcmhuctbaif","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pf00c2qmcm7ejn6bte"},{"post_id":"ckm3l69pb00bmqmcmhss8acyl","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pg00c5qmcm74s77ur7"},{"post_id":"ckm3l69pc00bpqmcm5i0ae60t","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ph00c8qmcm0fss2ldk"},{"post_id":"ckm3l69pc00bsqmcm7hrfe3zy","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ph00cbqmcmfefsanw5"},{"post_id":"ckm3l69pe00bvqmcmczq85ida","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pi00ceqmcm41vf2t8p"},{"post_id":"ckm3l69pe00byqmcmcxfgd4hx","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pi00chqmcm6xcp1mcr"},{"post_id":"ckm3l69pf00c1qmcma7k6ht2k","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pj00ckqmcmh7kh7sft"},{"post_id":"ckm3l69pg00c4qmcm3f8r4pz2","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pk00cnqmcm4o7i7f6e"},{"post_id":"ckm3l69pg00c7qmcm894xciwe","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pk00cqqmcm4zsw25wb"},{"post_id":"ckm3l69ph00caqmcmbztx47s1","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pl00ctqmcmd7il7yjf"},{"post_id":"ckm3l69ph00cdqmcm4ncyeqy2","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pl00cxqmcmg360hw49"},{"post_id":"ckm3l69pi00cgqmcm2xftb1jm","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pm00d0qmcm3p7s9x2l"},{"post_id":"ckm3l69pj00cjqmcmbwec5qzn","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pn00d4qmcm3lkvec2j"},{"post_id":"ckm3l69pj00cmqmcme28rgt2f","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69po00d7qmcm9i723vdl"},{"post_id":"ckm3l69pk00cpqmcm0giu0de1","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69po00daqmcm8s471ipn"},{"post_id":"ckm3l69pk00csqmcm536n33a8","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pp00ddqmcmbd7t44tg"},{"post_id":"ckm3l69pl00cwqmcmgil0eh7q","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pp00dgqmcm5t0f7at3"},{"post_id":"ckm3l69pm00czqmcm7ukd5ao0","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pq00djqmcm7ne47r6h"},{"post_id":"ckm3l69pm00d2qmcmdhfldwvj","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pr00dnqmcm7yxr87sh"},{"post_id":"ckm3l69pn00d6qmcm2kyx3gwy","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pr00dqqmcmcakah1ss"},{"post_id":"ckm3l69po00d9qmcmhvft8dne","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ps00duqmcm1s0hamit"},{"post_id":"ckm3l69po00dcqmcmht6db56k","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pt00dxqmcm6tfa3u7f"},{"post_id":"ckm3l69pp00dfqmcmh98x2iod","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pu00e0qmcmcyf63b3d"},{"post_id":"ckm3l69pq00diqmcmdgzycmmc","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pu00e4qmcmewyxa3bz"},{"post_id":"ckm3l69pq00dmqmcma6g7hg1f","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pv00e7qmcm91kpaqf9"},{"post_id":"ckm3l69pr00dpqmcm2g3w9thp","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pw00ebqmcm4t9b86uu"},{"post_id":"ckm3l69ps00dsqmcmg70ia38i","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pw00eeqmcmfof92fbp"},{"post_id":"ckm3l69pt00dwqmcmcexy5oxt","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69px00eiqmcm9os4f2cx"},{"post_id":"ckm3l69pt00dzqmcm4iro4qih","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69py00elqmcmhgc2ejqm"},{"post_id":"ckm3l69pu00e3qmcmcyb966vo","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69pz00epqmcm2zh164kk"},{"post_id":"ckm3l69pv00e6qmcm14hpdysh","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q000esqmcmbv6e4xfb"},{"post_id":"ckm3l69pv00eaqmcm0ijv9zzg","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q000evqmcmg0og655b"},{"post_id":"ckm3l69pw00edqmcm4zmd0xih","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q100ezqmcmdpcs6w8u"},{"post_id":"ckm3l69px00ehqmcm9snq1e9f","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q200f2qmcm5or9gi9u"},{"post_id":"ckm3l69px00ekqmcm40brgumj","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q400f6qmcm9xfi7kuv"},{"post_id":"ckm3l69py00enqmcmcmc1hyqx","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q400f9qmcm226t2umf"},{"post_id":"ckm3l69pz00erqmcmhwgw30m0","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q500fcqmcm7czvbfwo"},{"post_id":"ckm3l69q000euqmcm4mua61v1","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q600ffqmcmb6jy307d"},{"post_id":"ckm3l69q100eyqmcm6wpv1x1l","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q600fiqmcm3tgig2z5"},{"post_id":"ckm3l69q100f1qmcm73qbcn7n","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q700flqmcmeu0i29ix"},{"post_id":"ckm3l69q200f5qmcmarx0c1o8","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q800foqmcmh37l6pei"},{"post_id":"ckm3l69q400f8qmcmayih53ya","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q900frqmcm15u7dqbv"},{"post_id":"ckm3l69q500fbqmcmc8dfhs7s","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69q900fuqmcm5yko6h0v"},{"post_id":"ckm3l69q500feqmcmaiip3sqt","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qa00fxqmcm3fu94otu"},{"post_id":"ckm3l69q600fhqmcm7i1u1n80","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qb00g0qmcm1mnk3u5b"},{"post_id":"ckm3l69q700fkqmcmfe5c327t","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qc00g3qmcm53j6d4id"},{"post_id":"ckm3l69q700fnqmcmh7vp0of4","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qd00g6qmcm4arw8nfx"},{"post_id":"ckm3l69q800fqqmcm48374v94","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qd00g9qmcm8s1gfykr"},{"post_id":"ckm3l69q900ftqmcmhbi45zov","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qe00gdqmcmaz0b7shv"},{"post_id":"ckm3l69qa00fwqmcmb8g22gh0","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qf00ggqmcmbdduhu1f"},{"post_id":"ckm3l69qa00fzqmcm0pjef7p5","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qg00gkqmcm6of0f1c2"},{"post_id":"ckm3l69qb00g2qmcm12tqa6ax","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qg00gnqmcmc1z80sgg"},{"post_id":"ckm3l69qc00g5qmcmg5ih70be","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qh00gqqmcme1rnfpbj"},{"post_id":"ckm3l69qd00g8qmcmgnw3ag0y","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qi00guqmcm4gt5ezlo"},{"post_id":"ckm3l69qe00gcqmcm0lsq1ttm","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qi00gxqmcm3xoibocs"},{"post_id":"ckm3l69qe00gfqmcm278ca7ou","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qj00h1qmcm9f381ojg"},{"post_id":"ckm3l69qf00giqmcma9y30ats","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qk00h4qmcm5rulg5xx"},{"post_id":"ckm3l69qg00gmqmcm88b9gq21","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69ql00h8qmcma6xe5cut"},{"post_id":"ckm3l69qg00gpqmcm0pgqcu3s","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qm00hbqmcm3ttug53o"},{"post_id":"ckm3l69qh00gtqmcmezwrf5eg","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qm00heqmcm445ihnlz"},{"post_id":"ckm3l69qi00gwqmcm4mqvas7a","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qm00hgqmcmcgi7cjzw"},{"post_id":"ckm3l69qj00h0qmcm662h26yv","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qn00hjqmcm3uoncpc8"},{"post_id":"ckm3l69qj00h3qmcm9cea7215","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qn00hlqmcmc55uetp4"},{"post_id":"ckm3l69qk00h7qmcm612s52c9","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qn00hoqmcm42et9n77"},{"post_id":"ckm3l69ql00haqmcm72ekb0do","category_id":"ckm3l69md0002qmcm4ph18bmm","_id":"ckm3l69qn00hqqmcmafs2admf"}],"PostTag":[{"post_id":"ckm3l69mf0005qmcm5uatff51","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mi0009qmcm5virebbd"},{"post_id":"ckm3l69m70000qmcm3ked11e6","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mj000bqmcmh18015lo"},{"post_id":"ckm3l69mi000aqmcm78ksd6jd","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ml000gqmcmfzoqc4k7"},{"post_id":"ckm3l69mj000cqmcmeqdwa6sd","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mm000jqmcmep0ifgxs"},{"post_id":"ckm3l69mb0001qmcm9nfgdu8q","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mn000pqmcm6hxv9nxn"},{"post_id":"ckm3l69mb0001qmcm9nfgdu8q","tag_id":"ckm3l69mk000fqmcm63dk8dqn","_id":"ckm3l69mo000sqmcm83o18iv6"},{"post_id":"ckm3l69mm000kqmcm70qc4gxy","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mp000wqmcme372hyj2"},{"post_id":"ckm3l69mn000nqmcm7ocm26vs","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mq000zqmcm6z9u4zgy"},{"post_id":"ckm3l69me0004qmcmb3tx8g6s","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mr0013qmcm0am6g5y9"},{"post_id":"ckm3l69mo000qqmcmh9ul1n3i","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ms0016qmcm4pc5fh8c"},{"post_id":"ckm3l69mp000xqmcmfahh9eyi","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mt001aqmcm7cle6vyv"},{"post_id":"ckm3l69mg0006qmcm8utkdbpc","tag_id":"ckm3l69mo000tqmcm30un02tv","_id":"ckm3l69mt001dqmcm291sbdk6"},{"post_id":"ckm3l69mg0006qmcm8utkdbpc","tag_id":"ckm3l69mq0010qmcm1m601uvs","_id":"ckm3l69mu001hqmcme6bda5sm"},{"post_id":"ckm3l69mr0014qmcmgb7a912y","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mv001kqmcm98kkhlxs"},{"post_id":"ckm3l69mt001bqmcmd6069ijf","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mw001oqmcmbi8ycfeq"},{"post_id":"ckm3l69ml000hqmcm4n6reye5","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mx001rqmcm0nqp0vs8"},{"post_id":"ckm3l69ml000hqmcm4n6reye5","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69my001uqmcmebma79b0"},{"post_id":"ckm3l69mu001eqmcmeb0lhzkk","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69mz001yqmcmbjnk5cf2"},{"post_id":"ckm3l69mv001iqmcmalp6gnc5","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69n00021qmcmhj7tfb8r"},{"post_id":"ckm3l69mv001iqmcmalp6gnc5","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69n10025qmcmeg0shpd4"},{"post_id":"ckm3l69mp000uqmcmfiakeob1","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69n10028qmcm6wuo0uva"},{"post_id":"ckm3l69mp000uqmcmfiakeob1","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69n3002cqmcm4aqo4xjo"},{"post_id":"ckm3l69mv001lqmcmevat38ii","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69n3002fqmcm865mdypl"},{"post_id":"ckm3l69mq0011qmcmgtzqhs1b","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69n5002jqmcmcah3anzz"},{"post_id":"ckm3l69mq0011qmcmgtzqhs1b","tag_id":"ckm3l69mw001nqmcm996layu9","_id":"ckm3l69n5002mqmcm8n2hesbb"},{"post_id":"ckm3l69mx001sqmcm8xmf0quu","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69n8002qqmcmh90k2maw"},{"post_id":"ckm3l69my001wqmcmbm137rms","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nc002tqmcm5c8k3zoy"},{"post_id":"ckm3l69my001wqmcmbm137rms","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69nd002xqmcmeu4p1pig"},{"post_id":"ckm3l69n10026qmcmah4ae1t3","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ne0030qmcm075m8mfo"},{"post_id":"ckm3l69n2002aqmcm9pjw29f0","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ne0033qmcmgysbeqia"},{"post_id":"ckm3l69ms0018qmcmea566m5b","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nf0037qmcm08wdf7jn"},{"post_id":"ckm3l69ms0018qmcmea566m5b","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69ng003aqmcmhygrf61j"},{"post_id":"ckm3l69ms0018qmcmea566m5b","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69nh003eqmcm3bk34z52"},{"post_id":"ckm3l69ms0018qmcmea566m5b","tag_id":"ckm3l69n20029qmcm19kx8smy","_id":"ckm3l69ni003hqmcm3bhi2xgn"},{"post_id":"ckm3l69n3002dqmcmcpv225ug","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nj003lqmcmfj3148fq"},{"post_id":"ckm3l69n4002hqmcmbdym273k","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nk003oqmcmghcq2lln"},{"post_id":"ckm3l69mw001pqmcm13ilgolp","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nk003sqmcmbyct0ejn"},{"post_id":"ckm3l69mw001pqmcm13ilgolp","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69nl003vqmcm0rtia33w"},{"post_id":"ckm3l69mw001pqmcm13ilgolp","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69nm003yqmcmchuz50zi"},{"post_id":"ckm3l69n5002kqmcm3eyu3ajy","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nn0041qmcmfgapbqwd"},{"post_id":"ckm3l69n5002kqmcm3eyu3ajy","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69nn0044qmcmhw0eb227"},{"post_id":"ckm3l69n6002oqmcmgvi6a3fl","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69no0047qmcm6palegks"},{"post_id":"ckm3l69nb002rqmcm54dsczbe","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69no004aqmcm25oz6sf1"},{"post_id":"ckm3l69nd002yqmcmby9hgaut","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69np004dqmcm4i38h2vm"},{"post_id":"ckm3l69mz001zqmcm2jf6485z","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nq004gqmcmheaheiyx"},{"post_id":"ckm3l69mz001zqmcm2jf6485z","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69nr004jqmcmhwnobemh"},{"post_id":"ckm3l69mz001zqmcm2jf6485z","tag_id":"ckm3l69n6002nqmcm16u433p3","_id":"ckm3l69ns004mqmcm1nxigy1o"},{"post_id":"ckm3l69mz001zqmcm2jf6485z","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69nt004pqmcm2tw9d3tb"},{"post_id":"ckm3l69mz001zqmcm2jf6485z","tag_id":"ckm3l69nd002wqmcmaysehp2b","_id":"ckm3l69nt004sqmcmgpuu2sfv"},{"post_id":"ckm3l69ne0031qmcmb1ai04jo","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nu004vqmcmezpj56o5"},{"post_id":"ckm3l69ne0031qmcmb1ai04jo","tag_id":"ckm3l69mw001nqmcm996layu9","_id":"ckm3l69nv004yqmcmh31f013o"},{"post_id":"ckm3l69nf0035qmcm52a61azq","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nw0051qmcmeyhh81zo"},{"post_id":"ckm3l69n00023qmcmh7b1h3jd","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nw0054qmcm82mpf0dr"},{"post_id":"ckm3l69n00023qmcmh7b1h3jd","tag_id":"ckm3l69ne0034qmcm2yefbrm2","_id":"ckm3l69nx0057qmcm2kx495of"},{"post_id":"ckm3l69nf0038qmcm0bs0gjga","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ny005aqmcmfmhqe5if"},{"post_id":"ckm3l69nf0038qmcm0bs0gjga","tag_id":"ckm3l69mw001nqmcm996layu9","_id":"ckm3l69nz005dqmcm0kli5cn0"},{"post_id":"ckm3l69nc002uqmcm1rrsd65z","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69nz005gqmcm97f10g4f"},{"post_id":"ckm3l69nc002uqmcm1rrsd65z","tag_id":"ckm3l69ng003bqmcmbteyey4o","_id":"ckm3l69o0005jqmcm7occ8i3i"},{"post_id":"ckm3l69nh003fqmcm8rdt3g2u","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o1005mqmcmc449fbg8"},{"post_id":"ckm3l69nj003mqmcmdhfp9edi","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o1005pqmcm9bi0e0gh"},{"post_id":"ckm3l69nh003cqmcm7s1s7216","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o2005sqmcm0dlb1d1k"},{"post_id":"ckm3l69nh003cqmcm7s1s7216","tag_id":"ckm3l69ni003iqmcm0xokawhd","_id":"ckm3l69o2005vqmcmh6su1w0u"},{"post_id":"ckm3l69nk003pqmcmg6at2ijo","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o3005yqmcm25ood86t"},{"post_id":"ckm3l69nl003tqmcmaf6p8zmo","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o30061qmcm8gth81h0"},{"post_id":"ckm3l69ni003jqmcm937gb8oe","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o40064qmcma7y8483o"},{"post_id":"ckm3l69ni003jqmcm937gb8oe","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69o50067qmcma7x4dqcb"},{"post_id":"ckm3l69ni003jqmcm937gb8oe","tag_id":"ckm3l69nk003rqmcm70hz5ehm","_id":"ckm3l69o5006aqmcmb22351gi"},{"post_id":"ckm3l69nl003wqmcm2b7r5hmd","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o6006eqmcmc8kahmpl"},{"post_id":"ckm3l69nm003zqmcmdgf8ay6s","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o6006hqmcmbkps47ik"},{"post_id":"ckm3l69nn0042qmcm1wrx6c2p","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o7006kqmcmd858eg2e"},{"post_id":"ckm3l69nn0042qmcm1wrx6c2p","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69o8006nqmcm8qtwh2xi"},{"post_id":"ckm3l69nn0045qmcmgwd3e6nx","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o8006qqmcmbm6tbo18"},{"post_id":"ckm3l69no0048qmcm5x9x214g","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69o9006tqmcm71uh16zx"},{"post_id":"ckm3l69no0048qmcm5x9x214g","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69o9006wqmcmamem3ect"},{"post_id":"ckm3l69np004bqmcm3c2y6evx","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oa006zqmcm0mk22duy"},{"post_id":"ckm3l69np004eqmcmblsy1adk","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oa0072qmcmf2wwcoih"},{"post_id":"ckm3l69nq004hqmcm16q594zq","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ob0075qmcm32cq0iro"},{"post_id":"ckm3l69nr004kqmcm01zzdbey","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oc0078qmcmhzdp4xi9"},{"post_id":"ckm3l69ns004nqmcmb6k9hs6b","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oc007bqmcm0zfxc2c3"},{"post_id":"ckm3l69nt004qqmcmdg4h5yx0","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69od007eqmcmhw384vcp"},{"post_id":"ckm3l69nt004qqmcmdg4h5yx0","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69od007hqmcm4q7m1w0f"},{"post_id":"ckm3l69nt004tqmcmedvzf1mj","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oe007lqmcmew0e7eax"},{"post_id":"ckm3l69nt004tqmcmedvzf1mj","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69of007oqmcmbbqfb5gz"},{"post_id":"ckm3l69nt004tqmcmedvzf1mj","tag_id":"ckm3l69n20029qmcm19kx8smy","_id":"ckm3l69of007rqmcm68fd5eco"},{"post_id":"ckm3l69nv004wqmcmc1f600e9","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69og007uqmcm6xkn55pk"},{"post_id":"ckm3l69nv004zqmcmgjm1687z","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oh007xqmcmclewgx9i"},{"post_id":"ckm3l69nw0052qmcm8dx685xu","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oh0080qmcmg02ie3o1"},{"post_id":"ckm3l69nx0055qmcmgo7whsso","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oi0083qmcmayec0rp5"},{"post_id":"ckm3l69ny0058qmcmgp9t30ks","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oi0086qmcm8jxi7ht0"},{"post_id":"ckm3l69ny005bqmcmgggt7mqa","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oj0089qmcmhz887bk1"},{"post_id":"ckm3l69nz005eqmcm0j140b16","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ok008cqmcm82syho1t"},{"post_id":"ckm3l69o0005hqmcm95kb46dk","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ol008fqmcm1svd9k0n"},{"post_id":"ckm3l69o0005kqmcmanpvge2q","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ol008iqmcm1hxr2h1p"},{"post_id":"ckm3l69o0005kqmcmanpvge2q","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69om008lqmcmgaqa9216"},{"post_id":"ckm3l69o1005nqmcmefmv5rbv","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69on008oqmcmb1gpc6oc"},{"post_id":"ckm3l69o1005qqmcm5r65cebs","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69on008sqmcmcflben6q"},{"post_id":"ckm3l69o2005tqmcmdvax4y07","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69oo008vqmcmge8x41ca"},{"post_id":"ckm3l69o2005wqmcmd6pd5px3","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69op008yqmcm8u47h9d1"},{"post_id":"ckm3l69o3005zqmcm6s7ebs5o","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69op0091qmcmgr5hf6f6"},{"post_id":"ckm3l69o40062qmcm2e39ezn0","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oq0094qmcmauknd0ny"},{"post_id":"ckm3l69o50068qmcm7sp62cv6","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69or0097qmcm7fzu0me8"},{"post_id":"ckm3l69o5006cqmcm9pd094td","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69or009aqmcmhwpvarvc"},{"post_id":"ckm3l69o5006cqmcm9pd094td","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69os009dqmcm8byveu5t"},{"post_id":"ckm3l69o6006fqmcm40fxcu3b","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ot009gqmcm461k4eop"},{"post_id":"ckm3l69o40065qmcm3smf1hve","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ot009jqmcm6zu722ze"},{"post_id":"ckm3l69o40065qmcm3smf1hve","tag_id":"ckm3l69o5006bqmcmfwjmeoga","_id":"ckm3l69ov009mqmcmhcxoa42y"},{"post_id":"ckm3l69o7006iqmcmby9p2c29","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ov009pqmcm3oqy1dje"},{"post_id":"ckm3l69o7006lqmcmcxul8ddw","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ow009sqmcm793kdlb8"},{"post_id":"ckm3l69o8006oqmcmh2sz0buk","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ox009vqmcmf5jphpvr"},{"post_id":"ckm3l69o8006rqmcma9sy46m2","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ox009yqmcm6gd23yms"},{"post_id":"ckm3l69o9006uqmcmg4ubbn4a","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oy00a1qmcm4t2a3al3"},{"post_id":"ckm3l69oa006xqmcm57nrgb7s","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oz00a4qmcm9ayk1hv3"},{"post_id":"ckm3l69oa0070qmcm2anb54u1","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69oz00a7qmcmcrcedadh"},{"post_id":"ckm3l69ob0073qmcmeq4b8jk0","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p000aaqmcm2mh03pmv"},{"post_id":"ckm3l69ob0076qmcmao430d0v","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p100adqmcmbv9fa181"},{"post_id":"ckm3l69ob0076qmcmao430d0v","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69p100agqmcmclowc73e"},{"post_id":"ckm3l69oc0079qmcm8drd9nwb","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p200ajqmcm556o1p7x"},{"post_id":"ckm3l69od007fqmcme2mqdjli","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p300amqmcmc7so0nrr"},{"post_id":"ckm3l69oe007jqmcm07uc3ebu","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p400apqmcm4tc37dsf"},{"post_id":"ckm3l69oe007jqmcm07uc3ebu","tag_id":"ckm3l69o5006bqmcmfwjmeoga","_id":"ckm3l69p400asqmcmbrrsggy1"},{"post_id":"ckm3l69oe007mqmcmagd5frlu","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p500avqmcm1i4e8ic1"},{"post_id":"ckm3l69oc007cqmcmfyw6bdhs","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p500ayqmcm79yl0xl5"},{"post_id":"ckm3l69oc007cqmcmfyw6bdhs","tag_id":"ckm3l69oe007iqmcmbu652zfu","_id":"ckm3l69p600b1qmcmd9oa9bzm"},{"post_id":"ckm3l69of007pqmcmhb7few0u","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p700b5qmcmcacgewua"},{"post_id":"ckm3l69og007sqmcmcnxy9gvd","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p700b8qmcm02r2bjau"},{"post_id":"ckm3l69og007vqmcmfb158c7v","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p800bcqmcm8w3p1m1z"},{"post_id":"ckm3l69oh007yqmcmd9io9wgz","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69p900bfqmcm6k6qgt4o"},{"post_id":"ckm3l69oh0081qmcmdpoq97rx","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pa00biqmcm5qn78yim"},{"post_id":"ckm3l69oi0084qmcme35ncrn0","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pb00blqmcmdun5evo4"},{"post_id":"ckm3l69oj0087qmcm7goe3wbl","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pc00boqmcm5dc68wbt"},{"post_id":"ckm3l69oj008aqmcm7j0bahx6","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pc00brqmcmhye21mmg"},{"post_id":"ckm3l69oj008aqmcm7j0bahx6","tag_id":"ckm3l69oe007iqmcmbu652zfu","_id":"ckm3l69pd00buqmcm8qx9227c"},{"post_id":"ckm3l69ok008dqmcmb0ns7058","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pe00bxqmcm69ol9t68"},{"post_id":"ckm3l69ol008gqmcm2rts6hdm","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pf00c0qmcmbvqccpvg"},{"post_id":"ckm3l69ol008gqmcm2rts6hdm","tag_id":"ckm3l69oe007iqmcmbu652zfu","_id":"ckm3l69pf00c3qmcmcf2aem8x"},{"post_id":"ckm3l69om008mqmcm81ua313r","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pg00c6qmcmhyvv63qq"},{"post_id":"ckm3l69om008mqmcm81ua313r","tag_id":"ckm3l69oe007iqmcmbu652zfu","_id":"ckm3l69ph00c9qmcmhg94655d"},{"post_id":"ckm3l69on008qqmcm554qhxia","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ph00ccqmcm6wb7e9ht"},{"post_id":"ckm3l69on008qqmcm554qhxia","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69pi00cfqmcm9tnf9g9h"},{"post_id":"ckm3l69oo008tqmcmeb761vs9","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pi00ciqmcmea6m9uy6"},{"post_id":"ckm3l69ol008jqmcm35aqdcrs","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pj00clqmcm0v08b2f8"},{"post_id":"ckm3l69ol008jqmcm35aqdcrs","tag_id":"ckm3l69oe007iqmcmbu652zfu","_id":"ckm3l69pk00coqmcm36xz28ip"},{"post_id":"ckm3l69ol008jqmcm35aqdcrs","tag_id":"ckm3l69on008pqmcm1wrs4uz2","_id":"ckm3l69pk00crqmcm0en42tiq"},{"post_id":"ckm3l69oo008wqmcm1tdq0yn4","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pl00cuqmcm6zdmdk1t"},{"post_id":"ckm3l69op008zqmcm66kuc49x","tag_id":"ckm3l69mw001nqmcm996layu9","_id":"ckm3l69pm00cyqmcm7n10ha94"},{"post_id":"ckm3l69oq0092qmcm6ef02x5k","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pm00d1qmcmhc8rhkit"},{"post_id":"ckm3l69oq0092qmcm6ef02x5k","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69pn00d5qmcma7ro56b0"},{"post_id":"ckm3l69oq0095qmcmddta92vq","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69po00d8qmcmbxigc171"},{"post_id":"ckm3l69or0098qmcmd25me45k","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69po00dbqmcm3burbfpz"},{"post_id":"ckm3l69or009bqmcm3hlsdm03","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pp00deqmcm661ddylg"},{"post_id":"ckm3l69os009eqmcm8mnwf5kx","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pp00dhqmcm68ma62yj"},{"post_id":"ckm3l69ot009hqmcm5j15boue","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pq00dkqmcm586e6equ"},{"post_id":"ckm3l69ot009hqmcm5j15boue","tag_id":"ckm3l69ne0034qmcm2yefbrm2","_id":"ckm3l69pr00doqmcm0yl038sa"},{"post_id":"ckm3l69ou009kqmcmg1cud5nm","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pr00drqmcm27g6hxzj"},{"post_id":"ckm3l69ou009kqmcmg1cud5nm","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69ps00dvqmcm0jsp4wc8"},{"post_id":"ckm3l69ov009nqmcm1ryydvwz","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pt00dyqmcmaji12nkj"},{"post_id":"ckm3l69ow009qqmcm6o377xvy","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pu00e1qmcm2bfvfmzb"},{"post_id":"ckm3l69ow009tqmcmha2fewk8","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pu00e5qmcm5kp4e82v"},{"post_id":"ckm3l69ow009tqmcmha2fewk8","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69pv00e8qmcm4a5388by"},{"post_id":"ckm3l69ox009wqmcma3ahddzz","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pw00ecqmcmc7n6496a"},{"post_id":"ckm3l69ox009wqmcma3ahddzz","tag_id":"ckm3l69mo000tqmcm30un02tv","_id":"ckm3l69pw00efqmcm72p2cm0p"},{"post_id":"ckm3l69oy009zqmcm3hhqghul","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69px00ejqmcmdq4i8dkj"},{"post_id":"ckm3l69oy009zqmcm3hhqghul","tag_id":"ckm3l69mw001nqmcm996layu9","_id":"ckm3l69py00emqmcmdtrt5dze"},{"post_id":"ckm3l69oy00a2qmcm57hs1yda","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69pz00eqqmcm1sp60lxx"},{"post_id":"ckm3l69oz00a5qmcm0du88tw7","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q000etqmcmg60sg69s"},{"post_id":"ckm3l69oz00a5qmcm0du88tw7","tag_id":"ckm3l69ne0034qmcm2yefbrm2","_id":"ckm3l69q000ewqmcm3pzz899t"},{"post_id":"ckm3l69oz00a8qmcma9t886yk","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q100f0qmcm4zyh1a4f"},{"post_id":"ckm3l69p000abqmcm0uvv73qr","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q200f3qmcm42ti1w5a"},{"post_id":"ckm3l69p100aeqmcma8vcb0ch","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q400f7qmcm9r5fcshp"},{"post_id":"ckm3l69p200ahqmcmfm0ag0x2","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q500faqmcmhf4c0fc1"},{"post_id":"ckm3l69p200akqmcmclvnamje","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q500fdqmcmdb2a933r"},{"post_id":"ckm3l69p300anqmcm89pmfesc","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q600fgqmcm7jt721rg"},{"post_id":"ckm3l69p400aqqmcm0zwz1r02","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q600fjqmcm0u7p7fka"},{"post_id":"ckm3l69p400atqmcmaotp763x","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q700fmqmcmh86f00ln"},{"post_id":"ckm3l69p600b3qmcm58nc6zps","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q800fpqmcmeggb7pqa"},{"post_id":"ckm3l69p700b6qmcmffrqfhli","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69q900fsqmcm7nr77s7q"},{"post_id":"ckm3l69p700b6qmcmffrqfhli","tag_id":"ckm3l69mw001nqmcm996layu9","_id":"ckm3l69q900fvqmcm08fmfymn"},{"post_id":"ckm3l69p500awqmcm6pxl1se4","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qa00fyqmcm4k8o2w7b"},{"post_id":"ckm3l69p500awqmcm6pxl1se4","tag_id":"ckm3l69p600b2qmcmch21amoa","_id":"ckm3l69qb00g1qmcm5lgnat6t"},{"post_id":"ckm3l69p800b9qmcmgslx9zdo","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qc00g4qmcme8tk13ev"},{"post_id":"ckm3l69p800b9qmcmgslx9zdo","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69qd00g7qmcm6psha3fo"},{"post_id":"ckm3l69p800bdqmcm8pow5n9q","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qd00gaqmcmaj6a5zmh"},{"post_id":"ckm3l69p800bdqmcm8pow5n9q","tag_id":"ckm3l69mw001nqmcm996layu9","_id":"ckm3l69qe00geqmcm7yy23cwg"},{"post_id":"ckm3l69p600azqmcm58cl1hpr","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qf00ghqmcm7xbcanhx"},{"post_id":"ckm3l69p600azqmcm58cl1hpr","tag_id":"ckm3l69p800baqmcm9ooe16xq","_id":"ckm3l69qg00glqmcm5xxw8vz0"},{"post_id":"ckm3l69p900bgqmcm06846ewm","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qg00goqmcm93h21pry"},{"post_id":"ckm3l69pa00bjqmcmhuctbaif","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qh00grqmcmcvdme2x3"},{"post_id":"ckm3l69pb00bmqmcmhss8acyl","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qi00gvqmcmgmlf76bl"},{"post_id":"ckm3l69pc00bpqmcm5i0ae60t","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qi00gyqmcmagt38f79"},{"post_id":"ckm3l69pc00bsqmcm7hrfe3zy","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qj00h2qmcme3tk0ara"},{"post_id":"ckm3l69pc00bsqmcm7hrfe3zy","tag_id":"ckm3l69mq0010qmcm1m601uvs","_id":"ckm3l69qk00h5qmcmbhlq0jka"},{"post_id":"ckm3l69pe00bvqmcmczq85ida","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69ql00h9qmcmhj7l8h5f"},{"post_id":"ckm3l69pe00byqmcmcxfgd4hx","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qm00hcqmcm9elt6273"},{"post_id":"ckm3l69pf00c1qmcma7k6ht2k","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qm00hfqmcm4n0lhsuy"},{"post_id":"ckm3l69pg00c4qmcm3f8r4pz2","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qm00hhqmcm2xdad19a"},{"post_id":"ckm3l69pg00c7qmcm894xciwe","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qn00hkqmcmgg205dx8"},{"post_id":"ckm3l69ph00caqmcmbztx47s1","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qn00hmqmcmai2i1mur"},{"post_id":"ckm3l69ph00cdqmcm4ncyeqy2","tag_id":"ckm3l69mo000tqmcm30un02tv","_id":"ckm3l69qn00hpqmcmhtkdcrpp"},{"post_id":"ckm3l69ph00cdqmcm4ncyeqy2","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qn00hrqmcm8gf7eo3j"},{"post_id":"ckm3l69pi00cgqmcm2xftb1jm","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qn00hsqmcm9xf35oue"},{"post_id":"ckm3l69pj00cjqmcmbwec5qzn","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qn00huqmcm6hldelp6"},{"post_id":"ckm3l69pj00cmqmcme28rgt2f","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qo00hvqmcmfw6mb1q5"},{"post_id":"ckm3l69pj00cmqmcme28rgt2f","tag_id":"ckm3l69p800baqmcm9ooe16xq","_id":"ckm3l69qo00hxqmcm8ysg4ejc"},{"post_id":"ckm3l69pk00csqmcm536n33a8","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qo00hyqmcm2scd22vb"},{"post_id":"ckm3l69pm00czqmcm7ukd5ao0","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qo00i0qmcm0ec777mm"},{"post_id":"ckm3l69pk00cpqmcm0giu0de1","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qo00i1qmcmh23obw0o"},{"post_id":"ckm3l69pk00cpqmcm0giu0de1","tag_id":"ckm3l69pl00cvqmcm4ruyb2dq","_id":"ckm3l69qo00i2qmcmaay8h745"},{"post_id":"ckm3l69pm00d2qmcmdhfldwvj","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qo00i3qmcm7ywt84f9"},{"post_id":"ckm3l69pn00d6qmcm2kyx3gwy","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qo00i4qmcm0eoy6ldu"},{"post_id":"ckm3l69pl00cwqmcmgil0eh7q","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qo00i5qmcm3m7uf1os"},{"post_id":"ckm3l69pl00cwqmcmgil0eh7q","tag_id":"ckm3l69pl00cvqmcm4ruyb2dq","_id":"ckm3l69qo00i6qmcmgbxb8zrr"},{"post_id":"ckm3l69po00d9qmcmhvft8dne","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qo00i7qmcmc65v3v01"},{"post_id":"ckm3l69po00dcqmcmht6db56k","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qo00i8qmcmeksr4lpc"},{"post_id":"ckm3l69pq00dmqmcma6g7hg1f","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00i9qmcmf0dif0uw"},{"post_id":"ckm3l69pp00dfqmcmh98x2iod","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00iaqmcm0sonhclf"},{"post_id":"ckm3l69pp00dfqmcmh98x2iod","tag_id":"ckm3l69pq00dlqmcm7hox84yl","_id":"ckm3l69qp00ibqmcmd3no61nd"},{"post_id":"ckm3l69pt00dwqmcmcexy5oxt","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00icqmcmhtwm6bn2"},{"post_id":"ckm3l69pq00diqmcmdgzycmmc","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00idqmcmgmbf59kf"},{"post_id":"ckm3l69pq00diqmcmdgzycmmc","tag_id":"ckm3l69ps00dtqmcm3ye1aklh","_id":"ckm3l69qp00ieqmcmckfreg2w"},{"post_id":"ckm3l69pr00dpqmcm2g3w9thp","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00ifqmcmadz17vxd"},{"post_id":"ckm3l69pr00dpqmcm2g3w9thp","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69qp00igqmcmfzco3zwp"},{"post_id":"ckm3l69pr00dpqmcm2g3w9thp","tag_id":"ckm3l69pu00e2qmcmaeh31y9i","_id":"ckm3l69qp00ihqmcm6y8aexoa"},{"post_id":"ckm3l69pr00dpqmcm2g3w9thp","tag_id":"ckm3l69pl00cvqmcm4ruyb2dq","_id":"ckm3l69qp00iiqmcm5ai49fik"},{"post_id":"ckm3l69pv00eaqmcm0ijv9zzg","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00ijqmcmg4ctg665"},{"post_id":"ckm3l69ps00dsqmcmg70ia38i","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00ikqmcm0jwd76ll"},{"post_id":"ckm3l69ps00dsqmcmg70ia38i","tag_id":"ckm3l69pv00e9qmcm7t5m18wk","_id":"ckm3l69qp00ilqmcm7w2p88h0"},{"post_id":"ckm3l69pw00edqmcm4zmd0xih","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00imqmcm6qqch1fx"},{"post_id":"ckm3l69px00ehqmcm9snq1e9f","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00inqmcm68nw9d3d"},{"post_id":"ckm3l69px00ekqmcm40brgumj","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00ioqmcm3n5lamrt"},{"post_id":"ckm3l69pt00dzqmcm4iro4qih","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00ipqmcmd1z0ax0z"},{"post_id":"ckm3l69pt00dzqmcm4iro4qih","tag_id":"ckm3l69px00egqmcmhulg6quh","_id":"ckm3l69qp00iqqmcm4vk56mf1"},{"post_id":"ckm3l69py00enqmcmcmc1hyqx","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00irqmcm1dsch0fg"},{"post_id":"ckm3l69py00enqmcmcmc1hyqx","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69qp00isqmcm0yfg97mu"},{"post_id":"ckm3l69pu00e3qmcmcyb966vo","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00itqmcm7ubh9gvw"},{"post_id":"ckm3l69pu00e3qmcmcyb966vo","tag_id":"ckm3l69py00eoqmcm045zht1a","_id":"ckm3l69qp00iuqmcmdn57g07t"},{"post_id":"ckm3l69q000euqmcm4mua61v1","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00ivqmcm96wv39bf"},{"post_id":"ckm3l69q000euqmcm4mua61v1","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69qp00iwqmcm6bip1rd7"},{"post_id":"ckm3l69q100eyqmcm6wpv1x1l","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00ixqmcm865m0dug"},{"post_id":"ckm3l69pv00e6qmcm14hpdysh","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00iyqmcmde1ocu6h"},{"post_id":"ckm3l69pv00e6qmcm14hpdysh","tag_id":"ckm3l69q000exqmcmclf3aozd","_id":"ckm3l69qp00izqmcm4d1xc1lc"},{"post_id":"ckm3l69q100f1qmcm73qbcn7n","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00j0qmcm7gu4awo4"},{"post_id":"ckm3l69q200f5qmcmarx0c1o8","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00j1qmcmg2kihl4i"},{"post_id":"ckm3l69pz00erqmcmhwgw30m0","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00j2qmcmd3ba7u9b"},{"post_id":"ckm3l69pz00erqmcmhwgw30m0","tag_id":"ckm3l69q200f4qmcm7c4ff9nl","_id":"ckm3l69qp00j3qmcm1hhj80bd"},{"post_id":"ckm3l69q400f8qmcmayih53ya","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qp00j4qmcm6fzt0ah9"},{"post_id":"ckm3l69q400f8qmcmayih53ya","tag_id":"ckm3l69ne0034qmcm2yefbrm2","_id":"ckm3l69qq00j5qmcm48uu3v2r"},{"post_id":"ckm3l69q500fbqmcmc8dfhs7s","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00j6qmcmck3z6vlr"},{"post_id":"ckm3l69q500fbqmcmc8dfhs7s","tag_id":"ckm3l69ne0034qmcm2yefbrm2","_id":"ckm3l69qq00j7qmcm9e8na736"},{"post_id":"ckm3l69q500feqmcmaiip3sqt","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00j8qmcm4gurefx9"},{"post_id":"ckm3l69q600fhqmcm7i1u1n80","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69qq00j9qmcmbluq7exp"},{"post_id":"ckm3l69q600fhqmcm7i1u1n80","tag_id":"ckm3l69pl00cvqmcm4ruyb2dq","_id":"ckm3l69qq00jaqmcmd3tm9w28"},{"post_id":"ckm3l69q700fkqmcmfe5c327t","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jbqmcmhf4gg0pa"},{"post_id":"ckm3l69q700fnqmcmh7vp0of4","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jcqmcmbqib5e8h"},{"post_id":"ckm3l69q800fqqmcm48374v94","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jdqmcm2hib0dn5"},{"post_id":"ckm3l69q900ftqmcmhbi45zov","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jeqmcme1ap1qsq"},{"post_id":"ckm3l69q900ftqmcmhbi45zov","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69qq00jfqmcmedncddme"},{"post_id":"ckm3l69qa00fwqmcmb8g22gh0","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jgqmcmew9cdrvd"},{"post_id":"ckm3l69qa00fwqmcmb8g22gh0","tag_id":"ckm3l69ne0034qmcm2yefbrm2","_id":"ckm3l69qq00jhqmcm9m9wfnct"},{"post_id":"ckm3l69qa00fzqmcm0pjef7p5","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jiqmcm4xxs00pw"},{"post_id":"ckm3l69qb00g2qmcm12tqa6ax","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jjqmcm0rxs9b9j"},{"post_id":"ckm3l69qe00gcqmcm0lsq1ttm","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69qq00jkqmcm66fufguq"},{"post_id":"ckm3l69qe00gcqmcm0lsq1ttm","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jlqmcm93nv749s"},{"post_id":"ckm3l69qe00gfqmcm278ca7ou","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jmqmcmdg3ufhr2"},{"post_id":"ckm3l69qg00gpqmcm0pgqcu3s","tag_id":"ckm3l69p600b2qmcmch21amoa","_id":"ckm3l69qq00jnqmcmdhpggof8"},{"post_id":"ckm3l69qg00gpqmcm0pgqcu3s","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00joqmcm88l1ff86"},{"post_id":"ckm3l69qc00g5qmcmg5ih70be","tag_id":"ckm3l69qe00gbqmcmcxot2alg","_id":"ckm3l69qq00jpqmcm7k3zdxgf"},{"post_id":"ckm3l69qc00g5qmcmg5ih70be","tag_id":"ckm3l69qf00gjqmcm36nhbjr8","_id":"ckm3l69qq00jqqmcm19275wef"},{"post_id":"ckm3l69qc00g5qmcmg5ih70be","tag_id":"ckm3l69qh00gsqmcm1vu474nj","_id":"ckm3l69qq00jrqmcmfi0hde7v"},{"post_id":"ckm3l69qc00g5qmcmg5ih70be","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jsqmcmhf0f98qo"},{"post_id":"ckm3l69qj00h0qmcm662h26yv","tag_id":"ckm3l69my001vqmcm65195713","_id":"ckm3l69qq00jtqmcmdxm5fi05"},{"post_id":"ckm3l69qj00h0qmcm662h26yv","tag_id":"ckm3l69p600b2qmcmch21amoa","_id":"ckm3l69qq00juqmcm70813bji"},{"post_id":"ckm3l69qj00h0qmcm662h26yv","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jvqmcmcuxcdvnx"},{"post_id":"ckm3l69qd00g8qmcmgnw3ag0y","tag_id":"ckm3l69qf00gjqmcm36nhbjr8","_id":"ckm3l69qq00jwqmcmduqjgma4"},{"post_id":"ckm3l69qj00h3qmcm9cea7215","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69qq00jxqmcm7qapek25"},{"post_id":"ckm3l69qj00h3qmcm9cea7215","tag_id":"ckm3l69nk003rqmcm70hz5ehm","_id":"ckm3l69qq00jyqmcmcg6fdez6"},{"post_id":"ckm3l69qj00h3qmcm9cea7215","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00jzqmcm5svm06wk"},{"post_id":"ckm3l69ql00haqmcm72ekb0do","tag_id":"ckm3l69qf00gjqmcm36nhbjr8","_id":"ckm3l69qq00k0qmcm2jwyelc1"},{"post_id":"ckm3l69ql00haqmcm72ekb0do","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qq00k1qmcm5602h8yd"},{"post_id":"ckm3l69qf00giqmcma9y30ats","tag_id":"ckm3l69qk00h6qmcm7qdl02ed","_id":"ckm3l69qr00k2qmcm0zecarp2"},{"post_id":"ckm3l69qf00giqmcma9y30ats","tag_id":"ckm3l69qh00gsqmcm1vu474nj","_id":"ckm3l69qr00k3qmcmeevthoyo"},{"post_id":"ckm3l69qf00giqmcma9y30ats","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qr00k4qmcm0879fyzb"},{"post_id":"ckm3l69qg00gmqmcm88b9gq21","tag_id":"ckm3l69qm00hiqmcmeqqgff77","_id":"ckm3l69qr00k5qmcm0whb0tun"},{"post_id":"ckm3l69qg00gmqmcm88b9gq21","tag_id":"ckm3l69qn00hnqmcmfsk45gqc","_id":"ckm3l69qr00k6qmcm5r1802dt"},{"post_id":"ckm3l69qg00gmqmcm88b9gq21","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qr00k7qmcmafw0apdi"},{"post_id":"ckm3l69qh00gtqmcmezwrf5eg","tag_id":"ckm3l69ms0017qmcm6hgz3f7i","_id":"ckm3l69qr00k8qmcm369oeu3w"},{"post_id":"ckm3l69qh00gtqmcmezwrf5eg","tag_id":"ckm3l69qn00htqmcm3u96azpx","_id":"ckm3l69qr00k9qmcmhaeu3v0h"},{"post_id":"ckm3l69qh00gtqmcmezwrf5eg","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qr00kaqmcm5a8x6v9n"},{"post_id":"ckm3l69qi00gwqmcm4mqvas7a","tag_id":"ckm3l69qo00hwqmcmedaz005k","_id":"ckm3l69qr00kbqmcm7n27a5lc"},{"post_id":"ckm3l69qi00gwqmcm4mqvas7a","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qr00kcqmcmh5r0e853"},{"post_id":"ckm3l69qk00h7qmcm612s52c9","tag_id":"ckm3l69me0003qmcm9y8516ki","_id":"ckm3l69qr00kdqmcm3x8b6o37"},{"post_id":"ckm3l69qk00h7qmcm612s52c9","tag_id":"ckm3l69qo00hzqmcm18bzhi9v","_id":"ckm3l69qr00keqmcmbyo3br3k"}],"Tag":[{"name":"LeetCode","_id":"ckm3l69me0003qmcm9y8516ki"},{"name":"Tires","_id":"ckm3l69mk000fqmcm63dk8dqn"},{"name":"链表","_id":"ckm3l69mo000tqmcm30un02tv"},{"name":"算法","_id":"ckm3l69mq0010qmcm1m601uvs"},{"name":"Tree","_id":"ckm3l69ms0017qmcm6hgz3f7i"},{"name":"DP","_id":"ckm3l69mw001nqmcm996layu9"},{"name":"Stack","_id":"ckm3l69my001vqmcm65195713"},{"name":"Design","_id":"ckm3l69n20029qmcm19kx8smy"},{"name":"Queues","_id":"ckm3l69n6002nqmcm16u433p3"},{"name":"BFS","_id":"ckm3l69nd002wqmcmaysehp2b"},{"name":"动态规划","_id":"ckm3l69ne0034qmcm2yefbrm2"},{"name":"Hash","_id":"ckm3l69ng003bqmcmbteyey4o"},{"name":"图","_id":"ckm3l69ni003iqmcm0xokawhd"},{"name":"Depth-first Search","_id":"ckm3l69nk003rqmcm70hz5ehm"},{"name":"Linked-List","_id":"ckm3l69o5006bqmcmfwjmeoga"},{"name":"串","_id":"ckm3l69oe007iqmcmbu652zfu"},{"name":"分治法","_id":"ckm3l69on008pqmcm1wrs4uz2"},{"name":"Linked List","_id":"ckm3l69p600b2qmcmch21amoa"},{"name":"LinkedList","_id":"ckm3l69p800baqmcm9ooe16xq"},{"name":"String","_id":"ckm3l69pl00cvqmcm4ruyb2dq"},{"name":"Search","_id":"ckm3l69pq00dlqmcm7hox84yl"},{"name":"二叉树","_id":"ckm3l69ps00dtqmcm3ye1aklh"},{"name":"FSM","_id":"ckm3l69pu00e2qmcmaeh31y9i"},{"name":"Bit-Manipulation","_id":"ckm3l69pv00e9qmcm7t5m18wk"},{"name":"sort","_id":"ckm3l69px00egqmcmhulg6quh"},{"name":"List","_id":"ckm3l69py00eoqmcm045zht1a"},{"name":"Array","_id":"ckm3l69q000exqmcmclf3aozd"},{"name":"ListNode","_id":"ckm3l69q200f4qmcm7c4ff9nl"},{"name":"Brainteaser","_id":"ckm3l69qe00gbqmcmcxot2alg"},{"name":"Math","_id":"ckm3l69qf00gjqmcm36nhbjr8"},{"name":"Dynamic Programming","_id":"ckm3l69qh00gsqmcm1vu474nj"},{"name":"Minimax","_id":"ckm3l69qk00h6qmcm7qdl02ed"},{"name":"Sort","_id":"ckm3l69qm00hiqmcmeqqgff77"},{"name":"Hash Table","_id":"ckm3l69qn00hnqmcmfsk45gqc"},{"name":"Recursion","_id":"ckm3l69qn00htqmcm3u96azpx"},{"name":"Bit Manipulation","_id":"ckm3l69qo00hwqmcmedaz005k"},{"name":"查找","_id":"ckm3l69qo00hzqmcm18bzhi9v"}]}}